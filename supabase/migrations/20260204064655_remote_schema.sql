


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE EXTENSION IF NOT EXISTS "pg_cron" WITH SCHEMA "pg_catalog";






CREATE EXTENSION IF NOT EXISTS "pg_net" WITH SCHEMA "extensions";






COMMENT ON SCHEMA "public" IS 'Performance indexes added on 2026-01-29 for matching system v3.0.
Expected improvement: 50-80% faster queries.
Indexes cover: course lookups, profile completeness, text search, vector similarity.
Monitor query performance with: EXPLAIN ANALYZE SELECT ...';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pg_trgm" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "vector" WITH SCHEMA "extensions";






CREATE TYPE "public"."account_status" AS ENUM (
    'pending',
    'active',
    'suspended',
    'deactivated',
    'approved',
    'rejected',
    'inactive',
    'blacklisted'
);


ALTER TYPE "public"."account_status" OWNER TO "postgres";


CREATE TYPE "public"."approval_status" AS ENUM (
    'pending',
    'approved',
    'rejected',
    'under_review'
);


ALTER TYPE "public"."approval_status" OWNER TO "postgres";


CREATE TYPE "public"."assessment_status" AS ENUM (
    'pending',
    'in_progress',
    'completed',
    'abandoned'
);


ALTER TYPE "public"."assessment_status" OWNER TO "postgres";


CREATE TYPE "public"."collegeType" AS ENUM (
    'standalone',
    'university_department'
);


ALTER TYPE "public"."collegeType" OWNER TO "postgres";


CREATE TYPE "public"."confidence_tag" AS ENUM (
    'high',
    'medium',
    'low'
);


ALTER TYPE "public"."confidence_tag" OWNER TO "postgres";


CREATE TYPE "public"."educator_types" AS ENUM (
    'school',
    'college'
);


ALTER TYPE "public"."educator_types" OWNER TO "postgres";


CREATE TYPE "public"."enrollmentStatus" AS ENUM (
    'active',
    'completed',
    'withdrawn',
    'transferred',
    'suspended'
);


ALTER TYPE "public"."enrollmentStatus" OWNER TO "postgres";


CREATE TYPE "public"."entity_type" AS ENUM (
    'school',
    'college',
    'university',
    'company'
);


ALTER TYPE "public"."entity_type" OWNER TO "postgres";


CREATE TYPE "public"."grade_level" AS ENUM (
    'middle_school',
    'high_school',
    'higher_secondary'
);


ALTER TYPE "public"."grade_level" OWNER TO "postgres";


CREATE TYPE "public"."path_classification" AS ENUM (
    'ascending',
    'descending',
    'stable',
    'fluctuating'
);


ALTER TYPE "public"."path_classification" OWNER TO "postgres";


CREATE TYPE "public"."payment_status_enum" AS ENUM (
    'pending',
    'completed',
    'failed',
    'refunded',
    'cancelled'
);


ALTER TYPE "public"."payment_status_enum" OWNER TO "postgres";


CREATE TYPE "public"."placement_status" AS ENUM (
    'applied',
    'shortlisted',
    'offered',
    'hired',
    'rejected',
    'withdrawn'
);


ALTER TYPE "public"."placement_status" OWNER TO "postgres";


CREATE TYPE "public"."question_subtag" AS ENUM (
    'numerical_reasoning',
    'logical_reasoning',
    'verbal_reasoning',
    'spatial_reasoning',
    'data_interpretation',
    'pattern_recognition'
);


ALTER TYPE "public"."question_subtag" OWNER TO "postgres";


CREATE TYPE "public"."session_status" AS ENUM (
    'in_progress',
    'completed',
    'abandoned'
);


ALTER TYPE "public"."session_status" OWNER TO "postgres";


CREATE TYPE "public"."student_type" AS ENUM (
    'school',
    'college',
    'university'
);


ALTER TYPE "public"."student_type" OWNER TO "postgres";


CREATE TYPE "public"."subscription_status" AS ENUM (
    'pending',
    'active',
    'cancelled',
    'expired',
    'paused'
);


ALTER TYPE "public"."subscription_status" OWNER TO "postgres";


COMMENT ON TYPE "public"."subscription_status" IS 'Valid subscription status values';



CREATE TYPE "public"."test_phase" AS ENUM (
    'diagnostic_screener',
    'adaptive_core',
    'stability_confirmation'
);


ALTER TYPE "public"."test_phase" OWNER TO "postgres";


CREATE TYPE "public"."tier_classification" AS ENUM (
    'L',
    'M',
    'H'
);


ALTER TYPE "public"."tier_classification" OWNER TO "postgres";


CREATE TYPE "public"."user_approval_status" AS ENUM (
    'approved',
    'pending',
    'rejected'
);


ALTER TYPE "public"."user_approval_status" OWNER TO "postgres";


CREATE TYPE "public"."user_role" AS ENUM (
    'super_admin',
    'rm_admin',
    'rm_manager',
    'school_admin',
    'college_admin',
    'university_admin',
    'company_admin',
    'school_educator',
    'recruiter',
    'school_student',
    'college_student',
    'college_educator'
);


ALTER TYPE "public"."user_role" OWNER TO "postgres";


CREATE TYPE "public"."verification_status" AS ENUM (
    'pending',
    'verified',
    'rejected',
    'in_review'
);


ALTER TYPE "public"."verification_status" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_achievement_update"("p_student_id" "uuid", "p_achievement" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  PERFORM add_recent_update(
    p_student_id,
    p_achievement,
    'achievement'
  );
END;
$$;


ALTER FUNCTION "public"."add_achievement_update"("p_student_id" "uuid", "p_achievement" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."add_achievement_update"("p_student_id" "uuid", "p_achievement" "text") IS 'Manually adds achievement update';



CREATE OR REPLACE FUNCTION "public"."add_column_if_not_exists"("p_table_name" "text", "p_column_name" "text", "p_column_definition" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_schema = 'public'
        AND table_name = p_table_name
        AND column_name = p_column_name
    ) THEN
        EXECUTE format('ALTER TABLE %I.%I ADD COLUMN %I %s',
            'public',
            p_table_name,
            p_column_name,
            p_column_definition
        );
    END IF;
END;
$$;


ALTER FUNCTION "public"."add_column_if_not_exists"("p_table_name" "text", "p_column_name" "text", "p_column_definition" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_constraint_if_not_exists"("p_table_name" "text", "p_constraint_name" "text", "p_constraint_definition" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    constraint_exists boolean;
BEGIN
    SELECT EXISTS (
        SELECT 1 
        FROM information_schema.table_constraints 
        WHERE constraint_schema = 'public' 
        AND table_name = p_table_name 
        AND constraint_name = p_constraint_name
    ) INTO constraint_exists;
    
    IF NOT constraint_exists THEN
        EXECUTE format('ALTER TABLE %I ADD CONSTRAINT %I %s', 
            p_table_name, p_constraint_name, p_constraint_definition);
        RAISE NOTICE 'Added constraint % to %', p_constraint_name, p_table_name;
    ELSE
        RAISE NOTICE 'Constraint % already exists on %, skipping', p_constraint_name, p_table_name;
    END IF;
END;
$$;


ALTER FUNCTION "public"."add_constraint_if_not_exists"("p_table_name" "text", "p_constraint_name" "text", "p_constraint_definition" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_jsonb_recent_update"("student_email" "text", "update_title" "text", "update_type" "text" DEFAULT 'system'::"text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  student_uuid UUID;
  update_json JSONB;
BEGIN
  -- Get the student_id dynamically
  SELECT id INTO student_uuid
  FROM public.students
  WHERE profile->>'email' = student_email;

  IF student_uuid IS NULL THEN
    RAISE EXCEPTION 'No student found with email: %', student_email;
  END IF;

  -- Create new update object
  update_json := jsonb_build_object(
    'title', update_title,
    'type', update_type,
    'created_at', NOW()
  );

  -- Insert or update JSONB array
  INSERT INTO public.recent_updates (student_id, updates)
  VALUES (student_uuid, jsonb_build_object('updates', jsonb_build_array(update_json)))
  ON CONFLICT (student_id)
  DO UPDATE
  SET updates = jsonb_set(
    recent_updates.updates,
    '{updates}',
    (recent_updates.updates->'updates') || jsonb_build_array(update_json)
  );
END;
$$;


ALTER FUNCTION "public"."add_jsonb_recent_update"("student_email" "text", "update_title" "text", "update_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_jsonb_recent_update"("student_uuid" "uuid", "update_title" "text", "update_description" "text" DEFAULT NULL::"text", "update_type" "text" DEFAULT 'system'::"text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  update_json JSONB;
BEGIN
  -- Build JSON for the new update
  update_json := jsonb_build_object(
    'title', update_title,
    'description', update_description,
    'type', update_type,
    'created_at', now()
  );

  -- Insert or update dynamically
  INSERT INTO public.recent_updates (student_id, updates)
  VALUES (
    student_uuid,
    jsonb_build_object('updates', jsonb_build_array(update_json))
  )
  ON CONFLICT (student_id)
  DO UPDATE
  SET updates = jsonb_set(
    COALESCE(recent_updates.updates, '{"updates":[]}'::jsonb),
    '{updates}',
    (COALESCE(recent_updates.updates->'updates', '[]'::jsonb) || jsonb_build_array(update_json))
  ),
  created_at = now();
END;
$$;


ALTER FUNCTION "public"."add_jsonb_recent_update"("student_uuid" "uuid", "update_title" "text", "update_description" "text", "update_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_opportunity_match_update"("p_student_id" "uuid", "p_opportunity_title" "text", "p_company_name" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  PERFORM add_recent_update(
    p_student_id,
    'New opportunity match: ' || p_opportunity_title || ' at ' || p_company_name,
    'opportunity_match'
  );
END;
$$;


ALTER FUNCTION "public"."add_opportunity_match_update"("p_student_id" "uuid", "p_opportunity_title" "text", "p_company_name" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."add_opportunity_match_update"("p_student_id" "uuid", "p_opportunity_title" "text", "p_company_name" "text") IS 'Manually adds opportunity match update';



CREATE OR REPLACE FUNCTION "public"."add_recent_update"("p_student_id" "uuid", "p_message" "text", "p_type" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_new_update jsonb;
  v_current_updates jsonb;
  v_updates_array jsonb;
BEGIN
  v_new_update := jsonb_build_object(
    'id', gen_random_uuid()::text,
    'message', p_message,
    'timestamp', 'Just now',
    'type', p_type,
    'created_at', now()
  );

  SELECT updates INTO v_current_updates
  FROM public.recent_updates
  WHERE student_id = p_student_id;

  IF v_current_updates IS NULL THEN
    v_updates_array := jsonb_build_array();
  ELSIF v_current_updates ? 'updates' THEN
    v_updates_array := v_current_updates->'updates';
  ELSE
    v_updates_array := jsonb_build_array();
  END IF;

  v_updates_array := jsonb_build_array(v_new_update) || v_updates_array;

  IF jsonb_array_length(v_updates_array) > 20 THEN
    v_updates_array := v_updates_array #> ARRAY['0:19'];
  END IF;

  INSERT INTO public.recent_updates (student_id, updates, updated_at)
  VALUES (
    p_student_id,
    jsonb_build_object('updates', v_updates_array),
    now()
  )
  ON CONFLICT (student_id) 
  DO UPDATE SET
    updates = jsonb_build_object('updates', v_updates_array),
    updated_at = now();
END;
$$;


ALTER FUNCTION "public"."add_recent_update"("p_student_id" "uuid", "p_message" "text", "p_type" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."add_recent_update"("p_student_id" "uuid", "p_message" "text", "p_type" "text") IS 'Adds a new update to student recent_updates table (uses student_id only)';



CREATE OR REPLACE FUNCTION "public"."add_recent_update"("student_email" "text", "update_title" "text", "update_description" "text" DEFAULT NULL::"text", "update_type" "text" DEFAULT 'system'::"text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_uuid UUID;
BEGIN
    -- Get student_id dynamically using email inside JSONB "profile"
    SELECT id INTO student_uuid
    FROM public.students
    WHERE profile->>'email' = student_email;

    -- Handle missing student
    IF student_uuid IS NULL THEN
        RAISE EXCEPTION 'âŒ No student found with email: %', student_email;
    END IF;

    -- Insert recent update
    INSERT INTO public.recent_updates (student_id, title, description, type)
    VALUES (student_uuid, update_title, update_description, update_type);
END;
$$;


ALTER FUNCTION "public"."add_recent_update"("student_email" "text", "update_title" "text", "update_description" "text", "update_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_recent_update_by_email"("student_email" "text", "update_title" "text", "update_description" "text" DEFAULT NULL::"text", "update_type" "text" DEFAULT 'system'::"text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  student_uuid UUID;
  update_json JSONB;
BEGIN
  -- Find student_id from students.profile->>'email'
  SELECT id INTO student_uuid
  FROM public.students
  WHERE profile->>'email' = student_email
  LIMIT 1;

  -- If no student found, exit
  IF student_uuid IS NULL THEN
    RAISE NOTICE 'No student found with email: %', student_email;
    RETURN;
  END IF;

  -- Build the update JSON object
  update_json := jsonb_build_object(
    'title', update_title,
    'description', update_description,
    'type', update_type,
    'created_at', now()
  );

  -- Insert or update dynamically (upsert)
  INSERT INTO public.recent_updates (student_id, updates)
  VALUES (
    student_uuid,
    jsonb_build_object('updates', jsonb_build_array(update_json))
  )
  ON CONFLICT (student_id)
  DO UPDATE
  SET updates = jsonb_set(
        COALESCE(recent_updates.updates, '{"updates":[]}'::jsonb),
        '{updates}',
        (COALESCE(recent_updates.updates->'updates', '[]'::jsonb) || jsonb_build_array(update_json))
      ),
      created_at = now();
END;
$$;


ALTER FUNCTION "public"."add_recent_update_by_email"("student_email" "text", "update_title" "text", "update_description" "text", "update_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."add_to_profile_array"("p_student_id" "uuid", "p_array_name" "text", "p_new_item" "jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_profile JSONB;
  v_array JSONB;
  v_new_id INTEGER;
BEGIN
  -- Get current profile
  SELECT profile INTO v_profile
  FROM students
  WHERE id = p_student_id;
  
  -- Get current array or initialize empty
  v_array := COALESCE(v_profile -> p_array_name, '[]'::jsonb);
  
  -- Generate new ID
  v_new_id := COALESCE(
    (SELECT MAX((elem->>'id')::int) FROM jsonb_array_elements(v_array) elem),
    0
  ) + 1;
  
  -- Add id to new item
  p_new_item := jsonb_set(p_new_item, '{id}', to_jsonb(v_new_id));
  
  -- Append to array
  v_array := v_array || p_new_item;
  
  -- Update profile
  v_profile := jsonb_set(v_profile, ARRAY[p_array_name], v_array);
  
  -- Save and return
  UPDATE students SET profile = v_profile WHERE id = p_student_id;
  
  RETURN v_profile;
END;
$$;


ALTER FUNCTION "public"."add_to_profile_array"("p_student_id" "uuid", "p_array_name" "text", "p_new_item" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."add_to_profile_array"("p_student_id" "uuid", "p_array_name" "text", "p_new_item" "jsonb") IS 'Add a new item to a JSONB array in student profile';



CREATE OR REPLACE FUNCTION "public"."add_to_teacher_journal"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF NEW.status = 'approved' AND (OLD.status IS NULL OR OLD.status != 'approved') THEN
    INSERT INTO teacher_journal (educator_id, lesson_plan_id, date)
    VALUES (NEW.educator_id, NEW.id, NEW.date)
    ON CONFLICT (educator_id, lesson_plan_id, date) DO NOTHING;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."add_to_teacher_journal"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."analyze_skills_demand"() RETURNS TABLE("skill" "text", "total_mentions" bigint)
    LANGUAGE "sql" STABLE
    AS $$

WITH wanted(skill) AS (
  VALUES
    ('html'),('css'),('sass'),('scss'),('tailwind'),('bootstrap'),
    ('javascript'),('js'),('typescript'),('ts'),
    ('react'),('reactjs'),('react.js'),('nextjs'),('next.js'),('gatsby'),
    ('angular'),('vue'),('vuejs'),('vue.js'),('svelte'),
    ('nodejs'),('node'),('express'),('nest'),
    ('python'),('swift'),
    ('django'),('flask'),('fastapi'),
    ('c'),('c++'),('csharp'),('c#'),('.net'),
    ('java'),('spring'),('kotlin'),('scala'),
    ('php'),('laravel'),('symfony'),
    ('ruby'),('rails'),('go'),('golang'),
    ('rust'),('dart'),('flutter'),
    ('sql'),('mysql'),('postgresql'),('sqlite'),
    ('mongodb'),('redis'),('elasticsearch'),
    ('docker'),('kubernetes'),('k8s'),
    ('aws'),('azure'),('gcp'),('googlecloud'),
    ('github'),('gitlab'),('bitbucket'),('git'),
    ('jenkins'),('githubactions'),('gitlabci'),('circleci'),('cicd'),('ci/cd'),
    ('rest'),('restful'),('graphql'),('grpc'),
    ('jest'),('mocha'),('jasmine'),('cypress'),('selenium'),
    ('webpack'),('vite'),('parcel'),('babel'),('eslint'),('prettier'),
    ('npm'),('yarn'),('pnpm'),
    ('microservices'),('serverless'),('lambda'),
    ('oauth'),('jwt'),('auth'),
    ('figma'),('sketch'),('adobe'),
    ('framer'),('framer motion'),('framermotion'),
    ('responsive'),('mobilefirst'),('crossbrowser'),
    ('agile'),('scrum'),('kanban')
),

/* explode responsibilities -> one text row per array element */
raw_lines AS (
  SELECT  
    o.id,
    lower(regexp_replace(jsonb_array_elements_text(o.requirements), '[^\w+#/]',' ','g')) AS line
  FROM opportunities o
  WHERE o.requirements IS NOT NULL
),

/* count occurrences per line */
per_line AS (
  SELECT 
    w.skill,
    r.id,
    CASE 
      /* use regex boundaries for longer words to avoid partial matches */
      WHEN length(w.skill) > 3 THEN 
        CASE WHEN r.line ~ ('\m' || w.skill || '\M') THEN 1 ELSE 0 END
      /* use simple regex for short keywords that may terminate a line */
      ELSE 
        CASE WHEN r.line ~ ('\m' || w.skill) THEN 1 ELSE 0 END
    END as found
  FROM wanted w
  CROSS JOIN raw_lines r
)

/* aggregate totals across all listings */
SELECT 
  w.skill,
  sum(p.found)::bigint as total_mentions
FROM wanted w
LEFT JOIN per_line p ON w.skill = p.skill  
GROUP BY w.skill
HAVING sum(p.found) > 0
ORDER BY total_mentions DESC

$$;


ALTER FUNCTION "public"."analyze_skills_demand"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."apply_change_to_tables"("p_curriculum_id" "uuid", "p_change_type" character varying, "p_entity_id" "uuid", "p_change_data" "jsonb", "p_user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_unit_id UUID;
BEGIN
  CASE p_change_type
    
    WHEN 'unit_add' THEN
      INSERT INTO college_curriculum_units (
        id, curriculum_id, name, code, description, order_index,
        estimated_duration, duration_unit, credits, created_by, updated_by
      ) VALUES (
        p_entity_id, p_curriculum_id,
        p_change_data->>'name',
        p_change_data->>'code',
        p_change_data->>'description',
        (p_change_data->>'order_index')::INTEGER,
        (p_change_data->>'estimatedDuration')::INTEGER,
        p_change_data->>'durationUnit',
        (p_change_data->>'credits')::DECIMAL,
        p_user_id, p_user_id
      )
      ON CONFLICT (id) DO UPDATE SET
        name = EXCLUDED.name, updated_by = p_user_id, updated_at = NOW();
      
      RAISE NOTICE 'Applied unit: %', p_change_data->>'name';
    
    WHEN 'unit_edit' THEN
      UPDATE college_curriculum_units
      SET 
        name = COALESCE(p_change_data->>'new_name', p_change_data->>'name', name),
        code = COALESCE(p_change_data->>'new_code', p_change_data->>'code', code),
        description = COALESCE(p_change_data->>'new_description', p_change_data->>'description', description),
        order_index = COALESCE((p_change_data->>'new_order_index')::INTEGER, (p_change_data->>'order_index')::INTEGER, order_index),
        estimated_duration = COALESCE((p_change_data->>'new_estimatedDuration')::INTEGER, (p_change_data->>'estimatedDuration')::INTEGER, estimated_duration),
        duration_unit = COALESCE(p_change_data->>'new_durationUnit', p_change_data->>'durationUnit', duration_unit),
        credits = COALESCE((p_change_data->>'new_credits')::DECIMAL, (p_change_data->>'credits')::DECIMAL, credits),
        updated_by = p_user_id, updated_at = NOW()
      WHERE id = p_entity_id;
      
      RAISE NOTICE 'Updated unit: %', p_entity_id;
    
    WHEN 'unit_delete' THEN
      DELETE FROM college_curriculum_units WHERE id = p_entity_id;
      RAISE NOTICE 'Deleted unit: %', p_entity_id;
    
    WHEN 'outcome_add' THEN
      INSERT INTO college_curriculum_outcomes (
        id, curriculum_id, unit_id, outcome_text, bloom_level,
        assessment_mappings, created_by, updated_by
      ) VALUES (
        p_entity_id, p_curriculum_id,
        (p_change_data->>'unitId')::UUID,
        p_change_data->>'outcome',
        p_change_data->>'bloomLevel',
        COALESCE(p_change_data->'assessmentMappings', '[]'::jsonb),
        p_user_id, p_user_id
      )
      ON CONFLICT (id) DO UPDATE SET
        outcome_text = EXCLUDED.outcome_text, updated_by = p_user_id, updated_at = NOW();
      
      RAISE NOTICE 'Applied outcome for unit: %', p_change_data->>'unitId';
    
    WHEN 'outcome_edit' THEN
      UPDATE college_curriculum_outcomes
      SET 
        outcome_text = COALESCE(p_change_data->>'new_outcome', p_change_data->>'outcome', outcome_text),
        bloom_level = COALESCE(p_change_data->>'new_bloomLevel', p_change_data->>'bloomLevel', bloom_level),
        assessment_mappings = COALESCE(p_change_data->'new_assessmentMappings', p_change_data->'assessmentMappings', assessment_mappings),
        unit_id = COALESCE((p_change_data->>'new_unitId')::UUID, (p_change_data->>'unitId')::UUID, unit_id),
        updated_by = p_user_id, updated_at = NOW()
      WHERE id = p_entity_id;
      
      RAISE NOTICE 'Updated outcome: %', p_entity_id;
    
    WHEN 'outcome_delete' THEN
      DELETE FROM college_curriculum_outcomes WHERE id = p_entity_id;
      RAISE NOTICE 'Deleted outcome: %', p_entity_id;
    
    ELSE
      RAISE NOTICE 'Unknown change type: %', p_change_type;
      RETURN FALSE;
  END CASE;
  
  RETURN TRUE;
  
EXCEPTION
  WHEN OTHERS THEN
    RAISE WARNING 'Error applying change: % - %', SQLERRM, SQLSTATE;
    RETURN FALSE;
END;
$$;


ALTER FUNCTION "public"."apply_change_to_tables"("p_curriculum_id" "uuid", "p_change_type" character varying, "p_entity_id" "uuid", "p_change_data" "jsonb", "p_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."apply_to_job"("p_student_id" "uuid", "p_opportunity_id" integer) RETURNS TABLE("success" boolean, "message" "text", "application_id" integer)
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_application_id INTEGER;
  v_already_applied BOOLEAN;
  v_opportunity_active BOOLEAN;
BEGIN
  -- Check if opportunity exists and is active
  SELECT is_active INTO v_opportunity_active
  FROM public.opportunities
  WHERE id = p_opportunity_id;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT FALSE, 'Opportunity not found', NULL::INTEGER;
    RETURN;
  END IF;
  
  IF NOT v_opportunity_active THEN
    RETURN QUERY SELECT FALSE, 'This opportunity is no longer active', NULL::INTEGER;
    RETURN;
  END IF;

  -- Check if already applied
  SELECT EXISTS (
    SELECT 1 
    FROM public.applications 
    WHERE student_id = p_student_id 
    AND opportunity_id = p_opportunity_id
  ) INTO v_already_applied;
  
  IF v_already_applied THEN
    RETURN QUERY SELECT FALSE, 'You have already applied to this opportunity', NULL::INTEGER;
    RETURN;
  END IF;
  
  -- Create application
  INSERT INTO public.applications (
    student_id,
    opportunity_id,
    application_date,
    status
  ) 
  VALUES (
    p_student_id,
    p_opportunity_id,
    NOW(),
    'pending'::public.approval_status
  )
  RETURNING id INTO v_application_id;
  
  -- Add recent update
  PERFORM public.add_recent_update(
    p_student_id, 
    'Applied to job opportunity',
    'application'
  );
  
  RETURN QUERY SELECT TRUE, 'Application submitted successfully', v_application_id;
END;
$$;


ALTER FUNCTION "public"."apply_to_job"("p_student_id" "uuid", "p_opportunity_id" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_add_applicant_to_pipeline"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_opportunity RECORD;
  v_student RECORD;
  v_existing_candidate INTEGER;
BEGIN
  -- Get opportunity details including requisition_id
  SELECT 
    o.requisition_id, 
    COALESCE(o.job_title, o.title) as job_title
  INTO v_opportunity
  FROM opportunities o
  WHERE o.id = NEW.opportunity_id;
  
  -- Only proceed if opportunity has a linked requisition
  IF v_opportunity.requisition_id IS NULL THEN
    RAISE NOTICE 'Opportunity % has no linked requisition, skipping pipeline addition', NEW.opportunity_id;
    RETURN NEW;
  END IF;
  
  -- Get student details from the students table (CORRECTED: use direct columns)
  SELECT 
    s.id,
    COALESCE(s.name, 'Unknown Student') as name,
    COALESCE(s.email, '') as email,
    COALESCE(s.contact_number::TEXT, '') as phone
  INTO v_student
  FROM students s
  WHERE s.id = NEW.student_id;
  
  -- If student not found, try to get basic info
  IF v_student.id IS NULL THEN
    RAISE NOTICE 'Student % not found in students table, skipping pipeline addition', NEW.student_id;
    RETURN NEW;
  END IF;
  
  -- Check if candidate already exists in this pipeline
  SELECT id INTO v_existing_candidate
  FROM pipeline_candidates
  WHERE requisition_id = v_opportunity.requisition_id
    AND student_id = NEW.student_id
  LIMIT 1;
  
  -- If candidate doesn't exist, add them to the pipeline
  IF v_existing_candidate IS NULL THEN
    BEGIN
      INSERT INTO pipeline_candidates (
        requisition_id,
        student_id,
        candidate_name,
        candidate_email,
        candidate_phone,
        stage,
        source,
        status,
        added_at,
        stage_changed_at,
        created_at,
        updated_at
      ) VALUES (
        v_opportunity.requisition_id,
        v_student.id,
        v_student.name,
        v_student.email,
        v_student.phone,
        'sourced', -- Start at sourced stage
        'direct_application', -- Mark as direct application
        'active',
        NOW(),
        NOW(),
        NOW(),
        NOW()
      );
      
      RAISE NOTICE 'Successfully added student % (%) to pipeline for requisition %', 
        v_student.name, NEW.student_id, v_opportunity.requisition_id;
    EXCEPTION WHEN OTHERS THEN
      RAISE WARNING 'Failed to add student to pipeline: %', SQLERRM;
    END;
  ELSE
    RAISE NOTICE 'Student % already exists in pipeline for requisition % (pipeline_candidate_id: %)', 
      NEW.student_id, v_opportunity.requisition_id, v_existing_candidate;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_add_applicant_to_pipeline"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_assign_license_to_member"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_organization_id UUID;
    v_organization_type VARCHAR;
    v_member_type VARCHAR;
    v_user_id UUID;
    v_pool RECORD;
BEGIN
    -- Determine organization ID, type, and member type based on the table
    IF TG_TABLE_NAME = 'students' THEN
        IF NEW.school_id IS NOT NULL THEN
            v_organization_id := NEW.school_id;
            v_organization_type := 'school';
        ELSIF NEW.college_id IS NOT NULL THEN
            v_organization_id := NEW.college_id;
            v_organization_type := 'college';
        ELSE
            RETURN NEW;
        END IF;
        v_member_type := 'student';
        v_user_id := NEW.user_id;
        
    ELSIF TG_TABLE_NAME = 'school_educators' THEN
        v_organization_id := NEW.school_id;
        v_organization_type := 'school';
        v_member_type := 'educator';
        v_user_id := NEW.user_id;
        
    ELSIF TG_TABLE_NAME = 'college_lecturers' THEN
        v_organization_id := NEW."collegeId";
        v_organization_type := 'college';
        v_member_type := 'educator';
        v_user_id := NEW.user_id;
        
    ELSE
        RETURN NEW;
    END IF;
    
    IF v_user_id IS NULL OR v_organization_id IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Check if user already has an active license assignment
    IF EXISTS (
        SELECT 1 FROM license_assignments la
        JOIN license_pools lp ON la.license_pool_id = lp.id
        WHERE la.user_id = v_user_id
        AND la.status = 'active'
        AND lp.organization_id = v_organization_id
    ) THEN
        RETURN NEW;
    END IF;
    
    -- Find an eligible pool with auto-assign enabled
    FOR v_pool IN
        SELECT 
            lp.id AS pool_id,
            lp.organization_subscription_id,
            lp.allocated_seats,
            lp.created_by,
            COALESCE(lp.assigned_seats, 0) AS current_assigned
        FROM license_pools lp
        WHERE lp.organization_id = v_organization_id
        AND lp.organization_type = v_organization_type
        AND lp.member_type = v_member_type
        AND lp.auto_assign_new_members = true
        AND lp.is_active = true
        ORDER BY lp.created_at ASC
        LIMIT 1
    LOOP
        IF v_pool.current_assigned < v_pool.allocated_seats THEN
            -- Create the license assignment
            -- The trigger_sync_pool_seats will handle updating the counts
            INSERT INTO license_assignments (
                license_pool_id,
                organization_subscription_id,
                user_id,
                member_type,
                status,
                assigned_at,
                assigned_by
            ) VALUES (
                v_pool.pool_id,
                v_pool.organization_subscription_id,
                v_user_id,
                v_member_type,
                'active',
                NOW(),
                COALESCE(v_pool.created_by, v_user_id)
            );
            
            EXIT;
        END IF;
    END LOOP;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_assign_license_to_member"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."auto_assign_license_to_member"() IS 'Automatically assigns a license from an eligible pool when a new member is added to an organization. 
Pools must have auto_assign_new_members=true, is_active=true, and available seats.';



CREATE OR REPLACE FUNCTION "public"."auto_create_assessment_result"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- Only proceed if status changed to 'completed' and no result exists yet
    IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
        -- Check if result already exists
        IF NOT EXISTS (
            SELECT 1 FROM personal_assessment_results 
            WHERE attempt_id = NEW.id
        ) THEN
            -- Create the result
            INSERT INTO personal_assessment_results (
                attempt_id,
                student_id,
                stream_id,
                grade_level,
                status,
                gemini_results,
                overall_summary,
                created_at,
                updated_at
            ) VALUES (
                NEW.id,
                NEW.student_id,
                NEW.stream_id,
                COALESCE(NEW.grade_level, 'highschool'),
                'completed',
                '{}'::jsonb,
                'Assessment completed - AI analysis will be generated when viewing report',
                COALESCE(NEW.completed_at, NOW()),
                COALESCE(NEW.completed_at, NOW())
            );
            
            RAISE NOTICE 'Auto-created assessment result for attempt %', NEW.id;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_create_assessment_result"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_set_cancelled_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- If status changed to cancelled and cancelled_at is not set
  IF NEW.status = 'cancelled' AND OLD.status != 'cancelled' AND NEW.cancelled_at IS NULL THEN
    NEW.cancelled_at := NOW();
  END IF;
  
  -- If status changed away from cancelled, clear cancelled_at
  IF NEW.status != 'cancelled' AND OLD.status = 'cancelled' THEN
    NEW.cancelled_at := NULL;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_set_cancelled_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."auto_set_university_id"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_university_id UUID;
BEGIN
    -- Get university_id for the college
    SELECT uc.university_id INTO v_university_id
    FROM university_colleges uc
    WHERE uc.college_id = NEW.college_id
    AND uc.account_status = 'active'
    LIMIT 1;
    
    -- Set university_id if college is affiliated
    IF v_university_id IS NOT NULL THEN
        NEW.university_id := v_university_id;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."auto_set_university_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."backfill_assessment_reminders"() RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    assessment_record RECORD;
    reminders_created INTEGER := 0;
BEGIN
    -- Process existing assessments that don't have scheduled reminders
    FOR assessment_record IN 
        SELECT par.* 
        FROM personal_assessment_results par
        WHERE par.status = 'completed'
        AND par.created_at >= NOW() - INTERVAL '6 months' -- Only recent assessments
        AND NOT EXISTS (
            SELECT 1 FROM notifications n 
            WHERE n.assessment_id = par.id 
            AND n.type = 'assessment_6month_reminder'
        )
    LOOP
        -- Use the trigger function logic
        PERFORM schedule_assessment_reminder() FROM (SELECT assessment_record.*) AS NEW;
        reminders_created := reminders_created + 1;
    END LOOP;

    RETURN reminders_created;
END;
$$;


ALTER FUNCTION "public"."backfill_assessment_reminders"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."certificates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "title" character varying(200) NOT NULL,
    "issuer" character varying(150),
    "level" character varying(100),
    "credential_id" character varying(150),
    "link" "text",
    "issued_on" "date",
    "description" "text",
    "status" character varying(50),
    "approval_status" character varying(20) DEFAULT 'pending'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "upload" character varying,
    "document_url" "text",
    "enabled" boolean DEFAULT true,
    "training_id" "uuid",
    "platform" character varying(100),
    "instructor" character varying(255),
    "category" character varying(100),
    "expiry_date" "date",
    "embedding" "extensions"."vector"(1536),
    "pending_edit_data" "jsonb",
    "has_pending_edit" boolean DEFAULT false,
    "verified_data" "jsonb"
);


ALTER TABLE "public"."certificates" OWNER TO "postgres";


COMMENT ON COLUMN "public"."certificates"."pending_edit_data" IS 'Stores the edited version of data awaiting verification';



COMMENT ON COLUMN "public"."certificates"."has_pending_edit" IS 'Flag to indicate if there is a pending edit for this record';



COMMENT ON COLUMN "public"."certificates"."verified_data" IS 'Stores the last verified version of the data';



CREATE OR REPLACE FUNCTION "public"."build_certificate_text"("cert_record" "public"."certificates") RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
  result_text TEXT;
BEGIN
  result_text := '';
  
  -- Title is the primary identifier
  IF cert_record.title IS NOT NULL AND cert_record.title != '' THEN
    result_text := 'Certificate: ' || cert_record.title;
  END IF;
  
  -- Issuer adds credibility context
  IF cert_record.issuer IS NOT NULL AND cert_record.issuer != '' THEN
    result_text := result_text || ' issued by ' || cert_record.issuer;
  END IF;
  
  -- Platform indicates the learning source
  IF cert_record.platform IS NOT NULL AND cert_record.platform != '' THEN
    result_text := result_text || ' on ' || cert_record.platform;
  END IF;
  
  -- Level indicates expertise depth
  IF cert_record.level IS NOT NULL AND cert_record.level != '' THEN
    result_text := result_text || '. Level: ' || cert_record.level;
  END IF;
  
  -- Category for domain classification
  IF cert_record.category IS NOT NULL AND cert_record.category != '' THEN
    result_text := result_text || '. Category: ' || cert_record.category;
  END IF;
  
  -- Description for full context
  IF cert_record.description IS NOT NULL AND cert_record.description != '' THEN
    result_text := result_text || '. ' || cert_record.description;
  END IF;
  
  RETURN result_text;
END;
$$;


ALTER FUNCTION "public"."build_certificate_text"("cert_record" "public"."certificates") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."course_enrollments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "student_name" "text",
    "student_email" "text" NOT NULL,
    "course_id" "uuid" NOT NULL,
    "course_title" "text",
    "educator_id" "uuid",
    "educator_name" "text",
    "enrolled_at" timestamp with time zone DEFAULT "now"(),
    "last_accessed" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "progress" integer DEFAULT 0,
    "completed_lessons" "text"[] DEFAULT '{}'::"text"[],
    "total_lessons" integer DEFAULT 0,
    "status" "text" DEFAULT 'active'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "training_id" "uuid",
    "skills_acquired" "jsonb" DEFAULT '[]'::"jsonb",
    "certificate_url" "text",
    "grade" character varying(10),
    "last_module_index" integer DEFAULT 0,
    "last_lesson_index" integer DEFAULT 0,
    "last_lesson_id" "uuid",
    "last_video_position" integer DEFAULT 0,
    "total_time_spent_seconds" integer DEFAULT 0,
    "sessions_count" integer DEFAULT 1,
    "average_session_duration" integer DEFAULT 0,
    "embedding" "extensions"."vector"(1536)
);


ALTER TABLE "public"."course_enrollments" OWNER TO "postgres";


COMMENT ON COLUMN "public"."course_enrollments"."training_id" IS 'Links to training record created when course is completed';



COMMENT ON COLUMN "public"."course_enrollments"."skills_acquired" IS 'JSON array of skill names acquired from this course';



COMMENT ON COLUMN "public"."course_enrollments"."last_module_index" IS 'Index of last accessed module for restore';



COMMENT ON COLUMN "public"."course_enrollments"."last_lesson_index" IS 'Index of last accessed lesson within module';



COMMENT ON COLUMN "public"."course_enrollments"."last_lesson_id" IS 'UUID of last accessed lesson for validation';



COMMENT ON COLUMN "public"."course_enrollments"."last_video_position" IS 'Video position in seconds for restore';



COMMENT ON COLUMN "public"."course_enrollments"."total_time_spent_seconds" IS 'Total time spent on course';



COMMENT ON COLUMN "public"."course_enrollments"."sessions_count" IS 'Number of learning sessions';



COMMENT ON COLUMN "public"."course_enrollments"."embedding" IS 'Vector embedding (1536 dimensions) for semantic course matching';



CREATE OR REPLACE FUNCTION "public"."build_course_enrollment_text"("p_enrollment" "public"."course_enrollments") RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
  result TEXT := '';
  skills_text TEXT;
BEGIN
  IF p_enrollment.course_title IS NOT NULL THEN
    result := 'Course: ' || p_enrollment.course_title;
  END IF;
  
  IF p_enrollment.status IS NOT NULL THEN
    result := result || ' (Status: ' || p_enrollment.status || ')';
  END IF;
  
  IF p_enrollment.progress IS NOT NULL AND p_enrollment.progress > 0 THEN
    result := result || '. Progress: ' || p_enrollment.progress || '%';
  END IF;
  
  IF p_enrollment.grade IS NOT NULL THEN
    result := result || '. Grade: ' || p_enrollment.grade;
  END IF;
  
  -- Extract skills from JSONB array
  IF p_enrollment.skills_acquired IS NOT NULL AND jsonb_array_length(p_enrollment.skills_acquired) > 0 THEN
    SELECT string_agg(skill::text, ', ') INTO skills_text
    FROM jsonb_array_elements_text(p_enrollment.skills_acquired) AS skill;
    IF skills_text IS NOT NULL THEN
      result := result || '. Skills learned: ' || skills_text;
    END IF;
  END IF;
  
  RETURN result;
END;
$$;


ALTER FUNCTION "public"."build_course_enrollment_text"("p_enrollment" "public"."course_enrollments") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."projects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "title" character varying(200) NOT NULL,
    "description" "text",
    "status" character varying(50),
    "start_date" "date",
    "end_date" "date",
    "duration" character varying(100),
    "tech_stack" "text"[],
    "demo_link" "text",
    "github_link" "text",
    "approval_status" character varying(20) DEFAULT 'pending'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "certificate_url" "text",
    "video_url" "text",
    "ppt_url" "text",
    "organization" "text",
    "enabled" boolean DEFAULT true,
    "approval_authority" character varying(20) DEFAULT 'rareminds_admin'::character varying,
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "rejected_by" "uuid",
    "rejected_at" timestamp with time zone,
    "approval_notes" "text",
    "role" "text",
    "embedding" "extensions"."vector"(1536),
    "pending_edit_data" "jsonb",
    "has_pending_edit" boolean DEFAULT false,
    "verified_data" "jsonb",
    CONSTRAINT "projects_approval_authority_check" CHECK ((("approval_authority")::"text" = ANY (ARRAY[('school_admin'::character varying)::"text", ('college_admin'::character varying)::"text", ('rareminds_admin'::character varying)::"text"]))),
    CONSTRAINT "projects_approval_status_check" CHECK ((("approval_status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('approved'::character varying)::"text", ('rejected'::character varying)::"text", ('verified'::character varying)::"text"])))
);


ALTER TABLE "public"."projects" OWNER TO "postgres";


COMMENT ON COLUMN "public"."projects"."pending_edit_data" IS 'Stores the edited version of data awaiting verification';



COMMENT ON COLUMN "public"."projects"."has_pending_edit" IS 'Flag to indicate if there is a pending edit for this record';



COMMENT ON COLUMN "public"."projects"."verified_data" IS 'Stores the last verified version of the data';



CREATE OR REPLACE FUNCTION "public"."build_project_text"("proj_record" "public"."projects") RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
  result_text TEXT;
  tech_stack_text TEXT;
BEGIN
  result_text := '';
  
  -- Title is the primary identifier
  IF proj_record.title IS NOT NULL AND proj_record.title != '' THEN
    result_text := 'Project: ' || proj_record.title;
  END IF;
  
  -- Role in the project
  IF proj_record.role IS NOT NULL AND proj_record.role != '' THEN
    result_text := result_text || '. Role: ' || proj_record.role;
  END IF;
  
  -- Organization context
  IF proj_record.organization IS NOT NULL AND proj_record.organization != '' THEN
    result_text := result_text || ' at ' || proj_record.organization;
  END IF;
  
  -- Tech stack is crucial for technical matching
  IF proj_record.tech_stack IS NOT NULL AND array_length(proj_record.tech_stack, 1) > 0 THEN
    tech_stack_text := array_to_string(proj_record.tech_stack, ', ');
    result_text := result_text || '. Technologies: ' || tech_stack_text;
  END IF;
  
  -- Description for full context
  IF proj_record.description IS NOT NULL AND proj_record.description != '' THEN
    result_text := result_text || '. ' || proj_record.description;
  END IF;
  
  RETURN result_text;
END;
$$;


ALTER FUNCTION "public"."build_project_text"("proj_record" "public"."projects") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."skills" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "name" character varying(100) NOT NULL,
    "type" character varying(20),
    "level" integer,
    "description" "text",
    "verified" boolean DEFAULT false,
    "enabled" boolean DEFAULT true,
    "approval_status" character varying(20) DEFAULT 'pending'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "training_id" "uuid",
    "proficiency_level" "text",
    "embedding" "extensions"."vector"(1536),
    "pending_edit_data" "jsonb",
    "has_pending_edit" boolean DEFAULT false,
    "verified_data" "jsonb",
    CONSTRAINT "skills_level_check" CHECK ((("level" >= 1) AND ("level" <= 5))),
    CONSTRAINT "skills_type_check" CHECK ((("type")::"text" = ANY (ARRAY[('technical'::character varying)::"text", ('soft'::character varying)::"text"])))
);


ALTER TABLE "public"."skills" OWNER TO "postgres";


COMMENT ON COLUMN "public"."skills"."enabled" IS 'Controls visibility of skill item on profile. Default is true (visible).';



COMMENT ON COLUMN "public"."skills"."embedding" IS 'Vector embedding (1536 dimensions) for semantic skill matching';



COMMENT ON COLUMN "public"."skills"."pending_edit_data" IS 'Stores the edited version of data awaiting verification';



COMMENT ON COLUMN "public"."skills"."has_pending_edit" IS 'Flag to indicate if there is a pending edit for this record';



COMMENT ON COLUMN "public"."skills"."verified_data" IS 'Stores the last verified version of the data';



CREATE OR REPLACE FUNCTION "public"."build_skill_text"("p_skill" "public"."skills") RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
  result TEXT := '';
BEGIN
  IF p_skill.name IS NOT NULL THEN
    result := p_skill.name;
  END IF;
  
  IF p_skill.type IS NOT NULL THEN
    result := result || ' (' || p_skill.type || ' skill)';
  END IF;
  
  IF p_skill.proficiency_level IS NOT NULL THEN
    result := result || '. Proficiency: ' || p_skill.proficiency_level;
  ELSIF p_skill.level IS NOT NULL THEN
    result := result || '. Level: ' || p_skill.level || '/5';
  END IF;
  
  IF p_skill.description IS NOT NULL THEN
    result := result || '. ' || p_skill.description;
  END IF;
  
  RETURN result;
END;
$$;


ALTER FUNCTION "public"."build_skill_text"("p_skill" "public"."skills") OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."trainings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "title" character varying(150) NOT NULL,
    "organization" character varying(150),
    "start_date" "date",
    "end_date" "date",
    "duration" character varying(100),
    "description" "text",
    "approval_status" character varying(20) DEFAULT 'pending'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "status" "text" DEFAULT 'ongoing'::"text",
    "completed_modules" integer DEFAULT 0,
    "total_modules" integer DEFAULT 0,
    "hours_spent" integer DEFAULT 0,
    "course_id" "uuid",
    "source" character varying(50) DEFAULT 'manual'::character varying,
    "approval_authority" character varying(20) DEFAULT 'rareminds_admin'::character varying,
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "approval_notes" "text",
    "rejected_by" "uuid",
    "rejected_at" timestamp with time zone,
    "embedding" "extensions"."vector"(1536),
    CONSTRAINT "trainings_approval_authority_check" CHECK ((("approval_authority")::"text" = ANY (ARRAY[('school_admin'::character varying)::"text", ('college_admin'::character varying)::"text", ('rareminds_admin'::character varying)::"text"]))),
    CONSTRAINT "trainings_source_check" CHECK ((("source")::"text" = ANY (ARRAY[('manual'::character varying)::"text", ('internal_course'::character varying)::"text", ('external_course'::character varying)::"text", ('certification'::character varying)::"text", ('mooc'::character varying)::"text"]))),
    CONSTRAINT "trainings_status_check" CHECK (("status" = ANY (ARRAY['ongoing'::"text", 'completed'::"text"])))
);


ALTER TABLE "public"."trainings" OWNER TO "postgres";


COMMENT ON COLUMN "public"."trainings"."course_id" IS 'Links training to internal course if applicable';



COMMENT ON COLUMN "public"."trainings"."source" IS 'Source of training: manual, internal_course, external_course, certification, mooc';



CREATE OR REPLACE FUNCTION "public"."build_training_text"("training_record" "public"."trainings") RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
  result_text TEXT;
BEGIN
  result_text := '';
  
  -- Title is the primary identifier
  IF training_record.title IS NOT NULL AND training_record.title != '' THEN
    result_text := 'Training: ' || training_record.title;
  END IF;
  
  -- Organization adds credibility
  IF training_record.organization IS NOT NULL AND training_record.organization != '' THEN
    result_text := result_text || ' by ' || training_record.organization;
  END IF;
  
  -- Source indicates the platform
  IF training_record.source IS NOT NULL AND training_record.source != '' THEN
    result_text := result_text || ' via ' || training_record.source;
  END IF;
  
  -- Duration indicates depth
  IF training_record.duration IS NOT NULL AND training_record.duration != '' THEN
    result_text := result_text || '. Duration: ' || training_record.duration;
  END IF;
  
  -- Description for full context
  IF training_record.description IS NOT NULL AND training_record.description != '' THEN
    result_text := result_text || '. ' || training_record.description;
  END IF;
  
  RETURN result_text;
END;
$$;


ALTER FUNCTION "public"."build_training_text"("training_record" "public"."trainings") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_assessment_scores"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  attempt_record RECORD;
  aptitude_questions JSONB;
  knowledge_questions JSONB;
  all_responses JSONB;
  
  -- Score counters
  verbal_correct INT := 0;
  verbal_total INT := 0;
  numerical_correct INT := 0;
  numerical_total INT := 0;
  abstract_correct INT := 0;
  abstract_total INT := 0;
  spatial_correct INT := 0;
  spatial_total INT := 0;
  clerical_correct INT := 0;
  clerical_total INT := 0;
  
  knowledge_correct INT := 0;
  knowledge_total INT := 0;
  
  -- Loop variables
  answer_key TEXT;
  answer_value TEXT;
  question_id TEXT;
  question JSONB;
  correct_answer TEXT;
  subtype TEXT;
  
  -- Final scores
  total_aptitude_correct INT;
  total_aptitude_questions INT;
  aptitude_percentage NUMERIC;
  knowledge_percentage NUMERIC;
  
  -- Updated scores JSONB
  new_aptitude_scores JSONB;
  new_knowledge_details JSONB;
BEGIN
  -- Get the attempt record with all_responses
  SELECT * INTO attempt_record
  FROM personal_assessment_attempts
  WHERE id = NEW.attempt_id;
  
  IF attempt_record IS NULL THEN
    RAISE NOTICE 'No attempt found for attempt_id: %', NEW.attempt_id;
    RETURN NEW;
  END IF;
  
  all_responses := attempt_record.all_responses;
  
  IF all_responses IS NULL THEN
    RAISE NOTICE 'No all_responses found for attempt_id: %', NEW.attempt_id;
    RETURN NEW;
  END IF;
  
  -- Get aptitude questions for this student
  SELECT questions INTO aptitude_questions
  FROM career_assessment_ai_questions
  WHERE student_id = NEW.student_id
    AND question_type = 'aptitude'
    AND is_active = true
  ORDER BY created_at DESC
  LIMIT 1;
  
  -- Get knowledge questions for this student
  SELECT questions INTO knowledge_questions
  FROM career_assessment_ai_questions
  WHERE student_id = NEW.student_id
    AND question_type = 'knowledge'
    AND is_active = true
  ORDER BY created_at DESC
  LIMIT 1;
  
  -- Calculate aptitude scores
  IF aptitude_questions IS NOT NULL THEN
    FOR answer_key, answer_value IN SELECT * FROM jsonb_each_text(all_responses)
    LOOP
      IF answer_key LIKE 'aptitude_%' THEN
        question_id := REPLACE(answer_key, 'aptitude_', '');
        
        -- Find the question in the questions array
        SELECT q INTO question
        FROM jsonb_array_elements(aptitude_questions) AS q
        WHERE q->>'id' = question_id;
        
        IF question IS NOT NULL THEN
          correct_answer := TRIM(question->>'correct_answer');
          subtype := LOWER(COALESCE(question->>'subtype', question->>'category', 'verbal'));
          
          -- Map subtypes to categories
          IF subtype IN ('mathematics', 'math', 'numerical_reasoning', 'numerical', 'data_interpretation', 'economics') THEN
            numerical_total := numerical_total + 1;
            IF TRIM(answer_value) = correct_answer THEN
              numerical_correct := numerical_correct + 1;
            END IF;
          ELSIF subtype IN ('english', 'verbal_reasoning', 'verbal', 'social_studies', 'history', 'civics', 'general_knowledge') THEN
            verbal_total := verbal_total + 1;
            IF TRIM(answer_value) = correct_answer THEN
              verbal_correct := verbal_correct + 1;
            END IF;
          ELSIF subtype IN ('science', 'logical_reasoning', 'logical', 'abstract', 'reasoning', 'pattern_recognition') THEN
            abstract_total := abstract_total + 1;
            IF TRIM(answer_value) = correct_answer THEN
              abstract_correct := abstract_correct + 1;
            END IF;
          ELSIF subtype IN ('geography', 'spatial_reasoning', 'spatial') THEN
            spatial_total := spatial_total + 1;
            IF TRIM(answer_value) = correct_answer THEN
              spatial_correct := spatial_correct + 1;
            END IF;
          ELSE
            -- Default to clerical for unknown types
            clerical_total := clerical_total + 1;
            IF TRIM(answer_value) = correct_answer THEN
              clerical_correct := clerical_correct + 1;
            END IF;
          END IF;
        END IF;
      END IF;
    END LOOP;
  END IF;
  
  -- Calculate knowledge scores
  IF knowledge_questions IS NOT NULL THEN
    FOR answer_key, answer_value IN SELECT * FROM jsonb_each_text(all_responses)
    LOOP
      IF answer_key LIKE 'knowledge_%' THEN
        question_id := REPLACE(answer_key, 'knowledge_', '');
        
        -- Find the question in the questions array
        SELECT q INTO question
        FROM jsonb_array_elements(knowledge_questions) AS q
        WHERE q->>'id' = question_id;
        
        IF question IS NOT NULL THEN
          correct_answer := TRIM(question->>'correct_answer');
          knowledge_total := knowledge_total + 1;
          IF TRIM(answer_value) = correct_answer THEN
            knowledge_correct := knowledge_correct + 1;
          END IF;
        END IF;
      END IF;
    END LOOP;
  END IF;
  
  -- Calculate totals and percentages
  total_aptitude_correct := verbal_correct + numerical_correct + abstract_correct + spatial_correct + clerical_correct;
  total_aptitude_questions := verbal_total + numerical_total + abstract_total + spatial_total + clerical_total;
  
  IF total_aptitude_questions > 0 THEN
    aptitude_percentage := ROUND((total_aptitude_correct::NUMERIC / total_aptitude_questions) * 100, 2);
  ELSE
    aptitude_percentage := 0;
  END IF;
  
  IF knowledge_total > 0 THEN
    knowledge_percentage := ROUND((knowledge_correct::NUMERIC / knowledge_total) * 100, 2);
  ELSE
    knowledge_percentage := 0;
  END IF;
  
  -- Build new aptitude_scores JSONB
  new_aptitude_scores := jsonb_build_object(
    'verbal', jsonb_build_object('correct', verbal_correct, 'total', verbal_total, 'percentage', CASE WHEN verbal_total > 0 THEN ROUND((verbal_correct::NUMERIC / verbal_total) * 100) ELSE 0 END),
    'numerical', jsonb_build_object('correct', numerical_correct, 'total', numerical_total, 'percentage', CASE WHEN numerical_total > 0 THEN ROUND((numerical_correct::NUMERIC / numerical_total) * 100) ELSE 0 END),
    'abstract', jsonb_build_object('correct', abstract_correct, 'total', abstract_total, 'percentage', CASE WHEN abstract_total > 0 THEN ROUND((abstract_correct::NUMERIC / abstract_total) * 100) ELSE 0 END),
    'spatial', jsonb_build_object('correct', spatial_correct, 'total', spatial_total, 'percentage', CASE WHEN spatial_total > 0 THEN ROUND((spatial_correct::NUMERIC / spatial_total) * 100) ELSE 0 END),
    'clerical', jsonb_build_object('correct', clerical_correct, 'total', clerical_total, 'percentage', CASE WHEN clerical_total > 0 THEN ROUND((clerical_correct::NUMERIC / clerical_total) * 100) ELSE 0 END)
  );
  
  -- Build new knowledge_details JSONB
  new_knowledge_details := jsonb_build_object(
    'score', knowledge_percentage,
    'correctCount', knowledge_correct,
    'totalQuestions', knowledge_total,
    'strongTopics', CASE WHEN knowledge_correct > 0 THEN '["Calculated from answers"]'::jsonb ELSE '["No data"]'::jsonb END,
    'weakTopics', CASE WHEN knowledge_total - knowledge_correct > 0 THEN '["Calculated from answers"]'::jsonb ELSE '["No data"]'::jsonb END,
    'recommendation', CASE 
      WHEN knowledge_percentage >= 70 THEN 'Strong knowledge foundation. Continue building expertise.'
      WHEN knowledge_percentage >= 50 THEN 'Good knowledge base. Focus on weak areas for improvement.'
      ELSE 'Focus on building domain expertise through projects and certifications.'
    END
  );
  
  -- Update the NEW record with calculated scores
  NEW.aptitude_scores := new_aptitude_scores;
  NEW.aptitude_overall := aptitude_percentage;
  NEW.knowledge_score := knowledge_percentage;
  NEW.knowledge_details := new_knowledge_details;
  
  -- Also update gemini_results if it exists
  IF NEW.gemini_results IS NOT NULL THEN
    NEW.gemini_results := NEW.gemini_results || jsonb_build_object(
      'aptitude', jsonb_build_object(
        'scores', new_aptitude_scores,
        'overallScore', aptitude_percentage,
        'topStrengths', CASE 
          WHEN numerical_correct >= verbal_correct AND numerical_correct >= abstract_correct THEN '["Numerical Reasoning"]'::jsonb
          WHEN verbal_correct >= numerical_correct AND verbal_correct >= abstract_correct THEN '["Verbal Reasoning"]'::jsonb
          ELSE '["Abstract Reasoning"]'::jsonb
        END,
        'areasToImprove', '["Continue practicing"]'::jsonb,
        'cognitiveProfile', 'Calculated from actual assessment answers.',
        'careerImplications', 'Scores reflect actual performance on aptitude questions.'
      ),
      'knowledge', new_knowledge_details
    );
  END IF;
  
  RAISE NOTICE 'Calculated scores - Aptitude: %/% (%), Knowledge: %/% (%)', 
    total_aptitude_correct, total_aptitude_questions, aptitude_percentage,
    knowledge_correct, knowledge_total, knowledge_percentage;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."calculate_assessment_scores"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."calculate_assessment_scores"() IS 'Automatically calculates aptitude and knowledge scores from student answers stored in personal_assessment_attempts.all_responses by comparing with correct answers in career_assessment_ai_questions table.';



CREATE OR REPLACE FUNCTION "public"."calculate_batch_statistics"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.entries_pending := NEW.total_students - NEW.entries_completed;
  
  IF NEW.total_students > 0 THEN
    NEW.completion_percentage := (NEW.entries_completed::DECIMAL / NEW.total_students * 100);
  ELSE
    NEW.completion_percentage := 0;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."calculate_batch_statistics"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_days_borrowed"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Calculate days borrowed
  IF NEW.return_date IS NOT NULL THEN
    NEW.days_borrowed := NEW.return_date - NEW.issue_date;
  ELSE
    NEW.days_borrowed := CURRENT_DATE - NEW.issue_date;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."calculate_days_borrowed"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_exam_registration_fee"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.total_fee := NEW.registration_fee + NEW.late_fee;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."calculate_exam_registration_fee"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_fine"("issue_date" "date", "return_date" "date" DEFAULT CURRENT_DATE) RETURNS numeric
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    loan_period INTEGER;
    fine_per_day DECIMAL(10,2);
    due_date DATE;
    overdue_days INTEGER;
BEGIN
    -- Get library settings
    SELECT setting_value::INTEGER INTO loan_period 
    FROM library_settings WHERE setting_key = 'default_loan_period_days';
    
    SELECT setting_value::DECIMAL INTO fine_per_day 
    FROM library_settings WHERE setting_key = 'fine_per_day';
    
    -- Calculate due date
    due_date := issue_date + (loan_period || ' days')::INTERVAL;
    
    -- Calculate overdue days
    overdue_days := GREATEST(0, return_date - due_date);
    
    -- Return fine amount
    RETURN overdue_days * fine_per_day;
END;
$$;


ALTER FUNCTION "public"."calculate_fine"("issue_date" "date", "return_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_fine_college"("p_college_id" "uuid", "issue_date" "date", "return_date" "date" DEFAULT CURRENT_DATE) RETURNS numeric
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    loan_period INTEGER;
    fine_per_day DECIMAL(10,2);
    due_date DATE;
    overdue_days INTEGER;
BEGIN
    -- Get library settings for specific college
    SELECT setting_value::INTEGER INTO loan_period 
    FROM library_settings_college 
    WHERE college_id = p_college_id AND setting_key = 'default_loan_period_days';
    
    SELECT setting_value::DECIMAL INTO fine_per_day 
    FROM library_settings_college 
    WHERE college_id = p_college_id AND setting_key = 'fine_per_day';
    
    -- Use default values if settings not found
    loan_period := COALESCE(loan_period, 14);
    fine_per_day := COALESCE(fine_per_day, 10);
    
    -- Calculate due date
    due_date := issue_date + (loan_period || ' days')::INTERVAL;
    
    -- Calculate overdue days
    overdue_days := GREATEST(0, return_date - due_date);
    
    -- Return fine amount
    RETURN overdue_days * fine_per_day;
END;
$$;


ALTER FUNCTION "public"."calculate_fine_college"("p_college_id" "uuid", "issue_date" "date", "return_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_fine_school"("p_school_id" "uuid", "issue_date" "date", "return_date" "date" DEFAULT CURRENT_DATE) RETURNS numeric
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    loan_period INTEGER;
    fine_per_day DECIMAL(10,2);
    due_date DATE;
    overdue_days INTEGER;
BEGIN
    -- Get library settings for this school
    SELECT setting_value::INTEGER INTO loan_period 
    FROM library_settings_school 
    WHERE school_id = p_school_id AND setting_key = 'default_loan_period_days';
    
    SELECT setting_value::DECIMAL INTO fine_per_day 
    FROM library_settings_school 
    WHERE school_id = p_school_id AND setting_key = 'fine_per_day';
    
    -- Use defaults if settings not found
    loan_period := COALESCE(loan_period, 14);
    fine_per_day := COALESCE(fine_per_day, 10);
    
    -- Calculate due date
    due_date := issue_date + (loan_period || ' days')::INTERVAL;
    
    -- Calculate overdue days
    overdue_days := GREATEST(0, return_date - due_date);
    
    -- Return fine amount
    RETURN overdue_days * fine_per_day;
END;
$$;


ALTER FUNCTION "public"."calculate_fine_school"("p_school_id" "uuid", "issue_date" "date", "return_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_internship_duration"("start_date" "date", "end_date" "date") RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
  diff_days INTEGER;
  diff_months INTEGER;
  diff_weeks INTEGER;
  duration_text TEXT;
BEGIN
  IF start_date IS NULL OR end_date IS NULL THEN
    RETURN NULL;
  END IF;

  diff_days := end_date - start_date;

  IF diff_days >= 30 THEN
    diff_months := FLOOR(diff_days / 30);
    duration_text := diff_months || ' month';
    IF diff_months > 1 THEN
      duration_text := duration_text || 's';
    END IF;
  ELSIF diff_days >= 14 THEN
    diff_weeks := FLOOR(diff_days / 7);
    duration_text := diff_weeks || ' week';
    IF diff_weeks > 1 THEN
      duration_text := duration_text || 's';
    END IF;
  ELSIF diff_days > 1 THEN
    duration_text := diff_days || ' days';
  ELSE
    duration_text := '1 day';
  END IF;

  RETURN TO_CHAR(start_date, 'Mon YYYY') || ' â€“ ' ||
         TO_CHAR(end_date, 'Mon YYYY') || ' (' || duration_text || ')';
END;
$$;


ALTER FUNCTION "public"."calculate_internship_duration"("start_date" "date", "end_date" "date") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_library_fine"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Calculate days overdue
  IF NEW.return_date IS NULL AND CURRENT_DATE > NEW.due_date THEN
    NEW.days_overdue := CURRENT_DATE - NEW.due_date;
  ELSIF NEW.return_date IS NOT NULL AND NEW.return_date > NEW.due_date THEN
    NEW.days_overdue := NEW.return_date - NEW.due_date;
  ELSE
    NEW.days_overdue := 0;
  END IF;
  
  -- Calculate fine amount
  NEW.fine_amount := NEW.days_overdue * NEW.fine_per_day;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."calculate_library_fine"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_moderation_difference"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.difference := NEW.moderated_marks - NEW.original_marks;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."calculate_moderation_difference"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_session_stats"("p_session_id" "uuid") RETURNS TABLE("total_questions" integer, "total_correct" integer, "overall_accuracy" numeric, "avg_response_time_ms" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*)::INTEGER as total_questions,
    COUNT(*) FILTER (WHERE is_correct)::INTEGER as total_correct,
    ROUND((COUNT(*) FILTER (WHERE is_correct)::DECIMAL / NULLIF(COUNT(*), 0)) * 100, 2) as overall_accuracy,
    ROUND(AVG(response_time_ms))::INTEGER as avg_response_time_ms
  FROM adaptive_aptitude_responses
  WHERE session_id = p_session_id;
END;
$$;


ALTER FUNCTION "public"."calculate_session_stats"("p_session_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_teacher_workload"("p_educator_id" "uuid", "p_timetable_id" "uuid") RETURNS TABLE("total_periods" integer, "max_consecutive" integer, "exceeds_limit" boolean, "consecutive_violation" boolean)
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_total_periods INTEGER;
  v_max_consecutive INTEGER;
BEGIN
  -- Count total periods per week
  SELECT COUNT(*)
  INTO v_total_periods
  FROM timetable_slots
  WHERE educator_id = p_educator_id AND timetable_id = p_timetable_id;
  
  -- Calculate max consecutive classes
  WITH consecutive_periods AS (
    SELECT 
      day_of_week,
      period_number,
      period_number - ROW_NUMBER() OVER (PARTITION BY day_of_week ORDER BY period_number) AS grp
    FROM timetable_slots
    WHERE educator_id = p_educator_id AND timetable_id = p_timetable_id
  ),
  consecutive_counts AS (
    SELECT 
      day_of_week,
      grp,
      COUNT(*) AS consecutive_count
    FROM consecutive_periods
    GROUP BY day_of_week, grp
  )
  SELECT COALESCE(MAX(consecutive_count), 0)
  INTO v_max_consecutive
  FROM consecutive_counts;
  
  -- Update workload table
  INSERT INTO teacher_workload (educator_id, timetable_id, total_periods_per_week, max_consecutive_classes, last_calculated)
  VALUES (p_educator_id, p_timetable_id, v_total_periods, v_max_consecutive, NOW())
  ON CONFLICT (educator_id, timetable_id)
  DO UPDATE SET 
    total_periods_per_week = v_total_periods,
    max_consecutive_classes = v_max_consecutive,
    last_calculated = NOW();
  
  RETURN QUERY SELECT 
    v_total_periods,
    v_max_consecutive,
    v_total_periods > 30 AS exceeds_limit,
    v_max_consecutive > 3 AS consecutive_violation;
END;
$$;


ALTER FUNCTION "public"."calculate_teacher_workload"("p_educator_id" "uuid", "p_timetable_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."calculate_transcript_request_fee"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.total_fee := NEW.processing_fee + NEW.courier_charges;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."calculate_transcript_request_fee"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."can_student_join_club"("p_student_email" character varying, "p_club_id" "uuid") RETURNS TABLE("can_join" boolean, "reason" "text")
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_club_capacity INTEGER;
    v_current_members INTEGER;
    v_student_clubs INTEGER;
    v_max_clubs INTEGER := 5;
    v_club_school UUID;
    v_student_school UUID;
    v_already_member BOOLEAN;
BEGIN
    -- Check if already a member
    SELECT EXISTS(
        SELECT 1 FROM public.club_memberships 
        WHERE club_id = p_club_id 
        AND student_email = p_student_email 
        AND status = 'active'
    ) INTO v_already_member;
    
    IF v_already_member THEN
        RETURN QUERY SELECT FALSE, 'Already a member of this club';
        RETURN;
    END IF;
    
    -- Check school match
    SELECT school_id INTO v_club_school FROM public.clubs WHERE club_id = p_club_id;
    SELECT school_id INTO v_student_school FROM public.students WHERE email = p_student_email;
    
    IF v_club_school != v_student_school THEN
        RETURN QUERY SELECT FALSE, 'Student and club belong to different schools';
        RETURN;
    END IF;
    
    -- Check club capacity
    SELECT capacity INTO v_club_capacity FROM public.clubs WHERE club_id = p_club_id;
    SELECT COUNT(*) INTO v_current_members 
    FROM public.club_memberships 
    WHERE club_id = p_club_id AND status = 'active';
    
    IF v_current_members >= v_club_capacity THEN
        RETURN QUERY SELECT FALSE, 'Club is at full capacity';
        RETURN;
    END IF;
    
    -- Check student's club count
    SELECT COUNT(*) INTO v_student_clubs
    FROM public.club_memberships
    WHERE student_email = p_student_email AND status = 'active';
    
    IF v_student_clubs >= v_max_clubs THEN
        RETURN QUERY SELECT FALSE, 'Student has reached maximum club limit';
        RETURN;
    END IF;
    
    -- All checks passed
    RETURN QUERY SELECT TRUE, 'Can join club'::TEXT;
END;
$$;


ALTER FUNCTION "public"."can_student_join_club"("p_student_email" character varying, "p_club_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."can_student_join_club"("p_student_email" character varying, "p_club_id" "uuid") IS 'Validates if a student can join a specific club';



CREATE OR REPLACE FUNCTION "public"."can_take_assessment"("p_student_id" "text", "p_grade_level" "text") RETURNS boolean
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_last_restriction RECORD;
BEGIN
  SELECT * INTO v_last_restriction
  FROM public.personal_assessment_restrictions
  WHERE student_id = p_student_id AND grade_level = p_grade_level
  ORDER BY last_attempt_date DESC LIMIT 1;

  IF v_last_restriction IS NULL THEN
    RETURN true;
  END IF;

  IF NOW() >= v_last_restriction.next_allowed_date THEN
    RETURN true;
  END IF;

  RETURN false;
END;
$$;


ALTER FUNCTION "public"."can_take_assessment"("p_student_id" "text", "p_grade_level" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_attendance_alerts"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_student RECORD;
  v_total_days INTEGER;
  v_present_days INTEGER;
  v_absent_days INTEGER;
  v_percentage DECIMAL(5,2);
  v_consecutive_absent INTEGER;
BEGIN
  -- Loop through all active students
  FOR v_student IN 
    SELECT DISTINCT s.id, s.school_id
    FROM students s
    INNER JOIN student_management_records spe ON s.id = spe.student_id
    WHERE spe.status = 'active'
  LOOP
    -- Calculate attendance for last 30 days
    SELECT 
      COUNT(*) as total,
      COUNT(*) FILTER (WHERE status = 'present') as present,
      COUNT(*) FILTER (WHERE status = 'absent') as absent
    INTO v_total_days, v_present_days, v_absent_days
    FROM attendance_records
    WHERE student_id = v_student.id
      AND date >= CURRENT_DATE - INTERVAL '30 days';
    
    -- Calculate percentage
    IF v_total_days > 0 THEN
      v_percentage := (v_present_days::DECIMAL / v_total_days) * 100;
      
      -- Check if below 75%
      IF v_percentage < 75 THEN
        INSERT INTO attendance_alerts (student_id, school_id, alert_type, message, attendance_percentage)
        VALUES (
          v_student.id,
          v_student.school_id,
          'below_75',
          'Attendance has fallen below 75%',
          v_percentage
        )
        ON CONFLICT DO NOTHING;
      END IF;
    END IF;
    
    -- Check consecutive absences
    SELECT COUNT(*) INTO v_consecutive_absent
    FROM (
      SELECT date, status,
             date - ROW_NUMBER() OVER (ORDER BY date)::INTEGER * INTERVAL '1 day' as grp
      FROM attendance_records
      WHERE student_id = v_student.id
        AND status = 'absent'
        AND date >= CURRENT_DATE - INTERVAL '7 days'
    ) sub
    GROUP BY grp
    ORDER BY COUNT(*) DESC
    LIMIT 1;
    
    -- Alert if 3+ consecutive absences
    IF v_consecutive_absent >= 3 THEN
      INSERT INTO attendance_alerts (student_id, school_id, alert_type, message, days_absent)
      VALUES (
        v_student.id,
        v_student.school_id,
        'consecutive_absent',
        'Student has been absent for ' || v_consecutive_absent || ' consecutive days',
        v_consecutive_absent
      )
      ON CONFLICT DO NOTHING;
    END IF;
  END LOOP;
END;
$$;


ALTER FUNCTION "public"."check_attendance_alerts"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_attendance_slot_id"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Log a warning if slot_id is null (for debugging)
    IF NEW.slot_id IS NULL THEN
        RAISE WARNING 'Attendance record created without slot_id for student_id: %, date: %', NEW.student_id, NEW.date;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_attendance_slot_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_break_date_overlap"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  existing_break RECORD;
BEGIN
  -- Check for overlapping date ranges for the same college
  SELECT id, name, break_type, start_date, end_date INTO existing_break
  FROM college_breaks
  WHERE college_id = NEW.college_id
    AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
    AND start_date IS NOT NULL
    AND end_date IS NOT NULL
    AND NEW.start_date IS NOT NULL
    AND NEW.end_date IS NOT NULL
    AND NEW.start_date <= end_date
    AND NEW.end_date >= start_date
  LIMIT 1;

  IF FOUND THEN
    RAISE EXCEPTION 'Date range overlaps with existing break: "%" (% to %)', 
      existing_break.name, existing_break.start_date, existing_break.end_date;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_break_date_overlap"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_budget_alerts"("p_budget_id" "uuid", "p_budget_head_name" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_budget RECORD;
  v_utilization DECIMAL(5,2);
  v_alert_threshold DECIMAL(5,2);
BEGIN
  -- Get budget details
  SELECT * INTO v_budget
  FROM department_budgets
  WHERE id = p_budget_id;
  
  -- Check overall utilization
  v_utilization := v_budget.utilization_percentage;
  v_alert_threshold := v_budget.alert_threshold_percentage;
  
  -- Create alert if threshold reached
  IF v_utilization >= v_alert_threshold AND NOT v_budget.alert_sent THEN
    INSERT INTO budget_alerts (
      budget_id,
      department_id,
      alert_type,
      alert_level,
      allocated_amount,
      spent_amount,
      remaining_amount,
      utilization_percentage,
      alert_message
    ) VALUES (
      p_budget_id,
      v_budget.department_id,
      'threshold_reached',
      CASE 
        WHEN v_utilization >= 95 THEN 'critical'
        WHEN v_utilization >= v_alert_threshold THEN 'warning'
        ELSE 'info'
      END,
      v_budget.total_allocated,
      v_budget.total_spent,
      v_budget.total_remaining,
      v_utilization,
      format('Budget utilization has reached %s%%. Allocated: %s, Spent: %s, Remaining: %s',
        v_utilization, v_budget.total_allocated, v_budget.total_spent, v_budget.total_remaining)
    );
    
    -- Mark alert as sent
    UPDATE department_budgets
    SET alert_sent = TRUE
    WHERE id = p_budget_id;
  END IF;
  
  -- Check for overspending
  IF v_budget.total_spent > v_budget.total_allocated THEN
    INSERT INTO budget_alerts (
      budget_id,
      department_id,
      alert_type,
      alert_level,
      allocated_amount,
      spent_amount,
      remaining_amount,
      utilization_percentage,
      alert_message
    ) VALUES (
      p_budget_id,
      v_budget.department_id,
      'budget_exceeded',
      'critical',
      v_budget.total_allocated,
      v_budget.total_spent,
      v_budget.total_remaining,
      v_utilization,
      format('Budget exceeded! Allocated: %s, Spent: %s, Overspent: %s',
        v_budget.total_allocated, v_budget.total_spent, 
        v_budget.total_spent - v_budget.total_allocated)
    );
  END IF;
END;
$$;


ALTER FUNCTION "public"."check_budget_alerts"("p_budget_id" "uuid", "p_budget_head_name" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_club_capacity"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    current_members INTEGER;
    club_capacity INTEGER;
BEGIN
    -- Only check for active memberships
    IF NEW.status = 'active' THEN
        SELECT capacity INTO club_capacity
        FROM public.clubs 
        WHERE club_id = NEW.club_id;
        
        SELECT COUNT(*) INTO current_members
        FROM public.club_memberships
        WHERE club_id = NEW.club_id 
        AND status = 'active'
        AND membership_id != COALESCE(NEW.membership_id, '00000000-0000-0000-0000-000000000000'::UUID);
        
        IF current_members >= club_capacity THEN
            RAISE EXCEPTION 'Club is full (capacity: %). Cannot enroll more students.', club_capacity;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_club_capacity"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_college_affiliation"() RETURNS TABLE("is_affiliated" boolean, "college_id" "uuid", "university_id" "uuid", "university_name" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_id UUID;
    v_college_id UUID;
    v_university_id UUID;
    v_university_name TEXT;
    v_is_affiliated BOOLEAN := FALSE;
BEGIN
    -- Get current user ID
    v_user_id := auth.uid();
    
    -- Get college_id from user
    SELECT u."organizationId" INTO v_college_id
    FROM users u
    WHERE u.id = v_user_id;
    
    IF v_college_id IS NULL THEN
        RETURN QUERY SELECT FALSE, NULL::UUID, NULL::UUID, NULL::TEXT;
        RETURN;
    END IF;
    
    -- Check if college is affiliated with a university
    SELECT uc.university_id, o.name INTO v_university_id, v_university_name
    FROM university_colleges uc
    JOIN organizations o ON o.id = uc.university_id
    WHERE uc.college_id = v_college_id
    AND uc.account_status = 'active'
    LIMIT 1;
    
    v_is_affiliated := (v_university_id IS NOT NULL);
    
    RETURN QUERY SELECT v_is_affiliated, v_college_id, v_university_id, v_university_name;
END;
$$;


ALTER FUNCTION "public"."check_college_affiliation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_college_affiliation_status"("p_college_id" "uuid", "p_university_id" "uuid" DEFAULT NULL::"uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- If university_id is provided, check specific affiliation
    IF p_university_id IS NOT NULL THEN
        RETURN EXISTS (
            SELECT 1 FROM university_colleges 
            WHERE college_id = p_college_id 
            AND university_id = p_university_id
            AND account_status = 'active'
        );
    END IF;
    
    -- Otherwise, check if college is affiliated with any university
    RETURN EXISTS (
        SELECT 1 FROM university_colleges 
        WHERE college_id = p_college_id 
        AND account_status = 'active'
    );
END;
$$;


ALTER FUNCTION "public"."check_college_affiliation_status"("p_college_id" "uuid", "p_university_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_duplicate_active_subscription"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Only check on INSERT operations, not UPDATE
  -- This allows renewals (updating existing subscription) to work
  IF TG_OP = 'INSERT' AND NEW.status = 'active' THEN
    -- Check if there's already an active subscription for this user and plan
    IF EXISTS (
      SELECT 1 FROM public.subscriptions
      WHERE user_id = NEW.user_id
        AND plan_type = NEW.plan_type
        AND status = 'active'
        AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
    ) THEN
      RAISE EXCEPTION 'User already has an active % subscription. Please cancel the existing subscription before purchasing again.', NEW.plan_type
        USING HINT = 'Cancel existing subscription first or manage your current subscription',
              ERRCODE = '23505'; -- unique_violation error code
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_duplicate_active_subscription"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."check_duplicate_active_subscription"() IS 'Prevents users from having multiple active subscriptions of the same plan type';



CREATE OR REPLACE FUNCTION "public"."check_max_clubs_per_student"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    club_count INTEGER;
    max_clubs INTEGER := 5; -- Configure this value as needed
BEGIN
    -- Only check for active memberships
    IF NEW.status = 'active' THEN
        SELECT COUNT(*) INTO club_count
        FROM public.club_memberships
        WHERE student_email = NEW.student_email
        AND status = 'active'
        AND membership_id != COALESCE(NEW.membership_id, '00000000-0000-0000-0000-000000000000'::UUID);
        
        IF club_count >= max_clubs THEN
            RAISE EXCEPTION 'Student cannot join more than % clubs', max_clubs;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_max_clubs_per_student"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_swap_conflicts"("p_requester_slot_id" "uuid", "p_target_slot_id" "uuid", "p_swap_date" "date" DEFAULT NULL::"date") RETURNS TABLE("has_conflict" boolean, "conflict_reason" "text")
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_requester_slot RECORD;
  v_target_slot RECORD;
BEGIN
  -- Try to get slot from school timetable_slots first
  SELECT 
    id, timetable_id, day_of_week, period_number, start_time, end_time
  INTO v_requester_slot 
  FROM timetable_slots 
  WHERE id = p_requester_slot_id;
  
  -- If not found, try college_timetable_slots
  IF v_requester_slot IS NULL THEN
    SELECT 
      id, timetable_id, day_of_week, period_number, start_time, end_time
    INTO v_requester_slot 
    FROM college_timetable_slots 
    WHERE id = p_requester_slot_id;
  END IF;
  
  -- Try to get target slot from school timetable_slots first
  SELECT 
    id, timetable_id, day_of_week, period_number, start_time, end_time
  INTO v_target_slot 
  FROM timetable_slots 
  WHERE id = p_target_slot_id;
  
  -- If not found, try college_timetable_slots
  IF v_target_slot IS NULL THEN
    SELECT 
      id, timetable_id, day_of_week, period_number, start_time, end_time
    INTO v_target_slot 
    FROM college_timetable_slots 
    WHERE id = p_target_slot_id;
  END IF;
  
  -- Check if slots exist
  IF v_requester_slot IS NULL OR v_target_slot IS NULL THEN
    RETURN QUERY SELECT true, 'One or both slots not found'::TEXT;
    RETURN;
  END IF;
  
  -- Check if slots are from the same timetable
  IF v_requester_slot.timetable_id != v_target_slot.timetable_id THEN
    RETURN QUERY SELECT true, 'Slots must be from the same timetable'::TEXT;
    RETURN;
  END IF;
  
  -- Check if time slots overlap (for permanent swaps)
  IF p_swap_date IS NULL THEN
    IF v_requester_slot.day_of_week = v_target_slot.day_of_week AND
       v_requester_slot.period_number = v_target_slot.period_number THEN
      RETURN QUERY SELECT true, 'Cannot swap slots at the same time'::TEXT;
      RETURN;
    END IF;
  END IF;
  
  -- No conflicts found
  RETURN QUERY SELECT false, 'No conflicts detected'::TEXT;
END;
$$;


ALTER FUNCTION "public"."check_swap_conflicts"("p_requester_slot_id" "uuid", "p_target_slot_id" "uuid", "p_swap_date" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."check_swap_conflicts"("p_requester_slot_id" "uuid", "p_target_slot_id" "uuid", "p_swap_date" "date") IS 'Validates swap requests for scheduling conflicts';



CREATE OR REPLACE FUNCTION "public"."check_timetable_slot_conflicts"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  conflict_faculty RECORD;
  conflict_room RECORD;
BEGIN
  -- Check faculty conflict (same educator at same day/period in different class)
  SELECT 
    cts.id,
    cc.name as class_name,
    cc.grade,
    cc.section
  INTO conflict_faculty
  FROM college_timetable_slots cts
  JOIN college_classes cc ON cc.id = cts.class_id
  WHERE cts.timetable_id = NEW.timetable_id
    AND cts.educator_id = NEW.educator_id
    AND cts.day_of_week = NEW.day_of_week
    AND cts.period_number = NEW.period_number
    AND cts.class_id != NEW.class_id
    AND cts.id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
    AND (
      -- Both are recurring
      (NEW.is_recurring = true AND cts.is_recurring = true)
      -- Or both are on same specific date
      OR (NEW.schedule_date IS NOT NULL AND cts.schedule_date = NEW.schedule_date)
      -- Or new is specific date and existing is recurring (conflict on that day)
      OR (NEW.schedule_date IS NOT NULL AND cts.is_recurring = true)
      -- Or new is recurring and existing is specific date (would conflict)
      OR (NEW.is_recurring = true AND cts.schedule_date IS NOT NULL)
    )
  LIMIT 1;

  IF FOUND THEN
    RAISE EXCEPTION 'Faculty conflict: This faculty is already scheduled for % (%-%) at this time slot', 
      conflict_faculty.class_name, 
      conflict_faculty.grade, 
      conflict_faculty.section;
  END IF;

  -- Check room conflict (same room at same day/period) - only if room is specified
  IF NEW.room_number IS NOT NULL AND NEW.room_number != '' THEN
    SELECT 
      cts.id,
      cc.name as class_name,
      cc.grade,
      cc.section,
      cl.first_name,
      cl.last_name
    INTO conflict_room
    FROM college_timetable_slots cts
    JOIN college_classes cc ON cc.id = cts.class_id
    LEFT JOIN college_lecturers cl ON cl.id = cts.educator_id
    WHERE cts.timetable_id = NEW.timetable_id
      AND LOWER(cts.room_number) = LOWER(NEW.room_number)
      AND cts.day_of_week = NEW.day_of_week
      AND cts.period_number = NEW.period_number
      AND cts.id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
      AND (
        (NEW.is_recurring = true AND cts.is_recurring = true)
        OR (NEW.schedule_date IS NOT NULL AND cts.schedule_date = NEW.schedule_date)
        OR (NEW.schedule_date IS NOT NULL AND cts.is_recurring = true)
        OR (NEW.is_recurring = true AND cts.schedule_date IS NOT NULL)
      )
    LIMIT 1;

    IF FOUND THEN
      RAISE EXCEPTION 'Room conflict: Room % is already booked by % (%-%) with %', 
        NEW.room_number,
        conflict_room.class_name, 
        conflict_room.grade, 
        conflict_room.section,
        COALESCE(conflict_room.first_name || ' ' || conflict_room.last_name, 'Unknown');
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_timetable_slot_conflicts"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_embedding_queue"("days_old" integer DEFAULT 7) RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM embedding_queue
  WHERE status IN ('completed', 'failed')
    AND completed_at < NOW() - (days_old || ' days')::INTERVAL;
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$;


ALTER FUNCTION "public"."cleanup_embedding_queue"("days_old" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cleanup_expired_job_matches_cache"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_deleted_count INTEGER;
BEGIN
    DELETE FROM student_job_matches
    WHERE expires_at < NOW() - INTERVAL '7 days'
    OR (is_valid = false AND updated_at < NOW() - INTERVAL '1 day');
    
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
    RETURN v_deleted_count;
END;
$$;


ALTER FUNCTION "public"."cleanup_expired_job_matches_cache"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."cleanup_expired_job_matches_cache"() IS 'Cleanup function to remove old expired cache entries.';



CREATE OR REPLACE FUNCTION "public"."cleanup_expired_otps"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  DELETE FROM phone_otps WHERE expires_at < NOW();
  DELETE FROM otp_requests_log WHERE created_at < NOW() - INTERVAL '24 hours';
END;
$$;


ALTER FUNCTION "public"."cleanup_expired_otps"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."complete_embedding_queue_item"("queue_id" "uuid", "success" boolean, "error_msg" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE embedding_queue
  SET 
    status = CASE WHEN success THEN 'completed' ELSE 'failed' END,
    processed_at = NOW(),
    error_message = error_msg
  WHERE id = queue_id;
END;
$$;


ALTER FUNCTION "public"."complete_embedding_queue_item"("queue_id" "uuid", "success" boolean, "error_msg" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."compute_student_profile_hash"("p_student_id" "uuid") RETURNS character varying
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_hash_input TEXT;
    v_student RECORD;
    v_courses TEXT;
    v_trainings TEXT;
BEGIN
    -- Get student data (using actual column names from students table)
    SELECT 
        s.id,
        s.name,
        s.email,
        s.branch_field,
        s.semester,
        s."currentCgpa",
        s.skill_summary,
        s.interests,
        s.hobbies,
        s.metadata
    INTO v_student
    FROM students s
    WHERE s.id = p_student_id;
    
    IF NOT FOUND THEN
        RETURN NULL;
    END IF;
    
    -- Get course enrollments
    SELECT COALESCE(string_agg(ce.course_id::text || ':' || ce.status || ':' || COALESCE(ce.progress::text, '0'), '|' ORDER BY ce.course_id), '')
    INTO v_courses
    FROM course_enrollments ce
    WHERE ce.student_id = p_student_id;
    
    -- Get trainings
    SELECT COALESCE(string_agg(t.id::text || ':' || t.status, '|' ORDER BY t.id), '')
    INTO v_trainings
    FROM trainings t
    WHERE t.student_id = p_student_id;
    
    -- Build hash input from all relevant fields
    v_hash_input := COALESCE(v_student.name, '') || '|' ||
                    COALESCE(v_student.branch_field, '') || '|' ||
                    COALESCE(v_student.semester::text, '') || '|' ||
                    COALESCE(v_student."currentCgpa"::text, '') || '|' ||
                    COALESCE(v_student.skill_summary, '') || '|' ||
                    COALESCE(v_student.interests::text, '') || '|' ||
                    COALESCE(v_student.hobbies::text, '') || '|' ||
                    COALESCE(v_student.metadata::text, '') || '|' ||
                    v_courses || '|' ||
                    v_trainings;
    
    -- Return MD5 hash
    RETURN md5(v_hash_input);
END;
$$;


ALTER FUNCTION "public"."compute_student_profile_hash"("p_student_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."compute_student_profile_hash"("p_student_id" "uuid") IS 'Computes a hash of all student data relevant to job matching for cache invalidation.';



CREATE OR REPLACE FUNCTION "public"."copy_curriculum_template"("p_source_curriculum_id" "uuid", "p_target_school_id" "uuid", "p_target_subject" character varying, "p_target_class" character varying, "p_target_academic_year" character varying, "p_created_by" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_new_curriculum_id UUID;
  v_chapter_record RECORD;
  v_new_chapter_id UUID;
  v_outcome_record RECORD;
  v_new_outcome_id UUID;
  v_mapping_record RECORD;
BEGIN
  -- Create new curriculum
  INSERT INTO curriculums (
    school_id, subject, class, academic_year, status, created_by
  ) VALUES (
    p_target_school_id, p_target_subject, p_target_class, p_target_academic_year, 'draft', p_created_by
  ) RETURNING id INTO v_new_curriculum_id;
  
  -- Copy chapters
  FOR v_chapter_record IN 
    SELECT * FROM curriculum_chapters 
    WHERE curriculum_id = p_source_curriculum_id 
    ORDER BY order_number
  LOOP
    INSERT INTO curriculum_chapters (
      curriculum_id, name, code, description, order_number, 
      estimated_duration, duration_unit
    ) VALUES (
      v_new_curriculum_id, v_chapter_record.name, v_chapter_record.code, 
      v_chapter_record.description, v_chapter_record.order_number,
      v_chapter_record.estimated_duration, v_chapter_record.duration_unit
    ) RETURNING id INTO v_new_chapter_id;
    
    -- Copy learning outcomes for this chapter
    FOR v_outcome_record IN 
      SELECT * FROM curriculum_learning_outcomes 
      WHERE chapter_id = v_chapter_record.id
    LOOP
      INSERT INTO curriculum_learning_outcomes (
        chapter_id, outcome, bloom_level
      ) VALUES (
        v_new_chapter_id, v_outcome_record.outcome, v_outcome_record.bloom_level
      ) RETURNING id INTO v_new_outcome_id;
      
      -- Copy assessment mappings for this outcome
      FOR v_mapping_record IN 
        SELECT * FROM outcome_assessment_mappings 
        WHERE learning_outcome_id = v_outcome_record.id
      LOOP
        INSERT INTO outcome_assessment_mappings (
          learning_outcome_id, assessment_type_id, weightage
        ) VALUES (
          v_new_outcome_id, v_mapping_record.assessment_type_id, v_mapping_record.weightage
        );
      END LOOP;
    END LOOP;
  END LOOP;
  
  RETURN v_new_curriculum_id;
END;
$$;


ALTER FUNCTION "public"."copy_curriculum_template"("p_source_curriculum_id" "uuid", "p_target_school_id" "uuid", "p_target_subject" character varying, "p_target_class" character varying, "p_target_academic_year" character varying, "p_created_by" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_assessment_restriction"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
    INSERT INTO public.personal_assessment_restrictions (student_id, last_attempt_date, next_allowed_date, grade_level)
    VALUES (NEW.student_id, NEW.completed_at, NEW.completed_at + INTERVAL '90 days', NEW.grade_level)
    ON CONFLICT (student_id, grade_level)
    DO UPDATE SET
      last_attempt_date = EXCLUDED.last_attempt_date,
      next_allowed_date = EXCLUDED.next_allowed_date;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_assessment_restriction"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_faculty_leave_balances"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Insert leave balance records for all active leave types of the college
  INSERT INTO college_faculty_leave_balances (college_id, faculty_id, leave_type_id, academic_year, total_days, used_days)
  SELECT 
    NEW."collegeId",
    NEW.id,
    lt.id,
    '2025-2026',  -- Current academic year
    COALESCE(lt.max_days_per_year, 0),
    0
  FROM college_leave_types lt
  WHERE lt.college_id = NEW."collegeId" 
    AND lt.is_active = true;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_faculty_leave_balances"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_faculty_leave_balances"() IS 'Automatically creates leave balance records for all active leave types when a new lecturer is added';



CREATE OR REPLACE FUNCTION "public"."create_index_if_not_exists"("p_index_name" "text", "p_table_name" "text", "p_definition" "text") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes 
        WHERE schemaname = 'public' 
        AND indexname = p_index_name
    ) THEN
        EXECUTE format('CREATE INDEX %I ON %I %s', 
            p_index_name, p_table_name, p_definition);
        RAISE NOTICE 'Created index %', p_index_name;
    ELSE
        RAISE NOTICE 'Index % already exists, skipping', p_index_name;
    END IF;
END;
$$;


ALTER FUNCTION "public"."create_index_if_not_exists"("p_index_name" "text", "p_table_name" "text", "p_definition" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_message_notification"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
declare
  v_sender_name text;
  v_notification_title text;
  v_notification_message text;
begin
  -- Only create notification if receiver is a student
  if new.receiver_type = 'student' then
    -- Get sender name based on sender_type
    if new.sender_type = 'recruiter' then
      -- Fix: Use correct column names for recruiters table
      select coalesce(name, email) into v_sender_name
      from recruiters
      where id = new.sender_id;
    elsif new.sender_type = 'educator' then
      select coalesce(first_name || ' ' || last_name, email) into v_sender_name
      from school_educators
      where id = new.sender_id;
    elsif new.sender_type = 'school_admin' then
      select coalesce("firstName" || ' ' || "lastName", email) into v_sender_name
      from users
      where id = new.sender_id;
    elsif new.sender_type = 'college_admin' then
      select coalesce("firstName" || ' ' || "lastName", email) into v_sender_name
      from users
      where id = new.sender_id;
    elsif new.sender_type = 'student' then
      select coalesce(profile->>'name', email) into v_sender_name
      from students
      where id = new.sender_id;
    end if;

    v_sender_name := coalesce(v_sender_name, 'Someone');
    v_notification_title := 'New message from ' || v_sender_name;
    v_notification_message := substring(new.message_text from 1 for 100);

    -- Create notification for the student
    insert into notifications (
      recipient_id,
      type,
      title,
      message,
      read
    ) values (
      new.receiver_id,
      'new_message',
      v_notification_title,
      v_notification_message,
      false
    );
  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."create_message_notification"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_notification_from_pipeline_activity"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_student_id UUID;
  v_candidate_name TEXT;
  v_opportunity_title TEXT;
  v_notification_type TEXT;
  v_notification_title TEXT;
  v_notification_message TEXT;
BEGIN
  -- Get student ID from pipeline_candidates
  SELECT student_id INTO v_student_id
  FROM pipeline_candidates
  WHERE id = NEW.pipeline_candidate_id
  LIMIT 1;

  -- Get candidate name and opportunity title
  SELECT 
    pc.candidate_name,
    o.title
  INTO 
    v_candidate_name,
    v_opportunity_title
  FROM pipeline_candidates pc
  LEFT JOIN opportunities o ON pc.opportunity_id = o.id
  WHERE pc.id = NEW.pipeline_candidate_id
  LIMIT 1;

  -- Determine notification type and message based on activity
  IF NEW.activity_type = 'stage_change' THEN
    -- Stage change notification
    v_notification_type := 'pipeline_stage_changed';
    
    IF NEW.to_stage = 'hired' THEN
      v_notification_title := 'Congratulations! You''ve been hired!';
      v_notification_message := 'Great news! You have been selected for the position of ' || COALESCE(v_opportunity_title, 'the opportunity') || '.';
    ELSIF NEW.to_stage = 'offer' THEN
      v_notification_title := 'Offer Extended!';
      v_notification_message := 'You have received an offer for ' || COALESCE(v_opportunity_title, 'a position') || '. Review the details in your dashboard.';
    ELSIF NEW.to_stage = 'interview_2' THEN
      v_notification_title := 'Advanced to Final Interview';
      v_notification_message := 'Congratulations! You have been selected for the final interview round for ' || COALESCE(v_opportunity_title, 'a position') || '.';
    ELSIF NEW.to_stage = 'interview_1' THEN
      v_notification_title := 'Interview Scheduled';
      v_notification_message := 'You have been selected for an interview for ' || COALESCE(v_opportunity_title, 'a position') || '.';
    ELSIF NEW.to_stage = 'screened' THEN
      v_notification_title := 'Application Screened';
      v_notification_message := 'Your application for ' || COALESCE(v_opportunity_title, 'a position') || ' is under review.';
    ELSIF NEW.to_stage = 'rejected' THEN
      v_notification_type := 'candidate_rejected';
      v_notification_title := 'Application Status Update';
      v_notification_message := 'Thank you for your interest in ' || COALESCE(v_opportunity_title, 'a position') || '. We have decided to move forward with other candidates.';
    END IF;
  
  ELSIF NEW.activity_type = 'note_added' THEN
    v_notification_type := 'pipeline_stage_changed';
    v_notification_title := 'Update on your application';
    v_notification_message := 'Your application for ' || COALESCE(v_opportunity_title, 'a position') || ' has been updated.';
  
  ELSIF NEW.activity_type = 'next_action_set' THEN
    v_notification_type := 'interview_reminder';
    v_notification_title := 'Action Required';
    v_notification_message := 'Next steps for your application for ' || COALESCE(v_opportunity_title, 'a position') || ' have been set.';
  
  ELSE
    -- For other activity types, use generic notification
    v_notification_type := 'pipeline_stage_changed';
    v_notification_title := 'Application Update';
    v_notification_message := 'Your application for ' || COALESCE(v_opportunity_title, 'a position') || ' has been updated.';
  END IF;

  -- Only create notification if student_id exists
  IF v_student_id IS NOT NULL THEN
    -- Store student_id in the pipeline_activities record if not already set
    IF NEW.student_id IS NULL THEN
      NEW.student_id := v_student_id;
    END IF;

    -- Create notification in notifications table
    INSERT INTO notifications (
      recipient_id,
      type,
      title,
      message,
      read,
      created_at
    ) VALUES (
      v_student_id,
      v_notification_type,
      v_notification_title,
      v_notification_message,
      false,
      NOW()
    );
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_notification_from_pipeline_activity"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_skills_from_external_course"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  skill_name text;
  training_record_id uuid;
BEGIN
  -- Only process when course is completed
  IF NEW.completion_date IS NOT NULL AND (OLD IS NULL OR OLD.completion_date IS NULL OR OLD.completion_date != NEW.completion_date) THEN
    
    -- Create or update training record
    IF NEW.training_id IS NULL THEN
      INSERT INTO public.trainings (
        student_id,
        title,
        organization,
        start_date,
        end_date,
        status,
        source
      ) VALUES (
        NEW.student_id,
        NEW.course_name,
        NEW.organization,
        NEW.start_date,
        NEW.completion_date,
        'completed',
        'external_course'
      )
      RETURNING id INTO training_record_id;
      
      -- Update external course with training_id
      NEW.training_id := training_record_id;
    END IF;
    
    -- Create skills from skills_acquired array
    IF NEW.skills_acquired IS NOT NULL AND jsonb_array_length(NEW.skills_acquired) > 0 THEN
      FOR skill_name IN SELECT jsonb_array_elements_text(NEW.skills_acquired)
      LOOP
        INSERT INTO public.skills (
          student_id,
          name,
          type,
          level,
          training_id,
          verified,
          approval_status
        ) VALUES (
          NEW.student_id,
          skill_name,
          'technical',
          3, -- Default level
          COALESCE(NEW.training_id, training_record_id),
          true, -- Auto-verified from course completion
          'approved'
        )
        ON CONFLICT DO NOTHING;
      END LOOP;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_skills_from_external_course"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_skills_from_internal_course"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  skill_name text;
  training_record_id uuid;
BEGIN
  -- Only process when course is completed
  IF NEW.completed_at IS NOT NULL AND (OLD.completed_at IS NULL OR OLD.completed_at != NEW.completed_at) THEN
    
    -- Create or update training record
    IF NEW.training_id IS NULL THEN
      INSERT INTO public.trainings (
        student_id,
        title,
        organization,
        start_date,
        end_date,
        status,
        course_id,
        source
      ) VALUES (
        NEW.student_id,
        NEW.course_title,
        NEW.educator_name,
        NEW.enrolled_at::date,
        NEW.completed_at::date,
        'completed',
        NEW.course_id,
        'internal_course'
      )
      RETURNING id INTO training_record_id;
      
      -- Update enrollment with training_id
      NEW.training_id := training_record_id;
    END IF;
    
    -- Create skills from skills_acquired array
    IF NEW.skills_acquired IS NOT NULL AND jsonb_array_length(NEW.skills_acquired) > 0 THEN
      FOR skill_name IN SELECT jsonb_array_elements_text(NEW.skills_acquired)
      LOOP
        INSERT INTO public.skills (
          student_id,
          name,
          type,
          level,
          training_id,
          verified,
          approval_status
        ) VALUES (
          NEW.student_id,
          skill_name,
          'technical',
          3, -- Default level
          COALESCE(NEW.training_id, training_record_id),
          true, -- Auto-verified from course completion
          'approved'
        )
        ON CONFLICT DO NOTHING;
      END LOOP;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_skills_from_internal_course"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_student_with_user"("p_email" "text", "p_name" "text", "p_student_id" "text", "p_grade" "text", "p_school_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_id UUID;
    v_first_name TEXT;
    v_last_name TEXT;
BEGIN
    v_user_id := gen_random_uuid();
    v_first_name := split_part(p_name, ' ', 1);
    v_last_name := COALESCE(split_part(p_name, ' ', 2), '');
    
    INSERT INTO public.users (
        id,
        email,
        role,
        "firstName",
        "lastName",
        "createdAt",
        "updatedAt"
    ) VALUES (
        v_user_id,
        p_email,
        'school_student',
        v_first_name,
        v_last_name,
        NOW(),
        NOW()
    ) ON CONFLICT (email) DO UPDATE SET email = EXCLUDED.email
    RETURNING id INTO v_user_id;
    
    INSERT INTO public.students (
        id,
        user_id,
        school_id,
        name,
        email,
        student_id,
        grade,
        student_type,
        created_at
    ) VALUES (
        v_user_id,
        v_user_id,
        p_school_id,
        p_name,
        p_email,
        p_student_id,
        p_grade,
        'direct',
        NOW()
    ) ON CONFLICT (email) DO NOTHING;
    
    RETURN v_user_id;
END;
$$;


ALTER FUNCTION "public"."create_student_with_user"("p_email" "text", "p_name" "text", "p_student_id" "text", "p_grade" "text", "p_school_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_swap_history_entry"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- On INSERT, create 'created' history entry
  IF TG_OP = 'INSERT' THEN
    INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
    VALUES (NEW.id, 'created', NEW.requester_faculty_id, 'requester', NEW.reason);
    RETURN NEW;
  END IF;
  
  -- On UPDATE, detect what changed and create appropriate history entry
  IF TG_OP = 'UPDATE' THEN
    -- Status changed to accepted
    IF OLD.status = 'pending' AND NEW.status = 'accepted' THEN
      INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
      VALUES (NEW.id, 'accepted', NEW.target_faculty_id, 'target', NEW.target_response);
    END IF;
    
    -- Status changed to rejected
    IF OLD.status = 'pending' AND NEW.status = 'rejected' THEN
      INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
      VALUES (NEW.id, 'rejected', NEW.target_faculty_id, 'target', NEW.target_response);
    END IF;
    
    -- Status changed to cancelled
    IF NEW.status = 'cancelled' THEN
      INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
      VALUES (NEW.id, 'cancelled', NEW.requester_faculty_id, 'requester', 'Request cancelled by requester');
    END IF;
    
    -- Admin approval status changed
    IF OLD.admin_approval_status IS DISTINCT FROM NEW.admin_approval_status THEN
      IF NEW.admin_approval_status = 'approved' THEN
        INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
        VALUES (NEW.id, 'admin_approved', NEW.admin_id, 'admin', NEW.admin_response);
      ELSIF NEW.admin_approval_status = 'rejected' THEN
        INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
        VALUES (NEW.id, 'admin_rejected', NEW.admin_id, 'admin', NEW.admin_response);
      END IF;
    END IF;
    
    -- Status changed to completed
    IF OLD.status != 'completed' AND NEW.status = 'completed' THEN
      INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
      VALUES (NEW.id, 'completed', COALESCE(NEW.admin_id, NEW.requester_faculty_id), 'admin', 'Swap completed successfully');
    END IF;
    
    RETURN NEW;
  END IF;
  
  RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."create_swap_history_entry"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."curriculum_add_pending_change"("p_curriculum_id" "uuid", "p_change_type" "text", "p_entity_id" "uuid" DEFAULT NULL::"uuid", "p_change_data" "jsonb" DEFAULT '{}'::"jsonb", "p_message" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_change_id UUID;
  v_user_id UUID;
  v_user_name TEXT;
  v_user_email TEXT;
BEGIN
  -- Get current user info
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'User not authenticated';
  END IF;
  
  SELECT name, email INTO v_user_name, v_user_email
  FROM users 
  WHERE id = v_user_id;
  
  -- Generate new change ID
  v_change_id := gen_random_uuid();
  
  -- Add to pending_changes JSONB array in college_curriculums
  UPDATE college_curriculums 
  SET 
    pending_changes = COALESCE(pending_changes, '[]'::jsonb) || 
    jsonb_build_object(
      'id', v_change_id,
      'change_type', p_change_type,
      'entity_id', p_entity_id,
      'request_timestamp', NOW(),
      'requested_by', v_user_id,
      'requester_name', COALESCE(v_user_name, v_user_email, 'Unknown'),
      'request_message', p_message,
      'status', 'pending',
      'data', p_change_data
    ),
    has_pending_changes = true,
    updated_at = NOW()
  WHERE id = p_curriculum_id;
  
  -- Add to change_history for tracking
  UPDATE college_curriculums 
  SET 
    change_history = COALESCE(change_history, '[]'::jsonb) || 
    jsonb_build_object(
      'id', v_change_id,
      'action', 'change_requested',
      'change_type', p_change_type,
      'request_timestamp', NOW(),
      'user_id', v_user_id,
      'user_name', COALESCE(v_user_name, v_user_email, 'Unknown'),
      'message', p_message
    )
  WHERE id = p_curriculum_id;
  
  RETURN v_change_id;
END;
$$;


ALTER FUNCTION "public"."curriculum_add_pending_change"("p_curriculum_id" "uuid", "p_change_type" "text", "p_entity_id" "uuid", "p_change_data" "jsonb", "p_message" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."curriculum_approve_pending_change"("p_curriculum_id" "uuid", "p_change_id" "uuid", "p_review_notes" "text" DEFAULT NULL::"text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_change JSONB;
  v_change_type TEXT;
  v_change_data JSONB;
  v_entity_id UUID;
  v_user_id UUID;
  v_user_name TEXT;
  v_user_email TEXT;
  v_new_outcome_id UUID;
  v_pending_changes JSONB;
  v_updated_changes JSONB;
  v_change_elem JSONB;
  v_outcome_unit_id UUID;
  v_outcome_text TEXT;
  v_bloom_level TEXT;
  v_assessment_mappings JSONB;
BEGIN
  -- Get current user info
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'User not authenticated';
  END IF;
  
  SELECT name, email INTO v_user_name, v_user_email
  FROM users 
  WHERE id = v_user_id;
  
  -- Get pending changes
  SELECT pending_changes INTO v_pending_changes
  FROM college_curriculums
  WHERE id = p_curriculum_id;
  
  IF v_pending_changes IS NULL THEN
    RAISE EXCEPTION 'No pending changes found for curriculum';
  END IF;
  
  -- Find the specific change
  v_change := NULL;
  FOR i IN 0..jsonb_array_length(v_pending_changes) - 1 LOOP
    v_change_elem := v_pending_changes->i;
    IF v_change_elem->>'id' = p_change_id::text THEN
      v_change := v_change_elem;
      EXIT;
    END IF;
  END LOOP;
  
  IF v_change IS NULL THEN
    RAISE EXCEPTION 'Change request not found with ID: %', p_change_id;
  END IF;
  
  -- Extract change details
  v_change_type := v_change->>'change_type';
  v_change_data := v_change->'data';
  v_entity_id := (v_change->>'entity_id')::UUID;
  
  -- Apply the change based on type
  IF v_change_type = 'outcome_add' THEN
    -- Add new outcome - handle the specific data structure we found
    -- Data structure: {"data": {"unitId": "...", "outcome": "...", "bloomLevel": "...", "assessmentMappings": [...]}}
    
    -- Extract unit_id (it's nested as data.data.unitId)
    v_outcome_unit_id := NULL;
    IF v_change_data->'data'->>'unitId' IS NOT NULL THEN
      v_outcome_unit_id := (v_change_data->'data'->>'unitId')::UUID;
    ELSIF v_change_data->'data'->>'unit_id' IS NOT NULL THEN
      v_outcome_unit_id := (v_change_data->'data'->>'unit_id')::UUID;
    ELSIF v_change_data->>'unitId' IS NOT NULL THEN
      v_outcome_unit_id := (v_change_data->>'unitId')::UUID;
    ELSIF v_change_data->>'unit_id' IS NOT NULL THEN
      v_outcome_unit_id := (v_change_data->>'unit_id')::UUID;
    END IF;
    
    -- Extract outcome text (it's nested as data.data.outcome)
    v_outcome_text := NULL;
    IF v_change_data->'data'->>'outcome' IS NOT NULL THEN
      v_outcome_text := v_change_data->'data'->>'outcome';
    ELSIF v_change_data->'data'->>'outcome_text' IS NOT NULL THEN
      v_outcome_text := v_change_data->'data'->>'outcome_text';
    ELSIF v_change_data->>'outcome' IS NOT NULL THEN
      v_outcome_text := v_change_data->>'outcome';
    ELSIF v_change_data->>'outcome_text' IS NOT NULL THEN
      v_outcome_text := v_change_data->>'outcome_text';
    END IF;
    
    -- Extract bloom level (it's nested as data.data.bloomLevel)
    v_bloom_level := 'Apply'; -- Default value
    IF v_change_data->'data'->>'bloomLevel' IS NOT NULL THEN
      v_bloom_level := v_change_data->'data'->>'bloomLevel';
    ELSIF v_change_data->'data'->>'bloom_level' IS NOT NULL THEN
      v_bloom_level := v_change_data->'data'->>'bloom_level';
    ELSIF v_change_data->>'bloomLevel' IS NOT NULL THEN
      v_bloom_level := v_change_data->>'bloomLevel';
    ELSIF v_change_data->>'bloom_level' IS NOT NULL THEN
      v_bloom_level := v_change_data->>'bloom_level';
    END IF;
    
    -- Extract assessment mappings (it's nested as data.data.assessmentMappings)
    v_assessment_mappings := '[]'::jsonb;
    IF v_change_data->'data'->'assessmentMappings' IS NOT NULL THEN
      v_assessment_mappings := v_change_data->'data'->'assessmentMappings';
    ELSIF v_change_data->'data'->'assessment_mappings' IS NOT NULL THEN
      v_assessment_mappings := v_change_data->'data'->'assessment_mappings';
    ELSIF v_change_data->'assessmentMappings' IS NOT NULL THEN
      v_assessment_mappings := v_change_data->'assessmentMappings';
    ELSIF v_change_data->'assessment_mappings' IS NOT NULL THEN
      v_assessment_mappings := v_change_data->'assessment_mappings';
    END IF;
    
    -- Validate required fields
    IF v_outcome_unit_id IS NULL THEN
      RAISE EXCEPTION 'unit_id is required for outcome_add but was not found. Change data: %. Looking for: data.data.unitId or data.data.unit_id', v_change_data::text;
    END IF;
    
    IF v_outcome_text IS NULL OR v_outcome_text = '' OR v_outcome_text = 'NA' THEN
      RAISE EXCEPTION 'outcome_text is required for outcome_add but was not found or is invalid. Change data: %. Looking for: data.data.outcome or data.data.outcome_text', v_change_data::text;
    END IF;
    
    -- Verify the unit exists
    IF NOT EXISTS (SELECT 1 FROM college_curriculum_units WHERE id = v_outcome_unit_id AND curriculum_id = p_curriculum_id) THEN
      RAISE EXCEPTION 'Unit with id % does not exist in curriculum %', v_outcome_unit_id, p_curriculum_id;
    END IF;
    
    -- Add new outcome
    v_new_outcome_id := gen_random_uuid();
    INSERT INTO college_curriculum_outcomes (
      id,
      curriculum_id,
      unit_id,
      outcome_text,
      bloom_level,
      assessment_mappings,
      created_by,
      updated_by
    ) VALUES (
      v_new_outcome_id,
      p_curriculum_id,
      v_outcome_unit_id,
      v_outcome_text,
      v_bloom_level,
      v_assessment_mappings,
      v_user_id,
      v_user_id
    );
    
  ELSE
    RAISE EXCEPTION 'This function currently only handles outcome_add changes. Change type: %', v_change_type;
  END IF;
  
  -- Remove the change from pending_changes array
  SELECT jsonb_agg(elem) INTO v_updated_changes
  FROM jsonb_array_elements(v_pending_changes) elem
  WHERE elem->>'id' != p_change_id::text;
  
  UPDATE college_curriculums 
  SET 
    pending_changes = COALESCE(v_updated_changes, '[]'::jsonb),
    has_pending_changes = CASE 
      WHEN jsonb_array_length(COALESCE(v_updated_changes, '[]'::jsonb)) > 0 THEN true 
      ELSE false 
    END,
    updated_at = NOW()
  WHERE id = p_curriculum_id;
  
  -- Add to change_history
  UPDATE college_curriculums 
  SET 
    change_history = COALESCE(change_history, '[]'::jsonb) || 
    jsonb_build_object(
      'id', p_change_id,
      'action', 'change_approved',
      'change_type', v_change_type,
      'request_timestamp', NOW(),
      'user_id', v_user_id,
      'user_name', COALESCE(v_user_name, v_user_email, 'Unknown'),
      'review_notes', p_review_notes,
      'applied', true
    )
  WHERE id = p_curriculum_id;
  
  RETURN TRUE;
END;
$$;


ALTER FUNCTION "public"."curriculum_approve_pending_change"("p_curriculum_id" "uuid", "p_change_id" "uuid", "p_review_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."curriculum_reject_pending_change"("p_curriculum_id" "uuid", "p_change_id" "uuid", "p_review_notes" "text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_change JSONB;
  v_change_type TEXT;
  v_user_id UUID;
  v_user_name TEXT;
  v_user_email TEXT;
  v_pending_changes JSONB;
  v_updated_changes JSONB;
  v_change_elem JSONB;
BEGIN
  -- Get current user info
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'User not authenticated';
  END IF;
  
  SELECT name, email INTO v_user_name, v_user_email
  FROM users 
  WHERE id = v_user_id;
  
  -- Get pending changes
  SELECT pending_changes INTO v_pending_changes
  FROM college_curriculums
  WHERE id = p_curriculum_id;
  
  IF v_pending_changes IS NULL THEN
    RAISE EXCEPTION 'No pending changes found for curriculum';
  END IF;
  
  -- Find the specific change
  v_change := NULL;
  FOR i IN 0..jsonb_array_length(v_pending_changes) - 1 LOOP
    v_change_elem := v_pending_changes->i;
    IF v_change_elem->>'id' = p_change_id::text THEN
      v_change := v_change_elem;
      EXIT;
    END IF;
  END LOOP;
  
  IF v_change IS NULL THEN
    RAISE EXCEPTION 'Change request not found';
  END IF;
  
  v_change_type := v_change->>'change_type';
  
  -- Remove the change from pending_changes array
  SELECT jsonb_agg(elem) INTO v_updated_changes
  FROM jsonb_array_elements(v_pending_changes) elem
  WHERE elem->>'id' != p_change_id::text;
  
  UPDATE college_curriculums 
  SET 
    pending_changes = COALESCE(v_updated_changes, '[]'::jsonb),
    has_pending_changes = CASE 
      WHEN jsonb_array_length(COALESCE(v_updated_changes, '[]'::jsonb)) > 0 THEN true 
      ELSE false 
    END,
    updated_at = NOW()
  WHERE id = p_curriculum_id;
  
  -- Add to change_history
  UPDATE college_curriculums 
  SET 
    change_history = COALESCE(change_history, '[]'::jsonb) || 
    jsonb_build_object(
      'id', p_change_id,
      'action', 'change_rejected',
      'change_type', v_change_type,
      'request_timestamp', NOW(),
      'user_id', v_user_id,
      'user_name', COALESCE(v_user_name, v_user_email, 'Unknown'),
      'review_notes', p_review_notes,
      'applied', false
    )
  WHERE id = p_curriculum_id;
  
  RETURN TRUE;
END;
$$;


ALTER FUNCTION "public"."curriculum_reject_pending_change"("p_curriculum_id" "uuid", "p_change_id" "uuid", "p_review_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."decrement_applications_count"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE public.opportunities
  SET applications_count = GREATEST(applications_count - 1, 0)
  WHERE id = OLD.opportunity_id;
  RETURN OLD;
END;
$$;


ALTER FUNCTION "public"."decrement_applications_count"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."delete_from_profile_array"("p_student_id" "uuid", "p_array_name" "text", "p_item_id" integer) RETURNS "jsonb"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_profile JSONB;
  v_array JSONB;
  v_new_array JSONB := '[]'::jsonb;
  v_item JSONB;
BEGIN
  -- Get current profile
  SELECT profile INTO v_profile
  FROM students
  WHERE id = p_student_id;
  
  -- Get array
  v_array := v_profile -> p_array_name;
  
  -- Filter out matching item
  FOR v_item IN SELECT * FROM jsonb_array_elements(v_array)
  LOOP
    IF (v_item->>'id')::int != p_item_id THEN
      v_new_array := v_new_array || v_item;
    END IF;
  END LOOP;
  
  -- Update profile
  v_profile := jsonb_set(v_profile, ARRAY[p_array_name], v_new_array);
  
  -- Save and return
  UPDATE students SET profile = v_profile WHERE id = p_student_id;
  
  RETURN v_profile;
END;
$$;


ALTER FUNCTION "public"."delete_from_profile_array"("p_student_id" "uuid", "p_array_name" "text", "p_item_id" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."delete_from_profile_array"("p_student_id" "uuid", "p_array_name" "text", "p_item_id" integer) IS 'Delete an item from a JSONB array';



CREATE OR REPLACE FUNCTION "public"."detect_timetable_conflicts"("p_timetable_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Clear existing unresolved conflicts
  DELETE FROM timetable_conflicts 
  WHERE timetable_id = p_timetable_id AND resolved = FALSE;
  
  -- Check for max periods exceeded
  INSERT INTO timetable_conflicts (timetable_id, conflict_type, educator_id, conflict_details)
  SELECT 
    p_timetable_id,
    'max_periods_exceeded',
    educator_id,
    jsonb_build_object('total_periods', total_periods_per_week, 'limit', 30)
  FROM teacher_workload
  WHERE timetable_id = p_timetable_id AND total_periods_per_week > 30;
  
  -- Check for consecutive classes exceeded
  INSERT INTO timetable_conflicts (timetable_id, conflict_type, educator_id, conflict_details)
  SELECT 
    p_timetable_id,
    'consecutive_classes_exceeded',
    educator_id,
    jsonb_build_object('max_consecutive', max_consecutive_classes, 'limit', 3)
  FROM teacher_workload
  WHERE timetable_id = p_timetable_id AND max_consecutive_classes > 3;
  
  -- Check for double booking
  INSERT INTO timetable_conflicts (timetable_id, conflict_type, educator_id, slot_id, conflict_details)
  SELECT 
    p_timetable_id,
    'double_booking',
    ts1.educator_id,
    ts1.id,
    jsonb_build_object('day', ts1.day_of_week, 'period', ts1.period_number, 'conflicting_slots', jsonb_agg(ts2.id))
  FROM timetable_slots ts1
  JOIN timetable_slots ts2 ON 
    ts1.timetable_id = ts2.timetable_id AND
    ts1.educator_id = ts2.educator_id AND
    ts1.day_of_week = ts2.day_of_week AND
    ts1.period_number = ts2.period_number AND
    ts1.id < ts2.id
  WHERE ts1.timetable_id = p_timetable_id
  GROUP BY ts1.id, ts1.educator_id, ts1.day_of_week, ts1.period_number;
END;
$$;


ALTER FUNCTION "public"."detect_timetable_conflicts"("p_timetable_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."expire_old_subscriptions"() RETURNS TABLE("expired_count" integer)
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  count INTEGER;
BEGIN
  WITH expired_subs AS (
    UPDATE public.subscriptions
    SET 
      status = 'expired'::subscription_status,
      auto_renew = false,
      updated_at = NOW()
    WHERE 
      status IN ('active', 'cancelled', 'paused')
      AND subscription_end_date < NOW()
      AND subscription_end_date IS NOT NULL
    RETURNING id
  )
  SELECT COUNT(*)::INTEGER INTO count FROM expired_subs;
  
  RETURN QUERY SELECT count;
END;
$$;


ALTER FUNCTION "public"."expire_old_subscriptions"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_certificate_credential_id"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    IF NEW.credential_id IS NULL THEN
        NEW.credential_id := UPPER(SUBSTRING(
            CASE NEW.certificate_type
                WHEN 'course_completion' THEN 'CC'
                WHEN 'skill_achievement' THEN 'SA'
                WHEN 'competition' THEN 'CM'
                WHEN 'workshop' THEN 'WS'
                WHEN 'leadership' THEN 'LD'
                WHEN 'participation' THEN 'PT'
                WHEN 'excellence' THEN 'EX'
                ELSE 'CT'
            END || '-' ||
            TO_CHAR(NEW.issued_date, 'YYYY') || '-' ||
            LPAD(FLOOR(RANDOM() * 10000)::TEXT, 4, '0'),
            1, 20
        ));
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."generate_certificate_credential_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_enrollment_number"("p_school_id" "uuid", "p_academic_year" "text") RETURNS "text"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_count INTEGER;
  v_enrollment_number TEXT;
BEGIN
  -- Count existing enrollments for this school and year
  SELECT COUNT(*) INTO v_count
  FROM student_management_records
  WHERE school_id = p_school_id
    AND academic_year = p_academic_year;
  
  -- Generate enrollment number: YEAR-SCHOOLID-SEQUENCE
  v_enrollment_number := p_academic_year || '-' || 
                         SUBSTRING(p_school_id::TEXT, 1, 8) || '-' || 
                         LPAD((v_count + 1)::TEXT, 4, '0');
  
  RETURN v_enrollment_number;
END;
$$;


ALTER FUNCTION "public"."generate_enrollment_number"("p_school_id" "uuid", "p_academic_year" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_student_id"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  seq_num TEXT;
  prefix TEXT;
  year_part TEXT;
  name_part TEXT;
BEGIN
  IF NEW.student_id IS NULL THEN
    -- ðŸ”¹ Generate next sequence (8 digits)
    seq_num := lpad(nextval('student_id_seq')::text, 8, '0');

    -- ðŸ”¹ Remove ALL non-alphabetic characters (no spaces, dots, etc.)
    name_part := upper(substring(regexp_replace(coalesce(NEW.name, 'NONAME'), '[^A-Za-z]', '', 'g') from 1 for 3));

    -- ðŸ”¹ Extract year from createdAt (or now if missing)
    year_part := to_char(coalesce(NEW."createdAt", now()), 'YY');

    -- ðŸ”¹ Build final ID
    prefix := 'STU';
    NEW.student_id := prefix || '-' || name_part || year_part || '-' || seq_num;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."generate_student_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."generate_teacher_id"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $_$
DECLARE
  school_code VARCHAR(10);
  next_number INTEGER;
  new_teacher_id VARCHAR(20);
BEGIN
  -- Get school code from organizations table
  SELECT COALESCE(UPPER(SUBSTRING(name FROM 1 FOR 3)), 'SCH')
  INTO school_code
  FROM organizations
  WHERE id = NEW.school_id AND organization_type = 'school';
  
  -- Get next sequential number
  SELECT COALESCE(MAX(CAST(SUBSTRING(teacher_id FROM '[0-9]+$') AS INTEGER)), 0) + 1
  INTO next_number
  FROM school_educators
  WHERE school_id = NEW.school_id AND teacher_id IS NOT NULL;
  
  -- Generate Teacher ID: SCHOOLCODE-T-0001
  new_teacher_id := school_code || '-T-' || LPAD(next_number::TEXT, 4, '0');
  
  NEW.teacher_id := new_teacher_id;
  RETURN NEW;
END;
$_$;


ALTER FUNCTION "public"."generate_teacher_id"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."getActiveEnrollment"("p_studentId" "uuid") RETURNS TABLE("enrollmentId" "uuid", "entityType" "text", "entityName" "text", "className" "text", "enrollmentDate" "date", "expectedGraduationDate" "date")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        se."id" as "enrollmentId",
        CASE 
            WHEN se."schoolId" IS NOT NULL THEN 'school'
            WHEN se."collegeId" IS NOT NULL THEN 'college'
            WHEN se."universityId" IS NOT NULL THEN 'university'
        END as "entityType",
        o."name" as "entityName",
        COALESCE(sc."name", cc."name", uc."name") as "className",
        se."enrollmentDate",
        se."expectedGraduationDate"
    FROM "studentEnrollments" se
    LEFT JOIN "organizations" o ON (se."schoolId" = o."id" OR se."collegeId" = o."id" OR se."universityId" = o."id")
    LEFT JOIN "school_classes" sc ON se."schoolClassId" = sc."id"
    LEFT JOIN "college_courses" cc ON se."collegeCourseId" = cc."id"
    LEFT JOIN "university_courses" uc ON se."universityCourseId" = uc."id"
    WHERE se."studentId" = "p_studentId"
    AND se."enrollmentStatus" = 'active'
    ORDER BY se."enrollmentDate" DESC
    LIMIT 1;
END;
$$;


ALTER FUNCTION "public"."getActiveEnrollment"("p_studentId" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_active_subscription"("uid" "uuid") RETURNS TABLE("id" "uuid", "plan_type" character varying, "subscription_end_date" timestamp with time zone)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT s.id, s.plan_type, s.subscription_end_date
  FROM subscriptions s
  WHERE s.user_id = uid
    AND s.status = 'active'
    AND s.subscription_end_date > NOW()
  ORDER BY s.subscription_end_date DESC
  LIMIT 1;
END;
$$;


ALTER FUNCTION "public"."get_active_subscription"("uid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_all_pending_changes_for_university"("p_university_id" "uuid") RETURNS TABLE("curriculum_id" "uuid", "curriculum_name" "text", "college_name" "text", "change_id" "uuid", "change_type" "text", "change_timestamp" timestamp with time zone, "requester_name" "text", "request_message" "text", "change_data" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_id UUID;
    v_user_role TEXT;
    v_user_org_id UUID;
BEGIN
    -- Get current user
    v_user_id := auth.uid();
    
    IF v_user_id IS NULL THEN 
        RAISE EXCEPTION 'User not authenticated'; 
    END IF;
    
    -- Get user role and organization
    SELECT role, "organizationId" 
    INTO v_user_role, v_user_org_id 
    FROM users 
    WHERE id = v_user_id;
    
    -- Check if user is university admin
    IF v_user_role != 'university_admin' THEN 
        RAISE EXCEPTION 'Only university admins can view pending changes'; 
    END IF;
    
    -- Verify user can access this university
    IF v_user_org_id IS NOT NULL AND v_user_org_id != p_university_id THEN 
        RAISE EXCEPTION 'Access denied: You can only view changes for your own university'; 
    END IF;
    
    -- Return pending changes
    RETURN QUERY
    SELECT 
        c.id::UUID,
        CASE 
            WHEN cc.course_name IS NOT NULL AND cc.course_name != '' 
            THEN CONCAT(cc.course_name, ' ', c.academic_year)::TEXT
            ELSE c.academic_year::TEXT
        END,
        o.name::TEXT,
        (change_obj->>'id')::UUID,
        (change_obj->>'change_type')::TEXT,
        (change_obj->>'timestamp')::TIMESTAMPTZ,
        (change_obj->>'requester_name')::TEXT,
        (change_obj->>'request_message')::TEXT,
        change_obj::JSONB
    FROM college_curriculums c
    LEFT JOIN college_course_mappings cm ON cm.id = c.course_id
    LEFT JOIN college_courses cc ON cc.id = cm.course_id
    LEFT JOIN organizations o ON o.id = c.college_id,
         jsonb_array_elements(COALESCE(c.pending_changes, '[]'::jsonb)) AS change_obj
    WHERE c.university_id = p_university_id 
    AND c.has_pending_changes = TRUE 
    AND (change_obj->>'status')::TEXT = 'pending'
    ORDER BY (change_obj->>'timestamp')::TIMESTAMPTZ DESC;
END;
$$;


ALTER FUNCTION "public"."get_all_pending_changes_for_university"("p_university_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_approved_trainings_for_student"("student_email" "text") RETURNS TABLE("id" "uuid", "student_id" "uuid", "title" character varying, "organization" character varying, "start_date" "date", "end_date" "date", "duration" character varying, "description" "text", "status" "text", "completed_modules" integer, "total_modules" integer, "hours_spent" integer, "course_id" "uuid", "source" character varying, "approval_status" character varying, "approval_authority" character varying, "created_at" timestamp with time zone, "updated_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT t.*
    FROM public.trainings t
    JOIN public.students s ON t.student_id = s.id
    WHERE s.email = student_email 
    AND t.approval_status = 'approved';
END;
$$;


ALTER FUNCTION "public"."get_approved_trainings_for_student"("student_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_available_questions"("p_grade_level" "public"."grade_level", "p_phase" "public"."test_phase", "p_difficulty" smallint DEFAULT NULL::smallint, "p_subtag" "public"."question_subtag" DEFAULT NULL::"public"."question_subtag", "p_limit" integer DEFAULT 10) RETURNS TABLE("id" "uuid", "question_id" "text", "text" "text", "options" "jsonb", "correct_answer" character, "difficulty" smallint, "subtag" "public"."question_subtag", "explanation" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    q.id,
    q.question_id,
    q.text,
    q.options,
    q.correct_answer,
    q.difficulty,
    q.subtag,
    q.explanation
  FROM adaptive_aptitude_questions_cache q
  WHERE q.grade_level = p_grade_level
    AND q.phase = p_phase
    AND q.is_active = TRUE
    AND (p_difficulty IS NULL OR q.difficulty = p_difficulty)
    AND (p_subtag IS NULL OR q.subtag = p_subtag)
  ORDER BY q.usage_count ASC, RANDOM()
  LIMIT p_limit;
END;
$$;


ALTER FUNCTION "public"."get_available_questions"("p_grade_level" "public"."grade_level", "p_phase" "public"."test_phase", "p_difficulty" smallint, "p_subtag" "public"."question_subtag", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_cached_job_matches"("p_student_id" "uuid") RETURNS TABLE("matches" "jsonb", "match_count" integer, "computed_at" timestamp with time zone, "is_cached" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- Check if cache is valid
    IF is_job_matches_cache_valid(p_student_id) THEN
        RETURN QUERY
        SELECT 
            sjm.matches,
            sjm.match_count,
            sjm.computed_at,
            true::boolean as is_cached
        FROM student_job_matches sjm
        WHERE sjm.student_id = p_student_id;
    ELSE
        -- Return empty result indicating cache miss
        RETURN QUERY
        SELECT 
            NULL::jsonb as matches,
            0 as match_count,
            NULL::timestamptz as computed_at,
            false::boolean as is_cached;
    END IF;
END;
$$;


ALTER FUNCTION "public"."get_cached_job_matches"("p_student_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_cached_job_matches"("p_student_id" "uuid") IS 'Returns cached job matches if valid, otherwise returns is_cached=false.';



CREATE OR REPLACE FUNCTION "public"."get_club_details"("p_club_id" "uuid") RETURNS TABLE("club_id" "uuid", "name" character varying, "category" character varying, "description" "text", "capacity" integer, "member_count" bigint, "meeting_day" character varying, "meeting_time" character varying, "location" character varying, "mentor_name" "text", "avg_attendance" numeric, "upcoming_competitions" bigint)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.club_id,
        c.name,
        c.category,
        c.description,
        c.capacity,
        COUNT(DISTINCT cm.student_email) as member_count,
        c.meeting_day,
        c.meeting_time,
        c.location,
        CASE 
            WHEN c.mentor_type = 'educator' THEN se.first_name || ' ' || se.last_name
            WHEN c.mentor_type = 'school' THEN sc.principal_name
            ELSE 'TBD'
        END as mentor_name,
        ROUND(AVG(cm.attendance_percentage), 2) as avg_attendance,
        COUNT(DISTINCT cc.comp_id) as upcoming_competitions
    FROM public.clubs c
    LEFT JOIN public.club_memberships cm ON c.club_id = cm.club_id AND cm.status = 'active'
    LEFT JOIN public.school_educators se ON c.mentor_educator_id = se.id
    LEFT JOIN public.schools sc ON c.mentor_school_id = sc.id
    LEFT JOIN public.competition_clubs cc ON c.club_id = cc.club_id
    LEFT JOIN public.competitions comp ON cc.comp_id = comp.comp_id AND comp.status = 'upcoming'
    WHERE c.club_id = p_club_id
    GROUP BY c.club_id, c.name, c.category, c.description, c.capacity, 
             c.meeting_day, c.meeting_time, c.location, c.mentor_type,
             se.first_name, se.last_name, sc.principal_name;
END;
$$;


ALTER FUNCTION "public"."get_club_details"("p_club_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_club_details"("p_club_id" "uuid") IS 'Returns comprehensive club information including member count and activities';



CREATE OR REPLACE FUNCTION "public"."get_college_admin_notifications"("admin_college_id" "uuid", "unread_only" boolean DEFAULT false) RETURNS TABLE("notification_id" "uuid", "training_id" "uuid", "experience_id" "uuid", "project_id" "uuid", "message" "text", "is_read" boolean, "created_at" timestamp with time zone, "item_title" "text", "student_name" "text", "notification_type" "text")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        tn.id as notification_id,
        tn.training_id,
        tn.experience_id,
        tn.project_id,
        tn.message,
        tn.is_read,
        tn.created_at,
        CASE 
            WHEN tn.training_id IS NOT NULL THEN t.title
            WHEN tn.experience_id IS NOT NULL THEN CONCAT(e.role, ' at ', e.organization)
            WHEN tn.project_id IS NOT NULL THEN p.title
            ELSE 'Unknown'
        END as item_title,
        COALESCE(s.name, sp.name) as student_name,
        CASE 
            WHEN tn.training_id IS NOT NULL THEN 'training'
            WHEN tn.experience_id IS NOT NULL THEN 'experience'
            WHEN tn.project_id IS NOT NULL THEN 'project'
            ELSE 'unknown'
        END as notification_type
    FROM training_notifications tn
    LEFT JOIN trainings t ON tn.training_id = t.id
    LEFT JOIN experience e ON tn.experience_id = e.id
    LEFT JOIN projects p ON tn.project_id = p.id
    LEFT JOIN students s ON (t.student_id = s.id OR e.student_id = s.id OR p.student_id = s.id)
    LEFT JOIN students sp ON s.id = sp.id  -- For profile name fallback
    WHERE tn.recipient_type = 'college_admin'
    AND tn.college_id = admin_college_id
    AND (NOT unread_only OR tn.is_read = FALSE)
    ORDER BY tn.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_college_admin_notifications"("admin_college_id" "uuid", "unread_only" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_college_admin_project_notifications"("admin_college_id" "uuid", "unread_only" boolean DEFAULT false) RETURNS TABLE("notification_id" "uuid", "project_id" "uuid", "message" "text", "is_read" boolean, "created_at" timestamp with time zone, "project_title" "text", "student_name" "text")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        pn.id as notification_id,
        pn.project_id,
        pn.message,
        pn.is_read,
        pn.created_at,
        p.title as project_title,
        COALESCE(s.name, sp.name) as student_name
    FROM project_notifications pn
    JOIN projects p ON pn.project_id = p.id
    JOIN students s ON p.student_id = s.id
    LEFT JOIN students sp ON s.id = sp.id  -- For profile name fallback
    WHERE pn.recipient_type = 'college_admin'
    AND pn.college_id = admin_college_id
    AND (NOT unread_only OR pn.is_read = FALSE)
    ORDER BY pn.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_college_admin_project_notifications"("admin_college_id" "uuid", "unread_only" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_college_educator_assignments"("educator_user_id" "uuid") RETURNS TABLE("assignment_id" "uuid", "title" "text", "description" "text", "instructions" "text", "course_name" "text", "course_code" "text", "college_educator_id" "uuid", "educator_name" "text", "college_id" "uuid", "program_section_id" "uuid", "department_id" "uuid", "program_id" "uuid", "total_points" numeric, "assignment_type" "text", "skill_outcomes" "text"[], "due_date" timestamp with time zone, "available_from" timestamp with time zone, "allow_late_submission" boolean, "document_pdf" "text", "instruction_files" "jsonb", "created_date" timestamp with time zone, "updated_date" timestamp with time zone, "status" "text", "program_name" "text", "department_name" "text", "semester" integer, "section" "text", "academic_year" "text", "student_count" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ca.assignment_id,
        ca.title,
        ca.description,
        ca.instructions,
        ca.course_name,
        ca.course_code,
        ca.college_educator_id,
        ca.educator_name,
        ca.college_id,
        ca.program_section_id,
        ca.department_id,
        ca.program_id,
        ca.total_points,
        ca.assignment_type,
        ca.skill_outcomes,
        ca.due_date,
        ca.available_from,
        ca.allow_late_submission,
        ca.document_pdf,
        COALESCE(ca.instruction_files, '[]'::jsonb) as instruction_files,
        ca.created_date,
        ca.updated_date,
        CASE 
            WHEN ca.due_date < NOW() THEN 'completed'::text
            ELSE 'active'::text
        END as status,
        COALESCE(p.name, '')::text as program_name,
        COALESCE(d.name, '')::text as department_name,
        ps.semester,
        COALESCE(ps.section, '')::text as section,
        COALESCE(ps.academic_year, '')::text as academic_year,
        0 as student_count
    FROM 
        college_assignments ca
    LEFT JOIN programs p ON ca.program_id = p.id
    LEFT JOIN departments d ON ca.department_id = d.id
    LEFT JOIN program_sections ps ON ca.program_section_id = ps.id
    WHERE 
        ca.college_educator_id = educator_user_id
        AND ca.is_deleted = false
    ORDER BY 
        ca.created_date DESC;
END;
$$;


ALTER FUNCTION "public"."get_college_educator_assignments"("educator_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_course_full_details"("course_uuid" "uuid") RETURNS json
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    result JSON;
BEGIN
    SELECT json_build_object(
        'course', row_to_json(c),
        'modules', (
            SELECT json_agg(
                json_build_object(
                    'module', row_to_json(cm),
                    'lessons', (
                        SELECT json_agg(
                            json_build_object(
                                'lesson', row_to_json(l),
                                'resources', (
                                    SELECT json_agg(row_to_json(lr))
                                    FROM lesson_resources lr
                                    WHERE lr.lesson_id = l.lesson_id
                                    ORDER BY lr.order_index
                                )
                            )
                        )
                        FROM lessons l
                        WHERE l.module_id = cm.module_id
                        ORDER BY l.order_index
                    )
                )
            )
            FROM course_modules cm
            WHERE cm.course_id = c.course_id
            ORDER BY cm.order_index
        ),
        'skills', (
            SELECT json_agg(cs.skill_name)
            FROM course_skills cs
            WHERE cs.course_id = c.course_id
        ),
        'classes', (
            SELECT json_agg(cc.class_name)
            FROM course_classes cc
            WHERE cc.course_id = c.course_id
        ),
        'co_educators', (
            SELECT json_agg(json_build_object('id', cce.educator_id, 'name', cce.educator_name))
            FROM course_co_educators cce
            WHERE cce.course_id = c.course_id
        )
    ) INTO result
    FROM courses c
    WHERE c.course_id = course_uuid;

    RETURN result;
END;
$$;


ALTER FUNCTION "public"."get_course_full_details"("course_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_current_academic_year"("p_school_id" "uuid" DEFAULT NULL::"uuid") RETURNS character varying
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_year VARCHAR;
BEGIN
  SELECT year INTO v_year
  FROM curriculum_academic_years
  WHERE (school_id = p_school_id OR (school_id IS NULL AND p_school_id IS NULL))
  AND is_current = TRUE
  AND is_active = TRUE
  ORDER BY school_id NULLS LAST
  LIMIT 1;
  
  RETURN v_year;
END;
$$;


ALTER FUNCTION "public"."get_current_academic_year"("p_school_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_embedding_queue_batch"("batch_size" integer DEFAULT 20) RETURNS TABLE("id" "uuid", "record_id" "uuid", "table_name" "text", "operation" "text", "priority" integer, "retry_count" integer)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY SELECT eq.id, eq.record_id, eq.table_name, eq.operation, eq.priority, eq.retry_count
  FROM embedding_queue eq WHERE eq.status = 'pending' AND (eq.next_retry_at IS NULL OR eq.next_retry_at <= NOW())
  ORDER BY eq.priority DESC, eq.created_at ASC LIMIT batch_size FOR UPDATE SKIP LOCKED;
END;
$$;


ALTER FUNCTION "public"."get_embedding_queue_batch"("batch_size" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_embedding_queue_stats"() RETURNS TABLE("queue_status" "text", "item_count" bigint, "oldest_item" timestamp with time zone, "newest_item" timestamp with time zone)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    eq.status,
    COUNT(*)::BIGINT,
    MIN(eq.created_at),
    MAX(eq.created_at)
  FROM embedding_queue eq
  GROUP BY eq.status;
END;
$$;


ALTER FUNCTION "public"."get_embedding_queue_stats"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_embedding_stats"() RETURNS TABLE("table_name" "text", "total_records" bigint, "with_embedding" bigint, "without_embedding" bigint, "coverage_percent" numeric)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    'students'::TEXT,
    COUNT(*)::BIGINT,
    COUNT(embedding)::BIGINT,
    (COUNT(*) - COUNT(embedding))::BIGINT,
    ROUND(COUNT(embedding)::NUMERIC / NULLIF(COUNT(*), 0) * 100, 2)
  FROM students
  UNION ALL
  SELECT 
    'opportunities'::TEXT,
    COUNT(*)::BIGINT,
    COUNT(embedding)::BIGINT,
    (COUNT(*) - COUNT(embedding))::BIGINT,
    ROUND(COUNT(embedding)::NUMERIC / NULLIF(COUNT(*), 0) * 100, 2)
  FROM opportunities;
END;
$$;


ALTER FUNCTION "public"."get_embedding_stats"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_lecturer_details"("p_user_id" "uuid") RETURNS TABLE("lecturer_id" "uuid", "user_id" "uuid", "college_id" "uuid", "college_name" "text", "employee_id" "text", "department" "text", "specialization" "text", "qualification" "text", "experience_years" integer, "date_of_joining" "date")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    cl.id,
    cl.user_id,
    cl."collegeId",
    o.name as college_name,
    cl."employeeId"::TEXT,
    cl.department::TEXT,
    cl.specialization::TEXT,
    cl.qualification::TEXT,
    cl."experienceYears",
    cl."dateOfJoining"
  FROM college_lecturers cl
  LEFT JOIN organizations o ON o.id = cl."collegeId" AND o.organization_type = 'college'
  WHERE cl.user_id = p_user_id;
END;
$$;


ALTER FUNCTION "public"."get_lecturer_details"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_lecturer_details"("p_user_id" "uuid") IS 'Get complete lecturer details by user_id';



CREATE OR REPLACE FUNCTION "public"."get_or_create_college_educator_admin_conversation"("p_educator_id" "uuid", "p_college_id" "uuid", "p_subject" "text" DEFAULT 'General Discussion'::"text") RETURNS TABLE("conversation_id" "text")
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  existing_conversation_id TEXT;
  new_conversation_id TEXT;
BEGIN
  -- Check for existing conversation
  SELECT id INTO existing_conversation_id
  FROM conversations
  WHERE educator_id = p_educator_id
    AND college_id = p_college_id
    AND conversation_type = 'college_educator_admin'
    AND (subject = p_subject OR (subject IS NULL AND p_subject = 'General Discussion'))
  LIMIT 1;
  
  IF existing_conversation_id IS NOT NULL THEN
    -- Return existing conversation
    RETURN QUERY SELECT existing_conversation_id;
  ELSE
    -- Create new conversation
    new_conversation_id := 'conv_cea_' || extract(epoch from now())::bigint || '_' || substr(md5(random()::text), 1, 9);
    
    INSERT INTO conversations (
      id,
      educator_id,
      college_id,
      subject,
      conversation_type,
      status,
      created_at,
      updated_at
    ) VALUES (
      new_conversation_id,
      p_educator_id,
      p_college_id,
      p_subject,
      'college_educator_admin',
      'active',
      timezone('utc'::text, now()),
      timezone('utc'::text, now())
    );
    
    RETURN QUERY SELECT new_conversation_id;
  END IF;
END;
$$;


ALTER FUNCTION "public"."get_or_create_college_educator_admin_conversation"("p_educator_id" "uuid", "p_college_id" "uuid", "p_subject" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_or_create_educator_admin_conversation"("p_educator_id" "uuid", "p_school_id" "uuid", "p_subject" "text" DEFAULT 'General Discussion'::"text") RETURNS TABLE("conversation_id" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    existing_conversation_id TEXT;
    new_conversation_id TEXT;
BEGIN
    -- Try to find existing conversation
    SELECT id INTO existing_conversation_id
    FROM conversations
    WHERE educator_id = p_educator_id 
      AND school_id = p_school_id
      AND conversation_type = 'educator_admin'
      AND (p_subject IS NULL OR subject = p_subject)
    LIMIT 1;
    
    IF existing_conversation_id IS NOT NULL THEN
        -- If conversation was soft deleted, restore it
        UPDATE conversations 
        SET deleted_by_educator = FALSE,
            deleted_by_admin = FALSE,
            educator_deleted_at = NULL,
            admin_deleted_at = NULL,
            updated_at = NOW()
        WHERE id = existing_conversation_id;
        
        RETURN QUERY SELECT existing_conversation_id;
    ELSE
        -- Create new conversation with explicit NULL for student_id
        new_conversation_id := 'conv_ea_' || EXTRACT(EPOCH FROM NOW())::BIGINT || '_' || SUBSTRING(MD5(RANDOM()::TEXT), 1, 9);
        
        INSERT INTO conversations (
            id,
            student_id,
            educator_id,
            school_id,
            recruiter_id,
            subject,
            conversation_type,
            status,
            student_unread_count,
            recruiter_unread_count,
            educator_unread_count,
            admin_unread_count,
            created_at,
            updated_at
        ) VALUES (
            new_conversation_id,
            NULL,
            p_educator_id,
            p_school_id,
            NULL,
            p_subject,
            'educator_admin',
            'active',
            0,
            0,
            0,
            0,
            NOW(),
            NOW()
        );
        
        RETURN QUERY SELECT new_conversation_id;
    END IF;
END;
$$;


ALTER FUNCTION "public"."get_or_create_educator_admin_conversation"("p_educator_id" "uuid", "p_school_id" "uuid", "p_subject" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_or_create_student_admin_conversation"("p_student_id" "uuid", "p_school_id" "uuid", "p_subject" "text" DEFAULT 'General Discussion'::"text") RETURNS TABLE("conversation_id" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    existing_conversation_id TEXT;
    new_conversation_id TEXT;
BEGIN
    -- Try to find existing conversation
    SELECT id INTO existing_conversation_id
    FROM conversations
    WHERE student_id = p_student_id 
      AND school_id = p_school_id
      AND conversation_type = 'student_admin'
      AND (p_subject IS NULL OR subject = p_subject)
    LIMIT 1;
    
    IF existing_conversation_id IS NOT NULL THEN
        -- If conversation was soft deleted, restore it
        UPDATE conversations 
        SET deleted_by_student = FALSE,
            deleted_by_admin = FALSE,
            student_deleted_at = NULL,
            admin_deleted_at = NULL,
            updated_at = NOW()
        WHERE id = existing_conversation_id;
        
        RETURN QUERY SELECT existing_conversation_id;
    ELSE
        -- Create new conversation
        new_conversation_id := 'conv_sa_' || EXTRACT(EPOCH FROM NOW())::BIGINT || '_' || SUBSTRING(MD5(RANDOM()::TEXT), 1, 9);
        
        INSERT INTO conversations (
            id,
            student_id,
            school_id,
            subject,
            conversation_type,
            status,
            student_unread_count,
            recruiter_unread_count,
            educator_unread_count,
            admin_unread_count,
            created_at,
            updated_at
        ) VALUES (
            new_conversation_id,
            p_student_id,
            p_school_id,
            p_subject,
            'student_admin',
            'active',
            0,
            0,
            0,
            0,
            NOW(),
            NOW()
        );
        
        RETURN QUERY SELECT new_conversation_id;
    END IF;
END;
$$;


ALTER FUNCTION "public"."get_or_create_student_admin_conversation"("p_student_id" "uuid", "p_school_id" "uuid", "p_subject" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_or_create_student_admin_conversation"("p_student_id" "uuid", "p_school_id" "uuid", "p_subject" "text") IS 'Helper function to get or create a conversation between student and school (visible to all school admins)';



CREATE OR REPLACE FUNCTION "public"."get_or_create_student_college_admin_conversation"("p_student_id" "uuid", "p_college_id" "uuid", "p_subject" "text" DEFAULT 'General Discussion'::"text") RETURNS TABLE("conversation_id" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    existing_conversation_id TEXT;
    new_conversation_id TEXT;
BEGIN
    -- Try to find existing conversation
    SELECT id INTO existing_conversation_id
    FROM conversations
    WHERE student_id = p_student_id 
      AND college_id = p_college_id
      AND conversation_type = 'student_college_admin'
      AND (p_subject IS NULL OR subject = p_subject)
    LIMIT 1;
    
    IF existing_conversation_id IS NOT NULL THEN
        -- If conversation was soft deleted, restore it
        UPDATE conversations 
        SET deleted_by_student = FALSE,
            deleted_by_college_admin = FALSE,
            student_deleted_at = NULL,
            college_admin_deleted_at = NULL,
            updated_at = NOW()
        WHERE id = existing_conversation_id;
        
        RETURN QUERY SELECT existing_conversation_id;
    ELSE
        -- Create new conversation
        new_conversation_id := 'conv_ca_' || EXTRACT(EPOCH FROM NOW())::BIGINT || '_' || SUBSTRING(MD5(RANDOM()::TEXT), 1, 9);
        
        INSERT INTO conversations (
            id,
            student_id,
            college_id,
            subject,
            conversation_type,
            status,
            student_unread_count,
            recruiter_unread_count,
            educator_unread_count,
            admin_unread_count,
            college_admin_unread_count,
            created_at,
            updated_at
        ) VALUES (
            new_conversation_id,
            p_student_id,
            p_college_id,
            p_subject,
            'student_college_admin',
            'active',
            0,
            0,
            0,
            0,
            0,
            NOW(),
            NOW()
        );
        
        RETURN QUERY SELECT new_conversation_id;
    END IF;
END;
$$;


ALTER FUNCTION "public"."get_or_create_student_college_admin_conversation"("p_student_id" "uuid", "p_college_id" "uuid", "p_subject" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_or_create_student_college_admin_conversation"("p_student_id" "uuid", "p_college_id" "uuid", "p_subject" "text") IS 'Helper function to get or create a conversation between student and college (visible to all college admins)';



CREATE OR REPLACE FUNCTION "public"."get_or_create_student_educator_conversation"("p_student_id" "uuid", "p_educator_id" "uuid", "p_class_id" "uuid" DEFAULT NULL::"uuid", "p_subject" "text" DEFAULT 'General Discussion'::"text") RETURNS TABLE("conversation_id" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    existing_conversation_id TEXT;
    new_conversation_id TEXT;
BEGIN
    -- Try to find existing conversation
    SELECT id INTO existing_conversation_id
    FROM conversations
    WHERE student_id = p_student_id 
      AND educator_id = p_educator_id
      AND conversation_type = 'student_educator'
      AND (p_class_id IS NULL OR class_id = p_class_id)
      AND (p_subject IS NULL OR subject = p_subject)
    LIMIT 1;
    
    IF existing_conversation_id IS NOT NULL THEN
        -- If conversation was soft deleted, restore it
        UPDATE conversations 
        SET deleted_by_student = FALSE,
            deleted_by_educator = FALSE,
            student_deleted_at = NULL,
            educator_deleted_at = NULL,
            updated_at = NOW()
        WHERE id = existing_conversation_id;
        
        RETURN QUERY SELECT existing_conversation_id;
    ELSE
        -- Create new conversation
        new_conversation_id := 'conv_se_' || EXTRACT(EPOCH FROM NOW())::BIGINT || '_' || SUBSTRING(MD5(RANDOM()::TEXT), 1, 9);
        
        INSERT INTO conversations (
            id,
            student_id,
            educator_id,
            class_id,
            subject,
            conversation_type,
            status,
            student_unread_count,
            recruiter_unread_count,
            educator_unread_count,
            created_at,
            updated_at
        ) VALUES (
            new_conversation_id,
            p_student_id,
            p_educator_id,
            p_class_id,
            p_subject,
            'student_educator',
            'active',
            0,
            0,
            0,
            NOW(),
            NOW()
        );
        
        RETURN QUERY SELECT new_conversation_id;
    END IF;
END;
$$;


ALTER FUNCTION "public"."get_or_create_student_educator_conversation"("p_student_id" "uuid", "p_educator_id" "uuid", "p_class_id" "uuid", "p_subject" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_or_create_student_educator_conversation"("p_student_id" "uuid", "p_educator_id" "uuid", "p_class_id" "uuid", "p_subject" "text") IS 'Helper function to get or create a conversation between student and educator';



CREATE OR REPLACE FUNCTION "public"."get_pending_changes"("p_curriculum_id" "uuid") RETURNS TABLE("change_id" "uuid", "change_type" "text", "entity_id" "uuid", "change_timestamp" timestamp with time zone, "requested_by" "uuid", "requester_name" "text", "request_message" "text", "change_status" "text", "change_data" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        (change_obj->>'id')::UUID,
        (change_obj->>'change_type')::TEXT,
        (change_obj->>'entity_id')::UUID,
        (change_obj->>'timestamp')::TIMESTAMPTZ,
        (change_obj->>'requested_by')::UUID,
        (change_obj->>'requester_name')::TEXT,
        (change_obj->>'request_message')::TEXT,
        (change_obj->>'status')::TEXT,
        change_obj::JSONB
    FROM college_curriculums,
         jsonb_array_elements(COALESCE(pending_changes, '[]'::jsonb)) AS change_obj
    WHERE id = p_curriculum_id AND (change_obj->>'status')::TEXT = 'pending'
    ORDER BY (change_obj->>'timestamp')::TIMESTAMPTZ DESC;
END;
$$;


ALTER FUNCTION "public"."get_pending_changes"("p_curriculum_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pending_college_experiences"() RETURNS TABLE("id" "uuid", "student_id" "uuid", "role" character varying, "organization" character varying, "start_date" "date", "end_date" "date", "duration" character varying, "description" "text", "approval_status" character varying, "approval_authority" character varying, "created_at" timestamp with time zone, "updated_at" timestamp with time zone, "student_name" character varying, "student_email" "text", "student_college" character varying, "student_type" character varying)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    e.id,
    e.student_id,
    e.role,
    e.organization,
    e.start_date,
    e.end_date,
    e.duration,
    e.description,
    e.approval_status,
    e.approval_authority,
    e.created_at,
    e.updated_at,
    p.name as student_name,
    p.email as student_email,
    p.college_school_name as student_college,
    s.student_type
  FROM experience e
  JOIN students s ON e.student_id = s.id
  JOIN profiles p ON s.user_id = p.id
  WHERE e.approval_status = 'pending'
    AND e.approval_authority = 'college_admin'
    AND s.student_type = 'college_student'
  ORDER BY e.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_pending_college_experiences"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pending_college_experiences"("p_admin_user_id" "uuid") RETURNS TABLE("id" "uuid", "student_id" "uuid", "role" character varying, "organization" character varying, "start_date" "date", "end_date" "date", "duration" character varying, "description" "text", "approval_status" character varying, "approval_authority" character varying, "created_at" timestamp with time zone, "updated_at" timestamp with time zone, "student_name" "text", "student_email" "text", "student_college" "text", "student_type" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    e.id,
    e.student_id,
    e.role,
    e.organization,
    e.start_date,
    e.end_date,
    e.duration,
    e.description,
    e.approval_status,
    e.approval_authority,
    e.created_at,
    e.updated_at,
    p.name as student_name,
    p.email as student_email,
    p.college_school_name as student_college,
    s.student_type
  FROM experience e
  JOIN students s ON e.student_id = s.id
  JOIN profiles p ON s.user_id = p.id
  WHERE e.approval_status = 'pending'
    AND e.approval_authority = 'college_admin'
    AND s.student_type = 'college_student'
  ORDER BY e.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_pending_college_experiences"("p_admin_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pending_college_projects"("input_college_id" "uuid") RETURNS TABLE("project_id" "uuid", "student_id" "uuid", "student_name" character varying, "title" character varying, "description" "text", "organization" "text", "status" character varying, "start_date" "date", "end_date" "date", "duration" character varying, "tech_stack" "text"[], "demo_link" "text", "github_link" "text", "certificate_url" "text", "video_url" "text", "ppt_url" "text", "created_at" timestamp with time zone, "approval_status" character varying, "approval_authority" character varying)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.id as project_id,
        p.student_id,
        COALESCE(s.name, sp.name) as student_name,
        p.title,
        p.description,
        p.organization,
        p.status,
        p.start_date,
        p.end_date,
        p.duration,
        p.tech_stack,
        p.demo_link,
        p.github_link,
        p.certificate_url,
        p.video_url,
        p.ppt_url,
        p.created_at,
        p.approval_status,
        p.approval_authority
    FROM projects p
    JOIN students s ON p.student_id = s.id
    LEFT JOIN students sp ON s.id = sp.id
    WHERE p.approval_status = 'pending'
    AND p.approval_authority = 'college_admin'
    AND (s.college_id = input_college_id OR s.university_college_id = input_college_id)
    ORDER BY p.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_pending_college_projects"("input_college_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pending_college_trainings"() RETURNS TABLE("id" "uuid", "student_id" "uuid", "title" character varying, "organization" character varying, "start_date" "date", "end_date" "date", "duration" character varying, "description" "text", "status" "text", "completed_modules" integer, "total_modules" integer, "hours_spent" integer, "skills" "jsonb", "certificate_url" "text", "progress" integer, "approval_status" character varying, "approval_authority" character varying, "created_at" timestamp with time zone, "updated_at" timestamp with time zone, "student_name" character varying, "student_email" "text", "student_college" character varying, "student_type" character varying)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.id,
    t.student_id,
    t.title,
    t.organization,
    t.start_date,
    t.end_date,
    t.duration,
    t.description,
    t.status,
    t.completed_modules,
    t.total_modules,
    t.hours_spent,
    NULL::JSONB as skills,
    NULL::TEXT as certificate_url,
    NULL::INTEGER as progress,
    t.approval_status,
    t.approval_authority,
    t.created_at,
    t.updated_at,
    p.name as student_name,
    p.email as student_email,
    p.college_school_name as student_college,
    s.student_type
  FROM trainings t
  JOIN students s ON t.student_id = s.id
  JOIN profiles p ON s.user_id = p.id
  WHERE t.approval_status = 'pending'
    AND t.approval_authority = 'college_admin'
    AND s.student_type = 'college_student'
  ORDER BY t.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_pending_college_trainings"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pending_college_trainings"("p_admin_user_id" "uuid") RETURNS TABLE("id" "uuid", "student_id" "uuid", "title" character varying, "organization" character varying, "start_date" "date", "end_date" "date", "duration" character varying, "description" "text", "status" "text", "completed_modules" integer, "total_modules" integer, "hours_spent" integer, "skills" "text"[], "certificate_url" "text", "progress" integer, "approval_status" character varying, "approval_authority" character varying, "created_at" timestamp with time zone, "updated_at" timestamp with time zone, "student_name" "text", "student_email" "text", "student_college" "text", "student_type" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    t.id,
    t.student_id,
    t.title,
    t.organization,
    t.start_date,
    t.end_date,
    t.duration,
    t.description,
    t.status,
    t.completed_modules,
    t.total_modules,
    t.hours_spent,
    t.skills,
    t.certificate_url,
    t.progress,
    t.approval_status,
    t.approval_authority,
    t.created_at,
    t.updated_at,
    p.name as student_name,
    p.email as student_email,
    p.college_school_name as student_college,
    s.student_type
  FROM trainings t
  JOIN students s ON t.student_id = s.id
  JOIN profiles p ON s.user_id = p.id
  WHERE t.approval_status = 'pending'
    AND t.approval_authority = 'college_admin'
    AND s.student_type = 'college_student'
  ORDER BY t.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_pending_college_trainings"("p_admin_user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pending_rareminds_trainings"() RETURNS TABLE("id" "uuid", "student_id" "uuid", "student_name" "text", "student_email" "text", "school_name" "text", "title" character varying, "organization" character varying, "start_date" "date", "end_date" "date", "description" "text", "approval_status" character varying, "approval_authority" character varying, "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        t.id,
        t.student_id,
        s.name as student_name,
        s.email as student_email,
        o.name as school_name,
        t.title,
        t.organization,
        t.start_date,
        t.end_date,
        t.description,
        t.approval_status,
        t.approval_authority,
        t.created_at
    FROM public.trainings t
    JOIN public.students s ON t.student_id = s.id
    LEFT JOIN public.organizations o ON s.school_id = o.id
    WHERE t.approval_status = 'pending'
    AND t.approval_authority = 'rareminds_admin'
    ORDER BY t.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_pending_rareminds_trainings"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pending_school_experiences"("input_school_id" "uuid") RETURNS TABLE("id" "uuid", "student_id" "uuid", "student_name" character varying, "student_email" "text", "organization" character varying, "role" character varying, "start_date" "date", "end_date" "date", "duration" character varying, "approval_status" character varying, "approval_authority" character varying, "created_at" timestamp with time zone)
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    school_name_var TEXT;
BEGIN
    -- Get the school name for the input school ID from organizations table
    SELECT o.name INTO school_name_var
    FROM organizations o
    WHERE o.id = input_school_id;
    
    IF school_name_var IS NULL THEN
        -- If school not found, return empty result
        RETURN;
    END IF;
    
    RETURN QUERY
    SELECT 
        e.id,
        e.student_id,
        s.name as student_name,
        s.email as student_email,
        e.organization,
        e.role,
        e.start_date,
        e.end_date,
        e.duration,
        e.approval_status::VARCHAR(20),
        e.approval_authority,
        e.created_at
    FROM public.experience e
    JOIN public.students s ON e.student_id = s.id
    WHERE e.approval_status = 'pending'
    AND e.approval_authority = 'school_admin'
    AND LOWER(TRIM(e.organization)) = LOWER(TRIM(school_name_var))
    ORDER BY e.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_pending_school_experiences"("input_school_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pending_school_projects"("input_school_id" "uuid") RETURNS TABLE("project_id" "uuid", "student_id" "uuid", "student_name" character varying, "title" character varying, "description" "text", "organization" "text", "status" character varying, "start_date" "date", "end_date" "date", "duration" character varying, "tech_stack" "text"[], "demo_link" "text", "github_link" "text", "certificate_url" "text", "video_url" "text", "ppt_url" "text", "created_at" timestamp with time zone, "approval_status" character varying, "approval_authority" character varying)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.id as project_id,
        p.student_id,
        COALESCE(s.name, sp.name) as student_name,
        p.title,
        p.description,
        p.organization,
        p.status,
        p.start_date,
        p.end_date,
        p.duration,
        p.tech_stack,
        p.demo_link,
        p.github_link,
        p.certificate_url,
        p.video_url,
        p.ppt_url,
        p.created_at,
        p.approval_status,
        p.approval_authority
    FROM projects p
    JOIN students s ON p.student_id = s.id
    LEFT JOIN students sp ON s.id = sp.id
    WHERE p.approval_status = 'pending'
    AND p.approval_authority = 'school_admin'
    AND s.school_id = input_school_id
    ORDER BY p.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_pending_school_projects"("input_school_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pending_school_trainings"("input_school_id" "uuid") RETURNS TABLE("id" "uuid", "student_id" "uuid", "student_name" character varying, "student_email" "text", "title" character varying, "organization" character varying, "start_date" "date", "end_date" "date", "description" "text", "approval_status" character varying, "approval_authority" character varying, "created_at" timestamp with time zone)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        t.id,
        t.student_id,
        s.name as student_name,
        s.email as student_email,
        t.title,
        t.organization,
        t.start_date,
        t.end_date,
        t.description,
        t.approval_status::VARCHAR(20),
        t.approval_authority,
        t.created_at
    FROM public.trainings t
    JOIN public.students s ON t.student_id = s.id
    WHERE s.school_id = input_school_id
    AND t.approval_status = 'pending'
    AND t.approval_authority = 'school_admin'
    ORDER BY t.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_pending_school_trainings"("input_school_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_pending_swap_count"("p_faculty_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)::INTEGER
    FROM class_swap_requests
    WHERE target_faculty_id = p_faculty_id
    AND status = 'pending'
  );
END;
$$;


ALTER FUNCTION "public"."get_pending_swap_count"("p_faculty_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_pending_swap_count"("p_faculty_id" "uuid") IS 'Returns count of pending swap requests for a faculty member';



CREATE OR REPLACE FUNCTION "public"."get_plan_features"("p_plan_code" "text", "p_limit" integer DEFAULT NULL::integer) RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_features JSONB;
  v_total_count INTEGER;
BEGIN
  -- Get features from subscription_plans
  SELECT features INTO v_features
  FROM subscription_plans
  WHERE plan_code = p_plan_code AND is_active = true;
  
  IF v_features IS NULL THEN
    RETURN jsonb_build_object('features', '[]'::jsonb, 'total', 0, 'limited', false);
  END IF;
  
  v_total_count := jsonb_array_length(v_features);
  
  -- If limit is provided and less than total, slice the array
  IF p_limit IS NOT NULL AND p_limit < v_total_count THEN
    -- Use jsonb array slice: features[0:limit]
    SELECT jsonb_agg(elem)
    INTO v_features
    FROM (
      SELECT elem
      FROM jsonb_array_elements(v_features) WITH ORDINALITY AS t(elem, idx)
      WHERE idx <= p_limit
    ) sub;
    
    RETURN jsonb_build_object(
      'features', COALESCE(v_features, '[]'::jsonb),
      'total', v_total_count,
      'limited', true
    );
  END IF;
  
  RETURN jsonb_build_object(
    'features', v_features,
    'total', v_total_count,
    'limited', false
  );
END;
$$;


ALTER FUNCTION "public"."get_plan_features"("p_plan_code" "text", "p_limit" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_popular_opportunities"("student_id_param" "uuid", "limit_count" integer DEFAULT 20) RETURNS TABLE("id" "uuid", "title" "text", "job_title" "text", "company_name" "text", "company_logo" "text", "employment_type" "text", "location" "text", "mode" "text", "stipend_or_salary" "text", "experience_required" "text", "experience_level" "text", "skills_required" "jsonb", "requirements" "jsonb", "responsibilities" "jsonb", "description" "text", "application_link" "text", "deadline" timestamp with time zone, "department" "text", "salary_range_min" integer, "salary_range_max" integer, "posted_date" timestamp with time zone, "is_active" boolean, "status" "text", "created_at" timestamp with time zone, "updated_at" timestamp with time zone, "views_count" integer, "applications_count" integer, "embedding" "extensions"."vector", "view_count" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    o.id,
    o.title,
    o.job_title,
    o.company_name,
    o.company_logo,
    o.employment_type,
    o.location,
    o.mode,
    o.stipend_or_salary,
    o.experience_required,
    o.experience_level,
    o.skills_required,
    o.requirements,
    o.responsibilities,
    o.description,
    o.application_link,
    o.deadline,
    o.department,
    o.salary_range_min,
    o.salary_range_max,
    o.posted_date,
    o.is_active,
    o.status,
    o.created_at,
    o.updated_at,
    o.views_count,
    o.applications_count,
    o.embedding,
    COALESCE(
      (SELECT COUNT(*) 
       FROM opportunity_interactions 
       WHERE opportunity_id = o.id AND action = 'view')::INTEGER,
      0
    ) as view_count
  FROM opportunities o
  WHERE o.is_active = true
    AND o.status = 'open'
    AND (o.deadline IS NULL OR o.deadline > NOW())
  ORDER BY 
    o.posted_date DESC NULLS LAST,
    o.created_at DESC
  LIMIT limit_count;
END;
$$;


ALTER FUNCTION "public"."get_popular_opportunities"("student_id_param" "uuid", "limit_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_popular_opportunities_with_eligibility"("student_id_param" "uuid", "student_grade_param" "text", "student_course_param" "text" DEFAULT NULL::"text", "student_type_param" "text" DEFAULT NULL::"text", "limit_count" integer DEFAULT 10) RETURNS TABLE("id" integer, "title" "text", "job_title" "text", "company_name" "text", "company_logo" "text", "employment_type" "text", "location" "text", "mode" "text", "stipend_or_salary" "text", "experience_required" "text", "experience_level" "text", "skills_required" "jsonb", "requirements" "jsonb", "responsibilities" "jsonb", "description" "text", "application_link" "text", "deadline" timestamp with time zone, "department" "text", "salary_range_min" integer, "salary_range_max" integer, "posted_date" timestamp with time zone, "is_active" boolean, "status" "text", "created_at" timestamp with time zone, "updated_at" timestamp with time zone, "views_count" integer, "applications_count" integer, "similarity" double precision)
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  allowed_types TEXT[];
  max_exp INT;
  elig_level TEXT;
  effective_grade TEXT;
BEGIN
  effective_grade := COALESCE(student_grade_param, student_course_param, student_type_param, '');
  
  SELECT e.allowed_employment_types, e.max_experience_years, e.eligibility_level
  INTO allowed_types, max_exp, elig_level
  FROM get_student_eligibility(effective_grade) e;

  IF elig_level = 'school_junior' THEN
    RETURN QUERY
    SELECT 
      o.id, o.title, o.job_title, o.company_name, o.company_logo, o.employment_type,
      o.location, o.mode, o.stipend_or_salary, o.experience_required, o.experience_level,
      o.skills_required, o.requirements, o.responsibilities, o.description,
      o.application_link, o.deadline, o.department, o.salary_range_min, o.salary_range_max,
      o.posted_date, o.is_active, o.status, o.created_at, o.updated_at,
      o.views_count, o.applications_count,
      0.5::FLOAT as similarity
    FROM opportunities o
    WHERE (o.is_active IS NULL OR o.is_active = true)
      AND (o.status IS NULL OR o.status IN ('open', 'published'))
      AND (o.deadline IS NULL OR o.deadline > NOW())
      AND (o.employment_type IS NULL OR o.employment_type = ANY(allowed_types) OR o.employment_type ILIKE ANY(SELECT '%' || unnest(allowed_types) || '%'))
      AND (o.experience_required IS NULL OR parse_experience_years(o.experience_required) <= max_exp)
      AND NOT has_advanced_skills(o.skills_required)
    ORDER BY COALESCE(o.views_count, 0) DESC, COALESCE(o.applications_count, 0) DESC, o.created_at DESC
    LIMIT limit_count;
  ELSE
    RETURN QUERY
    SELECT 
      o.id, o.title, o.job_title, o.company_name, o.company_logo, o.employment_type,
      o.location, o.mode, o.stipend_or_salary, o.experience_required, o.experience_level,
      o.skills_required, o.requirements, o.responsibilities, o.description,
      o.application_link, o.deadline, o.department, o.salary_range_min, o.salary_range_max,
      o.posted_date, o.is_active, o.status, o.created_at, o.updated_at,
      o.views_count, o.applications_count,
      0.5::FLOAT as similarity
    FROM opportunities o
    WHERE (o.is_active IS NULL OR o.is_active = true)
      AND (o.status IS NULL OR o.status IN ('open', 'published'))
      AND (o.deadline IS NULL OR o.deadline > NOW())
      AND (o.employment_type IS NULL OR o.employment_type = ANY(allowed_types) OR o.employment_type ILIKE ANY(SELECT '%' || unnest(allowed_types) || '%'))
      AND (o.experience_required IS NULL OR parse_experience_years(o.experience_required) <= max_exp)
    ORDER BY COALESCE(o.views_count, 0) DESC, COALESCE(o.applications_count, 0) DESC, o.created_at DESC
    LIMIT limit_count;
  END IF;
END;
$$;


ALTER FUNCTION "public"."get_popular_opportunities_with_eligibility"("student_id_param" "uuid", "student_grade_param" "text", "student_course_param" "text", "student_type_param" "text", "limit_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_program_section_students"("section_id" "uuid") RETURNS TABLE("student_id" "uuid", "user_id" "uuid", "name" "text", "email" "text", "roll_number" "text", "program_id" "uuid", "section" "text", "semester" integer)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.id as student_id,
        s.user_id,
        s.name::text,
        s.email::text,
        s.roll_number::text,
        s.program_id,
        s.section::text,
        s.semester
    FROM students s
    INNER JOIN program_sections ps ON s.program_id = ps.program_id 
        AND s.section = ps.section 
        AND s.semester = ps.semester
    WHERE ps.id = section_id
        AND s.is_deleted = false
    ORDER BY s.name;
END;
$$;


ALTER FUNCTION "public"."get_program_section_students"("section_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_program_section_students"("section_id" "uuid") IS 'Returns all students enrolled in a specific program section';



CREATE OR REPLACE FUNCTION "public"."get_scheduled_assessment_reminders"("days_ahead" integer DEFAULT 30) RETURNS TABLE("notification_id" "uuid", "student_id" "uuid", "assessment_id" "uuid", "scheduled_date" timestamp with time zone, "days_until" integer, "assessment_date" timestamp with time zone)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        n.id as notification_id,
        n.recipient_id as student_id,
        n.assessment_id,
        n.scheduled_for as scheduled_date,
        EXTRACT(DAY FROM n.scheduled_for - NOW())::INTEGER as days_until,
        par.created_at as assessment_date
    FROM notifications n
    JOIN personal_assessment_results par ON n.assessment_id = par.id
    WHERE n.status = 'scheduled'
    AND n.type = 'assessment_6month_reminder'
    AND n.scheduled_for <= NOW() + (days_ahead || ' days')::INTERVAL
    ORDER BY n.scheduled_for;
END;
$$;


ALTER FUNCTION "public"."get_scheduled_assessment_reminders"("days_ahead" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_school_admin_notifications"("admin_school_id" "uuid", "unread_only" boolean DEFAULT false) RETURNS TABLE("notification_id" "uuid", "training_id" "uuid", "experience_id" "uuid", "project_id" "uuid", "message" "text", "is_read" boolean, "created_at" timestamp with time zone, "item_title" "text", "student_name" "text", "notification_type" "text")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        tn.id as notification_id,
        tn.training_id,
        tn.experience_id,
        tn.project_id,
        tn.message,
        tn.is_read,
        tn.created_at,
        CASE 
            WHEN tn.training_id IS NOT NULL THEN t.title
            WHEN tn.experience_id IS NOT NULL THEN CONCAT(e.role, ' at ', e.organization)
            WHEN tn.project_id IS NOT NULL THEN p.title
            ELSE 'Unknown'
        END as item_title,
        COALESCE(s.name, sp.name) as student_name,
        CASE 
            WHEN tn.training_id IS NOT NULL THEN 'training'
            WHEN tn.experience_id IS NOT NULL THEN 'experience'
            WHEN tn.project_id IS NOT NULL THEN 'project'
            ELSE 'unknown'
        END as notification_type
    FROM training_notifications tn
    LEFT JOIN trainings t ON tn.training_id = t.id
    LEFT JOIN experience e ON tn.experience_id = e.id
    LEFT JOIN projects p ON tn.project_id = p.id
    LEFT JOIN students s ON (t.student_id = s.id OR e.student_id = s.id OR p.student_id = s.id)
    LEFT JOIN students sp ON s.id = sp.id  -- For profile name fallback
    WHERE tn.recipient_type = 'school_admin'
    AND tn.school_id = admin_school_id
    AND (NOT unread_only OR tn.is_read = FALSE)
    ORDER BY tn.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_school_admin_notifications"("admin_school_id" "uuid", "unread_only" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_school_admin_project_notifications"("admin_school_id" "uuid", "unread_only" boolean DEFAULT false) RETURNS TABLE("notification_id" "uuid", "project_id" "uuid", "message" "text", "is_read" boolean, "created_at" timestamp with time zone, "project_title" "text", "student_name" "text")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        pn.id as notification_id,
        pn.project_id,
        pn.message,
        pn.is_read,
        pn.created_at,
        p.title as project_title,
        COALESCE(s.name, sp.name) as student_name
    FROM project_notifications pn
    JOIN projects p ON pn.project_id = p.id
    JOIN students s ON p.student_id = s.id
    LEFT JOIN students sp ON s.id = sp.id  -- For profile name fallback
    WHERE pn.recipient_type = 'school_admin'
    AND pn.school_id = admin_school_id
    AND (NOT unread_only OR pn.is_read = FALSE)
    ORDER BY pn.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_school_admin_project_notifications"("admin_school_id" "uuid", "unread_only" boolean) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_student_academic_summary"("p_student_user_id" "uuid") RETURNS TABLE("student_name" "text", "roll_number" "text", "college_name" "text", "program_name" "text", "current_semester" integer, "current_cgpa" numeric, "total_assessments" integer, "passed_assessments" integer, "failed_assessments" integer, "average_percentage" numeric, "total_fee_due" numeric, "total_fee_paid" numeric, "fee_balance" numeric, "books_issued" integer, "books_overdue" integer)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    s.name,
    s.roll_number,
    o.name as college_name,
    p.name as program_name,
    CAST(s.grade AS INTEGER) as current_semester,
    s."currentCgpa",
    COUNT(DISTINCT m.id)::INTEGER as total_assessments,
    COUNT(DISTINCT CASE WHEN m.is_pass = TRUE THEN m.id END)::INTEGER as passed_assessments,
    COUNT(DISTINCT CASE WHEN m.is_pass = FALSE THEN m.id END)::INTEGER as failed_assessments,
    ROUND(AVG(m.percentage), 2) as average_percentage,
    COALESCE(SUM(DISTINCT l.due_amount), 0) as total_fee_due,
    COALESCE(SUM(DISTINCT l.paid_amount), 0) as total_fee_paid,
    COALESCE(SUM(DISTINCT l.balance), 0) as fee_balance,
    COUNT(DISTINCT lib.id)::INTEGER as books_issued,
    COUNT(DISTINCT CASE WHEN lib.days_overdue > 0 THEN lib.id END)::INTEGER as books_overdue
  FROM students s
  LEFT JOIN organizations o ON o.id = s.college_id AND o.organization_type = 'college'
  LEFT JOIN programs p ON p.id = CAST(s.grade AS UUID) -- Adjust based on actual relationship
  LEFT JOIN mark_entries m ON m.student_id = s.user_id
  LEFT JOIN student_ledgers l ON l.student_id = s.user_id
  LEFT JOIN library_issued_books lib ON lib.student_id = s.user_id AND lib.status = 'issued'
  WHERE s.user_id = p_student_user_id
  GROUP BY s.id, s.name, s.roll_number, o.name, p.name, s.grade, s."currentCgpa";
END;
$$;


ALTER FUNCTION "public"."get_student_academic_summary"("p_student_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_student_academic_summary"("p_student_user_id" "uuid") IS 'Get comprehensive academic summary for a student';



CREATE OR REPLACE FUNCTION "public"."get_student_details"("p_user_id" "uuid") RETURNS TABLE("student_id" "uuid", "user_id" "uuid", "email" "text", "name" "text", "roll_number" "text", "admission_number" "text", "college_id" "uuid", "college_name" "text", "grade" "text", "section" "text", "category" "text", "quota" "text", "current_cgpa" numeric, "enrollment_date" "date", "expected_graduation_date" "date")
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    s.id,
    s.user_id,
    s.email,
    s.name,
    s.roll_number,
    s.admission_number,
    s.college_id,
    o.name as college_name,
    s.grade,
    s.section,
    s.category,
    s.quota,
    s."currentCgpa",
    s."enrollmentDate",
    s."expectedGraduationDate"
  FROM students s
  LEFT JOIN organizations o ON o.id = s.college_id AND o.organization_type = 'college'
  WHERE s.user_id = p_user_id;
END;
$$;


ALTER FUNCTION "public"."get_student_details"("p_user_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_student_details"("p_user_id" "uuid") IS 'Get complete student details by user_id';



CREATE OR REPLACE FUNCTION "public"."get_student_eligibility"("student_grade" "text") RETURNS TABLE("allowed_employment_types" "text"[], "max_experience_years" integer, "eligibility_level" "text")
    LANGUAGE "plpgsql" IMMUTABLE
    AS $_$
BEGIN
  student_grade := LOWER(COALESCE(student_grade, ''));
  
  -- Grade 6-10: Only internships, no experience required
  -- Matches: 'grade 10', 'class 10', '10th', '10', 'Grade 10', etc.
  IF student_grade ~ '(grade\s*(6|7|8|9|10)|class\s*(6|7|8|9|10)|6th|7th|8th|9th|10th|^(6|7|8|9|10)$)' THEN
    RETURN QUERY SELECT 
      ARRAY['Internship']::TEXT[],
      0::INT,
      'school_junior'::TEXT;
  
  -- Grade 11-12: Internships and part-time, 0-1 year experience
  ELSIF student_grade ~ '(grade\s*(11|12)|class\s*(11|12)|11th|12th|plus\s*two|intermediate|^(11|12)$)' THEN
    RETURN QUERY SELECT 
      ARRAY['Internship', 'Part-time']::TEXT[],
      1::INT,
      'school_senior'::TEXT;
  
  -- Undergraduate: Internships, part-time, entry-level, 0-2 years
  ELSIF student_grade ~ '(b\.?tech|b\.?e|b\.?sc|b\.?com|b\.?a|bba|bca|undergraduate|ug|bachelor|1st\s*year|2nd\s*year|3rd\s*year|4th\s*year|semester)' THEN
    RETURN QUERY SELECT 
      ARRAY['Internship', 'Part-time', 'Full-time', 'Contract']::TEXT[],
      2::INT,
      'undergraduate'::TEXT;
  
  -- Postgraduate: All types, all experience levels
  ELSIF student_grade ~ '(m\.?tech|m\.?e|m\.?sc|m\.?com|m\.?a|mba|mca|postgraduate|pg|master|phd|doctorate)' THEN
    RETURN QUERY SELECT 
      ARRAY['Internship', 'Part-time', 'Full-time', 'Contract']::TEXT[],
      99::INT,
      'postgraduate'::TEXT;
  
  -- Default: Treat as undergraduate (safe default)
  ELSE
    RETURN QUERY SELECT 
      ARRAY['Internship', 'Part-time', 'Full-time', 'Contract']::TEXT[],
      2::INT,
      'default'::TEXT;
  END IF;
END;
$_$;


ALTER FUNCTION "public"."get_student_eligibility"("student_grade" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_student_stream_recommendation_data"("p_student_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    result JSONB;
    student_data JSONB;
    marks_data JSONB;
    projects_data JSONB;
    experiences_data JSONB;
BEGIN
    -- Get student basic info
    SELECT jsonb_build_object(
        'id', s.id,
        'name', s.name,
        'grade', s.grade,
        'interests', COALESCE(s.interests, '[]'::jsonb),
        'hobbies', COALESCE(s.hobbies, '[]'::jsonb),
        'skill_summary', s.skill_summary
    ) INTO student_data
    FROM students s
    WHERE s.id = p_student_id;
    
    -- Get subject-wise marks (aggregate by subject)
    SELECT COALESCE(jsonb_object_agg(
        course_name,
        jsonb_build_object(
            'average_marks', avg_marks,
            'max_marks', max_marks,
            'percentage', ROUND((avg_marks / max_marks * 100)::numeric, 2),
            'assessments_count', assessment_count
        )
    ), '{}'::jsonb) INTO marks_data
    FROM (
        SELECT 
            a.course_name,
            AVG(me.marks_obtained) as avg_marks,
            MAX(me.total_marks) as max_marks,
            COUNT(*) as assessment_count
        FROM mark_entries me
        JOIN assessments a ON me.assessment_id = a.id
        WHERE (me.student_id = p_student_id OR me.student_record_id = p_student_id)
        AND me.marks_obtained IS NOT NULL
        GROUP BY a.course_name
    ) subject_marks;
    
    -- Get projects
    SELECT COALESCE(jsonb_agg(
        jsonb_build_object(
            'title', p.title,
            'description', p.description,
            'tech_stack', p.tech_stack,
            'status', p.status,
            'organization', p.organization
        )
    ), '[]'::jsonb) INTO projects_data
    FROM projects p
    WHERE p.student_id = p_student_id
    AND p.approval_status = 'approved';
    
    -- Get experiences
    SELECT COALESCE(jsonb_agg(
        jsonb_build_object(
            'organization', e.organization,
            'role', e.role,
            'duration', e.duration
        )
    ), '[]'::jsonb) INTO experiences_data
    FROM experience e
    WHERE e.student_id = p_student_id
    AND e.approval_status = 'approved';
    
    -- Combine all data
    result := jsonb_build_object(
        'student', student_data,
        'subject_marks', marks_data,
        'projects', projects_data,
        'experiences', experiences_data
    );
    
    RETURN result;
END;
$$;


ALTER FUNCTION "public"."get_student_stream_recommendation_data"("p_student_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_student_stream_recommendation_data"("p_student_id" "uuid") IS 'Gathers all student data (marks, projects, experiences, interests) needed for AI stream recommendation';



CREATE OR REPLACE FUNCTION "public"."get_student_trainings_with_approvers"("student_email" "text") RETURNS TABLE("id" "uuid", "title" character varying, "organization" character varying, "approval_status" character varying, "approval_authority" character varying, "approved_by_email" "text", "approved_at" timestamp with time zone, "rejected_by_email" "text", "rejected_at" timestamp with time zone, "approval_notes" "text", "approver_type" "text", "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT 
        t.id,
        t.title,
        t.organization,
        t.approval_status,
        t.approval_authority,
        approver.email as approved_by_email,
        t.approved_at,
        rejector.email as rejected_by_email,
        t.rejected_at,
        t.approval_notes,
        CASE 
            WHEN t.approval_authority = 'school_admin' THEN 'School Admin'
            ELSE 'Rareminds Admin'
        END as approver_type,
        t.created_at
    FROM public.trainings t
    JOIN public.students s ON t.student_id = s.id
    LEFT JOIN auth.users approver ON t.approved_by = approver.id
    LEFT JOIN auth.users rejector ON t.rejected_by = rejector.id
    WHERE s.email = student_email
    ORDER BY t.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."get_student_trainings_with_approvers"("student_email" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_students_needing_reminder"() RETURNS TABLE("student_id" "uuid", "student_email" "text", "student_name" "text", "current_streak" integer, "emails_sent_today" integer)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    s.id AS student_id,
    s.email::TEXT AS student_email,
    s.name::TEXT AS student_name,
    COALESCE(ss.current_streak, 0) AS current_streak,
    COALESCE(
      (SELECT COUNT(*)::INTEGER
       FROM streak_notification_log
       WHERE streak_notification_log.student_id = s.id
       AND notification_date = CURRENT_DATE
       AND status = 'sent'),
      0
    ) AS emails_sent_today
  FROM students s
  LEFT JOIN student_streaks ss ON s.id = ss.student_id
  WHERE
    -- Student hasn't completed streak today
    (ss.streak_completed_today = FALSE OR ss.streak_completed_today IS NULL)
    -- Haven't sent 4 emails yet today
    AND (
      SELECT COUNT(*)
      FROM streak_notification_log
      WHERE streak_notification_log.student_id = s.id
      AND notification_date = CURRENT_DATE
      AND status = 'sent'
    ) < 4
    -- Student has an email address
    AND s.email IS NOT NULL
    AND s.email != '';
END;
$$;


ALTER FUNCTION "public"."get_students_needing_reminder"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_students_needing_reminder"() IS 'Returns list of students who need streak reminder emails';



CREATE OR REPLACE FUNCTION "public"."get_training_with_approver_details"("training_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    result json;
BEGIN
    SELECT json_build_object(
        'training', json_build_object(
            'id', t.id,
            'title', t.title,
            'organization', t.organization,
            'student_name', s.name,
            'student_email', s.email,
            'school_name', o.name,
            'approval_status', t.approval_status,
            'approval_authority', t.approval_authority,
            'created_at', t.created_at,
            'updated_at', t.updated_at
        ),
        'approval_details', CASE 
            WHEN t.approval_status = 'approved' THEN json_build_object(
                'approved_by_id', t.approved_by,
                'approved_by_email', approver.email,
                'approved_at', t.approved_at,
                'approval_notes', t.approval_notes,
                'approver_type', CASE 
                    WHEN t.approval_authority = 'school_admin' THEN 'School Admin'
                    ELSE 'Rareminds Admin'
                END
            )
            WHEN t.approval_status = 'rejected' THEN json_build_object(
                'rejected_by_id', t.rejected_by,
                'rejected_by_email', rejector.email,
                'rejected_at', t.rejected_at,
                'rejection_notes', t.approval_notes,
                'rejector_type', CASE 
                    WHEN t.approval_authority = 'school_admin' THEN 'School Admin'
                    ELSE 'Rareminds Admin'
                END
            )
            ELSE json_build_object(
                'status', 'pending',
                'pending_with', CASE 
                    WHEN t.approval_authority = 'school_admin' THEN 'School Admin'
                    ELSE 'Rareminds Admin'
                END
            )
        END
    ) INTO result
    FROM public.trainings t
    JOIN public.students s ON t.student_id = s.id
    LEFT JOIN public.organizations o ON s.school_id = o.id
    LEFT JOIN auth.users approver ON t.approved_by = approver.id
    LEFT JOIN auth.users rejector ON t.rejected_by = rejector.id
    WHERE t.id = training_id;
    
    RETURN COALESCE(result, json_build_object('error', 'Training not found'));
END;
$$;


ALTER FUNCTION "public"."get_training_with_approver_details"("training_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_university_admins"("p_university_id" "uuid") RETURNS TABLE("id" "uuid", "email" "text", "full_name" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT u.id, u.email, CONCAT(u."firstName", ' ', u."lastName") as full_name
    FROM users u
    WHERE u."organizationId" = p_university_id
    AND u.role = 'university_admin'
    AND u."isActive" = true;
END;
$$;


ALTER FUNCTION "public"."get_university_admins"("p_university_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_unread_notification_count"("admin_school_id" "uuid" DEFAULT NULL::"uuid", "admin_college_id" "uuid" DEFAULT NULL::"uuid", "admin_type" "text" DEFAULT 'school_admin'::"text") RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    count_result INTEGER;
BEGIN
    IF admin_type = 'school_admin' AND admin_school_id IS NOT NULL THEN
        SELECT COUNT(*)
        INTO count_result
        FROM training_notifications
        WHERE recipient_type = 'school_admin'
        AND school_id = admin_school_id
        AND is_read = FALSE;
    ELSIF admin_type = 'college_admin' AND admin_college_id IS NOT NULL THEN
        SELECT COUNT(*)
        INTO count_result
        FROM training_notifications
        WHERE recipient_type = 'college_admin'
        AND college_id = admin_college_id
        AND is_read = FALSE;
    ELSE
        count_result := 0;
    END IF;
    
    RETURN COALESCE(count_result, 0);
END;
$$;


ALTER FUNCTION "public"."get_unread_notification_count"("admin_school_id" "uuid", "admin_college_id" "uuid", "admin_type" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_email"("user_id" "uuid") RETURNS "text"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    AS $$
  SELECT email FROM auth.users WHERE id = user_id;
$$;


ALTER FUNCTION "public"."get_user_email"("user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."get_user_unread_count"("user_id" "text", "user_type" "text") RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  unread_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO unread_count
  FROM messages
  WHERE receiver_id = user_id
    AND receiver_type = user_type
    AND is_read = false;
  
  RETURN COALESCE(unread_count, 0);
END;
$$;


ALTER FUNCTION "public"."get_user_unread_count"("user_id" "text", "user_type" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."get_user_unread_count"("user_id" "text", "user_type" "text") IS 'Get total unread message count for a specific user';



CREATE OR REPLACE FUNCTION "public"."handle_new_auth_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_first_name TEXT;
  v_last_name TEXT;
  v_full_name TEXT;
  v_role_text TEXT;
  v_role public.user_role;
  v_phone TEXT;
BEGIN
  -- Extract data from user metadata
  v_full_name := COALESCE(
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'name',
    ''
  );
  
  -- Try to split full name into first and last name
  v_first_name := COALESCE(
    NEW.raw_user_meta_data->>'first_name',
    SPLIT_PART(v_full_name, ' ', 1),
    ''
  );
  
  v_last_name := COALESCE(
    NEW.raw_user_meta_data->>'last_name',
    CASE 
      WHEN POSITION(' ' IN v_full_name) > 0 
      THEN SUBSTRING(v_full_name FROM POSITION(' ' IN v_full_name) + 1)
      ELSE ''
    END,
    ''
  );
  
  -- Get role from metadata and validate against enum
  v_role_text := COALESCE(
    NEW.raw_user_meta_data->>'user_role',
    NEW.raw_user_meta_data->>'role',
    'school_student'
  );
  
  -- Validate and cast role to enum
  IF v_role_text IN ('super_admin', 'rm_admin', 'rm_manager', 'school_admin', 'college_admin', 
                     'university_admin', 'company_admin', 'school_educator', 'recruiter', 
                     'school_student', 'college_student', 'college_educator') THEN
    v_role := v_role_text::public.user_role;
  ELSE
    v_role := 'school_student'::public.user_role;
  END IF;
  
  -- Get phone from metadata
  v_phone := NEW.raw_user_meta_data->>'phone';
  
  -- Insert into public.users if not exists
  INSERT INTO public.users (
    id,
    email,
    "firstName",
    "lastName",
    role,
    phone,
    "isActive",
    "organizationId",
    metadata,
    "createdAt",
    "updatedAt"
  )
  VALUES (
    NEW.id,
    NEW.email,
    v_first_name,
    v_last_name,
    v_role,
    v_phone,
    true,
    NULL,  -- organizationId will be set later when user joins/creates an organization
    jsonb_build_object(
      'source', 'auth_trigger',
      'registrationDate', NOW()::text,
      'fullName', v_full_name
    ),
    NOW(),
    NOW()
  )
  ON CONFLICT (id) DO NOTHING;  -- Don't fail if record already exists
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."handle_new_auth_user"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."handle_new_auth_user"() IS 'Automatically creates a public.users record when a new auth user is created. This ensures all auth users have a corresponding record in the public.users table. Role is validated against the user_role enum.';



CREATE OR REPLACE FUNCTION "public"."has_advanced_skills"("skills_json" "jsonb") RETURNS boolean
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
  skill_text TEXT;
  advanced_skills TEXT[] := ARRAY[
    'python', 'sql', 'java', 'javascript', 'react', 'node', 'angular', 'vue',
    'machine learning', 'ml', 'ai', 'data science', 'data analysis', 'analytics',
    'aws', 'azure', 'gcp', 'cloud', 'devops', 'docker', 'kubernetes',
    'spring boot', 'django', 'flask', 'express', 'mongodb', 'postgresql',
    'tensorflow', 'pytorch', 'deep learning', 'nlp', 'computer vision',
    'gmp', 'haccp', 'fssai', 'organic standards', 'lab skills', 'food tech',
    'marketing', 'content writing', 'seo', 'digital marketing',
    'accounting', 'finance', 'taxation', 'audit',
    'autocad', 'solidworks', 'matlab', 'simulation'
  ];
  skill_item TEXT;
BEGIN
  IF skills_json IS NULL THEN
    RETURN FALSE;
  END IF;
  skill_text := LOWER(skills_json::TEXT);
  FOREACH skill_item IN ARRAY advanced_skills LOOP
    IF skill_text LIKE '%' || skill_item || '%' THEN
      RETURN TRUE;
    END IF;
  END LOOP;
  RETURN FALSE;
END;
$$;


ALTER FUNCTION "public"."has_advanced_skills"("skills_json" "jsonb") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_applications_count"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE public.opportunities
  SET applications_count = applications_count + 1
  WHERE id = NEW.opportunity_id;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."increment_applications_count"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_course_enrollment"("course_id_param" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE courses
  SET enrollment_count = COALESCE(enrollment_count, 0) + 1
  WHERE course_id = course_id_param;
END;
$$;


ALTER FUNCTION "public"."increment_course_enrollment"("course_id_param" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."increment_search_usage"("search_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE recruiter_saved_searches
  SET 
    use_count = use_count + 1,
    last_used = NOW()
  WHERE id = search_id;
END;
$$;


ALTER FUNCTION "public"."increment_search_usage"("search_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."initialize_student_streak"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  INSERT INTO student_streaks (student_id, current_streak, longest_streak)
  VALUES (NEW.id, 0, 0)
  ON CONFLICT (student_id) DO NOTHING;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."initialize_student_streak"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."invalidate_all_job_matches_on_opportunity_change"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    -- When an opportunity is added, updated, or deleted, invalidate all caches
    UPDATE student_job_matches
    SET is_valid = false,
        invalidation_reason = 'Opportunity catalog changed',
        updated_at = NOW()
    WHERE is_valid = true;
    
    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."invalidate_all_job_matches_on_opportunity_change"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."invalidate_all_job_matches_on_opportunity_change"() IS 'Trigger function to invalidate all caches when opportunities change.';



CREATE OR REPLACE FUNCTION "public"."invalidate_job_matches_cache"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_student_id UUID;
    v_reason TEXT;
BEGIN
    -- Determine student_id based on table
    IF TG_TABLE_NAME = 'students' THEN
        v_student_id := COALESCE(NEW.id, OLD.id);
        v_reason := 'Student profile updated';
    ELSIF TG_TABLE_NAME = 'course_enrollments' THEN
        v_student_id := COALESCE(NEW.student_id, OLD.student_id);
        v_reason := 'Course enrollment changed';
    ELSIF TG_TABLE_NAME = 'trainings' THEN
        v_student_id := COALESCE(NEW.student_id, OLD.student_id);
        v_reason := 'Training record changed';
    ELSE
        RETURN COALESCE(NEW, OLD);
    END IF;
    
    -- Invalidate the cache
    UPDATE student_job_matches
    SET is_valid = false,
        invalidation_reason = v_reason,
        updated_at = NOW()
    WHERE student_id = v_student_id
    AND is_valid = true;
    
    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."invalidate_job_matches_cache"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."invalidate_job_matches_cache"() IS 'Trigger function to invalidate cache when student data changes.';



CREATE OR REPLACE FUNCTION "public"."is_job_matches_cache_valid"("p_student_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_cache RECORD;
    v_current_hash VARCHAR(64);
BEGIN
    -- Get current cache
    SELECT * INTO v_cache
    FROM student_job_matches
    WHERE student_id = p_student_id;
    
    -- No cache exists
    IF NOT FOUND THEN
        RETURN false;
    END IF;
    
    -- Cache explicitly invalidated
    IF NOT v_cache.is_valid THEN
        RETURN false;
    END IF;
    
    -- Cache expired
    IF v_cache.expires_at < NOW() THEN
        RETURN false;
    END IF;
    
    -- Check if student data has changed
    v_current_hash := compute_student_profile_hash(p_student_id);
    IF v_current_hash IS DISTINCT FROM v_cache.student_profile_hash THEN
        -- Mark cache as invalid
        UPDATE student_job_matches
        SET is_valid = false,
            invalidation_reason = 'Student profile changed',
            updated_at = NOW()
        WHERE student_id = p_student_id;
        RETURN false;
    END IF;
    
    RETURN true;
END;
$$;


ALTER FUNCTION "public"."is_job_matches_cache_valid"("p_student_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."is_job_matches_cache_valid"("p_student_id" "uuid") IS 'Checks if the cached job matches for a student are still valid.';



CREATE OR REPLACE FUNCTION "public"."is_organization_admin"("user_id" "uuid") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    AS $$
  SELECT EXISTS (
    SELECT 1 FROM users u 
    WHERE u.id = user_id 
    AND u.role IN ('school_admin', 'college_admin', 'university_admin', 'company_admin', 'super_admin')
  );
$$;


ALTER FUNCTION "public"."is_organization_admin"("user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_senior_level_job"("p_title" "text", "p_experience_level" "text", "p_experience_required" "text") RETURNS boolean
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
DECLARE
  title_lower TEXT := LOWER(COALESCE(p_title, ''));
  exp_level_lower TEXT := LOWER(COALESCE(p_experience_level, ''));
  exp_req_lower TEXT := LOWER(COALESCE(p_experience_required, ''));
  years_required INT;
BEGIN
  IF exp_level_lower = 'senior' THEN
    RETURN TRUE;
  END IF;
  
  IF title_lower ~ '(senior|lead|principal|staff|head|director|manager|chief|vp|vice president|architect)' THEN
    RETURN TRUE;
  END IF;
  
  IF exp_req_lower ~ '(\d+)' THEN
    years_required := (regexp_match(exp_req_lower, '(\d+)'))[1]::INT;
    IF years_required >= 5 THEN
      RETURN TRUE;
    END IF;
  END IF;
  
  RETURN FALSE;
END;
$$;


ALTER FUNCTION "public"."is_senior_level_job"("p_title" "text", "p_experience_level" "text", "p_experience_required" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_student_fresher"("p_student_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" STABLE
    AS $$
DECLARE
  student_rec RECORD;
  has_work_experience BOOLEAN := FALSE;
BEGIN
  SELECT 
    work_experience,
    student_type,
    course_name
  INTO student_rec
  FROM students 
  WHERE id = p_student_id;
  
  IF student_rec.work_experience IS NOT NULL 
     AND TRIM(student_rec.work_experience) != '' 
     AND LOWER(student_rec.work_experience) NOT IN ('none', 'no', 'n/a', 'nil', '0', 'fresher', 'no experience') THEN
    has_work_experience := TRUE;
  END IF;
  
  IF NOT has_work_experience THEN
    IF student_rec.student_type IN ('school', 'school_student', 'school-student', 'college', 'university', 'student', 'direct') THEN
      RETURN TRUE;
    END IF;
  END IF;
  
  RETURN NOT has_work_experience;
END;
$$;


ALTER FUNCTION "public"."is_student_fresher"("p_student_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_subscription_active"("sub_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  sub_status VARCHAR(50);
  end_date TIMESTAMPTZ;
BEGIN
  SELECT status, subscription_end_date 
  INTO sub_status, end_date
  FROM subscriptions
  WHERE id = sub_id;
  
  RETURN sub_status = 'active' AND end_date > NOW();
END;
$$;


ALTER FUNCTION "public"."is_subscription_active"("sub_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_notification_sent"("p_student_id" "uuid", "p_template_number" integer, "p_notification_type" character varying DEFAULT 'email'::character varying, "p_status" character varying DEFAULT 'sent'::character varying, "p_error_message" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_log_id UUID;
BEGIN
  INSERT INTO streak_notification_log (
    student_id,
    notification_type,
    email_template_number,
    notification_date,
    status,
    error_message
  ) VALUES (
    p_student_id,
    p_notification_type,
    p_template_number,
    CURRENT_DATE,
    p_status,
    p_error_message
  )
  RETURNING id INTO v_log_id;

  RETURN v_log_id;
END;
$$;


ALTER FUNCTION "public"."log_notification_sent"("p_student_id" "uuid", "p_template_number" integer, "p_notification_type" character varying, "p_status" character varying, "p_error_message" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_notification_sent"("p_student_id" "uuid", "p_template_number" integer, "p_notification_type" character varying, "p_status" character varying, "p_error_message" "text") IS 'Logs a notification sent to a student';



CREATE OR REPLACE FUNCTION "public"."mark_conversation_as_read"("p_conversation_id" "text", "p_user_id" "text") RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  affected_rows INTEGER;
BEGIN
  UPDATE messages
  SET 
    is_read = true,
    read_at = NOW(),
    updated_at = NOW()
  WHERE conversation_id = p_conversation_id
    AND receiver_id = p_user_id
    AND is_read = false;
  
  GET DIAGNOSTICS affected_rows = ROW_COUNT;
  RETURN affected_rows;
END;
$$;


ALTER FUNCTION "public"."mark_conversation_as_read"("p_conversation_id" "text", "p_user_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_notification_read"("notification_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    UPDATE public.training_notifications 
    SET is_read = true, updated_at = NOW()
    WHERE id = notification_id;
    
    RETURN FOUND;
END;
$$;


ALTER FUNCTION "public"."mark_notification_read"("notification_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."mark_previous_stream_reports_not_latest"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Mark all previous reports for this student as not latest
    UPDATE stream_recommendation_reports
    SET is_latest = false
    WHERE student_id = NEW.student_id
    AND id != NEW.id;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."mark_previous_stream_reports_not_latest"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."match_opportunities"("query_embedding" "extensions"."vector", "student_id_param" "uuid", "dismissed_ids" "uuid"[], "match_threshold" double precision, "match_count" integer) RETURNS TABLE("id" "uuid", "title" "text", "job_title" "text", "company_name" "text", "company_logo" "text", "description" "text", "location" "text", "employment_type" "text", "department" "text", "salary_min" numeric, "salary_max" numeric, "experience_level" "text", "skills_required" "jsonb", "requirements" "jsonb", "responsibilities" "jsonb", "created_at" timestamp with time zone, "similarity" double precision, "view_count" integer, "application_count" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    o.id,
    o.title,
    o.job_title,
    o.company_name,
    o.company_logo,
    o.description,
    o.location,
    o.employment_type,
    o.department,
    o.salary_range_min,
    o.salary_range_max,
    o.experience_level,
    o.skills_required,
    o.requirements,
    o.responsibilities,
    o.created_at,
    (1 - (o.embedding <=> query_embedding))::FLOAT,
    o.views_count,
    o.applications_count
  FROM opportunities o
  WHERE o.embedding IS NOT NULL
    AND o.is_active = true
    AND o.status = 'published'
    AND NOT (o.id = ANY(dismissed_ids))
    AND (1 - (o.embedding <=> query_embedding)) >= match_threshold
  ORDER BY o.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;


ALTER FUNCTION "public"."match_opportunities"("query_embedding" "extensions"."vector", "student_id_param" "uuid", "dismissed_ids" "uuid"[], "match_threshold" double precision, "match_count" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."match_opportunities"("query_embedding" "extensions"."vector", "student_id_param" "uuid", "dismissed_ids" "uuid"[], "match_threshold" double precision, "match_count" integer) IS 'ACTIVE: Basic vector similarity matching without quality boosting.';



CREATE OR REPLACE FUNCTION "public"."match_opportunities_enhanced"("query_embedding" "extensions"."vector", "student_id_param" "uuid", "dismissed_ids" "uuid"[] DEFAULT '{}'::"uuid"[], "match_threshold" double precision DEFAULT 0.30, "match_count" integer DEFAULT 50) RETURNS TABLE("id" "uuid", "title" "text", "job_title" "text", "company_name" "text", "company_logo" "text", "employment_type" "text", "location" "text", "mode" "text", "stipend_or_salary" "text", "experience_required" "text", "experience_level" "text", "skills_required" "jsonb", "requirements" "jsonb", "responsibilities" "jsonb", "description" "text", "application_link" "text", "deadline" timestamp with time zone, "department" "text", "salary_range_min" integer, "salary_range_max" integer, "posted_date" timestamp with time zone, "is_active" boolean, "status" "text", "created_at" timestamp with time zone, "updated_at" timestamp with time zone, "views_count" integer, "applications_count" integer, "embedding" "extensions"."vector", "similarity" double precision, "skill_match_score" double precision, "final_score" double precision)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  student_grade TEXT;
  student_type TEXT;
  student_semester INTEGER;
  student_branch TEXT;
  student_courses TEXT[];
  profile_completeness FLOAT;
BEGIN
  -- Get comprehensive student info
  SELECT 
    s.grade, 
    s.student_type,
    COALESCE(s.semester, 1) as semester,
    COALESCE(s.branch_field, s.course_name, '') as branch,
    ARRAY(
      SELECT ce.course_title 
      FROM course_enrollments ce 
      WHERE ce.student_id = s.id 
        AND ce.status IN ('in_progress', 'active', 'completed')
    ) as courses
  INTO student_grade, student_type, student_semester, student_branch, student_courses
  FROM students s 
  WHERE s.id = student_id_param;

  -- Calculate profile completeness (0.0 - 1.0)
  SELECT 
    (
      CASE WHEN s.branch_field IS NOT NULL THEN 0.15 ELSE 0.0 END +
      CASE WHEN s.course_name IS NOT NULL THEN 0.15 ELSE 0.0 END +
      CASE WHEN s.university IS NOT NULL THEN 0.10 ELSE 0.0 END +
      CASE WHEN EXISTS(SELECT 1 FROM skills sk WHERE sk.student_id = s.id AND sk.enabled = true) THEN 0.20 ELSE 0.0 END +
      CASE WHEN EXISTS(SELECT 1 FROM projects p WHERE p.student_id = s.id) THEN 0.20 ELSE 0.0 END +
      CASE WHEN EXISTS(SELECT 1 FROM trainings t WHERE t.student_id = s.id) THEN 0.10 ELSE 0.0 END +
      CASE WHEN EXISTS(SELECT 1 FROM course_enrollments ce WHERE ce.student_id = s.id AND ce.status = 'completed') THEN 0.10 ELSE 0.0 END
    )
  INTO profile_completeness
  FROM students s
  WHERE s.id = student_id_param;

  RETURN QUERY
  SELECT 
    o.id,
    o.title,
    o.job_title,
    o.company_name,
    o.company_logo,
    o.employment_type,
    o.location,
    o.mode,
    o.stipend_or_salary,
    o.experience_required,
    o.experience_level,
    o.skills_required,
    o.requirements,
    o.responsibilities,
    o.description,
    o.application_link,
    o.deadline,
    o.department,
    o.salary_range_min,
    o.salary_range_max,
    o.posted_date,
    o.is_active,
    o.status,
    o.created_at,
    o.updated_at,
    o.views_count,
    o.applications_count,
    o.embedding,
    (1 - (query_embedding <=> o.embedding))::FLOAT as similarity,
    0.0::FLOAT as skill_match_score,
    LEAST(1.0, 
      (1 - (query_embedding <=> o.embedding)) * 
      (1.0 + 
        CASE WHEN o.description IS NOT NULL AND length(o.description) > 100 THEN 0.15 ELSE 0.0 END +
        CASE WHEN o.skills_required IS NOT NULL 
          AND jsonb_typeof(o.skills_required) = 'array' 
          AND jsonb_array_length(o.skills_required) > 0 THEN 0.10 ELSE 0.0 END +
        CASE WHEN o.company_name IS NOT NULL AND o.company_name != '' THEN 0.05 ELSE 0.0 END
      ) *
      CASE
        WHEN student_grade = 'UG' 
          AND student_semester <= 4 
          AND o.employment_type = 'Full-time' THEN 0.0
        WHEN student_grade = 'UG' 
          AND o.employment_type = 'Internship' 
          AND o.description IS NOT NULL THEN 1.3
        WHEN (student_grade = 'UG' AND student_semester >= 7) 
          OR student_grade = 'PG'
          AND o.employment_type = 'Full-time' THEN 1.2
        WHEN student_grade IN ('UG', 'PG') AND (
          o.title LIKE '%School Newsletter%' OR 
          o.title LIKE '%Road Safety%' OR 
          o.title LIKE '%Mindfulness Buddy%' OR
          o.title LIKE '%Young%' OR
          o.title LIKE '%School Garden%'
        ) THEN 0.7
        ELSE 1.0
      END *
      CASE
        WHEN EXISTS(
          SELECT 1 FROM unnest(student_courses) course 
          WHERE LOWER(course) LIKE '%blockchain%' OR LOWER(course) LIKE '%crypto%'
        ) AND (
          LOWER(o.title) LIKE '%blockchain%' OR 
          LOWER(o.description) LIKE '%blockchain%' OR
          LOWER(o.title) LIKE '%crypto%' OR
          LOWER(o.description) LIKE '%web3%'
        ) THEN 1.5
        WHEN EXISTS(
          SELECT 1 FROM unnest(student_courses) course 
          WHERE LOWER(course) LIKE '%python%' OR LOWER(course) LIKE '%programming%'
        ) AND (
          LOWER(o.title) LIKE '%python%' OR 
          LOWER(o.title) LIKE '%developer%' OR
          LOWER(o.title) LIKE '%software%'
        ) THEN 1.4
        WHEN EXISTS(
          SELECT 1 FROM unnest(student_courses) course 
          WHERE LOWER(course) LIKE '%data%' OR LOWER(course) LIKE '%analytics%'
        ) AND (
          LOWER(o.title) LIKE '%data%' OR 
          LOWER(o.title) LIKE '%analyst%' OR
          LOWER(o.title) LIKE '%analytics%'
        ) THEN 1.4
        WHEN EXISTS(
          SELECT 1 FROM unnest(student_courses) course 
          WHERE LOWER(course) LIKE '%marketing%' OR LOWER(course) LIKE '%business%'
        ) AND (
          LOWER(o.title) LIKE '%marketing%' OR 
          LOWER(o.title) LIKE '%business%' OR
          LOWER(o.title) LIKE '%sales%'
        ) THEN 1.4
        WHEN EXISTS(
          SELECT 1 FROM unnest(student_courses) course 
          WHERE LOWER(course) LIKE '%design%' OR LOWER(course) LIKE '%ui%' OR LOWER(course) LIKE '%ux%'
        ) AND (
          LOWER(o.title) LIKE '%design%' OR 
          LOWER(o.title) LIKE '%ui%' OR
          LOWER(o.title) LIKE '%ux%'
        ) THEN 1.4
        ELSE 1.0
      END *
      CASE
        WHEN profile_completeness >= 0.60 THEN 1.0
        WHEN profile_completeness >= 0.40 THEN 0.95
        WHEN profile_completeness >= 0.20 THEN 0.85
        ELSE 0.75
      END *
      CASE
        WHEN o.experience_level IN ('Entry', 'Fresher', 'Beginner') 
          AND student_grade IN ('UG', 'Grade 12', 'Grade 11') THEN 1.2
        WHEN o.experience_level IN ('Junior', 'Associate') 
          AND (
            (student_grade = 'UG' AND student_semester >= 5) OR 
            student_grade = 'PG'
          ) THEN 1.1
        WHEN o.experience_level IN ('Senior', 'Lead', 'Manager') 
          AND student_grade IN ('UG', 'PG', 'Grade 12') THEN 0.8
        ELSE 1.0
      END
    )::FLOAT as final_score
  FROM opportunities o
  WHERE o.embedding IS NOT NULL
    AND o.is_active = true
    AND o.status = 'open'
    AND (o.deadline IS NULL OR o.deadline > NOW())
    AND NOT (o.id = ANY(dismissed_ids))
    AND length(o.title) > 10
    AND (1 - (query_embedding <=> o.embedding)) >= (match_threshold * 0.7)
    AND NOT (
      student_grade = 'UG' 
      AND student_semester <= 4 
      AND o.employment_type = 'Full-time'
    )
  ORDER BY final_score DESC
  LIMIT match_count;
END;
$$;


ALTER FUNCTION "public"."match_opportunities_enhanced"("query_embedding" "extensions"."vector", "student_id_param" "uuid", "dismissed_ids" "uuid"[], "match_threshold" double precision, "match_count" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."match_opportunities_enhanced"("query_embedding" "extensions"."vector", "student_id_param" "uuid", "dismissed_ids" "uuid"[], "match_threshold" double precision, "match_count" integer) IS 'Enhanced job matching v3.1 with score capping. All match scores are normalized to 0-100% range. Includes quality boosting, course alignment, profile completeness, employment type filtering, and experience level matching.';



CREATE OR REPLACE FUNCTION "public"."match_opportunities_enhanced_v2"("query_embedding" "extensions"."vector", "student_id_param" "uuid", "dismissed_ids" "uuid"[] DEFAULT '{}'::"uuid"[], "match_threshold" double precision DEFAULT 0.01, "match_count" integer DEFAULT 50) RETURNS TABLE("id" "uuid", "title" "text", "company_name" "text", "employment_type" "text", "location" "text", "mode" "text", "stipend_or_salary" "text", "experience_level" "text", "skills_required" "jsonb", "description" "text", "deadline" timestamp with time zone, "similarity" double precision, "skill_match_score" double precision, "certificate_match_score" double precision, "project_match_score" double precision, "final_score" double precision, "match_percentage" integer)
    LANGUAGE "plpgsql" STABLE
    AS $$
DECLARE
  student_is_fresher BOOLEAN;
BEGIN
  student_is_fresher := is_student_fresher(student_id_param);
  
  RETURN QUERY
  WITH base_matches AS (
    SELECT 
      o.id,
      o.title,
      o.company_name,
      o.employment_type,
      o.location,
      o.mode,
      o.stipend_or_salary,
      o.experience_level,
      o.experience_required,
      o.skills_required,
      o.description,
      o.deadline,
      1 - (query_embedding <=> o.embedding) AS similarity,
      is_senior_level_job(o.title, o.experience_level, o.experience_required) AS is_senior
    FROM opportunities o
    WHERE o.is_active = true
      AND o.status = 'open'
      AND (o.deadline IS NULL OR o.deadline > NOW())
      AND o.embedding IS NOT NULL
      AND o.id != ALL(dismissed_ids)
      AND (1 - (query_embedding <=> o.embedding)) >= match_threshold
    ORDER BY query_embedding <=> o.embedding
    LIMIT match_count * 2
  ),
  certificate_scores AS (
    SELECT 
      bm.id AS opportunity_id,
      COALESCE(MAX(1 - (c.embedding <=> o.embedding)), 0) AS cert_score
    FROM base_matches bm
    JOIN opportunities o ON o.id = bm.id
    LEFT JOIN certificates c ON c.student_id = student_id_param 
      AND c.enabled = true 
      AND c.embedding IS NOT NULL
    GROUP BY bm.id
  ),
  project_scores AS (
    SELECT 
      bm.id AS opportunity_id,
      COALESCE(MAX(1 - (p.embedding <=> o.embedding)), 0) AS proj_score
    FROM base_matches bm
    JOIN opportunities o ON o.id = bm.id
    LEFT JOIN projects p ON p.student_id = student_id_param 
      AND p.enabled = true 
      AND p.embedding IS NOT NULL
    GROUP BY bm.id
  ),
  skill_matches AS (
    SELECT 
      bm.id AS opportunity_id,
      CASE 
        WHEN o.skills_required IS NULL THEN 0.5
        WHEN jsonb_typeof(o.skills_required) = 'string' THEN
          (
            SELECT COALESCE(
              COUNT(DISTINCT s.name)::FLOAT / GREATEST(
                array_length(string_to_array(o.skills_required #>> '{}', ','), 1), 1
              ),
              0
            )
            FROM skills s
            WHERE s.student_id = student_id_param
              AND s.enabled = true
              AND EXISTS (
                SELECT 1 FROM unnest(string_to_array(o.skills_required #>> '{}', ',')) AS req_skill
                WHERE LOWER(TRIM(req_skill)) LIKE '%' || LOWER(s.name) || '%'
                   OR LOWER(s.name) LIKE '%' || LOWER(TRIM(req_skill)) || '%'
              )
          )
        WHEN jsonb_typeof(o.skills_required) = 'array' AND jsonb_array_length(o.skills_required) = 0 THEN 0.5
        WHEN jsonb_typeof(o.skills_required) = 'array' THEN
          (
            SELECT COALESCE(
              COUNT(DISTINCT s.name)::FLOAT / GREATEST(jsonb_array_length(o.skills_required), 1),
              0
            )
            FROM skills s
            WHERE s.student_id = student_id_param
              AND s.enabled = true
              AND LOWER(s.name) IN (
                SELECT LOWER(jsonb_array_elements_text(o.skills_required))
              )
          )
        ELSE 0.5
      END AS skill_overlap
    FROM base_matches bm
    JOIN opportunities o ON o.id = bm.id
  ),
  scored_opportunities AS (
    SELECT 
      bm.id,
      bm.title,
      bm.company_name,
      bm.employment_type,
      bm.location,
      bm.mode,
      bm.stipend_or_salary,
      bm.experience_level,
      bm.experience_required,
      bm.skills_required,
      bm.description,
      bm.deadline,
      bm.similarity,
      sm.skill_overlap AS skill_match_score,
      cs.cert_score AS certificate_match_score,
      ps.proj_score AS project_match_score,
      bm.is_senior,
      (
        (bm.similarity * 0.40) +
        (COALESCE(sm.skill_overlap, 0.5) * 0.25) +
        (cs.cert_score * 0.20) +
        (ps.proj_score * 0.15)
      ) AS base_score,
      (student_is_fresher AND bm.is_senior) AS exp_mismatch
    FROM base_matches bm
    LEFT JOIN certificate_scores cs ON cs.opportunity_id = bm.id
    LEFT JOIN project_scores ps ON ps.opportunity_id = bm.id
    LEFT JOIN skill_matches sm ON sm.opportunity_id = bm.id
  )
  SELECT 
    so.id,
    so.title,
    so.company_name,
    so.employment_type,
    so.location,
    so.mode,
    so.stipend_or_salary,
    so.experience_level,
    so.skills_required,
    so.description,
    so.deadline,
    so.similarity,
    COALESCE(so.skill_match_score, 0.5) AS skill_match_score,
    so.certificate_match_score,
    so.project_match_score,
    CASE 
      WHEN so.exp_mismatch THEN LEAST(1.0, so.base_score * 0.70)
      ELSE LEAST(1.0, so.base_score)
    END AS final_score,
    CASE 
      WHEN so.exp_mismatch THEN LEAST(100, ROUND(so.base_score * 0.70 * 100))::INT
      ELSE LEAST(100, ROUND(so.base_score * 100))::INT
    END AS match_percentage
  FROM scored_opportunities so
  WHERE NOT (
    student_is_fresher 
    AND so.is_senior 
    AND so.experience_level = 'Senior'
    AND (
      COALESCE((SELECT (regexp_match(LOWER(o.experience_required), '(\d+)'))[1]::INT 
                FROM opportunities o WHERE o.id = so.id), 0) >= 5
    )
  )
  ORDER BY final_score DESC
  LIMIT match_count;
END;
$$;


ALTER FUNCTION "public"."match_opportunities_enhanced_v2"("query_embedding" "extensions"."vector", "student_id_param" "uuid", "dismissed_ids" "uuid"[], "match_threshold" double precision, "match_count" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."match_opportunities_smart"("p_student_id" "uuid", "p_query_embedding" "extensions"."vector", "p_student_type" "text" DEFAULT NULL::"text", "p_grade" "text" DEFAULT NULL::"text", "p_semester" integer DEFAULT NULL::integer, "p_dismissed_ids" "uuid"[] DEFAULT '{}'::"uuid"[], "p_match_threshold" double precision DEFAULT 0.30, "p_match_count" integer DEFAULT 50) RETURNS TABLE("id" "uuid", "title" "text", "company_name" "text", "company_logo" "text", "employment_type" "text", "location" "text", "mode" "text", "stipend_or_salary" "text", "experience_required" "text", "experience_level" "text", "skills_required" "jsonb", "requirements" "jsonb", "responsibilities" "jsonb", "description" "text", "application_link" "text", "deadline" timestamp with time zone, "department" "text", "salary_range_min" integer, "salary_range_max" integer, "posted_date" timestamp with time zone, "is_active" boolean, "status" "text", "created_at" timestamp with time zone, "updated_at" timestamp with time zone, "views_count" integer, "applications_count" integer, "similarity_score" double precision, "skill_match_score" double precision, "certificate_match_score" double precision, "project_match_score" double precision, "experience_match_score" double precision, "final_score" double precision, "match_percentage" integer, "match_reasons" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_student_skills TEXT[];
  v_student_certificates TEXT[];
  v_student_projects TEXT[];
  v_student_experience_count INTEGER;
  v_is_school_student BOOLEAN;
  v_grade_number INTEGER;
BEGIN
  -- Determine if student is a school student
  v_is_school_student := (p_student_type = 'school-student');
  
  -- Extract grade number for school students
  IF v_is_school_student AND p_grade IS NOT NULL THEN
    v_grade_number := CAST(REGEXP_REPLACE(p_grade, '[^0-9]', '', 'g') AS INTEGER);
  END IF;

  -- Fetch student skills
  SELECT ARRAY_AGG(DISTINCT LOWER(s.name))
  INTO v_student_skills
  FROM skills s
  WHERE s.student_id = p_student_id
    AND s.enabled = true;

  -- Fetch student certificates
  SELECT ARRAY_AGG(DISTINCT LOWER(c.title))
  INTO v_student_certificates
  FROM certificates c
  WHERE c.student_id = p_student_id
    AND c.enabled = true;

  -- Fetch student projects
  SELECT ARRAY_AGG(DISTINCT LOWER(p.title))
  INTO v_student_projects
  FROM projects p
  WHERE p.student_id = p_student_id
    AND p.enabled = true;

  -- Count student experience
  SELECT COUNT(*)
  INTO v_student_experience_count
  FROM experience e
  WHERE e.student_id = p_student_id
    AND e.enabled = true;

  -- Return matched opportunities with comprehensive scoring
  RETURN QUERY
  WITH filtered_opportunities AS (
    SELECT o.*
    FROM opportunities o
    WHERE o.embedding IS NOT NULL
      AND o.is_active = true
      AND o.status = 'open'
      AND (o.deadline IS NULL OR o.deadline > NOW())
      AND NOT (o.id = ANY(p_dismissed_ids))
      -- Filter by student type and experience level
      AND (
        CASE
          -- School students (Grade 6-12): Only internships and entry-level
          WHEN v_is_school_student THEN
            LOWER(o.employment_type) IN ('internship', 'part-time') OR
            LOWER(o.experience_level) IN ('entry', 'intern', 'fresher', 'beginner')
          
          -- University students: Filter by semester/year
          WHEN p_student_type = 'university-student' THEN
            CASE
              -- Early years (Semester 1-4): Internships and entry-level
              WHEN p_semester IS NOT NULL AND p_semester <= 4 THEN
                LOWER(o.employment_type) IN ('internship', 'part-time', 'full-time') AND
                LOWER(o.experience_level) IN ('entry', 'intern', 'fresher', 'junior')
              
              -- Final years (Semester 5+): Entry to mid-level
              WHEN p_semester IS NOT NULL AND p_semester >= 5 THEN
                LOWER(o.experience_level) IN ('entry', 'junior', 'mid', 'fresher')
              
              -- Default: Entry and junior level
              ELSE
                LOWER(o.experience_level) IN ('entry', 'junior', 'intern', 'fresher')
            END
          
          -- College students: Similar to university
          WHEN p_student_type = 'college-student' THEN
            LOWER(o.experience_level) IN ('entry', 'junior', 'intern', 'fresher')
          
          -- Default: Show all
          ELSE true
        END
      )
  ),
  scored_opportunities AS (
    SELECT 
      o.*,
      
      -- 1. Semantic Similarity Score (40% weight)
      GREATEST(0, LEAST(1, (1 - (p_query_embedding <=> o.embedding))))::FLOAT as similarity,
      
      -- 2. Skill Match Score (30% weight)
      CASE 
        WHEN o.skills_required IS NULL OR jsonb_array_length(o.skills_required) = 0 THEN 0.5
        WHEN v_student_skills IS NULL THEN 0.0
        ELSE (
          SELECT COUNT(DISTINCT skill)::FLOAT / GREATEST(jsonb_array_length(o.skills_required), 1)
          FROM jsonb_array_elements_text(o.skills_required) skill
          WHERE EXISTS (
            SELECT 1 FROM UNNEST(v_student_skills) student_skill
            WHERE LOWER(skill) LIKE '%' || student_skill || '%'
               OR student_skill LIKE '%' || LOWER(skill) || '%'
          )
        )
      END as skill_match,
      
      -- 3. Certificate Match Score (15% weight)
      CASE
        WHEN v_student_certificates IS NULL THEN 0.0
        WHEN o.requirements IS NULL THEN 0.3
        ELSE (
          SELECT LEAST(1.0, COUNT(*)::FLOAT * 0.3)
          FROM jsonb_array_elements_text(o.requirements) req
          WHERE EXISTS (
            SELECT 1 FROM UNNEST(v_student_certificates) cert
            WHERE LOWER(req) LIKE '%' || cert || '%'
               OR cert LIKE '%' || LOWER(req) || '%'
          )
        )
      END as certificate_match,
      
      -- 4. Project Match Score (15% weight)
      CASE
        WHEN v_student_projects IS NULL THEN 0.0
        WHEN o.responsibilities IS NULL THEN 0.2
        ELSE (
          SELECT LEAST(1.0, COUNT(*)::FLOAT * 0.25)
          FROM jsonb_array_elements_text(o.responsibilities) resp
          WHERE EXISTS (
            SELECT 1 FROM UNNEST(v_student_projects) proj
            WHERE LOWER(resp) LIKE '%' || proj || '%'
               OR proj LIKE '%' || LOWER(resp) || '%'
          )
        )
      END as project_match,
      
      -- 5. Experience Level Match Score (bonus)
      CASE
        WHEN v_student_experience_count = 0 AND LOWER(o.experience_level) IN ('entry', 'intern', 'fresher') THEN 0.2
        WHEN v_student_experience_count >= 1 AND LOWER(o.experience_level) IN ('junior', 'mid') THEN 0.15
        WHEN v_student_experience_count >= 3 AND LOWER(o.experience_level) IN ('mid', 'senior') THEN 0.1
        ELSE 0.0
      END as experience_bonus
      
    FROM filtered_opportunities o
  )
  SELECT 
    so.id,
    so.title,
    so.company_name,
    so.company_logo,
    so.employment_type,
    so.location,
    so.mode,
    so.stipend_or_salary,
    so.experience_required,
    so.experience_level,
    so.skills_required,
    so.requirements,
    so.responsibilities,
    so.description,
    so.application_link,
    so.deadline,
    so.department,
    so.salary_range_min,
    so.salary_range_max,
    so.posted_date,
    so.is_active,
    so.status,
    so.created_at,
    so.updated_at,
    so.views_count,
    so.applications_count,
    
    -- Individual scores
    so.similarity as similarity_score,
    so.skill_match as skill_match_score,
    so.certificate_match as certificate_match_score,
    so.project_match as project_match_score,
    so.experience_bonus as experience_match_score,
    
    -- Final weighted score
    (
      (so.similarity * 0.40) +
      (so.skill_match * 0.30) +
      (so.certificate_match * 0.15) +
      (so.project_match * 0.15) +
      so.experience_bonus
    )::FLOAT as final_score,
    
    -- Match percentage (0-100)
    LEAST(100, GREATEST(0, ROUND(
      (
        (so.similarity * 0.40) +
        (so.skill_match * 0.30) +
        (so.certificate_match * 0.15) +
        (so.project_match * 0.15) +
        so.experience_bonus
      ) * 100
    )))::INTEGER as match_percentage,
    
    -- Match reasons (for UI display)
    jsonb_build_object(
      'profile_match', so.similarity >= 0.6,
      'skill_match', so.skill_match >= 0.5,
      'certificate_match', so.certificate_match >= 0.3,
      'project_match', so.project_match >= 0.3,
      'experience_appropriate', so.experience_bonus > 0,
      'recently_posted', (NOW() - so.posted_date) < INTERVAL '7 days',
      'high_demand', so.views_count > 50
    ) as match_reasons
    
  FROM scored_opportunities so
  WHERE (
    (so.similarity * 0.40) +
    (so.skill_match * 0.30) +
    (so.certificate_match * 0.15) +
    (so.project_match * 0.15) +
    so.experience_bonus
  ) >= p_match_threshold
  ORDER BY final_score DESC, so.posted_date DESC
  LIMIT p_match_count;
  
END;
$$;


ALTER FUNCTION "public"."match_opportunities_smart"("p_student_id" "uuid", "p_query_embedding" "extensions"."vector", "p_student_type" "text", "p_grade" "text", "p_semester" integer, "p_dismissed_ids" "uuid"[], "p_match_threshold" double precision, "p_match_count" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."match_opportunities_smart"("p_student_id" "uuid", "p_query_embedding" "extensions"."vector", "p_student_type" "text", "p_grade" "text", "p_semester" integer, "p_dismissed_ids" "uuid"[], "p_match_threshold" double precision, "p_match_count" integer) IS 'ACTIVE: Smart matching with certificate and project matching.';



CREATE OR REPLACE FUNCTION "public"."notify_admin_assessment_completion"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    admin_user_id UUID;
    student_name TEXT;
    student_school_id UUID;
    student_school_name TEXT;
    assessment_name TEXT;
BEGIN
    IF (TG_OP = 'INSERT' AND NEW.status = 'completed') OR 
       (TG_OP = 'UPDATE' AND OLD.status != 'completed' AND NEW.status = 'completed') THEN
        
        -- Get student details from organizations table
        SELECT s.name, s.school_id, o.name 
        INTO student_name, student_school_id, student_school_name
        FROM students s 
        LEFT JOIN organizations o ON s.school_id = o.id
        WHERE s.id = NEW.student_id;
        
        -- Create assessment name
        assessment_name := CASE 
            WHEN NEW.stream_id = 'middle_school' THEN 'Middle School Career Assessment'
            WHEN NEW.stream_id = 'high_school' THEN 'High School Career Assessment'
            WHEN NEW.stream_id = 'science' THEN 'Science Stream Assessment'
            WHEN NEW.stream_id = 'commerce' THEN 'Commerce Stream Assessment'
            WHEN NEW.stream_id = 'arts' THEN 'Arts Stream Assessment'
            WHEN NEW.stream_id = 'cs' THEN 'Computer Science Assessment'
            WHEN NEW.stream_id = 'bca' THEN 'BCA Career Assessment'
            WHEN NEW.stream_id = 'bba' THEN 'BBA Career Assessment'
            WHEN NEW.stream_id = 'engineering' THEN 'Engineering Assessment'
            WHEN NEW.stream_id = 'medical' THEN 'Medical Assessment'
            ELSE COALESCE(UPPER(NEW.stream_id), 'Career Assessment')
        END;
        
        IF NEW.grade_level IS NOT NULL THEN
            assessment_name := assessment_name || ' (' || 
                CASE NEW.grade_level
                    WHEN 'middle' THEN 'Grade 6-8'
                    WHEN 'highschool' THEN 'Grade 9-12'
                    WHEN 'after12' THEN 'After 12th'
                    ELSE NEW.grade_level
                END || ')';
        END IF;
        
        IF student_school_id IS NOT NULL THEN
            SELECT se.user_id INTO admin_user_id
            FROM school_educators se
            WHERE se.school_id = student_school_id 
            AND se.role = 'school_admin'
            LIMIT 1;
            
            IF admin_user_id IS NOT NULL THEN
                IF NOT EXISTS (
                    SELECT 1 FROM notifications 
                    WHERE recipient_id = admin_user_id 
                    AND type = 'assessment_completed'
                    AND message LIKE '%' || COALESCE(student_name, 'Student') || '%'
                    AND message LIKE '%' || assessment_name || '%'
                    AND created_at > NOW() - INTERVAL '1 hour'
                ) THEN
                    INSERT INTO notifications (recipient_id, type, title, message, read)
                    VALUES (
                        admin_user_id,
                        'assessment_completed',
                        'Student Assessment Completed',
                        COALESCE(student_name, 'Student') || ' completed ' || 
                        assessment_name || ' assessment',
                        false
                    );
                END IF;
            END IF;
        ELSE
            SELECT u.id INTO admin_user_id
            FROM users u
            WHERE u.role = 'super_admin'
            LIMIT 1;
            
            IF admin_user_id IS NOT NULL THEN
                IF NOT EXISTS (
                    SELECT 1 FROM notifications 
                    WHERE recipient_id = admin_user_id 
                    AND type = 'assessment_completed'
                    AND message LIKE '%' || COALESCE(student_name, 'Student') || '%'
                    AND message LIKE '%' || assessment_name || '%'
                    AND created_at > NOW() - INTERVAL '1 hour'
                ) THEN
                    INSERT INTO notifications (recipient_id, type, title, message, read)
                    VALUES (
                        admin_user_id,
                        'assessment_completed',
                        'Assessment Completed',
                        COALESCE(student_name, 'Student') || ' completed ' || 
                        assessment_name || ' assessment',
                        false
                    );
                END IF;
            END IF;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_admin_assessment_completion"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_admin_experience"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    student_record RECORD;
    admin_id UUID;
    submission_name TEXT;
    human_type TEXT;
    notification_message TEXT;
BEGIN
    -- 1ï¸âƒ£ Get student info
    SELECT id, name, student_type, college_id, school_id
    INTO student_record
    FROM students
    WHERE id = NEW.student_id;

    IF NOT FOUND THEN
        RAISE NOTICE 'âŒ Student not found: %', NEW.student_id;
        RETURN NEW;
    END IF;

    -- 2ï¸âƒ£ Determine admin_id based on student type
    admin_id := NULL;

    IF student_record.student_type = 'college' THEN
        SELECT org.admin_id INTO admin_id
        FROM organizations org
        WHERE org.id = student_record.college_id
          AND org.admin_id IS NOT NULL
        LIMIT 1;

    ELSIF student_record.student_type IN ('school', 'school-student') THEN
        SELECT org.admin_id INTO admin_id
        FROM organizations org
        WHERE org.id = student_record.school_id
          AND org.admin_id IS NOT NULL
        LIMIT 1;
    END IF;

    IF admin_id IS NULL THEN
        RAISE NOTICE 'âŒ No admin found for student %', student_record.name;
        RETURN NEW;
    END IF;

    -- 3ï¸âƒ£ Determine submission type and name
    IF TG_TABLE_NAME = 'experience' THEN
        submission_name := COALESCE(NEW.role, 'Unknown Role');
        human_type := 'experience';
    ELSIF TG_TABLE_NAME = 'training' THEN
        submission_name := COALESCE(NEW.title, 'Unknown Training');
        human_type := 'training';
    ELSIF TG_TABLE_NAME = 'projects' THEN
        submission_name := COALESCE(NEW.title, 'Unknown Project');
        human_type := 'project';
    ELSE
        submission_name := 'Unknown Submission';
        human_type := 'submission';
    END IF;

    -- 4ï¸âƒ£ Only notify if new or pending submission
    IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.approval_status = 'pending' AND OLD.approval_status IS DISTINCT FROM 'pending') THEN

        IF human_type = 'project' THEN
            notification_message := format(
            'Student %s submitted project "%s"',
            COALESCE(student_record.name, 'Unknown Student'),
            submission_name
        );
        ELSE
            notification_message := format(
            'Student %s submitted %s "%s" at "%s"',
            COALESCE(student_record.name, 'Unknown Student'),
            human_type,
            submission_name,
            COALESCE(org_name, 'Unknown Organization')
            );
        END IF;

        INSERT INTO notifications (
            id,
            recipient_id,
            type,
            title,
            message,
            read,
            created_at
        ) VALUES (
            gen_random_uuid(),
            admin_id,
            human_type || '_approval',
            'New ' || human_type || ' Submission',
            notification_message,
            FALSE,
            NOW()
        );

        RAISE NOTICE 'âœ… Admin notification created for admin %', admin_id;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_admin_experience"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_admin_experience_submission"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    admin_user_id UUID;
    student_name TEXT;
    student_school_id UUID;
    student_school_name TEXT;
    is_school_experience BOOLEAN := FALSE;
BEGIN
    -- Handle both INSERT and UPDATE events for pending experiences
    IF (TG_OP = 'INSERT' AND NEW.approval_status = 'pending') OR 
       (TG_OP = 'UPDATE' AND OLD.approval_status != 'pending' AND NEW.approval_status = 'pending') THEN
        
        -- Get student details including school info from organizations table
        SELECT s.name, s.school_id, o.name 
        INTO student_name, student_school_id, student_school_name
        FROM students s 
        LEFT JOIN organizations o ON s.school_id = o.id
        WHERE s.user_id = NEW.student_id;
        
        -- Check if the experience is at the student's own school
        IF student_school_name IS NOT NULL AND NEW.organization IS NOT NULL THEN
            is_school_experience := LOWER(TRIM(NEW.organization)) = LOWER(TRIM(student_school_name));
        END IF;
        
        -- Only notify school admin if student belongs to a school and experience is at their school
        IF student_school_id IS NOT NULL AND is_school_experience THEN
            SELECT se.user_id INTO admin_user_id
            FROM school_educators se
            WHERE se.school_id = student_school_id 
            AND se.role = 'school_admin'
            LIMIT 1;
            
            IF admin_user_id IS NOT NULL THEN
                IF NOT EXISTS (
                    SELECT 1 FROM notifications 
                    WHERE recipient_id = admin_user_id 
                    AND type = 'experience_submitted'
                    AND message LIKE '%' || COALESCE(NEW.role, 'Experience') || '%'
                    AND message LIKE '%' || COALESCE(NEW.organization, 'Organization') || '%'
                    AND created_at > NOW() - INTERVAL '1 hour'
                ) THEN
                    INSERT INTO notifications (recipient_id, type, title, message, read)
                    VALUES (
                        admin_user_id,
                        'experience_submitted',
                        'New School Experience Submitted',
                        COALESCE(student_name, 'Student') || ' submitted "' || 
                        COALESCE(NEW.role, 'Experience') || ' at ' || 
                        COALESCE(NEW.organization, 'Organization') || '" for approval',
                        false
                    );
                END IF;
            END IF;
        ELSE
            -- For external experiences, notify super admin
            IF student_school_id IS NOT NULL AND NOT is_school_experience THEN
                SELECT u.id INTO admin_user_id
                FROM users u
                WHERE u.role = 'super_admin'
                LIMIT 1;
                
                IF admin_user_id IS NOT NULL THEN
                    IF NOT EXISTS (
                        SELECT 1 FROM notifications 
                        WHERE recipient_id = admin_user_id 
                        AND type = 'experience_submitted'
                        AND message LIKE '%' || COALESCE(NEW.role, 'Experience') || '%'
                        AND message LIKE '%' || COALESCE(NEW.organization, 'Organization') || '%'
                        AND created_at > NOW() - INTERVAL '1 hour'
                    ) THEN
                        INSERT INTO notifications (recipient_id, type, title, message, read)
                        VALUES (
                            admin_user_id,
                            'experience_submitted',
                            'External Experience Submitted',
                            COALESCE(student_name, 'Student') || ' from ' || 
                            COALESCE(student_school_name, 'School') || ' submitted "' || 
                            COALESCE(NEW.role, 'Experience') || ' at ' || 
                            COALESCE(NEW.organization, 'Organization') || '" for approval',
                            false
                        );
                    END IF;
                END IF;
            END IF;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_admin_experience_submission"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_admin_on_experience_submission"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_record RECORD;
    admin_user_id UUID;
    notification_type TEXT;
    notification_title TEXT;
    notification_message TEXT;
    organization_name TEXT;
BEGIN
    -- Only trigger for new records with pending status
    IF TG_OP = 'INSERT' AND NEW.approval_status = 'pending' THEN
        -- Get student info
        SELECT s.school_id, s.university_college_id, s.name, s.user_id
        INTO student_record
        FROM students s
        WHERE s.id = NEW.student_id;
        
        IF student_record IS NOT NULL THEN
            -- Set notification details for experience
            notification_type := 'experience_submitted';
            notification_title := 'New Experience Submitted';
            notification_message := COALESCE(student_record.name, 'Student') || ' submitted "' || 
                                  COALESCE(NEW.role, NEW.title, 'Untitled Experience') || '" for approval';
            organization_name := NEW.organization;
            
            RAISE NOTICE 'Processing NEW experience submission: student=%, org=%, approval_authority=%', 
                        student_record.name, organization_name, NEW.approval_authority;
            
            -- Route notification based on approval_authority column
            CASE NEW.approval_authority
                WHEN 'college_admin' THEN
                    -- Find college admin for this student
                    SELECT o.admin_id INTO admin_user_id
                    FROM organizations o
                    WHERE o.id = student_record.university_college_id 
                    AND o.organization_type = 'college'
                    AND o.admin_id IS NOT NULL
                    LIMIT 1;
                    
                    IF admin_user_id IS NOT NULL THEN
                        INSERT INTO notifications (recipient_id, type, title, message, read, created_at)
                        VALUES (
                            admin_user_id,
                            notification_type,
                            notification_title,
                            notification_message || ' (College Experience)',
                            false,
                            NOW()
                        );
                        
                        RAISE NOTICE 'âœ… Created notification for college admin % about NEW experience submission by %', 
                                    admin_user_id, student_record.name;
                    ELSE
                        RAISE NOTICE 'âŒ No college admin found for student % (college_id: %)', 
                                    student_record.name, student_record.university_college_id;
                    END IF;
                    
                WHEN 'school_admin' THEN
                    -- Find school admin for this student
                    SELECT o.admin_id INTO admin_user_id
                    FROM organizations o
                    WHERE o.id = student_record.school_id 
                    AND o.organization_type = 'school'
                    AND o.admin_id IS NOT NULL
                    LIMIT 1;
                    
                    IF admin_user_id IS NOT NULL THEN
                        INSERT INTO notifications (recipient_id, type, title, message, read, created_at)
                        VALUES (
                            admin_user_id,
                            notification_type,
                            notification_title,
                            notification_message || ' (School Experience)',
                            false,
                            NOW()
                        );
                        
                        RAISE NOTICE 'âœ… Created notification for school admin % about NEW experience submission by %', 
                                    admin_user_id, student_record.name;
                    ELSE
                        RAISE NOTICE 'âŒ No school admin found for student % (school_id: %)', 
                                    student_record.name, student_record.school_id;
                    END IF;
                    
                WHEN 'rareminds_admin' THEN
                    -- Find RareMinds admin
                    SELECT u.id INTO admin_user_id
                    FROM users u
                    WHERE (u.role = 'admin' OR u.role = 'rareminds_admin' OR u.role = 'super_admin' OR LOWER(u.email) LIKE '%rareminds%')
                    AND u.is_active = true
                    ORDER BY 
                        CASE 
                            WHEN u.role = 'rareminds_admin' THEN 1
                            WHEN u.role = 'admin' THEN 2
                            WHEN u.role = 'super_admin' THEN 3
                            WHEN LOWER(u.email) LIKE '%rareminds%' THEN 4
                            ELSE 5
                        END,
                        u.created_at ASC
                    LIMIT 1;
                    
                    IF admin_user_id IS NOT NULL THEN
                        INSERT INTO notifications (recipient_id, type, title, message, read, created_at)
                        VALUES (
                            admin_user_id,
                            notification_type,
                            notification_title,
                            notification_message || ' (RareMinds Admin Review)',
                            false,
                            NOW()
                        );
                        
                        RAISE NOTICE 'âœ… Created notification for RareMinds admin % about NEW experience submission by %', 
                                    admin_user_id, student_record.name;
                    ELSE
                        RAISE NOTICE 'âŒ No RareMinds admin found for NEW experience submission by %', 
                                    student_record.name;
                    END IF;
                    
                ELSE
                    RAISE NOTICE 'âŒ Unknown approval_authority: % for NEW experience by %', 
                                NEW.approval_authority, student_record.name;
            END CASE;
            
        ELSE
            RAISE NOTICE 'âŒ Student record not found for student_id: %', NEW.student_id;
        END IF;
    ELSE
        RAISE NOTICE 'Trigger condition not met: TG_OP=%, approval_status=%', TG_OP, NEW.approval_status;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_admin_on_experience_submission"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_admin_on_experience_submission_final"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_record RECORD;
    admin_user_id UUID;
    notification_type TEXT;
    notification_title TEXT;
    notification_message TEXT;
    organization_name TEXT;
BEGIN
    -- Only trigger for records with pending status (both INSERT and UPDATE)
    IF NEW.approval_status = 'pending' THEN
        -- Get student info
        SELECT s.school_id, s.university_college_id, s.name, s.user_id
        INTO student_record
        FROM students s
        WHERE s.id = NEW.student_id;
        
        IF student_record IS NOT NULL THEN
            -- Set notification details for experience
            notification_type := 'experience_submitted';
            notification_title := 'New Experience Submitted';
            notification_message := COALESCE(student_record.name, 'Student') || ' submitted "' || 
                                  COALESCE(NEW.role, 'Untitled Experience') || '" for approval';
            organization_name := NEW.organization;
            
            RAISE NOTICE 'ðŸ”” Creating notification: student=%, org=%, approval_authority=%', 
                        student_record.name, organization_name, NEW.approval_authority;
            
            -- Route notification based on approval_authority column
            CASE NEW.approval_authority
                WHEN 'college_admin' THEN
                    -- Find college admin for this student
                    SELECT o.admin_id INTO admin_user_id
                    FROM organizations o
                    WHERE o.id = student_record.university_college_id 
                    AND o.organization_type = 'college'
                    AND o.admin_id IS NOT NULL
                    LIMIT 1;
                    
                    IF admin_user_id IS NOT NULL THEN
                        INSERT INTO notifications (recipient_id, type, title, message, read, created_at)
                        VALUES (
                            admin_user_id,
                            notification_type,
                            notification_title,
                            notification_message || ' (College Experience)',
                            false,
                            NOW()
                        );
                        
                        RAISE NOTICE 'âœ… Notification sent to college admin % for experience by %', 
                                    admin_user_id, student_record.name;
                    ELSE
                        RAISE NOTICE 'âŒ No college admin found for student % (college_id: %)', 
                                    student_record.name, student_record.university_college_id;
                    END IF;
                    
                WHEN 'school_admin' THEN
                    -- Find school admin for this student
                    SELECT o.admin_id INTO admin_user_id
                    FROM organizations o
                    WHERE o.id = student_record.school_id 
                    AND o.organization_type = 'school'
                    AND o.admin_id IS NOT NULL
                    LIMIT 1;
                    
                    IF admin_user_id IS NOT NULL THEN
                        INSERT INTO notifications (recipient_id, type, title, message, read, created_at)
                        VALUES (
                            admin_user_id,
                            notification_type,
                            notification_title,
                            notification_message || ' (School Experience)',
                            false,
                            NOW()
                        );
                        
                        RAISE NOTICE 'âœ… Notification sent to school admin % for experience by %', 
                                    admin_user_id, student_record.name;
                    ELSE
                        RAISE NOTICE 'âŒ No school admin found for student % (school_id: %)', 
                                    student_record.name, student_record.school_id;
                    END IF;
                    
                WHEN 'rareminds_admin' THEN
                    -- Find RareMinds admin
                    SELECT u.id INTO admin_user_id
                    FROM users u
                    WHERE (u.role = 'admin' OR u.role = 'rareminds_admin' OR u.role = 'super_admin' OR LOWER(u.email) LIKE '%rareminds%')
                    AND u.is_active = true
                    ORDER BY 
                        CASE 
                            WHEN u.role = 'rareminds_admin' THEN 1
                            WHEN u.role = 'admin' THEN 2
                            WHEN u.role = 'super_admin' THEN 3
                            WHEN LOWER(u.email) LIKE '%rareminds%' THEN 4
                            ELSE 5
                        END,
                        u.created_at ASC
                    LIMIT 1;
                    
                    IF admin_user_id IS NOT NULL THEN
                        INSERT INTO notifications (recipient_id, type, title, message, read, created_at)
                        VALUES (
                            admin_user_id,
                            notification_type,
                            notification_title,
                            notification_message || ' (RareMinds Admin Review)',
                            false,
                            NOW()
                        );
                        
                        RAISE NOTICE 'âœ… Notification sent to RareMinds admin % for experience by %', 
                                    admin_user_id, student_record.name;
                    ELSE
                        RAISE NOTICE 'âŒ No RareMinds admin found for experience by %', 
                                    student_record.name;
                    END IF;
                    
                ELSE
                    RAISE NOTICE 'âŒ Unknown approval_authority: % for experience by %', 
                                NEW.approval_authority, student_record.name;
            END CASE;
            
        ELSE
            RAISE NOTICE 'âŒ Student record not found for student_id: %', NEW.student_id;
        END IF;
    ELSE
        RAISE NOTICE 'â­ï¸  Skipping notification - approval_status is not pending: %', NEW.approval_status;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_admin_on_experience_submission_final"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_admin_on_submission"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    student_record RECORD;
    v_admin_id UUID;
    submission_name TEXT;
    notification_message TEXT;
BEGIN
    -- 1ï¸âƒ£ Get student info
    SELECT id, name, student_type, college_id, school_id
    INTO student_record
    FROM students
    WHERE id = NEW.student_id;

    IF NOT FOUND THEN
        RAISE NOTICE 'âŒ Student not found: %', NEW.student_id;
        RETURN NEW;
    END IF;

    -- 2ï¸âƒ£ Resolve admin ID
    v_admin_id := NULL;

    IF student_record.student_type = 'college' THEN
        SELECT o.admin_id
        INTO v_admin_id
        FROM organizations o
        WHERE o.id = student_record.college_id
          AND o.admin_id IS NOT NULL
        LIMIT 1;

    ELSIF student_record.student_type IN ('school', 'school-student') THEN
        SELECT o.admin_id
        INTO v_admin_id
        FROM organizations o
        WHERE o.id = student_record.school_id
          AND o.admin_id IS NOT NULL
        LIMIT 1;
    END IF;

    IF v_admin_id IS NULL THEN
        RAISE NOTICE 'âŒ No admin found for student %', student_record.name;
        RETURN NEW;
    END IF;

    -- 3ï¸âƒ£ Submission title
    IF TG_TABLE_NAME = 'experience' THEN
        submission_name := COALESCE(NEW.role, 'Unknown Role');
    ELSIF TG_TABLE_NAME = 'trainings' THEN
        submission_name := COALESCE(NEW.title, 'Unknown Training');
    ELSIF TG_TABLE_NAME = 'projects' THEN
        submission_name := COALESCE(NEW.title, 'Unknown Project');
    ELSE
        submission_name := 'Unknown Submission';
    END IF;

    -- 4ï¸âƒ£ Notification text
    notification_message := format(
        'Student %s submitted %s "%s"',
        COALESCE(student_record.name, 'Unknown Student'),
        TG_TABLE_NAME,
        submission_name
    );

    INSERT INTO notifications (
        id,
        recipient_id,
        type,
        title,
        message,
        read,
        created_at
    ) VALUES (
        gen_random_uuid(),
        v_admin_id,
        TG_TABLE_NAME || '_approval',
        'New ' || TG_TABLE_NAME || ' Submission',
        notification_message,
        FALSE,
        NOW()
    );

    RAISE NOTICE 'âœ… Notification created for admin %', v_admin_id;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_admin_on_submission"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_admin_training_submission"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    admin_user_id UUID;
    student_name TEXT;
    student_school_id UUID;
BEGIN
    -- Only create notification for new trainings with pending status
    IF TG_OP = 'INSERT' AND NEW.approval_status = 'pending' THEN
        -- Get student details
        SELECT s.name, s.school_id INTO student_name, student_school_id
        FROM students s 
        WHERE s.user_id = NEW.student_id;
        
        -- If student has a school, find the school admin
        IF student_school_id IS NOT NULL THEN
            SELECT se.user_id INTO admin_user_id
            FROM school_educators se
            WHERE se.school_id = student_school_id 
            AND se.role = 'admin'
            LIMIT 1;
            
            -- Create notification for school admin
            IF admin_user_id IS NOT NULL THEN
                INSERT INTO notifications (recipient_id, type, title, message, read)
                VALUES (
                    admin_user_id,
                    'training_submitted',
                    'New Training Submitted',
                    COALESCE(student_name, 'Student') || ' submitted "' || 
                    COALESCE(NEW.title, 'Training') || '" for approval',
                    false
                );
            END IF;
        ELSE
            -- If no school admin found, notify super admin
            SELECT u.id INTO admin_user_id
            FROM users u
            WHERE u.role = 'super_admin'
            LIMIT 1;
            
            IF admin_user_id IS NOT NULL THEN
                INSERT INTO notifications (recipient_id, type, title, message, read)
                VALUES (
                    admin_user_id,
                    'training_submitted',
                    'New Training Submitted',
                    COALESCE(student_name, 'Student') || ' submitted "' || 
                    COALESCE(NEW.title, 'Training') || '" for approval',
                    false
                );
            END IF;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_admin_training_submission"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_experience_approval"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_info RECORD;
    admin_id UUID;
    notification_message TEXT;
BEGIN
    -- CORRECTED GUARD LOGIC:
    -- For INSERT: Always create notification (don't check approval_status)
    -- For UPDATE: Only notify if status changed TO 'pending'
    IF TG_OP = 'UPDATE' THEN
        -- Only notify on UPDATE if status changed TO pending
        IF NEW.approval_status != 'pending' OR OLD.approval_status = 'pending' THEN
            RETURN NEW;
        END IF;
    END IF;
    -- For INSERT: No guard condition - always proceed

    -- Get student information
    SELECT 
        s.id,
        s.name,
        s.student_type,
        s.university_college_id,
        s.school_id
    INTO student_info
    FROM students s
    WHERE s.id = NEW.student_id;

    IF NOT FOUND THEN
        RETURN NEW;
    END IF;

    -- Find admin based on student type
    admin_id := NULL;

    IF student_info.student_type = 'college' THEN
        SELECT org.admin_id INTO admin_id
        FROM organizations org
        WHERE org.id = student_info.university_college_id
        AND org.admin_id IS NOT NULL
        LIMIT 1;
        
    ELSIF student_info.student_type IN ('school', 'school-student') THEN
        SELECT org.admin_id INTO admin_id
        FROM organizations org
        WHERE org.id = student_info.school_id
        AND org.admin_id IS NOT NULL
        LIMIT 1;
    END IF;

    -- Create notification if admin found
    IF admin_id IS NOT NULL THEN
        notification_message := format(
            'Student %s has submitted a new experience "%s" at "%s" that requires your approval.',
            COALESCE(student_info.name, 'Unknown Student'),
            COALESCE(NEW.role, 'Unknown Role'),
            COALESCE(NEW.organization, 'Unknown Organization')
        );

        INSERT INTO notifications (
            id,
            recipient_id,
            type,
            title,
            message,
            read,
            created_at
        ) VALUES (
            gen_random_uuid(),
            admin_id,
            'experience_approval',
            'New Experience Approval Request',
            notification_message,
            FALSE,
            NOW()
        );
    END IF;

    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        -- Don't fail the experience save if notification fails
        RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_experience_approval"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_experience_student"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_record RECORD;
    notification_message TEXT;
BEGIN
    -- Only run if approval_status changed from pending to approved/rejected
    IF OLD.approval_status = 'pending' AND NEW.approval_status IN ('approved', 'rejected') THEN

        -- Get student info
        SELECT id, name INTO student_record
        FROM students
        WHERE id = NEW.student_id;

        IF NOT FOUND THEN
            RAISE NOTICE 'Student not found for experience %', NEW.id;
            RETURN NEW;
        END IF;

        -- Prepare notification message
        notification_message := format(
            'Your experience "%s" at "%s" was %s by the admin.',
            COALESCE(NEW.role, 'Unknown Role'),
            COALESCE(NEW.organization, 'Unknown Organization'),
            NEW.approval_status
        );

        -- Insert notification
        BEGIN
            INSERT INTO notifications (
                id,
                recipient_id,
                type,
                title,
                message,
                read,
                created_at
            ) VALUES (
                gen_random_uuid(),
                student_record.id,
                'experience_status_update',
                'Experience Status Update',
                notification_message,
                FALSE,
                NOW()
            );
            RAISE NOTICE 'Notification sent to student % for experience %', student_record.id, NEW.id;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE NOTICE 'Failed to notify student %: %', student_record.id, SQLERRM;
        END;

    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_experience_student"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_experience_submission"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_record record;
    notification_message text;
    recipient_school_id uuid;
BEGIN
    -- Get student and school details
    SELECT s.*, o.name as school_name, o.id as school_id
    INTO student_record
    FROM public.students s
    LEFT JOIN public.organizations o ON s.school_id = o.id
    WHERE s.id = NEW.student_id;
    
    -- Create notification message
    notification_message := format(
        'New experience submitted by %s: "%s" at %s',
        COALESCE(student_record.name, 'Student'),
        COALESCE(NEW.role, 'Position'),
        COALESCE(NEW.organization, 'Unknown Organization')
    );
    
    -- Determine recipient school ID
    IF NEW.approval_authority IN ('school_admin', 'college_admin') THEN
        recipient_school_id := student_record.school_id;
    ELSE
        recipient_school_id := NULL; -- For rareminds_admin
    END IF;
    
    -- Insert notification
    INSERT INTO public.training_notifications (
        experience_id,
        recipient_type,
        school_id,
        message
    ) VALUES (
        NEW.id,
        NEW.approval_authority,
        recipient_school_id,
        notification_message
    );
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_experience_submission"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_project_approval"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_record RECORD;
    notification_message TEXT;
    target_school_id UUID;
    target_college_id UUID;
BEGIN
    -- Only create notifications for pending status
    IF NEW.approval_status != 'pending' THEN
        RETURN NEW;
    END IF;

    -- Get student and school/college information from organizations table
    SELECT 
        s.id as student_id,
        s.student_type,
        s.school_id,
        s.college_id,
        s.university_college_id,
        COALESCE(s.name, p.name) as student_name,
        sch.id as school_uuid,
        col.id as college_uuid
    INTO student_record
    FROM students s
    LEFT JOIN students p ON s.id = p.id  -- For profile name fallback
    LEFT JOIN organizations sch ON s.school_id = sch.id AND sch.organization_type = 'school'
    LEFT JOIN organizations col ON (s.college_id = col.id OR s.university_college_id = col.id) AND col.organization_type = 'college'
    WHERE s.id = NEW.student_id;

    IF NOT FOUND THEN
        RETURN NEW;
    END IF;

    -- Prepare notification message
    notification_message := format(
        'New project "%s" submitted by %s for approval (Organization: %s)',
        NEW.title,
        COALESCE(student_record.student_name, 'Student'),
        COALESCE(NEW.organization, 'Not specified')
    );

    -- Determine target school/college based on approval authority
    IF NEW.approval_authority = 'school_admin' THEN
        target_school_id := student_record.school_uuid;
        target_college_id := NULL;
    ELSIF NEW.approval_authority = 'college_admin' THEN
        target_school_id := NULL;
        target_college_id := student_record.college_uuid;
    ELSE
        -- For rareminds_admin, we don't create notifications in this table
        RETURN NEW;
    END IF;

    -- Insert notification
    INSERT INTO project_notifications (
        project_id,
        recipient_type,
        school_id,
        college_id,
        message,
        is_read,
        created_at
    ) VALUES (
        NEW.id,
        NEW.approval_authority,
        target_school_id,
        target_college_id,
        notification_message,
        FALSE,
        NOW()
    );

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_project_approval"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_project_approval_unified"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_record RECORD;
    notification_message TEXT;
    target_school_id UUID;
    target_college_id UUID;
BEGIN
    -- Only create notifications for pending status
    IF NEW.approval_status != 'pending' THEN
        RETURN NEW;
    END IF;

    -- Get student and school/college information from organizations table
    SELECT 
        s.id as student_id,
        s.student_type,
        s.school_id,
        s.college_id,
        s.university_college_id,
        COALESCE(s.name, sp.name) as student_name,
        sch.id as school_uuid,
        col.id as college_uuid
    INTO student_record
    FROM students s
    LEFT JOIN students sp ON s.id = sp.id  -- For profile name fallback
    LEFT JOIN organizations sch ON s.school_id = sch.id AND sch.organization_type = 'school'
    LEFT JOIN organizations col ON (s.college_id = col.id OR s.university_college_id = col.id) AND col.organization_type = 'college'
    WHERE s.id = NEW.student_id;

    IF NOT FOUND THEN
        RETURN NEW;
    END IF;

    -- Prepare notification message
    notification_message := format(
        'New project "%s" submitted by %s for approval (Organization: %s)',
        NEW.title,
        COALESCE(student_record.student_name, 'Student'),
        COALESCE(NEW.organization, 'Not specified')
    );

    -- Determine target school/college based on approval authority
    IF NEW.approval_authority = 'school_admin' THEN
        target_school_id := student_record.school_uuid;
        target_college_id := NULL;
    ELSIF NEW.approval_authority = 'college_admin' THEN
        target_school_id := NULL;
        target_college_id := student_record.college_uuid;
    ELSE
        -- For rareminds_admin, we don't create notifications in this table
        RETURN NEW;
    END IF;

    -- Insert notification into training_notifications table (unified)
    INSERT INTO training_notifications (
        project_id,
        recipient_type,
        school_id,
        college_id,
        message,
        is_read,
        created_at
    ) VALUES (
        NEW.id,
        NEW.approval_authority,
        target_school_id,
        target_college_id,
        notification_message,
        FALSE,
        NOW()
    );

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_project_approval_unified"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_student_on_approval"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    submission_name TEXT;
    human_type TEXT;
    notification_message TEXT;
BEGIN
    -- Only fire if approval_status changed
    IF OLD.approval_status = NEW.approval_status THEN
        RETURN NEW;
    END IF;

    -- ðŸ”’ ONLY notify on final decision
    IF NEW.approval_status NOT IN ('approved', 'rejected') THEN
        RETURN NEW;
    END IF;

    -- Determine type and name
    IF TG_TABLE_NAME = 'experience' THEN
        submission_name := COALESCE(NEW.role, 'Unknown Role');
        human_type := 'experience';
    ELSIF TG_TABLE_NAME = 'trainings' THEN
        submission_name := COALESCE(NEW.title, 'Unknown Training');
        human_type := 'training';
    ELSIF TG_TABLE_NAME = 'projects' THEN
        submission_name := COALESCE(NEW.title, 'Unknown Project');
        human_type := 'project';
    ELSE
        submission_name := 'submission';
        human_type := 'submission';
    END IF;

    notification_message := format(
        'Your %s "%s" has been %s by the admin',
        human_type,
        submission_name,
        NEW.approval_status
    );

    INSERT INTO notifications (
        id,
        recipient_id,
        type,
        title,
        message,
        read,
        created_at
    ) VALUES (
        gen_random_uuid(),
        NEW.student_id,
        human_type || '_student',
        INITCAP(human_type) || ' ' || INITCAP(NEW.approval_status),
        notification_message,
        FALSE,
        NOW()
    );

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_student_on_approval"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_student_on_approval_status_change"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_record RECORD;
    notification_type TEXT;
    notification_title TEXT;
    notification_message TEXT;
BEGIN
    -- Only trigger when approval_status changes from pending to approved/rejected
    IF TG_OP = 'UPDATE' AND OLD.approval_status = 'pending' AND NEW.approval_status != 'pending' THEN
        -- Get student info
        SELECT s.name, s.user_id
        INTO student_record
        FROM students s
        WHERE s.id = NEW.student_id;
        
        IF student_record IS NOT NULL AND student_record.user_id IS NOT NULL THEN
            -- Determine notification details based on table and status
            CASE NEW.approval_status
                WHEN 'approved' THEN
                    CASE TG_TABLE_NAME
                        WHEN 'experience' THEN
                            notification_type := 'experience_approved';
                            notification_title := 'Experience Approved';
                            notification_message := 'Your experience "' || COALESCE(NEW.role, NEW.title, 'Untitled Experience') || '" has been approved';
                        ELSE
                            notification_type := 'submission_approved';
                            notification_title := 'Submission Approved';
                            notification_message := 'Your submission has been approved';
                    END CASE;
                WHEN 'rejected' THEN
                    CASE TG_TABLE_NAME
                        WHEN 'experience' THEN
                            notification_type := 'experience_rejected';
                            notification_title := 'Experience Rejected';
                            notification_message := 'Your experience "' || COALESCE(NEW.role, NEW.title, 'Untitled Experience') || '" was rejected';
                        ELSE
                            notification_type := 'submission_rejected';
                            notification_title := 'Submission Rejected';
                            notification_message := 'Your submission was rejected';
                    END CASE;
                ELSE
                    RETURN NEW; -- Don't create notification for other statuses
            END CASE;
            
            -- Create notification for student
            INSERT INTO notifications (recipient_id, type, title, message, read, created_at)
            VALUES (
                student_record.user_id,
                notification_type,
                notification_title,
                notification_message,
                false,
                NOW()
            );
            
            RAISE NOTICE 'Created % notification for student % about % %', 
                        NEW.approval_status, student_record.user_id, TG_TABLE_NAME, COALESCE(NEW.title, NEW.role, 'item');
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_student_on_approval_status_change"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."notify_student_on_approval_status_change"() IS 'Automatically creates notifications for students when their submissions are approved/rejected (uses students.user_id which references users.id)';



CREATE OR REPLACE FUNCTION "public"."notify_students_new_opportunity"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_notification_title TEXT;
  v_notification_message TEXT;
  v_is_internship BOOLEAN;
BEGIN
  -- Only process if the opportunity is active
  IF NEW.is_active IS NOT TRUE THEN
    RETURN NEW;
  END IF;

  -- Check if this is an internship opportunity
  v_is_internship := LOWER(COALESCE(NEW.employment_type, '')) = 'internship';

  -- Build notification content
  v_notification_title := NEW.job_title || ' at ' || NEW.company_name;
  v_notification_message := NEW.title || ' - ' || NEW.location || 
    CASE 
      WHEN NEW.salary_range_min IS NOT NULL AND NEW.salary_range_max IS NOT NULL 
        THEN ' | â‚¹' || NEW.salary_range_min || ' - â‚¹' || NEW.salary_range_max
      ELSE ''
    END;

  -- Create notifications for matching students based on their type
  -- School students: only receive notifications for internships
  -- College/University students: receive notifications for all opportunities
  INSERT INTO notifications (recipient_id, type, title, message, read, created_at)
  SELECT DISTINCT
    s.user_id,
    'new_opportunity'::text,
    v_notification_title,
    v_notification_message,
    false,
    NOW()
  FROM students s
  INNER JOIN users u ON s.user_id = u.id
  WHERE u.role IN ('school_student', 'college_student')
    AND s.id IS NOT NULL
    AND (
      -- College/University students get all opportunities
      (u.role = 'college_student')
      OR
      -- School students only get internship opportunities
      (u.role = 'school_student' AND v_is_internship)
    )
  ON CONFLICT DO NOTHING;

  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  RAISE WARNING 'Error in notify_students_new_opportunity: %', SQLERRM;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_students_new_opportunity"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_students_opportunity_update"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_notification_title TEXT;
  v_notification_message TEXT;
BEGIN
  -- Check if opportunity became inactive
  IF OLD.is_active IS DISTINCT FROM NEW.is_active THEN
    IF NEW.is_active IS FALSE THEN
      v_notification_title := 'Opportunity Closed: ' || NEW.job_title;
      v_notification_message := 'The position at ' || NEW.company_name || ' is no longer available.';
      
      -- Create notifications for students who applied
      INSERT INTO notifications (recipient_id, type, title, message, read, created_at)
      SELECT DISTINCT
        aj.student_id,
        'opportunity_closed'::text,
        v_notification_title,
        v_notification_message,
        false,
        NOW()
      FROM applied_jobs aj
      WHERE aj.opportunity_id = NEW.id
        AND aj.student_id IS NOT NULL
      ON CONFLICT DO NOTHING;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_students_opportunity_update"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_training_admin"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    admin_id UUID;
    notification_message TEXT;
    human_type TEXT := 'training';
BEGIN
    -- 1ï¸âƒ£ Determine which admin to notify
    admin_id := NULL;

    IF NEW.approval_authority = 'college_admin' THEN
        SELECT org.admin_id
        INTO admin_id
        FROM organizations org
        JOIN students s ON s.college_id = org.id
        WHERE s.id = NEW.student_id
        LIMIT 1;

    ELSIF NEW.approval_authority = 'school_admin' THEN
        SELECT org.admin_id
        INTO admin_id
        FROM organizations org
        JOIN students s ON s.school_id = org.id
        WHERE s.id = NEW.student_id
        LIMIT 1;

    ELSIF NEW.approval_authority = 'rareminds_admin' THEN
        admin_id := 'cc6359fc-ed1f-4807-8185-03c997d576c6';

    ELSE
        RAISE NOTICE 'âš ï¸ Unknown approval_authority: %', NEW.approval_authority;
        RETURN NEW;
    END IF;

    -- 2ï¸âƒ£ Only notify if admin exists
    IF admin_id IS NOT NULL THEN

        -- 3ï¸âƒ£ Notify only on insert or when approval_status changes to pending
        IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.approval_status = 'pending' AND OLD.approval_status IS DISTINCT FROM 'pending') THEN

            notification_message := format(
                'Student submitted training "%s" at "%s"',
                COALESCE(NEW.title, 'Unknown Training'),
                COALESCE(NEW.organization, 'Unknown Organization')
            );

            INSERT INTO notifications (
                id,
                recipient_id,
                type,
                title,
                message,
                read,
                created_at
            ) VALUES (
                gen_random_uuid(),
                admin_id,
                human_type || '_approval',
                'New Training Submission',
                notification_message,
                FALSE,
                NOW()
            );

            RAISE NOTICE 'âœ… Admin notification created for %', admin_id;

        END IF;
    ELSE
        RAISE NOTICE 'âš ï¸ No admin found for student %', NEW.student_id;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_training_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."notify_training_submission"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_record RECORD;
    notification_message TEXT;
BEGIN
    -- Get student information from students table only
    SELECT s.*
    INTO student_record
    FROM students s
    WHERE s.id = NEW.student_id;
    
    IF NOT FOUND THEN
        RETURN NEW;
    END IF;
    
    -- Create notification message
    notification_message := format(
        'New training "%s" by %s (%s) requires approval',
        NEW.title,
        COALESCE(student_record.name, 'Unknown Student'),
        COALESCE(student_record.email, 'No email')
    );
    
    -- Insert into training_notifications table
    INSERT INTO training_notifications (
        training_id,
        recipient_type,
        school_id,
        message,
        is_read,
        created_at
    ) VALUES (
        NEW.id,
        NEW.approval_authority,
        student_record.school_id,
        notification_message,
        false,
        NOW()
    );
    
    RETURN NEW;
EXCEPTION WHEN OTHERS THEN
    -- If notification fails, don't block the training insertion
    RAISE WARNING 'Failed to create training notification: %', SQLERRM;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."notify_training_submission"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."on_timetable_slot_change"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  PERFORM calculate_teacher_workload(
    COALESCE(NEW.educator_id, OLD.educator_id),
    COALESCE(NEW.timetable_id, OLD.timetable_id)
  );
  
  PERFORM detect_timetable_conflicts(COALESCE(NEW.timetable_id, OLD.timetable_id));
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."on_timetable_slot_change"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."parse_experience_years"("experience_text" "text") RETURNS integer
    LANGUAGE "plpgsql" IMMUTABLE
    SET "search_path" TO ''
    AS $_$
DECLARE
  years INT;
  exp_lower TEXT;
BEGIN
  IF experience_text IS NULL OR experience_text = '' THEN
    RETURN 0;
  END IF;
  
  exp_lower := LOWER(experience_text);
  
  -- Handle "Fresher" or "No experience"
  IF exp_lower ~ '(fresher|no\s*experience|entry|beginner|0\s*year|none)' THEN
    RETURN 0;
  END IF;
  
  -- Handle "15 years+" or "15+ years"
  IF exp_lower ~ '(\d+)\s*\+?\s*year' THEN
    SELECT (regexp_matches(exp_lower, '(\d+)'))[1]::INT INTO years;
    RETURN COALESCE(years, 0);
  END IF;
  
  -- Handle "1-3 years" - take the minimum
  IF exp_lower ~ '(\d+)\s*[-â€“]\s*(\d+)' THEN
    SELECT (regexp_matches(exp_lower, '(\d+)'))[1]::INT INTO years;
    RETURN COALESCE(years, 0);
  END IF;
  
  -- Handle just a number like "2"
  IF exp_lower ~ '^\d+$' THEN
    RETURN exp_lower::INT;
  END IF;
  
  RETURN 0;
END;
$_$;


ALTER FUNCTION "public"."parse_experience_years"("experience_text" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."parse_experience_years"("experience_text" "text") IS 'Parses experience requirement text and returns the minimum years required.
Examples: "15 years+" -> 15, "0-1 year" -> 0, "Fresher" -> 0, "1-3 years" -> 1';



CREATE OR REPLACE FUNCTION "public"."populate_chapter_name"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Auto-populate chapter_name when chapter_id is set
  IF NEW.chapter_id IS NOT NULL THEN
    SELECT name INTO NEW.chapter_name
    FROM curriculum_chapters
    WHERE id = NEW.chapter_id;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."populate_chapter_name"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."populate_result_columns_from_gemini"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Only populate if gemini_results exists and individual columns are null
  IF NEW.gemini_results IS NOT NULL THEN
    -- RIASEC
    IF NEW.riasec_scores IS NULL AND NEW.gemini_results->'riasec'->'scores' IS NOT NULL THEN
      NEW.riasec_scores := NEW.gemini_results->'riasec'->'scores';
    END IF;
    IF NEW.riasec_code IS NULL AND NEW.gemini_results->'riasec'->>'code' IS NOT NULL THEN
      NEW.riasec_code := NEW.gemini_results->'riasec'->>'code';
    END IF;
    
    -- Aptitude
    IF NEW.aptitude_scores IS NULL AND NEW.gemini_results->'aptitude'->'scores' IS NOT NULL THEN
      NEW.aptitude_scores := NEW.gemini_results->'aptitude'->'scores';
    END IF;
    IF NEW.aptitude_overall IS NULL AND NEW.gemini_results->'aptitude'->>'overallScore' IS NOT NULL THEN
      NEW.aptitude_overall := (NEW.gemini_results->'aptitude'->>'overallScore')::numeric;
    END IF;
    
    -- BigFive
    IF NEW.bigfive_scores IS NULL AND NEW.gemini_results->'bigFive' IS NOT NULL THEN
      NEW.bigfive_scores := NEW.gemini_results->'bigFive';
    END IF;
    
    -- Work Values
    IF NEW.work_values_scores IS NULL AND NEW.gemini_results->'workValues'->'scores' IS NOT NULL THEN
      NEW.work_values_scores := NEW.gemini_results->'workValues'->'scores';
    END IF;
    
    -- Employability
    IF NEW.employability_scores IS NULL AND NEW.gemini_results->'employability'->'skillScores' IS NOT NULL THEN
      NEW.employability_scores := NEW.gemini_results->'employability'->'skillScores';
    END IF;
    IF NEW.employability_readiness IS NULL AND NEW.gemini_results->'employability'->>'overallReadiness' IS NOT NULL THEN
      NEW.employability_readiness := NEW.gemini_results->'employability'->>'overallReadiness';
    END IF;
    
    -- Knowledge
    IF NEW.knowledge_score IS NULL AND NEW.gemini_results->'knowledge'->>'score' IS NOT NULL THEN
      NEW.knowledge_score := (NEW.gemini_results->'knowledge'->>'score')::numeric;
    END IF;
    IF NEW.knowledge_details IS NULL AND NEW.gemini_results->'knowledge' IS NOT NULL THEN
      NEW.knowledge_details := NEW.gemini_results->'knowledge';
    END IF;
    
    -- Career guidance
    IF NEW.career_fit IS NULL AND NEW.gemini_results->'careerFit' IS NOT NULL THEN
      NEW.career_fit := NEW.gemini_results->'careerFit';
    END IF;
    IF NEW.skill_gap IS NULL AND NEW.gemini_results->'skillGap' IS NOT NULL THEN
      NEW.skill_gap := NEW.gemini_results->'skillGap';
    END IF;
    IF NEW.skill_gap_courses IS NULL AND NEW.gemini_results->'skillGapCourses' IS NOT NULL THEN
      NEW.skill_gap_courses := NEW.gemini_results->'skillGapCourses';
    END IF;
    IF NEW.roadmap IS NULL AND NEW.gemini_results->'roadmap' IS NOT NULL THEN
      NEW.roadmap := NEW.gemini_results->'roadmap';
    END IF;
    IF NEW.profile_snapshot IS NULL AND NEW.gemini_results->'profileSnapshot' IS NOT NULL THEN
      NEW.profile_snapshot := NEW.gemini_results->'profileSnapshot';
    END IF;
    IF NEW.timing_analysis IS NULL AND NEW.gemini_results->'timingAnalysis' IS NOT NULL THEN
      NEW.timing_analysis := NEW.gemini_results->'timingAnalysis';
    END IF;
    IF NEW.final_note IS NULL AND NEW.gemini_results->'finalNote' IS NOT NULL THEN
      NEW.final_note := NEW.gemini_results->'finalNote';
    END IF;
    IF NEW.overall_summary IS NULL AND NEW.gemini_results->>'overallSummary' IS NOT NULL THEN
      NEW.overall_summary := NEW.gemini_results->>'overallSummary';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."populate_result_columns_from_gemini"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_assessment_reminders"() RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    reminder_record RECORD;
    assessment_data RECORD;
    priority_a_courses TEXT[] := '{}';
    priority_b_courses TEXT[] := '{}';
    priority_a_completed BOOLEAN := true;
    priority_b_completed BOOLEAN := true;
    course_id TEXT;
    notifications_sent INTEGER := 0;
    skill_item JSONB;
    course_item JSONB;
    priority_skills JSONB;
    skill_gap_courses JSONB;
    course_recommendations TEXT := '';
BEGIN
    -- Process all scheduled notifications that are due
    FOR reminder_record IN 
        SELECT * FROM notifications 
        WHERE status = 'scheduled' 
        AND type = 'assessment_6month_reminder'
        AND scheduled_for <= NOW()
    LOOP
        -- Get assessment data
        SELECT * INTO assessment_data 
        FROM personal_assessment_results 
        WHERE id = reminder_record.assessment_id;
        
        IF NOT FOUND THEN
            -- Mark as cancelled if assessment not found
            UPDATE notifications 
            SET status = 'cancelled', updated_at = NOW()
            WHERE id = reminder_record.id;
            CONTINUE;
        END IF;

        -- Reset arrays for this assessment
        priority_a_courses := '{}';
        priority_b_courses := '{}';
        priority_a_completed := true;
        priority_b_completed := true;

        -- Collect Priority A courses
        IF assessment_data.skill_gap ? 'priorityA' THEN
            priority_skills := assessment_data.skill_gap->'priorityA';
            
            FOR skill_item IN SELECT * FROM jsonb_array_elements(priority_skills)
            LOOP
                IF assessment_data.skill_gap_courses ? (skill_item->>'skill') THEN
                    skill_gap_courses := assessment_data.skill_gap_courses->(skill_item->>'skill');
                    
                    FOR course_item IN SELECT * FROM jsonb_array_elements(skill_gap_courses)
                    LOOP
                        priority_a_courses := priority_a_courses || (course_item->>'course_id');
                    END LOOP;
                END IF;
            END LOOP;
        END IF;

        -- Check Priority A completion status
        IF array_length(priority_a_courses, 1) > 0 THEN
            FOREACH course_id IN ARRAY priority_a_courses
            LOOP
                -- Check if student has completed this course
                IF NOT EXISTS (
                    SELECT 1 FROM course_progress cp
                    WHERE cp.student_id = reminder_record.recipient_id
                    AND cp.course_id::TEXT = course_id
                    AND cp.completion_percentage = 100
                ) THEN
                    priority_a_completed := false;
                    EXIT; -- Exit loop early if any Priority A course is incomplete
                END IF;
            END LOOP;
        END IF;

        -- If Priority A is not completed, cancel notification (student should focus on Priority A first)
        IF NOT priority_a_completed THEN
            UPDATE notifications 
            SET status = 'cancelled', 
                message = 'Cancelled: Priority A skills still need attention',
                updated_at = NOW()
            WHERE id = reminder_record.id;
            CONTINUE;
        END IF;

        -- Collect Priority B courses
        IF assessment_data.skill_gap ? 'priorityB' THEN
            priority_skills := assessment_data.skill_gap->'priorityB';
            
            FOR skill_item IN SELECT * FROM jsonb_array_elements(priority_skills)
            LOOP
                IF assessment_data.skill_gap_courses ? (skill_item->>'skill') THEN
                    skill_gap_courses := assessment_data.skill_gap_courses->(skill_item->>'skill');
                    
                    FOR course_item IN SELECT * FROM jsonb_array_elements(skill_gap_courses)
                    LOOP
                        priority_b_courses := priority_b_courses || (course_item->>'course_id');
                        
                        -- Build course recommendations message
                        IF course_recommendations != '' THEN
                            course_recommendations := course_recommendations || ', ';
                        END IF;
                        course_recommendations := course_recommendations || (course_item->>'title');
                    END LOOP;
                END IF;
            END LOOP;
        END IF;

        -- Check Priority B completion status
        IF array_length(priority_b_courses, 1) > 0 THEN
            FOREACH course_id IN ARRAY priority_b_courses
            LOOP
                -- Check if student has completed this course
                IF NOT EXISTS (
                    SELECT 1 FROM course_progress cp
                    WHERE cp.student_id = reminder_record.recipient_id
                    AND cp.course_id::TEXT = course_id
                    AND cp.completion_percentage = 100
                ) THEN
                    priority_b_completed := false;
                    EXIT; -- Exit loop early if any Priority B course is incomplete
                END IF;
            END LOOP;
        END IF;

        -- If Priority B is completed, cancel notification (all skills developed)
        IF priority_b_completed THEN
            UPDATE notifications 
            SET status = 'cancelled', 
                message = 'Cancelled: All priority skills have been developed',
                updated_at = NOW()
            WHERE id = reminder_record.id;
            CONTINUE;
        END IF;

        -- Send Priority B course recommendations
        UPDATE notifications 
        SET status = 'sent',
            title = 'Time to Develop Your Priority B Skills!',
            message = FORMAT('Great progress on your Priority A skills! Now it''s time to focus on Priority B skills. We recommend these courses: %s. These will help you advance further in your career journey.',
                COALESCE(course_recommendations, 'your recommended courses')),
            updated_at = NOW()
        WHERE id = reminder_record.id;

        notifications_sent := notifications_sent + 1;
    END LOOP;

    RETURN notifications_sent;
END;
$$;


ALTER FUNCTION "public"."process_assessment_reminders"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."queue_embedding_generation"("p_record_id" "uuid", "p_table_name" "text", "p_operation" "text" DEFAULT 'update'::"text", "p_priority" integer DEFAULT 5) RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_queue_id UUID;
BEGIN
  SELECT id INTO v_queue_id FROM embedding_queue
  WHERE record_id = p_record_id AND table_name = p_table_name AND status = 'pending';
  
  IF v_queue_id IS NOT NULL THEN
    UPDATE embedding_queue SET priority = GREATEST(priority, p_priority), operation = p_operation WHERE id = v_queue_id;
    RETURN v_queue_id;
  END IF;
  
  INSERT INTO embedding_queue (record_id, table_name, operation, priority, status)
  VALUES (p_record_id, p_table_name, p_operation, p_priority, 'pending')
  ON CONFLICT (record_id, table_name, status) DO UPDATE
  SET priority = GREATEST(embedding_queue.priority, EXCLUDED.priority), operation = EXCLUDED.operation
  RETURNING id INTO v_queue_id;
  
  RETURN v_queue_id;
END;
$$;


ALTER FUNCTION "public"."queue_embedding_generation"("p_record_id" "uuid", "p_table_name" "text", "p_operation" "text", "p_priority" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reset_attempt_on_result_delete"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- When a result is deleted, reset the associated attempt to 'in_progress'
  UPDATE personal_assessment_attempts
  SET 
    status = 'in_progress',
    completed_at = NULL,
    updated_at = NOW()
  WHERE id = OLD.attempt_id
    AND status = 'completed'; -- Only reset if it was completed
  
  -- Log the action
  RAISE NOTICE 'Result deleted for attempt %. Attempt reset to in_progress.', OLD.attempt_id;
  
  RETURN OLD;
END;
$$;


ALTER FUNCTION "public"."reset_attempt_on_result_delete"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reset_daily_streak_flags"() RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_updated_count INTEGER;
BEGIN
  -- Reset all flags
  UPDATE student_streaks
  SET streak_completed_today = FALSE
  WHERE streak_completed_today = TRUE;

  GET DIAGNOSTICS v_updated_count = ROW_COUNT;

  -- Check for broken streaks (no activity yesterday)
  UPDATE student_streaks
  SET current_streak = 0
  WHERE last_activity_date < CURRENT_DATE - INTERVAL '1 day'
    AND current_streak > 0;

  RETURN v_updated_count;
END;
$$;


ALTER FUNCTION "public"."reset_daily_streak_flags"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."reset_daily_streak_flags"() IS 'Resets daily completion flags at midnight';



CREATE OR REPLACE FUNCTION "public"."reset_enrollment_progress"("p_student_email" "text", "p_course_id" "uuid") RETURNS TABLE("enrollment_id" "uuid", "student_email" "text", "course_title" "text", "new_status" "text", "training_synced" boolean)
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_enrollment_id UUID;
    v_course_title TEXT;
    v_training_id UUID;
BEGIN
    -- Get enrollment details
    SELECT ce.id, ce.course_title, ce.training_id
    INTO v_enrollment_id, v_course_title, v_training_id
    FROM course_enrollments ce
    WHERE ce.student_email = p_student_email
    AND ce.course_id = p_course_id;
    
    IF v_enrollment_id IS NULL THEN
        RAISE EXCEPTION 'No enrollment found for % in course %', p_student_email, p_course_id;
    END IF;
    
    -- Reset the enrollment (triggers will handle the rest)
    UPDATE course_enrollments
    SET 
        progress = 0,
        status = 'enrolled',
        completed_lessons = ARRAY[]::text[],
        completed_at = NULL,
        last_accessed = NOW(),
        last_module_index = 0,
        last_lesson_index = 0,
        last_lesson_id = NULL,
        last_video_position = 0,
        total_time_spent_seconds = 0,
        sessions_count = 0,
        average_session_duration = 0,
        skills_acquired = '[]'::jsonb,
        certificate_url = NULL,
        grade = NULL,
        updated_at = NOW()
    WHERE id = v_enrollment_id;
    
    RETURN QUERY
    SELECT 
        v_enrollment_id,
        p_student_email,
        v_course_title,
        'enrolled'::TEXT,
        (v_training_id IS NOT NULL);
END;
$$;


ALTER FUNCTION "public"."reset_enrollment_progress"("p_student_email" "text", "p_course_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."reset_enrollment_progress"("p_student_email" "text", "p_course_id" "uuid") IS 'Resets a student''s course enrollment progress. Automatically syncs trainings table and clears quiz progress via triggers.
Usage: SELECT * FROM reset_enrollment_progress(''email@example.com'', ''course-uuid'');';



CREATE OR REPLACE FUNCTION "public"."reset_quiz_progress_on_enrollment_reset"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- If progress is reset to 0 and completed_lessons is empty, delete quiz progress
    IF NEW.progress = 0 AND (NEW.completed_lessons IS NULL OR array_length(NEW.completed_lessons, 1) IS NULL) THEN
        DELETE FROM student_quiz_progress
        WHERE student_id = NEW.student_id
        AND course_id = NEW.course_id;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."reset_quiz_progress_on_enrollment_reset"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."reset_unread_count"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    unread_count INTEGER;
    conv_id TEXT;
BEGIN
    -- Get conversation_id from NEW (for INSERT/UPDATE) or OLD (for DELETE)
    IF TG_OP = 'DELETE' THEN
        conv_id := OLD.conversation_id;
    ELSE
        conv_id := NEW.conversation_id;
    END IF;

    -- Count unread messages for student
    SELECT COUNT(*) INTO unread_count
    FROM messages
    WHERE conversation_id = conv_id
        AND receiver_type = 'student'
        AND is_read = false;
    
    -- Update student unread count
    UPDATE conversations
    SET student_unread_count = unread_count
    WHERE id = conv_id;

    -- Count unread messages for recruiter
    SELECT COUNT(*) INTO unread_count
    FROM messages
    WHERE conversation_id = conv_id
        AND receiver_type = 'recruiter'
        AND is_read = false;
    
    -- Update recruiter unread count
    UPDATE conversations
    SET recruiter_unread_count = unread_count
    WHERE id = conv_id;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."reset_unread_count"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."review_curriculum"("p_curriculum_id" "uuid", "p_decision" "text", "p_notes" "text" DEFAULT NULL::"text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_id UUID;
    v_curriculum RECORD;
    v_new_status TEXT;
BEGIN
    -- Get current user ID
    v_user_id := auth.uid();
    
    -- Validate decision
    IF p_decision NOT IN ('approved', 'rejected') THEN
        RAISE EXCEPTION 'Invalid decision. Must be approved or rejected';
    END IF;
    
    -- Get curriculum info (using existing status column)
    SELECT * INTO v_curriculum
    FROM college_curriculums 
    WHERE id = p_curriculum_id
    AND status = 'pending_approval';
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Curriculum not found or not pending approval';
    END IF;
    
    -- Check if user is university admin for this curriculum
    IF NOT EXISTS (
        SELECT 1 FROM users 
        WHERE id = v_user_id 
        AND role = 'university_admin'
        AND "organizationId" = v_curriculum.university_id
    ) THEN
        RAISE EXCEPTION 'Access denied. University admin role required';
    END IF;
    
    -- Set new status (auto-publish on approval, no intermediate 'approved' status)
    v_new_status := CASE 
        WHEN p_decision = 'approved' THEN 'published'  -- Auto-publish on approval
        ELSE 'rejected'
    END;
    
    -- Update curriculum (using existing status column)
    UPDATE college_curriculums 
    SET 
        status = v_new_status,  -- Use existing status column
        reviewed_by = v_user_id,
        review_date = NOW(),
        review_notes = p_notes,
        published_date = CASE WHEN p_decision = 'approved' THEN NOW() ELSE NULL END
    WHERE id = p_curriculum_id;
    
    -- Create notification for requester (only if notifications table exists)
    IF to_regclass('public.notifications') IS NOT NULL THEN
        INSERT INTO notifications (
            recipient_id,
            title,
            message,
            type,
            metadata
        )
        VALUES (
            v_curriculum.requested_by,
            CASE 
                WHEN p_decision = 'approved' THEN 'Curriculum Approved and Published'
                ELSE 'Curriculum Approval Rejected'
            END,
            CASE 
                WHEN p_decision = 'approved' THEN 'Your curriculum has been approved and is now published'
                ELSE 'Your curriculum approval request has been rejected. Please review the feedback and resubmit.'
            END,
            CASE 
                WHEN p_decision = 'approved' THEN 'curriculum_approved'
                ELSE 'curriculum_rejected'
            END,
            jsonb_build_object(
                'curriculum_id', p_curriculum_id,
                'decision', p_decision,
                'notes', p_notes,
                'reviewer_id', v_user_id
            )
        );
    END IF;
    
    RETURN TRUE;
END;
$$;


ALTER FUNCTION "public"."review_curriculum"("p_curriculum_id" "uuid", "p_decision" "text", "p_notes" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."save_job_matches_cache"("p_student_id" "uuid", "p_matches" "jsonb", "p_algorithm_version" character varying DEFAULT 'v1.0'::character varying) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_profile_hash VARCHAR(64);
BEGIN
    -- Get current profile hash
    v_profile_hash := compute_student_profile_hash(p_student_id);
    
    -- Upsert the cache entry
    INSERT INTO student_job_matches (
        student_id,
        matches,
        match_count,
        algorithm_version,
        student_profile_hash,
        is_valid,
        invalidation_reason,
        computed_at,
        expires_at,
        created_at,
        updated_at
    ) VALUES (
        p_student_id,
        p_matches,
        jsonb_array_length(p_matches),
        p_algorithm_version,
        v_profile_hash,
        true,
        NULL,
        NOW(),
        NOW() + INTERVAL '24 hours',
        NOW(),
        NOW()
    )
    ON CONFLICT (student_id) DO UPDATE SET
        matches = EXCLUDED.matches,
        match_count = EXCLUDED.match_count,
        algorithm_version = EXCLUDED.algorithm_version,
        student_profile_hash = EXCLUDED.student_profile_hash,
        is_valid = true,
        invalidation_reason = NULL,
        computed_at = NOW(),
        expires_at = NOW() + INTERVAL '24 hours',
        updated_at = NOW();
END;
$$;


ALTER FUNCTION "public"."save_job_matches_cache"("p_student_id" "uuid", "p_matches" "jsonb", "p_algorithm_version" character varying) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."save_job_matches_cache"("p_student_id" "uuid", "p_matches" "jsonb", "p_algorithm_version" character varying) IS 'Saves computed job matches to cache with current profile hash.';



CREATE OR REPLACE FUNCTION "public"."schedule_assessment_reminder"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    skill_item JSONB;
    course_item JSONB;
    priority_skills JSONB;
    skill_gap_courses JSONB;
    course_titles TEXT[] := '{}';
    priority_a_courses TEXT[] := '{}';
    priority_b_courses TEXT[] := '{}';
    student_user_id UUID;
BEGIN
    -- Only process completed assessments
    IF NEW.status != 'completed' THEN
        RETURN NEW;
    END IF;

    -- Get the student's user_id for notifications (since notifications.recipient_id references users.id)
    SELECT user_id INTO student_user_id FROM students WHERE id = NEW.student_id;
    
    -- If no user_id found, skip notification (don't fail)
    IF student_user_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- Collect Priority A skill courses
    IF NEW.skill_gap ? 'priorityA' THEN
        priority_skills := NEW.skill_gap->'priorityA';
        
        FOR skill_item IN SELECT * FROM jsonb_array_elements(priority_skills)
        LOOP
            IF NEW.skill_gap_courses ? (skill_item->>'skill') THEN
                skill_gap_courses := NEW.skill_gap_courses->(skill_item->>'skill');
                
                FOR course_item IN SELECT * FROM jsonb_array_elements(skill_gap_courses)
                LOOP
                    priority_a_courses := priority_a_courses || (course_item->>'course_id');
                END LOOP;
            END IF;
        END LOOP;
    END IF;

    -- Collect Priority B skill courses
    IF NEW.skill_gap ? 'priorityB' THEN
        priority_skills := NEW.skill_gap->'priorityB';
        
        FOR skill_item IN SELECT * FROM jsonb_array_elements(priority_skills)
        LOOP
            IF NEW.skill_gap_courses ? (skill_item->>'skill') THEN
                skill_gap_courses := NEW.skill_gap_courses->(skill_item->>'skill');
                
                FOR course_item IN SELECT * FROM jsonb_array_elements(skill_gap_courses)
                LOOP
                    priority_b_courses := priority_b_courses || (course_item->>'course_id');
                END LOOP;
            END IF;
        END LOOP;
    END IF;

    -- Only schedule if there are courses to recommend
    IF array_length(priority_a_courses, 1) > 0 OR array_length(priority_b_courses, 1) > 0 THEN
        -- Schedule notification for exactly 6 months from assessment completion
        -- Use student_user_id (auth user ID) instead of student_id (student table ID)
        INSERT INTO notifications (
            recipient_id,
            type,
            title,
            message,
            read,
            status,
            scheduled_for,
            assessment_id,
            created_at
        ) VALUES (
            student_user_id,  -- Changed from NEW.student_id to student_user_id
            'assessment_6month_reminder',
            'Skill Development Reminder',
            'Time to continue your learning journey based on your assessment results.',
            false,
            'scheduled',
            NEW.created_at + INTERVAL '6 months',
            NEW.id,
            NOW()
        );
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."schedule_assessment_reminder"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_approval_authority"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_type TEXT;
BEGIN
    -- Only set approval_authority if:
    -- 1. It's an INSERT (new record)
    -- 2. It's an UPDATE where student_id changed
    -- 3. It's an UPDATE where approval_authority is NULL or empty
    IF TG_OP = 'INSERT' OR 
       (TG_OP = 'UPDATE' AND OLD.student_id != NEW.student_id) OR
       (TG_OP = 'UPDATE' AND (NEW.approval_authority IS NULL OR NEW.approval_authority = '')) THEN
        
        -- Get student type
        SELECT s.student_type INTO student_type
        FROM students s
        WHERE s.id = NEW.student_id;
        
        -- Set approval_authority based on student_type
        IF student_type = 'college' THEN
            NEW.approval_authority := 'college_admin';
        ELSIF student_type IN ('school', 'school-student') THEN
            NEW.approval_authority := 'school_admin';
        ELSE
            NEW.approval_authority := 'rareminds_admin';
        END IF;
        
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_approval_authority"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_experience_approval_authority"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_type_val TEXT;
BEGIN
    -- Get student type
    SELECT s.student_type INTO student_type_val
    FROM students s
    WHERE s.id = NEW.student_id;

    -- If student not found, default to rareminds_admin
    IF NOT FOUND THEN
        NEW.approval_authority := 'rareminds_admin';
        RETURN NEW;
    END IF;

    -- Set approval authority based on student type
    IF student_type_val = 'college' THEN
        NEW.approval_authority := 'college_admin';
    ELSIF student_type_val IN ('school', 'school-student') THEN
        NEW.approval_authority := 'school_admin';
    ELSE
        NEW.approval_authority := 'rareminds_admin';
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_experience_approval_authority"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_experience_approval_authority_final"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_record RECORD;
    calculated_authority TEXT;
BEGIN
    -- Log the trigger execution
    RAISE NOTICE 'ðŸ”§ TRIGGER FIRED: % on experience table, student_id: %', TG_OP, NEW.student_id;
    
    -- Get student information
    SELECT s.school_id, s.university_college_id, s.name, s.user_id
    INTO student_record
    FROM students s
    WHERE s.id = NEW.student_id;
    
    -- If no student found, force rareminds_admin
    IF NOT FOUND THEN
        NEW.approval_authority := 'rareminds_admin';
        RAISE NOTICE 'âŒ No student found for student_id %, setting rareminds_admin', NEW.student_id;
        RETURN NEW;
    END IF;
    
    RAISE NOTICE 'ðŸ‘¤ Student found: % (school_id: %, college_id: %)', 
                student_record.name, student_record.school_id, student_record.university_college_id;
    
    -- Calculate the correct approval authority
    calculated_authority := 'rareminds_admin'; -- default
    
    -- Rule 1: College students â†’ College Admin
    IF student_record.university_college_id IS NOT NULL THEN
        -- Check if college exists in organizations table with admin
        IF EXISTS (
            SELECT 1 FROM organizations o 
            WHERE o.id = student_record.university_college_id 
            AND o.organization_type = 'college'
            AND o.admin_id IS NOT NULL
        ) THEN
            calculated_authority := 'college_admin';
            RAISE NOTICE 'ðŸŽ“ College student detected - setting college_admin (college_id: %)', 
                        student_record.university_college_id;
        ELSE
            RAISE NOTICE 'âš ï¸  College student but no valid college organization found (college_id: %)', 
                        student_record.university_college_id;
        END IF;
    END IF;
    
    -- Rule 2: School students â†’ School Admin (only if not already college)
    IF calculated_authority = 'rareminds_admin' AND student_record.school_id IS NOT NULL THEN
        -- Check if school exists in organizations table with admin
        IF EXISTS (
            SELECT 1 FROM organizations o 
            WHERE o.id = student_record.school_id 
            AND o.organization_type = 'school'
            AND o.admin_id IS NOT NULL
        ) THEN
            calculated_authority := 'school_admin';
            RAISE NOTICE 'ðŸ« School student detected - setting school_admin (school_id: %)', 
                        student_record.school_id;
        ELSE
            RAISE NOTICE 'âš ï¸  School student but no valid school organization found (school_id: %)', 
                        student_record.school_id;
        END IF;
    END IF;
    
    -- ALWAYS set the calculated value (override whatever was sent)
    NEW.approval_authority := calculated_authority;
    
    RAISE NOTICE 'âœ… FINAL: approval_authority set to % for student % experience', 
                NEW.approval_authority, student_record.name;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_experience_approval_authority_final"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_project_approval_authority"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    student_record RECORD;
    org_lower TEXT;
    student_school_name TEXT;
    student_college_name TEXT;
    is_school_student BOOLEAN := FALSE;
    is_college_student BOOLEAN := FALSE;
BEGIN
    -- Get student information with school and college names from organizations table
    SELECT 
        s.student_type, 
        s.school_id, 
        s.college_id, 
        s.university_college_id,
        sch.name as school_name,
        col.name as college_name
    INTO student_record
    FROM students s
    LEFT JOIN organizations sch ON s.school_id = sch.id AND sch.organization_type = 'school'
    LEFT JOIN organizations col ON (s.college_id = col.id OR s.university_college_id = col.id) AND col.organization_type = 'college'
    WHERE s.id = NEW.student_id;

    -- If no student found, default to rareminds_admin
    IF NOT FOUND THEN
        NEW.approval_authority := 'rareminds_admin';
        RETURN NEW;
    END IF;

    -- If no organization specified, default to rareminds_admin
    IF NEW.organization IS NULL OR TRIM(NEW.organization) = '' THEN
        NEW.approval_authority := 'rareminds_admin';
        RETURN NEW;
    END IF;

    -- Normalize organization name for comparison
    org_lower := LOWER(TRIM(NEW.organization));
    
    -- Get student's school and college names (normalized)
    student_school_name := CASE 
        WHEN student_record.school_name IS NOT NULL 
        THEN LOWER(TRIM(student_record.school_name))
        ELSE NULL 
    END;
    
    student_college_name := CASE 
        WHEN student_record.college_name IS NOT NULL 
        THEN LOWER(TRIM(student_record.college_name))
        ELSE NULL 
    END;

    -- Determine if student is school or college type
    -- School students: have school_id OR student_type contains 'school' OR student_type is 'direct' with school_id
    is_school_student := (
        student_record.school_id IS NOT NULL OR
        student_record.student_type IN ('school', 'school_student', 'school-student') OR
        (student_record.student_type = 'direct' AND student_record.school_id IS NOT NULL)
    );
    
    -- College students: have college_id OR student_type contains 'college' OR student_type is 'direct' with college_id
    is_college_student := (
        student_record.college_id IS NOT NULL OR 
        student_record.university_college_id IS NOT NULL OR
        student_record.student_type IN ('college', 'college_student', 'college-student') OR
        (student_record.student_type = 'direct' AND (student_record.college_id IS NOT NULL OR student_record.university_college_id IS NOT NULL))
    );

    -- Route based on student type and organization matching
    IF is_school_student THEN
        -- For school students: check if organization matches their school name
        IF student_school_name IS NOT NULL AND org_lower = student_school_name THEN
            NEW.approval_authority := 'school_admin';
            RETURN NEW;
        END IF;
        
        -- Also check if organization matches any school name in the organizations table
        IF EXISTS (
            SELECT 1 FROM organizations 
            WHERE LOWER(TRIM(name)) = org_lower 
            AND organization_type = 'school'
            AND account_status IN ('active', 'pending')
        ) THEN
            NEW.approval_authority := 'school_admin';
            RETURN NEW;
        END IF;
        
    END IF;
    
    IF is_college_student THEN
        -- For college students: check if organization matches their college name
        IF student_college_name IS NOT NULL AND org_lower = student_college_name THEN
            NEW.approval_authority := 'college_admin';
            RETURN NEW;
        END IF;
        
        -- Also check if organization matches any college name in the organizations table
        IF EXISTS (
            SELECT 1 FROM organizations 
            WHERE LOWER(TRIM(name)) = org_lower 
            AND organization_type = 'college'
            AND account_status = 'active'
        ) THEN
            NEW.approval_authority := 'college_admin';
            RETURN NEW;
        END IF;
    END IF;

    -- Default to rareminds_admin for external/custom organizations
    NEW.approval_authority := 'rareminds_admin';
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_project_approval_authority"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_session_total_students"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Set total students from program_sections_view
    NEW.total_students := COALESCE((
        SELECT max_students
        FROM program_sections_view psv
        WHERE psv.department_name = NEW.department_name
        AND psv.program_name = NEW.program_name
        AND psv.semester = NEW.semester
        AND psv.section = NEW.section
        AND psv.status = 'active'
        LIMIT 1
    ), 0);
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_session_total_students"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_training_approval_authority"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    student_record RECORD;
    authority UUID;
BEGIN
    -- 1ï¸âƒ£ Get student info
    SELECT id, student_type, college_id, school_id
    INTO student_record
    FROM students
    WHERE id = NEW.student_id;

    IF NOT FOUND THEN
        RAISE NOTICE 'âŒ Student not found: %', NEW.student_id;
        RETURN NEW;
    END IF;

    authority := NULL;

    -- 2ï¸âƒ£ Determine approval authority
    IF NEW.source = 'manual' THEN
     IF student_record.student_type = 'college' THEN
        NEW.approval_authority := 'college_admin';
      ELSIF student_record.student_type IN ('school','school-student') THEN
        NEW.approval_authority := 'school_admin';
     END IF;
    ELSE
     NEW.approval_authority := 'rareminds_admin';
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_training_approval_authority"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_updated_at_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."set_updated_at_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."submit_curriculum_for_approval"("p_curriculum_id" "uuid", "p_message" "text" DEFAULT NULL::"text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
    v_user_id UUID;
    v_college_info RECORD;
    v_college_name TEXT;
BEGIN
    -- Get current user ID
    v_user_id := auth.uid();
    
    -- Get college affiliation info
    SELECT * INTO v_college_info FROM check_college_affiliation() LIMIT 1;
    
    -- Check if college is affiliated
    IF NOT v_college_info.is_affiliated THEN
        RAISE EXCEPTION 'College is not affiliated with any university';
    END IF;
    
    -- Get college name from organizations table
    SELECT name INTO v_college_name
    FROM organizations 
    WHERE id = v_college_info.college_id;
    
    -- Update curriculum status (using existing status column)
    UPDATE college_curriculums 
    SET 
        status = 'pending_approval',
        requested_by = v_user_id,
        request_date = NOW(),
        request_message = p_message,
        university_id = v_college_info.university_id
    WHERE id = p_curriculum_id
    AND college_id = v_college_info.college_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Curriculum not found or access denied';
    END IF;
    
    -- Create notifications for university admins (only if notifications table exists)
    -- Skip metadata column if it doesn't exist
    IF to_regclass('public.notifications') IS NOT NULL THEN
        -- Check if metadata column exists
        IF EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'notifications' 
            AND column_name = 'metadata'
        ) THEN
            -- Insert with metadata
            INSERT INTO notifications (
                recipient_id,
                title,
                message,
                type,
                metadata
            )
            SELECT 
                ua.id,
                'New Curriculum Approval Request',
                'A new curriculum approval request has been submitted by ' || COALESCE(v_college_name, 'Unknown College'),
                'curriculum_approval_request',
                jsonb_build_object(
                    'curriculum_id', p_curriculum_id,
                    'college_id', v_college_info.college_id,
                    'university_id', v_college_info.university_id,
                    'requested_by_email', (SELECT email FROM users WHERE id = v_user_id)
                )
            FROM get_university_admins(v_college_info.university_id) ua;
        ELSE
            -- Insert without metadata
            INSERT INTO notifications (
                recipient_id,
                title,
                message,
                type
            )
            SELECT 
                ua.id,
                'New Curriculum Approval Request',
                'A new curriculum approval request has been submitted by ' || COALESCE(v_college_name, 'Unknown College'),
                'curriculum_approval_request'
            FROM get_university_admins(v_college_info.university_id) ua;
        END IF;
    END IF;
    
    RETURN TRUE;
END;
$$;


ALTER FUNCTION "public"."submit_curriculum_for_approval"("p_curriculum_id" "uuid", "p_message" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_lecturer_record_id"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Auto-populate lecturer_record_id from invigilator_id
  IF NEW.invigilator_id IS NOT NULL AND NEW.lecturer_record_id IS NULL THEN
    SELECT id INTO NEW.lecturer_record_id
    FROM college_lecturers
    WHERE user_id = NEW.invigilator_id;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_lecturer_record_id"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."sync_lecturer_record_id"() IS 'Auto-populate lecturer_record_id from invigilator_id (user_id)';



CREATE OR REPLACE FUNCTION "public"."sync_pool_assigned_seats"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- Only increment if status is active
        IF NEW.status = 'active' THEN
            UPDATE license_pools
            SET assigned_seats = COALESCE(assigned_seats, 0) + 1,
                updated_at = NOW()
            WHERE id = NEW.license_pool_id;
            
            -- Also update organization_subscriptions
            UPDATE organization_subscriptions
            SET assigned_seats = COALESCE(assigned_seats, 0) + 1,
                updated_at = NOW()
            WHERE id = NEW.organization_subscription_id;
        END IF;
        RETURN NEW;
        
    ELSIF TG_OP = 'UPDATE' THEN
        -- Handle status changes
        IF OLD.status = 'active' AND NEW.status != 'active' THEN
            -- License was revoked/expired, decrement count
            UPDATE license_pools
            SET assigned_seats = GREATEST(COALESCE(assigned_seats, 0) - 1, 0),
                updated_at = NOW()
            WHERE id = NEW.license_pool_id;
            
            UPDATE organization_subscriptions
            SET assigned_seats = GREATEST(COALESCE(assigned_seats, 0) - 1, 0),
                updated_at = NOW()
            WHERE id = NEW.organization_subscription_id;
            
        ELSIF OLD.status != 'active' AND NEW.status = 'active' THEN
            -- License was reactivated, increment count
            UPDATE license_pools
            SET assigned_seats = COALESCE(assigned_seats, 0) + 1,
                updated_at = NOW()
            WHERE id = NEW.license_pool_id;
            
            UPDATE organization_subscriptions
            SET assigned_seats = COALESCE(assigned_seats, 0) + 1,
                updated_at = NOW()
            WHERE id = NEW.organization_subscription_id;
        END IF;
        RETURN NEW;
        
    ELSIF TG_OP = 'DELETE' THEN
        -- Decrement assigned_seats when assignment is deleted
        IF OLD.status = 'active' THEN
            UPDATE license_pools
            SET assigned_seats = GREATEST(COALESCE(assigned_seats, 0) - 1, 0),
                updated_at = NOW()
            WHERE id = OLD.license_pool_id;
            
            UPDATE organization_subscriptions
            SET assigned_seats = GREATEST(COALESCE(assigned_seats, 0) - 1, 0),
                updated_at = NOW()
            WHERE id = OLD.organization_subscription_id;
        END IF;
        RETURN OLD;
    END IF;
    
    RETURN NULL;
END;
$$;


ALTER FUNCTION "public"."sync_pool_assigned_seats"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."sync_pool_assigned_seats"() IS 'Keeps assigned_seats count synchronized in both license_pools and organization_subscriptions tables.';



CREATE OR REPLACE FUNCTION "public"."sync_student_record_id"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Auto-populate student_record_id from user_id
  IF NEW.student_id IS NOT NULL AND NEW.student_record_id IS NULL THEN
    SELECT id INTO NEW.student_record_id
    FROM students
    WHERE user_id = NEW.student_id;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_student_record_id"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."sync_student_record_id"() IS 'Auto-populate student_record_id from student_id (user_id)';



CREATE OR REPLACE FUNCTION "public"."sync_training_from_enrollment"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Only sync if there's a linked training_id
    IF NEW.training_id IS NOT NULL THEN
        UPDATE trainings
        SET 
            status = CASE 
                WHEN NEW.status = 'completed' THEN 'completed'
                ELSE 'ongoing'
            END,
            completed_modules = COALESCE(array_length(NEW.completed_lessons, 1), 0),
            hours_spent = COALESCE(NEW.total_time_spent_seconds / 3600, 0),
            end_date = CASE 
                WHEN NEW.status = 'completed' THEN NEW.completed_at::date
                ELSE NULL
            END,
            updated_at = NOW()
        WHERE id = NEW.training_id;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."sync_training_from_enrollment"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."test_assessment_reminders"("student_uuid" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("notification_id" "uuid", "student_id" "uuid", "assessment_id" "uuid", "status" "text", "scheduled_for" timestamp with time zone, "action_taken" "text")
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    test_results RECORD;
BEGIN
    -- Temporarily set scheduled_for to now for testing
    UPDATE notifications 
    SET scheduled_for = NOW() - INTERVAL '1 minute'
    WHERE type = 'assessment_6month_reminder'
    AND status = 'scheduled'
    AND (student_uuid IS NULL OR recipient_id = student_uuid);

    -- Process the reminders
    PERFORM process_assessment_reminders();

    -- Return results
    RETURN QUERY
    SELECT 
        n.id as notification_id,
        n.recipient_id as student_id,
        n.assessment_id,
        n.status,
        n.scheduled_for,
        CASE 
            WHEN n.status = 'sent' THEN 'Notification sent'
            WHEN n.status = 'cancelled' THEN 'Notification cancelled: ' || COALESCE(n.message, 'Unknown reason')
            ELSE 'No action taken'
        END as action_taken
    FROM notifications n
    WHERE n.type = 'assessment_6month_reminder'
    AND (student_uuid IS NULL OR n.recipient_id = student_uuid)
    ORDER BY n.created_at DESC;
END;
$$;


ALTER FUNCTION "public"."test_assessment_reminders"("student_uuid" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."test_outcome_approval_debug"("p_curriculum_id" "uuid", "p_change_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_change JSONB;
  v_change_data JSONB;
  v_pending_changes JSONB;
  v_change_elem JSONB;
  v_debug_info TEXT;
BEGIN
  -- Get pending changes
  SELECT pending_changes INTO v_pending_changes
  FROM college_curriculums
  WHERE id = p_curriculum_id;
  
  -- Find the specific change
  v_change := NULL;
  FOR i IN 0..jsonb_array_length(v_pending_changes) - 1 LOOP
    v_change_elem := v_pending_changes->i;
    IF v_change_elem->>'id' = p_change_id::text THEN
      v_change := v_change_elem;
      EXIT;
    END IF;
  END LOOP;
  
  IF v_change IS NULL THEN
    RETURN 'Change not found';
  END IF;
  
  v_change_data := v_change->'data';
  
  v_debug_info := 'Change Type: ' || (v_change->>'change_type') || E'\n';
  v_debug_info := v_debug_info || 'Full Change Data: ' || v_change_data::text || E'\n';
  v_debug_info := v_debug_info || 'Direct unit_id: ' || COALESCE(v_change_data->>'unit_id', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'Nested unit_id: ' || COALESCE(v_change_data->'data'->>'unit_id', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'CamelCase unitId: ' || COALESCE(v_change_data->>'unitId', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'Nested camelCase unitId: ' || COALESCE(v_change_data->'data'->>'unitId', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'Direct outcome_text: ' || COALESCE(v_change_data->>'outcome_text', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'Nested outcome_text: ' || COALESCE(v_change_data->'data'->>'outcome_text', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'Direct outcome: ' || COALESCE(v_change_data->>'outcome', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'Nested outcome: ' || COALESCE(v_change_data->'data'->>'outcome', 'NULL') || E'\n';
  
  RETURN v_debug_info;
END;
$$;


ALTER FUNCTION "public"."test_outcome_approval_debug"("p_curriculum_id" "uuid", "p_change_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."toggle_save_job"("p_student_id" "uuid", "p_opportunity_id" integer) RETURNS TABLE("success" boolean, "message" "text", "is_saved" boolean, "saved_job_id" integer)
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_saved_job_id INTEGER;
  v_is_saved BOOLEAN;
BEGIN
  -- Check if already saved
  SELECT id INTO v_saved_job_id
  FROM public.saved_jobs
  WHERE student_id = p_student_id 
    AND opportunity_id = p_opportunity_id;
  
  IF FOUND THEN
    -- Already saved, so unsave it
    DELETE FROM public.saved_jobs
    WHERE id = v_saved_job_id;
    
    RETURN QUERY SELECT TRUE, 'Job unsaved successfully', FALSE, NULL::INTEGER;
  ELSE
    -- Not saved, so save it
    INSERT INTO public.saved_jobs (
      student_id,
      opportunity_id,
      saved_at
    ) 
    VALUES (
      p_student_id,
      p_opportunity_id,
      NOW()
    )
    RETURNING id INTO v_saved_job_id;
    
    RETURN QUERY SELECT TRUE, 'Job saved successfully', TRUE, v_saved_job_id;
  END IF;
END;
$$;


ALTER FUNCTION "public"."toggle_save_job"("p_student_id" "uuid", "p_opportunity_id" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."track_profile_view"("p_student_id" "uuid", "p_viewer_type" "text" DEFAULT 'anonymous'::"text", "p_viewer_id" "uuid" DEFAULT NULL::"uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_recent_views int;
BEGIN
  -- Insert the view
  INSERT INTO public.profile_views (student_id, viewer_type, viewer_id)
  VALUES (p_student_id, p_viewer_type, p_viewer_id);

  -- Count views in the last 7 days
  SELECT COUNT(*) INTO v_recent_views
  FROM public.profile_views
  WHERE student_id = p_student_id
  AND viewed_at >= now() - interval '7 days';

  -- Add update every 5 views
  IF v_recent_views % 5 = 0 THEN
    PERFORM add_recent_update(
      p_student_id,
      'Your profile has been viewed ' || v_recent_views::text || ' times this week',
      'profile_view'
    );
    RAISE LOG 'Profile view milestone for student %: % views', p_student_id, v_recent_views;
  END IF;
END;
$$;


ALTER FUNCTION "public"."track_profile_view"("p_student_id" "uuid", "p_viewer_type" "text", "p_viewer_id" "uuid") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."track_profile_view"("p_student_id" "uuid", "p_viewer_type" "text", "p_viewer_id" "uuid") IS 'Tracks profile view and creates update notification every 5 views';



CREATE OR REPLACE FUNCTION "public"."transferStudent"("p_studentId" "uuid", "p_newEntityType" "text", "p_newEntityId" "uuid", "p_newClassId" "uuid", "p_transferReason" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_oldEnrollmentId UUID;
    v_newEnrollmentId UUID;
BEGIN
    -- Mark current enrollment as transferred
    UPDATE "studentEnrollments"
    SET "enrollmentStatus" = 'transferred',
        "transferDate" = CURRENT_DATE,
        "transferReason" = "p_transferReason",
        "transferToEntityId" = "p_newEntityId",
        "transferToClassId" = "p_newClassId",
        "updatedAt" = NOW()
    WHERE "studentId" = "p_studentId"
    AND "enrollmentStatus" = 'active'
    RETURNING "id" INTO v_oldEnrollmentId;
    
    -- Create new enrollment
    INSERT INTO "studentEnrollments" (
        "studentId", "schoolId", "collegeId",
        "universityId", "schoolClassId", "collegeCourseId", 
        "universityCourseId", "enrollmentDate", "enrollmentStatus"
    )
    VALUES (
        "p_studentId",
        CASE WHEN "p_newEntityType" = 'school' THEN "p_newEntityId" ELSE NULL END,
        CASE WHEN "p_newEntityType" = 'college' THEN "p_newEntityId" ELSE NULL END,
        CASE WHEN "p_newEntityType" = 'university' THEN "p_newEntityId" ELSE NULL END,
        CASE WHEN "p_newEntityType" = 'school' THEN "p_newClassId" ELSE NULL END,
        CASE WHEN "p_newEntityType" = 'college' THEN "p_newClassId" ELSE NULL END,
        CASE WHEN "p_newEntityType" = 'university' THEN "p_newClassId" ELSE NULL END,
        CURRENT_DATE,
        'active'
    )
    RETURNING "id" INTO v_newEnrollmentId;
    
    RETURN v_newEnrollmentId;
END;
$$;


ALTER FUNCTION "public"."transferStudent"("p_studentId" "uuid", "p_newEntityType" "text", "p_newEntityId" "uuid", "p_newClassId" "uuid", "p_transferReason" "text") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."transferStudent"("p_studentId" "uuid", "p_newEntityType" "text", "p_newEntityId" "uuid", "p_newClassId" "uuid", "p_transferReason" "text") IS 'Transfers student from current enrollment to new class/course';



CREATE OR REPLACE FUNCTION "public"."trg_assignments_completion_fn"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        IF NEW.submission_date IS NULL THEN
            NEW.submission_date := CURRENT_TIMESTAMP;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_assignments_completion_fn"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_assignments_grade_pct_fn"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    IF NEW.grade_received IS NOT NULL AND NEW.total_points IS NOT NULL AND NEW.total_points > 0 THEN
        NEW.grade_percentage := ROUND((NEW.grade_received / NEW.total_points) * 100, 2);
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_assignments_grade_pct_fn"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_assignments_updated_fn"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_date := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_assignments_updated_fn"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_college_assignments_updated_fn"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_date = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_college_assignments_updated_fn"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_college_student_assignments_grade_pct_fn"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_total_points numeric;
BEGIN
    IF NEW.grade_received IS NOT NULL THEN
        SELECT total_points INTO v_total_points
        FROM college_assignments
        WHERE assignment_id = NEW.assignment_id;
        
        IF v_total_points > 0 THEN
            NEW.grade_percentage := (NEW.grade_received / v_total_points) * 100;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_college_student_assignments_grade_pct_fn"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_college_student_assignments_late_check_fn"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_due_date timestamp with time zone;
BEGIN
    IF NEW.submission_date IS NOT NULL THEN
        SELECT due_date INTO v_due_date
        FROM college_assignments
        WHERE assignment_id = NEW.assignment_id;
        
        IF NEW.submission_date > v_due_date THEN
            NEW.is_late := true;
        ELSE
            NEW.is_late := false;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_college_student_assignments_late_check_fn"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_college_student_assignments_status_fn"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    IF NEW.status = 'in-progress' AND OLD.status = 'todo' THEN
        NEW.started_date := NOW();
    END IF;
    
    IF NEW.status = 'submitted' AND OLD.status <> 'submitted' THEN
        NEW.completed_date := NOW();
        NEW.submission_date := NOW();
    END IF;
    
    IF NEW.status = 'graded' AND OLD.status <> 'graded' THEN
        NEW.graded_date := NOW();
        NEW.feedback_date := NOW();
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_college_student_assignments_status_fn"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_college_student_assignments_updated_fn"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_date = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_college_student_assignments_updated_fn"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_insert_recent_update"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Only insert when training is marked as completed
  IF NEW.status = 'completed' AND (OLD.status IS DISTINCT FROM NEW.status) THEN
    INSERT INTO public.recent_updates (student_id, title, description, type)
    VALUES (
      NEW.student_id,
      CONCAT('You completed ', NEW.course, '.'),
      NEW.description,
      'achievement'
    );
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_insert_recent_update"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_student_assignments_grade_pct_fn"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_total_points numeric(7,2);
BEGIN
    -- Get total points from the assignment
    SELECT total_points INTO v_total_points
    FROM assignments
    WHERE assignment_id = NEW.assignment_id;
    
    IF NEW.grade_received IS NOT NULL AND v_total_points IS NOT NULL AND v_total_points > 0 THEN
        NEW.grade_percentage := ROUND((NEW.grade_received / v_total_points) * 100, 2);
    END IF;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_student_assignments_grade_pct_fn"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_student_assignments_late_check_fn"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_due_date timestamptz;
BEGIN
    -- Only check if submission_date is being set
    IF NEW.submission_date IS NOT NULL THEN
        -- Get due date from assignment
        SELECT due_date INTO v_due_date
        FROM assignments
        WHERE assignment_id = NEW.assignment_id;
        
        -- Mark as late if submitted after due date
        IF v_due_date IS NOT NULL AND NEW.submission_date > v_due_date THEN
            NEW.is_late := true;
        ELSE
            NEW.is_late := false;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_student_assignments_late_check_fn"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_student_assignments_status_fn"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Set started_date when status changes to in-progress
    IF NEW.status = 'in-progress' AND (OLD.status IS NULL OR OLD.status = 'todo') THEN
        IF NEW.started_date IS NULL THEN
            NEW.started_date := CURRENT_TIMESTAMP;
        END IF;
    END IF;
    
    -- Set completed_date when status changes to submitted
    IF NEW.status = 'submitted' AND (OLD IS NULL OR OLD.status != 'submitted') THEN
        IF NEW.completed_date IS NULL THEN
            NEW.completed_date := CURRENT_TIMESTAMP;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_student_assignments_status_fn"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trg_student_assignments_updated_fn"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_date := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trg_student_assignments_updated_fn"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_course_embedding_queue"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  PERFORM queue_embedding_generation(NEW.id, 'courses', CASE WHEN TG_OP = 'INSERT' THEN 'insert' ELSE 'update' END, CASE WHEN TG_OP = 'INSERT' THEN 7 ELSE 4 END);
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_course_embedding_queue"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_enrollment_completion_embedding"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF (NEW.progress >= 100 OR NEW.status = 'completed') AND (OLD.progress < 100 AND OLD.status != 'completed') THEN
    PERFORM queue_embedding_generation(NEW.student_id, 'students', 'update', 7);
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_enrollment_completion_embedding"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_entity_embedding_generation"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  payload JSONB;
  entity_type TEXT;
BEGIN
  -- Determine entity type from table name
  entity_type := TG_TABLE_NAME;
  
  -- Build payload with student_id and entity type
  IF TG_OP = 'DELETE' THEN
    -- No need to generate embeddings for deleted records
    RETURN OLD;
  END IF;
  
  -- Only trigger for INSERT or UPDATE
  -- For updates, only trigger if relevant fields changed (not just embedding)
  IF TG_OP = 'UPDATE' AND NEW.embedding IS NOT NULL THEN
    -- Skip if only embedding was updated (avoid infinite loop)
    RETURN NEW;
  END IF;
  
  payload := jsonb_build_object(
    'studentId', COALESCE(NEW.student_id::text, ''),
    'entityTypes', jsonb_build_array(entity_type),
    'batchSize', 5
  );
  
  -- Call the backfill endpoint asynchronously using pg_net
  PERFORM net.http_post(
    url := 'https://career-api.dark-mode-d021.workers.dev/backfill-embeddings',
    headers := jsonb_build_object('Content-Type', 'application/json'),
    body := payload
  );
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_entity_embedding_generation"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."trigger_entity_embedding_generation"() IS 'Automatically triggers embedding generation when entity data changes';



CREATE OR REPLACE FUNCTION "public"."trigger_opportunity_embedding"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  embedding_text TEXT;
BEGIN
  -- Build the embedding text from opportunity data
  embedding_text := NEW.title;
  
  IF NEW.company_name IS NOT NULL THEN
    embedding_text := embedding_text || ' at ' || NEW.company_name;
  END IF;
  
  IF NEW.description IS NOT NULL THEN
    embedding_text := embedding_text || '. ' || NEW.description;
  END IF;
  
  IF NEW.skills_required IS NOT NULL AND jsonb_typeof(NEW.skills_required) = 'array' THEN
    embedding_text := embedding_text || '. Required Skills: ' || 
                     (SELECT string_agg(value::text, ', ') 
                      FROM jsonb_array_elements_text(NEW.skills_required));
  END IF;
  
  IF NEW.requirements IS NOT NULL AND jsonb_typeof(NEW.requirements) = 'array' THEN
    embedding_text := embedding_text || '. Requirements: ' || 
                     (SELECT string_agg(value::text, '. ') 
                      FROM jsonb_array_elements_text(NEW.requirements));
  END IF;

  -- Log the trigger execution
  RAISE NOTICE 'Opportunity embedding trigger fired for: % (ID: %)', NEW.title, NEW.id;
  RAISE NOTICE 'Embedding text length: % characters', length(embedding_text);
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_opportunity_embedding"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."trigger_opportunity_embedding"() IS 'Logs when opportunities need embeddings. Actual generation should be done via career-api or batch script.';



CREATE OR REPLACE FUNCTION "public"."trigger_opportunity_embedding_queue"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  PERFORM queue_embedding_generation(NEW.id, 'opportunities', CASE WHEN TG_OP = 'INSERT' THEN 'insert' ELSE 'update' END, CASE WHEN TG_OP = 'INSERT' THEN 9 ELSE 7 END);
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_opportunity_embedding_queue"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_profile_update"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_changes text;
BEGIN
  v_changes := '';
  
  IF OLD.profile->>'name' != NEW.profile->>'name' THEN
    v_changes := 'Profile information updated';
  ELSIF OLD.profile->'education' != NEW.profile->'education' THEN
    v_changes := 'Education details updated';
  ELSIF OLD.profile->'experience' != NEW.profile->'experience' THEN
    v_changes := 'Experience information updated';
  ELSIF OLD.profile->'technicalSkills' != NEW.profile->'technicalSkills' THEN
    v_changes := 'Technical skills updated';
  ELSIF OLD.profile->'softSkills' != NEW.profile->'softSkills' THEN
    v_changes := 'Soft skills updated';
  ELSE
    v_changes := 'Profile updated';
  END IF;

  PERFORM add_recent_update(
    NEW.id,
    v_changes,
    'profile_update'
  );

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_profile_update"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_related_student_embedding"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE v_student_id UUID;
BEGIN
  IF TG_OP = 'DELETE' THEN v_student_id := OLD.student_id; ELSE v_student_id := NEW.student_id; END IF;
  IF v_student_id IS NOT NULL THEN PERFORM queue_embedding_generation(v_student_id, 'students', 'update', 6); END IF;
  RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."trigger_related_student_embedding"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_skills_improvement"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_old_tech_skills jsonb;
  v_new_tech_skills jsonb;
  v_skill_count_old int;
  v_skill_count_new int;
BEGIN
  -- Extract technical skills arrays
  v_old_tech_skills := OLD.profile->'technicalSkills';
  v_new_tech_skills := NEW.profile->'technicalSkills';
  
  -- Count skills
  SELECT jsonb_array_length(v_old_tech_skills) INTO v_skill_count_old;
  SELECT jsonb_array_length(v_new_tech_skills) INTO v_skill_count_new;
  
  -- Check if skills increased
  IF v_skill_count_new > v_skill_count_old THEN
    PERFORM add_recent_update(
      NEW.id,
      'Added new technical skills to your profile',
      'skills_update'
    );
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_skills_improvement"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_student_embedding_queue"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  PERFORM queue_embedding_generation(NEW.id, 'students', CASE WHEN TG_OP = 'INSERT' THEN 'insert' ELSE 'update' END, CASE WHEN TG_OP = 'INSERT' THEN 8 ELSE 5 END);
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_student_embedding_queue"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_training_completion"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_old_training jsonb;
  v_new_training jsonb;
  v_training_item jsonb;
  v_course_name text;
BEGIN
  v_old_training := OLD.profile->'training';
  v_new_training := NEW.profile->'training';

  IF v_old_training IS NOT NULL AND v_new_training IS NOT NULL THEN
    FOR v_training_item IN SELECT * FROM jsonb_array_elements(v_new_training)
    LOOP
      v_course_name := v_training_item->>'course';
      
      IF v_training_item->>'status' = 'completed' THEN
        IF NOT EXISTS (
          SELECT 1 FROM jsonb_array_elements(v_old_training) old_item
          WHERE old_item->>'id' = v_training_item->>'id'
          AND old_item->>'status' = 'completed'
        ) THEN
          PERFORM add_recent_update(
            NEW.id,
            'You completed ' || v_course_name || ' course',
            'training_completion'
          );
        END IF;
      END IF;
    END LOOP;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_training_completion"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."trigger_validate_aadhar"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF NEW.aadhar_number IS NOT NULL AND NOT validate_aadhar_number(NEW.aadhar_number) THEN
    RAISE EXCEPTION 'Invalid Aadhar number format. Must be 12 digits and cannot start with 0 or 1.';
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."trigger_validate_aadhar"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_adaptive_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_adaptive_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_applied_jobs_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = TIMEZONE('utc'::text, NOW());
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_applied_jobs_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_book_availability"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- If inserting a new issue (book being issued)
    IF TG_OP = 'INSERT' AND NEW.status = 'issued' THEN
        UPDATE library_books 
        SET available_copies = available_copies - 1,
            status = CASE 
                WHEN available_copies - 1 = 0 THEN 'all_issued'
                ELSE 'available'
            END
        WHERE id = NEW.book_id;
        
    -- If updating an issue (book being returned)
    ELSIF TG_OP = 'UPDATE' AND OLD.status = 'issued' AND NEW.status = 'returned' THEN
        UPDATE library_books 
        SET available_copies = available_copies + 1,
            status = 'available'
        WHERE id = NEW.book_id;
        
    -- If deleting an issue record (cleanup)
    ELSIF TG_OP = 'DELETE' AND OLD.status = 'issued' THEN
        UPDATE library_books 
        SET available_copies = available_copies + 1,
            status = 'available'
        WHERE id = OLD.book_id;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."update_book_availability"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_book_availability_college"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- If inserting a new issue (book being issued)
    IF TG_OP = 'INSERT' AND NEW.status = 'issued' THEN
        UPDATE library_books_college 
        SET available_copies = available_copies - 1,
            status = CASE 
                WHEN available_copies - 1 = 0 THEN 'all_issued'
                ELSE 'available'
            END
        WHERE id = NEW.book_id AND college_id = NEW.college_id;
        
    -- If updating an issue (book being returned)
    ELSIF TG_OP = 'UPDATE' AND OLD.status = 'issued' AND NEW.status = 'returned' THEN
        UPDATE library_books_college 
        SET available_copies = available_copies + 1,
            status = 'available'
        WHERE id = NEW.book_id AND college_id = NEW.college_id;
        
    -- If deleting an issue record (cleanup)
    ELSIF TG_OP = 'DELETE' AND OLD.status = 'issued' THEN
        UPDATE library_books_college 
        SET available_copies = available_copies + 1,
            status = 'available'
        WHERE id = OLD.book_id AND college_id = OLD.college_id;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."update_book_availability_college"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_book_availability_on_issue"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Decrease available copies when book is issued
  UPDATE library_books 
  SET available_copies = available_copies - 1,
      total_issues = total_issues + 1,
      last_issued_date = NEW.issue_date
  WHERE id = NEW.book_id;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_book_availability_on_issue"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_book_availability_on_return"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Increase available copies when book is returned
  IF NEW.return_date IS NOT NULL AND OLD.return_date IS NULL THEN
    UPDATE library_books 
    SET available_copies = available_copies + 1
    WHERE id = NEW.book_id;
    
    -- Archive to history
    INSERT INTO library_history (
      book_id, book_title, book_author, book_isbn, book_category,
      student_id, student_name, roll_number, email, department_id, academic_year,
      issue_date, due_date, return_date, days_overdue,
      fine_amount, fine_paid, fine_waived,
      issue_condition, return_condition, damage_charges,
      status, renewal_count,
      issued_by, issued_by_name, returned_to, returned_to_name,
      remarks
    )
    SELECT 
      lb.id, lb.title, lb.author, lb.isbn, lb.category,
      NEW.student_id, NEW.student_name, NEW.roll_number, NEW.email, NEW.department_id, NEW.academic_year,
      NEW.issue_date, NEW.due_date, NEW.return_date, NEW.days_overdue,
      NEW.fine_amount, NEW.fine_paid, NEW.fine_waived,
      NEW.issue_condition, NEW.return_condition, NEW.damage_charges,
      NEW.status, NEW.renewal_count,
      NEW.issued_by, u1.name, NEW.returned_to, u2.name,
      NEW.return_remarks
    FROM library_books lb
    LEFT JOIN users u1 ON u1.id = NEW.issued_by
    LEFT JOIN users u2 ON u2.id = NEW.returned_to
    WHERE lb.id = NEW.book_id;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_book_availability_on_return"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_book_availability_school"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- If inserting a new issue (book being issued)
    IF TG_OP = 'INSERT' AND NEW.status = 'issued' THEN
        UPDATE library_books_school 
        SET available_copies = available_copies - 1,
            status = CASE 
                WHEN available_copies - 1 = 0 THEN 'all_issued'
                ELSE 'available'
            END
        WHERE id = NEW.book_id AND school_id = NEW.school_id;
        
    -- If updating an issue (book being returned)
    ELSIF TG_OP = 'UPDATE' AND OLD.status = 'issued' AND NEW.status = 'returned' THEN
        UPDATE library_books_school 
        SET available_copies = available_copies + 1,
            status = 'available'
        WHERE id = NEW.book_id AND school_id = NEW.school_id;
        
    -- If deleting an issue record (cleanup)
    ELSIF TG_OP = 'DELETE' AND OLD.status = 'issued' THEN
        UPDATE library_books_school 
        SET available_copies = available_copies + 1,
            status = 'available'
        WHERE id = OLD.book_id AND school_id = OLD.school_id;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."update_book_availability_school"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_book_rating"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  UPDATE library_books
  SET average_rating = (
    SELECT ROUND(AVG(rating)::numeric, 1)
    FROM library_reviews
    WHERE book_id = NEW.book_id AND is_approved = TRUE
  ),
  total_reviews = (
    SELECT COUNT(*)
    FROM library_reviews
    WHERE book_id = NEW.book_id AND is_approved = TRUE
  )
  WHERE id = NEW.book_id;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_book_rating"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_budget_on_expenditure"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  budget_head_index INTEGER;
  current_heads JSONB;
  updated_heads JSONB;
BEGIN
  -- Only update when expenditure is approved
  IF NEW.status = 'approved' AND (OLD.status IS NULL OR OLD.status != 'approved') THEN
    -- Update total spent in budget
    UPDATE department_budgets
    SET total_spent = total_spent + NEW.total_amount
    WHERE id = NEW.budget_id;
    
    -- Update specific budget head
    SELECT budget_heads INTO current_heads
    FROM department_budgets
    WHERE id = NEW.budget_id;
    
    -- Find and update the specific budget head
    updated_heads := (
      SELECT jsonb_agg(
        CASE 
          WHEN elem->>'head' = NEW.budget_head_name 
          THEN jsonb_set(
            elem,
            '{spent}',
            to_jsonb(COALESCE((elem->>'spent')::numeric, 0) + NEW.total_amount)
          )
          ELSE elem
        END
      )
      FROM jsonb_array_elements(current_heads) elem
    );
    
    UPDATE department_budgets
    SET budget_heads = updated_heads
    WHERE id = NEW.budget_id;
    
    -- Check for budget alerts
    PERFORM check_budget_alerts(NEW.budget_id, NEW.budget_head_name);
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_budget_on_expenditure"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_certificates_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = TIMEZONE('utc'::text, NOW());
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_certificates_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_college_circulars_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_college_circulars_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_college_events_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_college_events_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_college_lesson_plans_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_college_lesson_plans_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_conversation_on_message"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Update conversation with last message info
    UPDATE conversations
    SET 
        last_message_at = NEW.created_at,
        last_message_preview = LEFT(NEW.message_text, 100),
        last_message_sender = NEW.sender_id::TEXT,
        updated_at = NOW()
    WHERE id = NEW.conversation_id;

    -- Increment unread count for receiver
    IF NEW.receiver_type = 'student' THEN
        UPDATE conversations
        SET student_unread_count = student_unread_count + 1
        WHERE id = NEW.conversation_id;
    ELSE
        UPDATE conversations
        SET recruiter_unread_count = recruiter_unread_count + 1
        WHERE id = NEW.conversation_id;
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_conversation_on_message"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_conversation_unread_count"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Update unread count based on receiver type
    IF NEW.receiver_type = 'student' THEN
        UPDATE conversations 
        SET student_unread_count = student_unread_count + 1,
            last_message_at = NEW.created_at,
            last_message_preview = LEFT(NEW.message_text, 100),
            last_message_sender = NEW.sender_type,
            updated_at = NEW.created_at
        WHERE id = NEW.conversation_id;
    ELSIF NEW.receiver_type = 'recruiter' THEN
        UPDATE conversations 
        SET recruiter_unread_count = recruiter_unread_count + 1,
            last_message_at = NEW.created_at,
            last_message_preview = LEFT(NEW.message_text, 100),
            last_message_sender = NEW.sender_type,
            updated_at = NEW.created_at
        WHERE id = NEW.conversation_id;
    ELSIF NEW.receiver_type = 'educator' THEN
        UPDATE conversations 
        SET educator_unread_count = educator_unread_count + 1,
            last_message_at = NEW.created_at,
            last_message_preview = LEFT(NEW.message_text, 100),
            last_message_sender = NEW.sender_type,
            updated_at = NEW.created_at
        WHERE id = NEW.conversation_id;
    ELSIF NEW.receiver_type = 'school_admin' THEN
        UPDATE conversations 
        SET admin_unread_count = admin_unread_count + 1,
            last_message_at = NEW.created_at,
            last_message_preview = LEFT(NEW.message_text, 100),
            last_message_sender = NEW.sender_type,
            updated_at = NEW.created_at
        WHERE id = NEW.conversation_id;
    ELSIF NEW.receiver_type = 'college_admin' THEN
        UPDATE conversations 
        SET college_admin_unread_count = college_admin_unread_count + 1,
            last_message_at = NEW.created_at,
            last_message_preview = LEFT(NEW.message_text, 100),
            last_message_sender = NEW.sender_type,
            updated_at = NEW.created_at
        WHERE id = NEW.conversation_id;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_conversation_unread_count"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_curriculum_last_modified"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_curriculum_id UUID;
BEGIN
  -- Determine curriculum_id based on which table triggered this
  IF TG_TABLE_NAME = 'curriculum_chapters' THEN
    -- For curriculum_chapters, use curriculum_id directly
    v_curriculum_id := COALESCE(NEW.curriculum_id, OLD.curriculum_id);
  ELSIF TG_TABLE_NAME = 'curriculum_learning_outcomes' THEN
    -- For curriculum_learning_outcomes, get curriculum_id via chapter_id
    SELECT curriculum_id INTO v_curriculum_id
    FROM curriculum_chapters
    WHERE id = COALESCE(NEW.chapter_id, OLD.chapter_id);
  END IF;
  
  -- Update last_modified on parent curriculum
  IF v_curriculum_id IS NOT NULL THEN
    UPDATE curriculums 
    SET last_modified = NOW() 
    WHERE id = v_curriculum_id;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."update_curriculum_last_modified"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_departments_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_departments_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_email_tracking_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_email_tracking_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_external_assessment_attempts_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_external_assessment_attempts_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_grade_on_program_mapping"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    program_degree_level VARCHAR;
BEGIN
    -- Only proceed if program_id is being set or changed
    IF NEW.program_id IS NOT NULL AND (OLD.program_id IS NULL OR OLD.program_id != NEW.program_id) THEN
        -- Get the degree level from the program
        SELECT degree_level INTO program_degree_level
        FROM programs
        WHERE id = NEW.program_id;
        
        -- Map degree level to grade
        -- Undergraduate programs (BBA, BCA, BSC, etc.) = After 12th
        -- Postgraduate programs (MBA, MCA, MSC, etc.) = After graduation
        IF program_degree_level IS NOT NULL THEN
            CASE program_degree_level
                WHEN 'Undergraduate' THEN
                    NEW.grade := 'UG'; -- Undergraduate (After 12th)
                WHEN 'Postgraduate' THEN
                    NEW.grade := 'PG'; -- Postgraduate
                WHEN 'Diploma' THEN
                    NEW.grade := 'Diploma'; -- Diploma (can be after 10th or 12th)
                WHEN 'Certificate' THEN
                    NEW.grade := 'Certificate';
                ELSE
                    NEW.grade := program_degree_level; -- Use as-is for other levels
            END CASE;
            
            -- Also set grade_start_date to current date if not already set
            IF NEW.grade_start_date IS NULL THEN
                NEW.grade_start_date := CURRENT_DATE;
            END IF;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_grade_on_program_mapping"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_grade_on_program_mapping"() IS 'Automatically updates student grade based on program degree_level when program_id is mapped. 
Undergraduate -> UG (After 12th), Postgraduate -> PG, etc. Also sets grade_start_date if not set.';



CREATE OR REPLACE FUNCTION "public"."update_ledger_overdue_status"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Update is_overdue based on current conditions
  IF NEW.payment_status IN ('paid', 'waived') THEN
    NEW.is_overdue := FALSE;
  ELSIF NEW.due_date < CURRENT_DATE AND (NEW.due_amount - NEW.paid_amount) > 0 THEN
    NEW.is_overdue := TRUE;
  ELSE
    NEW.is_overdue := FALSE;
  END IF;
  
  -- Auto-update payment_status based on amounts
  IF NEW.paid_amount >= NEW.due_amount THEN
    NEW.payment_status := 'paid';
  ELSIF NEW.paid_amount > 0 AND NEW.paid_amount < NEW.due_amount THEN
    NEW.payment_status := 'partial';
  ELSIF NEW.due_date < CURRENT_DATE AND NEW.paid_amount < NEW.due_amount THEN
    NEW.payment_status := 'overdue';
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_ledger_overdue_status"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_license_assignments_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_license_assignments_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_license_pools_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_license_pools_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_membership_attendance"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    UPDATE public.club_memberships cm
    SET 
        total_sessions_attended = (
            SELECT COUNT(*) 
            FROM public.club_attendance_records car
            JOIN public.club_attendance ca ON car.attendance_id = ca.attendance_id
            WHERE ca.club_id = cm.club_id 
            AND car.student_email = cm.student_email 
            AND car.status IN ('present', 'late')
        ),
        total_sessions_held = (
            SELECT COUNT(*) 
            FROM public.club_attendance ca
            WHERE ca.club_id = cm.club_id
            AND ca.session_date <= CURRENT_DATE
        ),
        attendance_percentage = CASE 
            WHEN (SELECT COUNT(*) FROM public.club_attendance ca WHERE ca.club_id = cm.club_id) > 0
            THEN (
                SELECT COUNT(*) * 100.0 / NULLIF((SELECT COUNT(*) FROM public.club_attendance ca WHERE ca.club_id = cm.club_id), 0)
                FROM public.club_attendance_records car
                JOIN public.club_attendance ca ON car.attendance_id = ca.attendance_id
                WHERE ca.club_id = cm.club_id 
                AND car.student_email = cm.student_email 
                AND car.status IN ('present', 'late')
            )
            ELSE 0
        END
    WHERE cm.club_id = (SELECT club_id FROM public.club_attendance WHERE attendance_id = NEW.attendance_id)
    AND cm.student_email = NEW.student_email;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_membership_attendance"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_mentor_note_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.last_updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_mentor_note_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_organization_invitations_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_organization_invitations_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_organization_subscriptions_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_organization_subscriptions_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_phone_otps_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_phone_otps_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_profile_array_item"("p_student_id" "uuid", "p_array_name" "text", "p_item_id" integer, "p_updates" "jsonb") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_profile JSONB;
  v_array JSONB;
  v_new_array JSONB := '[]'::jsonb;
  v_item JSONB;
BEGIN
  -- Get current profile
  SELECT profile INTO v_profile
  FROM students
  WHERE id = p_student_id;
  
  -- Get array
  v_array := v_profile -> p_array_name;
  
  -- Update matching item
  FOR v_item IN SELECT * FROM jsonb_array_elements(v_array)
  LOOP
    IF (v_item->>'id')::int = p_item_id THEN
      -- Merge updates with existing item
      v_item := v_item || p_updates;
    END IF;
    v_new_array := v_new_array || v_item;
  END LOOP;
  
  -- Update profile
  v_profile := jsonb_set(v_profile, ARRAY[p_array_name], v_new_array);
  
  -- Save and return
  UPDATE students SET profile = v_profile WHERE id = p_student_id;
  
  RETURN v_profile;
END;
$$;


ALTER FUNCTION "public"."update_profile_array_item"("p_student_id" "uuid", "p_array_name" "text", "p_item_id" integer, "p_updates" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_profile_array_item"("p_student_id" "uuid", "p_array_name" "text", "p_item_id" integer, "p_updates" "jsonb") IS 'Update an existing item in a JSONB array';



CREATE OR REPLACE FUNCTION "public"."update_question_usage"("p_question_id" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE adaptive_aptitude_questions_cache
  SET 
    usage_count = usage_count + 1,
    last_used_at = NOW()
  WHERE question_id = p_question_id;
END;
$$;


ALTER FUNCTION "public"."update_question_usage"("p_question_id" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_saved_jobs_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = TIMEZONE('utc'::text, NOW());
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_saved_jobs_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_section_enrollment_count"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF TG_OP = 'INSERT' AND NEW.section_id IS NOT NULL THEN
    UPDATE program_sections
    SET current_students = current_students + 1
    WHERE id = NEW.section_id;
  ELSIF TG_OP = 'DELETE' AND OLD.section_id IS NOT NULL THEN
    UPDATE program_sections
    SET current_students = GREATEST(0, current_students - 1)
    WHERE id = OLD.section_id;
  ELSIF TG_OP = 'UPDATE' AND OLD.section_id IS DISTINCT FROM NEW.section_id THEN
    IF OLD.section_id IS NOT NULL THEN
      UPDATE program_sections
      SET current_students = GREATEST(0, current_students - 1)
      WHERE id = OLD.section_id;
    END IF;
    IF NEW.section_id IS NOT NULL THEN
      UPDATE program_sections
      SET current_students = current_students + 1
      WHERE id = NEW.section_id;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_section_enrollment_count"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_session_attendance_stats"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Update attendance counts for the session
    UPDATE college_attendance_sessions 
    SET 
        present_count = (
            SELECT COUNT(*) FROM college_attendance_records 
            WHERE session_id = COALESCE(NEW.session_id, OLD.session_id) 
            AND status = 'present'
        ),
        absent_count = (
            SELECT COUNT(*) FROM college_attendance_records 
            WHERE session_id = COALESCE(NEW.session_id, OLD.session_id) 
            AND status = 'absent'
        ),
        late_count = (
            SELECT COUNT(*) FROM college_attendance_records 
            WHERE session_id = COALESCE(NEW.session_id, OLD.session_id) 
            AND status = 'late'
        ),
        excused_count = (
            SELECT COUNT(*) FROM college_attendance_records 
            WHERE session_id = COALESCE(NEW.session_id, OLD.session_id) 
            AND status = 'excused'
        ),
        updated_at = NOW()
    WHERE id = COALESCE(NEW.session_id, OLD.session_id);
    
    -- Calculate attendance percentage
    UPDATE college_attendance_sessions 
    SET attendance_percentage = CASE 
        WHEN total_students > 0 THEN 
            ROUND(((present_count + late_count + excused_count) * 100.0 / total_students), 2)
        ELSE 0 
    END
    WHERE id = COALESCE(NEW.session_id, OLD.session_id);
    
    RETURN COALESCE(NEW, OLD);
END;
$$;


ALTER FUNCTION "public"."update_session_attendance_stats"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_streak_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_streak_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_student_course_progress_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_student_course_progress_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_student_grade_on_promotion"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    -- Only update if student is promoted and to_grade is set
    IF NEW.is_promoted = true AND NEW.to_grade IS NOT NULL THEN
        UPDATE students
        SET 
            grade = NEW.to_grade,
            grade_start_date = COALESCE(NEW.promotion_date, CURRENT_DATE),
            updated_at = NOW()
        WHERE id = NEW.student_id;
        
        RAISE NOTICE 'Student % promoted from grade % to grade %', NEW.student_id, NEW.from_grade, NEW.to_grade;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_student_grade_on_promotion"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_student_grade_on_promotion"() IS 'Automatically updates student grade and grade_start_date when they are promoted to next class';



CREATE OR REPLACE FUNCTION "public"."update_student_promotions_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_student_promotions_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_student_streak"("p_student_id" "uuid", "p_activity_date" "date" DEFAULT CURRENT_DATE) RETURNS "jsonb"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_streak_record RECORD;
  v_new_streak INTEGER;
  v_new_longest INTEGER;
  v_result JSONB;
BEGIN
  -- Get current streak record
  SELECT * INTO v_streak_record
  FROM student_streaks
  WHERE student_id = p_student_id;

  -- If no record exists, create one
  IF NOT FOUND THEN
    INSERT INTO student_streaks (student_id, current_streak, longest_streak, last_activity_date, streak_completed_today)
    VALUES (p_student_id, 1, 1, p_activity_date, TRUE)
    RETURNING current_streak, longest_streak INTO v_new_streak, v_new_longest;

    RETURN jsonb_build_object(
      'success', TRUE,
      'current_streak', v_new_streak,
      'longest_streak', v_new_longest,
      'streak_broken', FALSE
    );
  END IF;

  -- Check if activity is for today
  IF p_activity_date = CURRENT_DATE THEN
    -- Check if already completed today
    IF v_streak_record.streak_completed_today = TRUE THEN
      RETURN jsonb_build_object(
        'success', TRUE,
        'current_streak', v_streak_record.current_streak,
        'longest_streak', v_streak_record.longest_streak,
        'streak_broken', FALSE,
        'message', 'Already completed today'
      );
    END IF;

    -- Check if this continues the streak
    IF v_streak_record.last_activity_date = CURRENT_DATE - INTERVAL '1 day'
       OR v_streak_record.last_activity_date = CURRENT_DATE
       OR v_streak_record.last_activity_date IS NULL THEN
      -- Continue streak
      v_new_streak := v_streak_record.current_streak + 1;
    ELSE
      -- Streak broken, restart
      v_new_streak := 1;
    END IF;

    -- Update longest streak if needed
    v_new_longest := GREATEST(v_streak_record.longest_streak, v_new_streak);

    -- Update the record
    UPDATE student_streaks
    SET
      current_streak = v_new_streak,
      longest_streak = v_new_longest,
      last_activity_date = p_activity_date,
      streak_completed_today = TRUE
    WHERE student_id = p_student_id;

    RETURN jsonb_build_object(
      'success', TRUE,
      'current_streak', v_new_streak,
      'longest_streak', v_new_longest,
      'streak_broken', v_new_streak = 1 AND v_streak_record.current_streak > 1
    );
  END IF;

  -- If activity is not for today, just return current state
  RETURN jsonb_build_object(
    'success', FALSE,
    'message', 'Activity date is not today',
    'current_streak', v_streak_record.current_streak,
    'longest_streak', v_streak_record.longest_streak
  );
END;
$$;


ALTER FUNCTION "public"."update_student_streak"("p_student_id" "uuid", "p_activity_date" "date") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."update_student_streak"("p_student_id" "uuid", "p_activity_date" "date") IS 'Updates a student''s streak when they complete an activity';



CREATE OR REPLACE FUNCTION "public"."update_students_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW."updatedAt" = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_students_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_subscription_plans_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_subscription_plans_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_swap_request_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_swap_request_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_timestamp"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_tutor_conversations_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_tutor_conversations_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."user_has_license_for_org_subscription"("org_sub_id" "uuid") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    AS $$
  SELECT EXISTS (
    SELECT 1 FROM license_assignments la
    WHERE la.organization_subscription_id = org_sub_id
    AND la.user_id = auth.uid()
    AND la.status = 'active'
  );
$$;


ALTER FUNCTION "public"."user_has_license_for_org_subscription"("org_sub_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validateOneActiveEnrollment"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    v_activeCount INTEGER;
BEGIN
    -- Count active enrollments for this student
    SELECT COUNT(*) INTO v_activeCount
    FROM "studentEnrollments"
    WHERE "studentId" = NEW."studentId"
    AND "enrollmentStatus" = 'active'
    AND id != NEW.id;  -- Exclude current enrollment being updated/inserted

    -- If trying to add/update to active and there's already an active enrollment
    IF NEW."enrollmentStatus" = 'active' AND v_activeCount > 0 THEN
        RAISE EXCEPTION 'Student already has an active enrollment. Only one active enrollment allowed per student.';
    END IF;

    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."validateOneActiveEnrollment"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_aadhar_number"("aadhar_num" "text") RETURNS boolean
    LANGUAGE "plpgsql"
    AS $_$
BEGIN
  -- Check if it's exactly 12 digits
  IF aadhar_num IS NULL OR LENGTH(aadhar_num) != 12 THEN
    RETURN FALSE;
  END IF;
  
  -- Check if all characters are digits
  IF aadhar_num !~ '^[0-9]{12}$' THEN
    RETURN FALSE;
  END IF;
  
  -- Basic Aadhar validation: first digit cannot be 0 or 1
  IF SUBSTRING(aadhar_num, 1, 1) IN ('0', '1') THEN
    RETURN FALSE;
  END IF;
  
  RETURN TRUE;
END;
$_$;


ALTER FUNCTION "public"."validate_aadhar_number"("aadhar_num" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_curriculum"("p_curriculum_id" "uuid") RETURNS TABLE("is_valid" boolean, "validation_errors" "jsonb")
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_errors JSONB := '[]'::jsonb;
  v_chapter_count INTEGER;
  v_outcome_count INTEGER;
  v_outcomes_without_assessments INTEGER;
BEGIN
  -- Check if curriculum has chapters
  SELECT COUNT(*) INTO v_chapter_count
  FROM curriculum_chapters
  WHERE curriculum_id = p_curriculum_id;
  
  IF v_chapter_count = 0 THEN
    v_errors := v_errors || jsonb_build_object('field', 'chapters', 'message', 'At least one chapter is required');
  END IF;
  
  -- Check if curriculum has learning outcomes
  SELECT COUNT(*) INTO v_outcome_count
  FROM curriculum_learning_outcomes clo
  JOIN curriculum_chapters cc ON clo.chapter_id = cc.id
  WHERE cc.curriculum_id = p_curriculum_id;
  
  IF v_outcome_count = 0 THEN
    v_errors := v_errors || jsonb_build_object('field', 'outcomes', 'message', 'Learning Outcomes cannot be empty');
  END IF;
  
  -- Check if all outcomes have at least one assessment mapping
  SELECT COUNT(*) INTO v_outcomes_without_assessments
  FROM curriculum_learning_outcomes clo
  JOIN curriculum_chapters cc ON clo.chapter_id = cc.id
  WHERE cc.curriculum_id = p_curriculum_id
  AND NOT EXISTS (
    SELECT 1 FROM outcome_assessment_mappings oam
    WHERE oam.learning_outcome_id = clo.id
  );
  
  IF v_outcomes_without_assessments > 0 THEN
    v_errors := v_errors || jsonb_build_object(
      'field', 'assessments', 
      'message', v_outcomes_without_assessments || ' learning outcome(s) missing assessment mappings'
    );
  END IF;
  
  RETURN QUERY SELECT 
    jsonb_array_length(v_errors) = 0 AS is_valid,
    v_errors AS validation_errors;
END;
$$;


ALTER FUNCTION "public"."validate_curriculum"("p_curriculum_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_evaluation_items"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  total_percentage NUMERIC;
BEGIN
  -- Calculate total percentage from evaluation_items
  IF NEW.evaluation_items IS NOT NULL AND jsonb_array_length(NEW.evaluation_items) > 0 THEN
    SELECT SUM((item->>'percentage')::NUMERIC)
    INTO total_percentage
    FROM jsonb_array_elements(NEW.evaluation_items) AS item;
    
    -- Check if total exceeds 100%
    IF total_percentage > 100 THEN
      RAISE EXCEPTION 'Total evaluation percentage cannot exceed 100%%. Current total: %', total_percentage;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."validate_evaluation_items"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_pool_allocation"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  total_allocated INTEGER;
  subscription_seats INTEGER;
BEGIN
  -- Get total allocated seats across all pools for this subscription
  SELECT COALESCE(SUM(allocated_seats), 0) INTO total_allocated
  FROM license_pools
  WHERE organization_subscription_id = NEW.organization_subscription_id
    AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::UUID);
  
  -- Get total seats from subscription
  SELECT total_seats INTO subscription_seats
  FROM organization_subscriptions
  WHERE id = NEW.organization_subscription_id;
  
  -- Check if total allocation exceeds subscription seats
  IF (total_allocated + NEW.allocated_seats) > subscription_seats THEN
    RAISE EXCEPTION 'Total pool allocation (%) exceeds subscription seats (%)', 
      (total_allocated + NEW.allocated_seats), subscription_seats;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."validate_pool_allocation"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_seat_availability"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  available INTEGER;
BEGIN
  IF TG_OP = 'INSERT' AND NEW.status = 'active' THEN
    SELECT available_seats INTO available
    FROM license_pools
    WHERE id = NEW.license_pool_id;
    
    IF available <= 0 THEN
      RAISE EXCEPTION 'No available seats in license pool. Available: %, Requested: 1', available;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."validate_seat_availability"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_student_competition_school"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    comp_school_id UUID;
    student_school_id UUID;
BEGIN
    -- Get the school_id from the competition
    SELECT school_id INTO comp_school_id
    FROM public.competitions
    WHERE comp_id = NEW.comp_id;
    
    -- Get the school_id from the student
    SELECT school_id INTO student_school_id
    FROM public.students
    WHERE email = NEW.student_email;
    
    -- Check if student has a school_id
    IF student_school_id IS NULL THEN
        RAISE EXCEPTION 'Student % does not belong to any school', NEW.student_email;
    END IF;
    
    -- Check if schools match
    IF comp_school_id != student_school_id THEN
        RAISE EXCEPTION 'Student % (school: %) cannot register for competition from different school (%)', 
            NEW.student_email, student_school_id, comp_school_id;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."validate_student_competition_school"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_student_school_match"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    club_school_id UUID;
    student_school_id UUID;
BEGIN
    -- Get the school_id from the club
    SELECT school_id INTO club_school_id
    FROM public.clubs
    WHERE club_id = NEW.club_id;
    
    -- Get the school_id from the student
    SELECT school_id INTO student_school_id
    FROM public.students
    WHERE email = NEW.student_email;
    
    -- Check if student has a school_id
    IF student_school_id IS NULL THEN
        RAISE EXCEPTION 'Student % does not belong to any school', NEW.student_email;
    END IF;
    
    -- Check if schools match
    IF club_school_id != student_school_id THEN
        RAISE EXCEPTION 'Student % (school: %) cannot join club from different school (%)', 
            NEW.student_email, student_school_id, club_school_id;
    END IF;
    
    RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."validate_student_school_match"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."validate_subscription_status_transition"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  old_status subscription_status;
  new_status subscription_status;
BEGIN
  old_status := OLD.status;
  new_status := NEW.status;
  
  -- If status hasn't changed, allow it
  IF old_status = new_status THEN
    RETURN NEW;
  END IF;
  
  -- Define invalid transitions
  -- Expired subscriptions cannot be reactivated
  IF old_status = 'expired' AND new_status IN ('active', 'pending') THEN
    RAISE EXCEPTION 'Cannot reactivate expired subscription. Create a new subscription instead.'
      USING HINT = 'Create new subscription',
            ERRCODE = '23514'; -- check_violation
  END IF;
  
  -- Cancelled subscriptions can only go to expired
  IF old_status = 'cancelled' AND new_status NOT IN ('expired', 'cancelled') THEN
    RAISE EXCEPTION 'Cancelled subscription can only transition to expired status'
      USING HINT = 'Create new subscription to reactivate',
            ERRCODE = '23514';
  END IF;
  
  -- Pending can only go to active or expired
  IF old_status = 'pending' AND new_status NOT IN ('active', 'expired', 'pending') THEN
    RAISE EXCEPTION 'Pending subscription can only become active or expired'
      USING HINT = 'Invalid status transition',
            ERRCODE = '23514';
  END IF;
  
  -- Log the transition (optional - good for debugging)
  RAISE NOTICE 'Subscription status transition: % â†’ % for user %', 
    old_status, new_status, NEW.user_id;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."validate_subscription_status_transition"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."validate_subscription_status_transition"() IS 'Ensures valid subscription status state transitions';



CREATE TABLE IF NOT EXISTS "public"."adaptive_aptitude_questions_cache" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "question_id" "text" NOT NULL,
    "text" "text" NOT NULL,
    "options" "jsonb" NOT NULL,
    "correct_answer" character(1) NOT NULL,
    "difficulty" smallint NOT NULL,
    "subtag" "public"."question_subtag" NOT NULL,
    "grade_level" "public"."grade_level" NOT NULL,
    "phase" "public"."test_phase" NOT NULL,
    "explanation" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "last_used_at" timestamp with time zone,
    "usage_count" integer DEFAULT 0 NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    CONSTRAINT "adaptive_aptitude_questions_cache_correct_answer_check" CHECK (("correct_answer" = ANY (ARRAY['A'::"bpchar", 'B'::"bpchar", 'C'::"bpchar", 'D'::"bpchar"]))),
    CONSTRAINT "adaptive_aptitude_questions_cache_difficulty_check" CHECK ((("difficulty" >= 1) AND ("difficulty" <= 5))),
    CONSTRAINT "valid_options" CHECK ((("options" ? 'A'::"text") AND ("options" ? 'B'::"text") AND ("options" ? 'C'::"text") AND ("options" ? 'D'::"text")))
);


ALTER TABLE "public"."adaptive_aptitude_questions_cache" OWNER TO "postgres";


COMMENT ON TABLE "public"."adaptive_aptitude_questions_cache" IS 'Caches AI-generated questions for reuse across test sessions';



COMMENT ON COLUMN "public"."adaptive_aptitude_questions_cache"."question_id" IS 'Unique identifier for the question, used for deduplication';



COMMENT ON COLUMN "public"."adaptive_aptitude_questions_cache"."options" IS 'JSON object with answer options A, B, C, D';



COMMENT ON COLUMN "public"."adaptive_aptitude_questions_cache"."usage_count" IS 'Number of times this question has been used in tests';



COMMENT ON COLUMN "public"."adaptive_aptitude_questions_cache"."is_active" IS 'Whether this question is available for use (can be deactivated if quality issues found)';



CREATE TABLE IF NOT EXISTS "public"."adaptive_aptitude_responses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "session_id" "uuid" NOT NULL,
    "question_id" "text" NOT NULL,
    "selected_answer" character(1) NOT NULL,
    "is_correct" boolean NOT NULL,
    "response_time_ms" integer NOT NULL,
    "difficulty_at_time" smallint NOT NULL,
    "subtag" "public"."question_subtag" NOT NULL,
    "phase" "public"."test_phase" NOT NULL,
    "sequence_number" integer NOT NULL,
    "answered_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "question_text" "text",
    "question_options" "jsonb",
    "correct_answer" character(1),
    "explanation" "text",
    CONSTRAINT "adaptive_aptitude_responses_difficulty_at_time_check" CHECK ((("difficulty_at_time" >= 1) AND ("difficulty_at_time" <= 5))),
    CONSTRAINT "adaptive_aptitude_responses_response_time_ms_check" CHECK (("response_time_ms" >= 0)),
    CONSTRAINT "adaptive_aptitude_responses_selected_answer_check" CHECK (("selected_answer" = ANY (ARRAY['A'::"bpchar", 'B'::"bpchar", 'C'::"bpchar", 'D'::"bpchar"]))),
    CONSTRAINT "adaptive_aptitude_responses_sequence_number_check" CHECK (("sequence_number" > 0))
);


ALTER TABLE "public"."adaptive_aptitude_responses" OWNER TO "postgres";


COMMENT ON TABLE "public"."adaptive_aptitude_responses" IS 'Records individual question responses with timing and context for analytics';



COMMENT ON COLUMN "public"."adaptive_aptitude_responses"."response_time_ms" IS 'Time taken to answer in milliseconds';



COMMENT ON COLUMN "public"."adaptive_aptitude_responses"."difficulty_at_time" IS 'Difficulty level when question was presented';



COMMENT ON COLUMN "public"."adaptive_aptitude_responses"."sequence_number" IS '1-based sequence number within the test session';



CREATE TABLE IF NOT EXISTS "public"."adaptive_aptitude_results" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "session_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "aptitude_level" smallint NOT NULL,
    "confidence_tag" "public"."confidence_tag" NOT NULL,
    "tier" "public"."tier_classification" NOT NULL,
    "total_questions" integer NOT NULL,
    "total_correct" integer NOT NULL,
    "overall_accuracy" numeric(5,2) NOT NULL,
    "accuracy_by_difficulty" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "accuracy_by_subtag" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "difficulty_path" smallint[] NOT NULL,
    "path_classification" "public"."path_classification" NOT NULL,
    "average_response_time_ms" integer NOT NULL,
    "grade_level" "public"."grade_level" NOT NULL,
    "completed_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "adaptive_aptitude_results_aptitude_level_check" CHECK ((("aptitude_level" >= 1) AND ("aptitude_level" <= 5))),
    CONSTRAINT "adaptive_aptitude_results_average_response_time_ms_check" CHECK (("average_response_time_ms" >= 0)),
    CONSTRAINT "adaptive_aptitude_results_check" CHECK ((("total_correct" >= 0) AND ("total_correct" <= "total_questions"))),
    CONSTRAINT "adaptive_aptitude_results_overall_accuracy_check" CHECK ((("overall_accuracy" >= (0)::numeric) AND ("overall_accuracy" <= (100)::numeric))),
    CONSTRAINT "adaptive_aptitude_results_total_questions_check" CHECK (("total_questions" > 0))
);


ALTER TABLE "public"."adaptive_aptitude_results" OWNER TO "postgres";


COMMENT ON TABLE "public"."adaptive_aptitude_results" IS 'Stores final adaptive aptitude test results with comprehensive analytics';



COMMENT ON COLUMN "public"."adaptive_aptitude_results"."aptitude_level" IS 'Final aptitude level (1-5) determined by the adaptive algorithm';



COMMENT ON COLUMN "public"."adaptive_aptitude_results"."accuracy_by_difficulty" IS 'JSON object with accuracy breakdown by difficulty level (1-5)';



COMMENT ON COLUMN "public"."adaptive_aptitude_results"."accuracy_by_subtag" IS 'JSON object with accuracy breakdown by question subtag';



COMMENT ON COLUMN "public"."adaptive_aptitude_results"."path_classification" IS 'Classification of difficulty path: ascending, descending, stable, or fluctuating';



COMMENT ON COLUMN "public"."adaptive_aptitude_results"."metadata" IS 'Stores test metadata including duplicate validation results. 
Format: {
  "duplicateValidation": {
    "isValid": boolean,
    "duplicates": [{"questionId": string, "sequences": number[]}]
  }
}';



CREATE TABLE IF NOT EXISTS "public"."adaptive_aptitude_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "grade_level" "public"."grade_level" NOT NULL,
    "current_phase" "public"."test_phase" DEFAULT 'diagnostic_screener'::"public"."test_phase" NOT NULL,
    "tier" "public"."tier_classification",
    "current_difficulty" smallint DEFAULT 3 NOT NULL,
    "difficulty_path" smallint[] DEFAULT ARRAY[]::smallint[] NOT NULL,
    "questions_answered" integer DEFAULT 0 NOT NULL,
    "correct_answers" integer DEFAULT 0 NOT NULL,
    "current_question_index" integer DEFAULT 0 NOT NULL,
    "current_phase_questions" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "provisional_band" smallint,
    "status" "public"."session_status" DEFAULT 'in_progress'::"public"."session_status" NOT NULL,
    "started_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "completed_at" timestamp with time zone,
    CONSTRAINT "adaptive_aptitude_sessions_current_difficulty_check" CHECK ((("current_difficulty" >= 1) AND ("current_difficulty" <= 5))),
    CONSTRAINT "adaptive_aptitude_sessions_provisional_band_check" CHECK ((("provisional_band" IS NULL) OR (("provisional_band" >= 1) AND ("provisional_band" <= 5)))),
    CONSTRAINT "valid_correct_answers" CHECK ((("correct_answers" >= 0) AND ("correct_answers" <= "questions_answered"))),
    CONSTRAINT "valid_question_index" CHECK (("current_question_index" >= 0)),
    CONSTRAINT "valid_questions_answered" CHECK (("questions_answered" >= 0))
);


ALTER TABLE "public"."adaptive_aptitude_sessions" OWNER TO "postgres";


COMMENT ON TABLE "public"."adaptive_aptitude_sessions" IS 'Tracks adaptive aptitude test sessions with phase progression and difficulty adaptation';



COMMENT ON COLUMN "public"."adaptive_aptitude_sessions"."tier" IS 'Tier classification (L/M/H) determined after diagnostic screener phase';



COMMENT ON COLUMN "public"."adaptive_aptitude_sessions"."difficulty_path" IS 'Array tracking difficulty level at each question for analytics';



COMMENT ON COLUMN "public"."adaptive_aptitude_sessions"."provisional_band" IS 'Provisional aptitude band updated during adaptive core phase';



CREATE TABLE IF NOT EXISTS "public"."addon_discount_codes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" character varying(50) NOT NULL,
    "discount_type" character varying(20) NOT NULL,
    "discount_value" numeric(10,2) NOT NULL,
    "applicable_feature_keys" "text"[],
    "applicable_bundle_ids" "uuid"[],
    "max_uses" integer,
    "current_uses" integer DEFAULT 0,
    "valid_from" timestamp with time zone NOT NULL,
    "valid_until" timestamp with time zone NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "addon_discount_codes_discount_type_check" CHECK ((("discount_type")::"text" = ANY (ARRAY[('percentage'::character varying)::"text", ('fixed'::character varying)::"text"])))
);


ALTER TABLE "public"."addon_discount_codes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."addon_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "event_type" character varying(50) NOT NULL,
    "feature_key" "text",
    "bundle_id" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "addon_events_event_type_check" CHECK ((("event_type")::"text" = ANY (ARRAY[('view'::character varying)::"text", ('purchase'::character varying)::"text", ('activation'::character varying)::"text", ('cancellation'::character varying)::"text", ('renewal'::character varying)::"text", ('expiry'::character varying)::"text", ('upgrade_prompt'::character varying)::"text"])))
);


ALTER TABLE "public"."addon_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."addon_pending_orders" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "addon_feature_key" "text" NOT NULL,
    "razorpay_order_id" character varying(100) NOT NULL,
    "razorpay_payment_id" character varying(100),
    "amount" numeric(10,2) NOT NULL,
    "currency" character varying(10) DEFAULT 'INR'::character varying,
    "billing_period" character varying(10) NOT NULL,
    "status" character varying(20) DEFAULT 'pending'::character varying NOT NULL,
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "organization_id" "uuid",
    "target_member_type" "text",
    "target_member_ids" "uuid"[] DEFAULT '{}'::"uuid"[],
    "is_bulk_order" boolean DEFAULT false,
    CONSTRAINT "addon_pending_orders_billing_period_check" CHECK ((("billing_period")::"text" = ANY (ARRAY[('monthly'::character varying)::"text", ('annual'::character varying)::"text"]))),
    CONSTRAINT "addon_pending_orders_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('completed'::character varying)::"text", ('failed'::character varying)::"text", ('expired'::character varying)::"text"]))),
    CONSTRAINT "addon_pending_orders_target_member_type_check" CHECK (("target_member_type" = ANY (ARRAY['school_student'::"text", 'school_educator'::"text", 'college_student'::"text", 'college_educator'::"text", 'all'::"text"]))),
    CONSTRAINT "check_bulk_order_has_org" CHECK (((("is_bulk_order" = true) AND ("organization_id" IS NOT NULL)) OR ("is_bulk_order" = false))),
    CONSTRAINT "check_bulk_order_has_targets" CHECK (((("is_bulk_order" = true) AND (("target_member_type" IS NOT NULL) OR ("array_length"("target_member_ids", 1) > 0))) OR ("is_bulk_order" = false)))
);


ALTER TABLE "public"."addon_pending_orders" OWNER TO "postgres";


COMMENT ON COLUMN "public"."addon_pending_orders"."organization_id" IS 'ID of the organization making the bulk add-on purchase';



COMMENT ON COLUMN "public"."addon_pending_orders"."target_member_type" IS 'Type of members to receive the add-ons (school_student, school_educator, etc.)';



COMMENT ON COLUMN "public"."addon_pending_orders"."target_member_ids" IS 'Specific member user IDs to receive the add-ons';



COMMENT ON COLUMN "public"."addon_pending_orders"."is_bulk_order" IS 'Flag indicating if this is an organization bulk add-on order';



CREATE TABLE IF NOT EXISTS "public"."admin_users" (
    "id" "uuid" NOT NULL,
    "admin_role" "text" NOT NULL,
    "granted_by" "uuid",
    "granted_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "admin_users_admin_role_check" CHECK (("admin_role" = ANY (ARRAY['super_admin'::"text", 'platform_admin'::"text"])))
);


ALTER TABLE "public"."admin_users" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."admission_applications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "school_id" "uuid" NOT NULL,
    "application_number" "text" NOT NULL,
    "student_name" "text" NOT NULL,
    "date_of_birth" "date" NOT NULL,
    "gender" "text",
    "aadhar_number" "text",
    "passport_number" "text",
    "email" "text" NOT NULL,
    "phone" "text" NOT NULL,
    "father_name" "text" NOT NULL,
    "father_occupation" "text",
    "father_phone" "text",
    "father_email" "text",
    "mother_name" "text" NOT NULL,
    "mother_occupation" "text",
    "mother_phone" "text",
    "guardian_name" "text",
    "guardian_relation" "text",
    "guardian_phone" "text",
    "address" "text" NOT NULL,
    "city" "text" NOT NULL,
    "state" "text" NOT NULL,
    "pincode" "text" NOT NULL,
    "previous_school" "text",
    "previous_class" "text",
    "previous_board" "text",
    "documents" "jsonb" DEFAULT '{}'::"jsonb",
    "status" "text" DEFAULT 'pending'::"text",
    "applied_for" "text" NOT NULL,
    "applied_date" timestamp with time zone DEFAULT "now"(),
    "verified_by" "uuid",
    "verified_date" timestamp with time zone,
    "enrollment_number" "text",
    "fee_status" "text" DEFAULT 'pending'::"text",
    "fee_amount" numeric(10,2),
    "fee_paid" numeric(10,2) DEFAULT 0,
    "remarks" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "admission_applications_fee_status_check" CHECK (("fee_status" = ANY (ARRAY['pending'::"text", 'partial'::"text", 'paid'::"text"]))),
    CONSTRAINT "admission_applications_gender_check" CHECK (("gender" = ANY (ARRAY['male'::"text", 'female'::"text", 'other'::"text"]))),
    CONSTRAINT "admission_applications_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'document_verification'::"text", 'fee_payment'::"text", 'approved'::"text", 'rejected'::"text"])))
);


ALTER TABLE "public"."admission_applications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."ai_evaluations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "conversation_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "message_id" "text" NOT NULL,
    "user_message" "text" NOT NULL,
    "ai_response" "text" NOT NULL,
    "detected_intent" "text",
    "intent_confidence" "text",
    "conversation_phase" "text",
    "thumbs_up" boolean,
    "user_rating" integer,
    "user_feedback" "text",
    "response_time_ms" integer,
    "model_used" "text" DEFAULT 'openai/gpt-4o-mini'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "feedback_at" timestamp with time zone,
    CONSTRAINT "ai_evaluations_user_rating_check" CHECK ((("user_rating" IS NULL) OR (("user_rating" >= 1) AND ("user_rating" <= 5))))
);


ALTER TABLE "public"."ai_evaluations" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_evaluations" IS 'Stores user feedback on Career AI responses for quality improvement';



CREATE TABLE IF NOT EXISTS "public"."app_config" (
    "key" "text" NOT NULL,
    "value" "text" NOT NULL
);


ALTER TABLE "public"."app_config" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."applied_jobs" (
    "id_old" integer,
    "student_id" "uuid" NOT NULL,
    "opportunity_id_old" integer,
    "application_status" "text" DEFAULT 'applied'::"text" NOT NULL,
    "applied_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "viewed_at" timestamp with time zone,
    "responded_at" timestamp with time zone,
    "interview_scheduled_at" timestamp with time zone,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "opportunity_id" "uuid" NOT NULL,
    CONSTRAINT "check_application_status" CHECK (("application_status" = ANY (ARRAY['applied'::"text", 'viewed'::"text", 'under_review'::"text", 'interview_scheduled'::"text", 'interviewed'::"text", 'offer_received'::"text", 'accepted'::"text", 'rejected'::"text", 'withdrawn'::"text"])))
);


ALTER TABLE "public"."applied_jobs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."applied_jobs_backup_migration" (
    "id" integer,
    "student_id" "uuid",
    "opportunity_id" integer,
    "application_status" "text",
    "applied_at" timestamp with time zone,
    "viewed_at" timestamp with time zone,
    "responded_at" timestamp with time zone,
    "interview_scheduled_at" timestamp with time zone,
    "notes" "text",
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone
);


ALTER TABLE "public"."applied_jobs_backup_migration" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."approval_actions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "request_id" "uuid",
    "approver_id" "uuid",
    "action" "public"."approval_status" NOT NULL,
    "comment" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."approval_actions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."approval_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid",
    "requester_id" "uuid",
    "status" "public"."approval_status" DEFAULT 'pending'::"public"."approval_status",
    "request_data" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."approval_requests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."approval_types" (
    "name" character varying(100) NOT NULL,
    "description" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."approval_types" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."approval_workflows" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "approval_type" character varying(100),
    "name" character varying(255) NOT NULL,
    "description" "text",
    "required_approvers" integer DEFAULT 1 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."approval_workflows" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."assessment_types" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(100) NOT NULL,
    "description" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"(),
    "institution_id" "uuid",
    "institution_type" character varying(20),
    CONSTRAINT "assessment_types_institution_type_check" CHECK ((("institution_type")::"text" = ANY (ARRAY[('school'::character varying)::"text", ('college'::character varying)::"text"])))
);


ALTER TABLE "public"."assessment_types" OWNER TO "postgres";


COMMENT ON TABLE "public"."assessment_types" IS 'Master table for assessment types (Written Test, Project, etc.)';



COMMENT ON COLUMN "public"."assessment_types"."institution_id" IS 'References either schools.id or colleges.id depending on institution_type';



COMMENT ON COLUMN "public"."assessment_types"."institution_type" IS 'Indicates whether institution_id references a school or college';



CREATE TABLE IF NOT EXISTS "public"."assessments" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "assessment_code" "text" NOT NULL,
    "type" "text" NOT NULL,
    "academic_year" "text" NOT NULL,
    "department_id" "uuid",
    "program_id" "uuid",
    "semester" integer NOT NULL,
    "course_id" "uuid",
    "course_name" "text" NOT NULL,
    "course_code" "text" NOT NULL,
    "duration_minutes" integer DEFAULT 180 NOT NULL,
    "total_marks" numeric(5,2) DEFAULT 100 NOT NULL,
    "pass_marks" numeric(5,2) DEFAULT 40 NOT NULL,
    "weightage" numeric(5,2),
    "instructions" "text",
    "syllabus_coverage" "jsonb" DEFAULT '[]'::"jsonb",
    "question_paper_pattern" "jsonb",
    "status" "text" DEFAULT 'draft'::"text",
    "is_published" boolean DEFAULT false,
    "is_locked" boolean DEFAULT false,
    "created_by" "uuid",
    "approved_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "approved_at" timestamp with time zone,
    "faculty_id" "uuid",
    "college_id" "uuid",
    "school_id" "uuid",
    "teacher_id" "uuid",
    "start_date" "date",
    "end_date" "date",
    "target_classes" "jsonb",
    CONSTRAINT "assessments_semester_check" CHECK ((("semester" >= 1) AND ("semester" <= 12))),
    CONSTRAINT "assessments_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'scheduled'::"text", 'ongoing'::"text", 'completed'::"text", 'cancelled'::"text", 'marks_pending'::"text", 'moderation'::"text", 'published'::"text"]))),
    CONSTRAINT "chk_assessments_date_range" CHECK (("end_date" >= "start_date")),
    CONSTRAINT "valid_marks" CHECK (("pass_marks" <= "total_marks")),
    CONSTRAINT "valid_weightage" CHECK ((("weightage" IS NULL) OR (("weightage" >= (0)::numeric) AND ("weightage" <= (100)::numeric))))
);


ALTER TABLE "public"."assessments" OWNER TO "postgres";


COMMENT ON TABLE "public"."assessments" IS 'Stores assessment/exam definitions with syllabus coverage and workflow';



COMMENT ON COLUMN "public"."assessments"."course_id" IS 'Reference to curriculum_courses table for the subject/course being assessed';



COMMENT ON COLUMN "public"."assessments"."faculty_id" IS 'Reference to college_lecturers for faculty who created assessment';



COMMENT ON COLUMN "public"."assessments"."college_id" IS 'College reference for multi-college support';



COMMENT ON CONSTRAINT "assessments_status_check" ON "public"."assessments" IS 'Valid status values: draft, scheduled, ongoing, completed, cancelled, marks_pending, moderation, published';



CREATE TABLE IF NOT EXISTS "public"."assignment_attachments" (
    "attachment_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "assignment_id" "uuid" NOT NULL,
    "file_name" "text" NOT NULL,
    "file_type" "text",
    "file_size" integer,
    "file_url" "text",
    "uploaded_date" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."assignment_attachments" OWNER TO "postgres";


COMMENT ON TABLE "public"."assignment_attachments" IS 'File attachments linked to assignment submissions or templates';



CREATE TABLE IF NOT EXISTS "public"."assignments" (
    "assignment_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "instructions" "text",
    "course_name" "text" NOT NULL,
    "course_code" "text",
    "educator_name" "text",
    "total_points" numeric(7,2) DEFAULT 100 NOT NULL,
    "assignment_type" "text",
    "skill_outcomes" "text"[],
    "assign_classes" "text",
    "document_pdf" "text",
    "due_date" timestamp with time zone NOT NULL,
    "available_from" timestamp with time zone,
    "created_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "allow_late_submission" boolean DEFAULT true NOT NULL,
    "is_deleted" boolean DEFAULT false NOT NULL,
    "updated_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "educator_id" "uuid",
    "school_class_id" "uuid",
    CONSTRAINT "assignments_assignment_type_check" CHECK (("assignment_type" = ANY (ARRAY['homework'::"text", 'project'::"text", 'quiz'::"text", 'exam'::"text", 'lab'::"text", 'essay'::"text", 'presentation'::"text", 'other'::"text"])))
);


ALTER TABLE "public"."assignments" OWNER TO "postgres";


COMMENT ON TABLE "public"."assignments" IS 'Master assignment templates created by instructors for courses';



COMMENT ON COLUMN "public"."assignments"."assignment_id" IS 'Primary key - auto-generated unique identifier';



COMMENT ON COLUMN "public"."assignments"."total_points" IS 'Maximum points possible for this assignment';



COMMENT ON COLUMN "public"."assignments"."skill_outcomes" IS 'Array of skill outcomes/learning objectives for this assignment';



COMMENT ON COLUMN "public"."assignments"."assign_classes" IS 'Classes/sections assigned to this assignment';



COMMENT ON COLUMN "public"."assignments"."document_pdf" IS 'URL or path to PDF document associated with assignment';



COMMENT ON COLUMN "public"."assignments"."educator_id" IS 'FK to school_educators.id (role at a specific school). Prefer this over educator_id (user_id).';



CREATE TABLE IF NOT EXISTS "public"."attendance_alerts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "school_id" "uuid" NOT NULL,
    "alert_type" "text" NOT NULL,
    "message" "text" NOT NULL,
    "days_absent" integer,
    "attendance_percentage" numeric(5,2),
    "parent_notified" boolean DEFAULT false,
    "notified_date" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "attendance_alerts_alert_type_check" CHECK (("alert_type" = ANY (ARRAY['consecutive_absent'::"text", 'below_75'::"text", 'irregular'::"text"])))
);


ALTER TABLE "public"."attendance_alerts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."attendance_records" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "school_id" "uuid" NOT NULL,
    "date" "date" NOT NULL,
    "status" "text" NOT NULL,
    "mode" "text" DEFAULT 'manual'::"text",
    "time_in" time without time zone,
    "time_out" time without time zone,
    "marked_by" "uuid",
    "remarks" "text",
    "otp_verified" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "slot_id" "uuid",
    CONSTRAINT "attendance_records_mode_check" CHECK (("mode" = ANY (ARRAY['manual'::"text", 'rfid'::"text", 'mobile'::"text"]))),
    CONSTRAINT "attendance_records_status_check" CHECK (("status" = ANY (ARRAY['present'::"text", 'absent'::"text", 'late'::"text", 'excused'::"text"])))
);


ALTER TABLE "public"."attendance_records" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."audit_logs" (
    "actorId" "uuid",
    "action" "text" NOT NULL,
    "target" "text",
    "payload" "jsonb" DEFAULT '{}'::"jsonb",
    "ip" "text",
    "createdAt" timestamp with time zone DEFAULT "now"(),
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL
);


ALTER TABLE "public"."audit_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."budget_alerts" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "budget_id" "uuid" NOT NULL,
    "department_id" "uuid" NOT NULL,
    "budget_head_name" "text",
    "alert_type" "text" NOT NULL,
    "alert_level" "text" NOT NULL,
    "allocated_amount" numeric(12,2) NOT NULL,
    "spent_amount" numeric(12,2) NOT NULL,
    "remaining_amount" numeric(12,2) NOT NULL,
    "utilization_percentage" numeric(5,2) NOT NULL,
    "alert_message" "text" NOT NULL,
    "notified_users" "uuid"[] DEFAULT '{}'::"uuid"[],
    "notification_sent" boolean DEFAULT false,
    "notification_sent_at" timestamp with time zone,
    "is_acknowledged" boolean DEFAULT false,
    "acknowledged_by" "uuid",
    "acknowledged_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "budget_alerts_alert_level_check" CHECK (("alert_level" = ANY (ARRAY['info'::"text", 'warning'::"text", 'critical'::"text"]))),
    CONSTRAINT "budget_alerts_alert_type_check" CHECK (("alert_type" = ANY (ARRAY['threshold_reached'::"text", 'budget_exceeded'::"text", 'low_balance'::"text", 'overspending'::"text"])))
);


ALTER TABLE "public"."budget_alerts" OWNER TO "postgres";


COMMENT ON TABLE "public"."budget_alerts" IS 'Budget utilization alerts and notifications';



CREATE TABLE IF NOT EXISTS "public"."budget_revisions" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "budget_id" "uuid" NOT NULL,
    "department_id" "uuid" NOT NULL,
    "revision_number" integer NOT NULL,
    "revision_type" "text" NOT NULL,
    "revision_reason" "text" NOT NULL,
    "previous_total" numeric(12,2) NOT NULL,
    "new_total" numeric(12,2) NOT NULL,
    "difference" numeric(12,2) GENERATED ALWAYS AS (("new_total" - "previous_total")) STORED,
    "previous_heads" "jsonb" NOT NULL,
    "new_heads" "jsonb" NOT NULL,
    "requested_by" "uuid" NOT NULL,
    "requested_at" timestamp with time zone DEFAULT "now"(),
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "approval_status" "text" DEFAULT 'pending'::"text",
    "approval_remarks" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "budget_revisions_approval_status_check" CHECK (("approval_status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"]))),
    CONSTRAINT "budget_revisions_revision_type_check" CHECK (("revision_type" = ANY (ARRAY['increase'::"text", 'decrease'::"text", 'reallocation'::"text", 'correction'::"text"])))
);


ALTER TABLE "public"."budget_revisions" OWNER TO "postgres";


COMMENT ON TABLE "public"."budget_revisions" IS 'Budget revision history and audit trail';



CREATE TABLE IF NOT EXISTS "public"."bundle_features" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "bundle_id" "uuid" NOT NULL,
    "feature_key" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."bundle_features" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."bundles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(100) NOT NULL,
    "slug" character varying(100) NOT NULL,
    "description" "text",
    "target_roles" "text"[] DEFAULT '{}'::"text"[] NOT NULL,
    "monthly_price" numeric(10,2) NOT NULL,
    "annual_price" numeric(10,2) NOT NULL,
    "discount_percentage" integer DEFAULT 0 NOT NULL,
    "is_active" boolean DEFAULT true,
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."bundles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."career_ai_conversations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "messages" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."career_ai_conversations" OWNER TO "postgres";


COMMENT ON TABLE "public"."career_ai_conversations" IS 'Stores Career AI chat conversations for students';



CREATE TABLE IF NOT EXISTS "public"."career_assessment_ai_questions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "stream_id" character varying(50) NOT NULL,
    "question_type" character varying(50) NOT NULL,
    "category" character varying(100),
    "questions" "jsonb" NOT NULL,
    "generated_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "student_id" "uuid",
    "attempt_id" "uuid",
    "grade_level" "text" DEFAULT 'Grade 10'::"text" NOT NULL
);


ALTER TABLE "public"."career_assessment_ai_questions" OWNER TO "postgres";


COMMENT ON TABLE "public"."career_assessment_ai_questions" IS 'Caches AI-generated questions for career assessment aptitude and knowledge sections';



COMMENT ON COLUMN "public"."career_assessment_ai_questions"."grade_level" IS 'Grade level for which these questions were generated (e.g., Grade 10, PG Year 1, UG Year 2)';



CREATE OR REPLACE VIEW "public"."chapter_details" AS
SELECT
    NULL::"uuid" AS "id",
    NULL::"uuid" AS "curriculum_id",
    NULL::character varying(200) AS "name",
    NULL::character varying(50) AS "code",
    NULL::"text" AS "description",
    NULL::integer AS "order_number",
    NULL::integer AS "estimated_duration",
    NULL::character varying(10) AS "duration_unit",
    NULL::timestamp without time zone AS "created_at",
    NULL::bigint AS "outcome_count";


ALTER VIEW "public"."chapter_details" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."class_swap_history" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "swap_request_id" "uuid" NOT NULL,
    "action" character varying(50) NOT NULL,
    "actor_id" "uuid" NOT NULL,
    "actor_role" character varying(20) NOT NULL,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."class_swap_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."class_swap_history" IS 'Audit trail for all swap request actions';



CREATE TABLE IF NOT EXISTS "public"."class_swap_requests" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "requester_faculty_id" "uuid" NOT NULL,
    "requester_slot_id" "uuid" NOT NULL,
    "target_faculty_id" "uuid" NOT NULL,
    "target_slot_id" "uuid" NOT NULL,
    "reason" "text" NOT NULL,
    "request_type" character varying(20) NOT NULL,
    "swap_date" "date",
    "status" character varying(20) DEFAULT 'pending'::character varying NOT NULL,
    "target_response" "text",
    "target_responded_at" timestamp with time zone,
    "requires_admin_approval" boolean DEFAULT true,
    "admin_approval_status" character varying(20),
    "admin_id" "uuid",
    "admin_response" "text",
    "admin_responded_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    CONSTRAINT "class_swap_requests_admin_approval_status_check" CHECK ((("admin_approval_status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('approved'::character varying)::"text", ('rejected'::character varying)::"text"]))),
    CONSTRAINT "class_swap_requests_request_type_check" CHECK ((("request_type")::"text" = ANY (ARRAY[('one_time'::character varying)::"text", ('permanent'::character varying)::"text"]))),
    CONSTRAINT "class_swap_requests_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('accepted'::character varying)::"text", ('rejected'::character varying)::"text", ('cancelled'::character varying)::"text", ('completed'::character varying)::"text"]))),
    CONSTRAINT "different_faculty" CHECK (("requester_faculty_id" <> "target_faculty_id")),
    CONSTRAINT "different_slots" CHECK (("requester_slot_id" <> "target_slot_id")),
    CONSTRAINT "swap_date_required_for_one_time" CHECK ((((("request_type")::"text" = 'permanent'::"text") AND ("swap_date" IS NULL)) OR ((("request_type")::"text" = 'one_time'::"text") AND ("swap_date" IS NOT NULL))))
);


ALTER TABLE "public"."class_swap_requests" OWNER TO "postgres";


COMMENT ON TABLE "public"."class_swap_requests" IS 'Stores class swap requests between educators';



CREATE TABLE IF NOT EXISTS "public"."club_activities" (
    "activity_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "club_id" "uuid" NOT NULL,
    "title" character varying(255) NOT NULL,
    "description" "text",
    "activity_date" "date" NOT NULL,
    "activity_time" character varying(50),
    "location" character varying(255),
    "activity_type" character varying(50),
    "status" character varying(20) DEFAULT 'scheduled'::character varying,
    "expected_participants" integer DEFAULT 0,
    "actual_participants" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by_type" character varying(20),
    "created_by_educator_id" "uuid",
    "created_by_admin_id" "uuid",
    CONSTRAINT "check_single_activity_creator" CHECK (((("created_by_educator_id" IS NOT NULL) AND ("created_by_admin_id" IS NULL) AND (("created_by_type")::"text" = 'educator'::"text")) OR (("created_by_educator_id" IS NULL) AND ("created_by_admin_id" IS NOT NULL) AND (("created_by_type")::"text" = 'admin'::"text")))),
    CONSTRAINT "club_activities_activity_type_check" CHECK ((("activity_type")::"text" = ANY (ARRAY[('workshop'::character varying)::"text", ('meeting'::character varying)::"text", ('event'::character varying)::"text", ('competition_prep'::character varying)::"text", ('practice'::character varying)::"text", ('field_trip'::character varying)::"text", ('guest_lecture'::character varying)::"text", ('other'::character varying)::"text"]))),
    CONSTRAINT "club_activities_created_by_type_check" CHECK ((("created_by_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('admin'::character varying)::"text"]))),
    CONSTRAINT "club_activities_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('scheduled'::character varying)::"text", ('ongoing'::character varying)::"text", ('completed'::character varying)::"text", ('cancelled'::character varying)::"text"])))
);


ALTER TABLE "public"."club_activities" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."club_attendance" (
    "attendance_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "club_id" "uuid" NOT NULL,
    "session_date" "date" NOT NULL,
    "session_topic" character varying(255),
    "session_description" "text",
    "duration_minutes" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by_type" character varying(20),
    "created_by_educator_id" "uuid",
    "created_by_admin_id" "uuid",
    CONSTRAINT "check_single_attendance_creator" CHECK (((("created_by_educator_id" IS NOT NULL) AND ("created_by_admin_id" IS NULL) AND (("created_by_type")::"text" = 'educator'::"text")) OR (("created_by_educator_id" IS NULL) AND ("created_by_admin_id" IS NOT NULL) AND (("created_by_type")::"text" = 'admin'::"text")))),
    CONSTRAINT "club_attendance_created_by_type_check" CHECK ((("created_by_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('admin'::character varying)::"text"])))
);


ALTER TABLE "public"."club_attendance" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."club_attendance_records" (
    "record_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "attendance_id" "uuid" NOT NULL,
    "student_email" character varying(255) NOT NULL,
    "status" character varying(20) NOT NULL,
    "remarks" "text",
    "marked_at" timestamp with time zone DEFAULT "now"(),
    "marked_by_type" character varying(20),
    "marked_by_educator_id" "uuid",
    "marked_by_admin_id" "uuid",
    CONSTRAINT "check_single_marker" CHECK (((("marked_by_educator_id" IS NOT NULL) AND ("marked_by_admin_id" IS NULL) AND (("marked_by_type")::"text" = 'educator'::"text")) OR (("marked_by_educator_id" IS NULL) AND ("marked_by_admin_id" IS NOT NULL) AND (("marked_by_type")::"text" = 'admin'::"text")))),
    CONSTRAINT "club_attendance_records_marked_by_type_check" CHECK ((("marked_by_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('admin'::character varying)::"text"]))),
    CONSTRAINT "club_attendance_records_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('present'::character varying)::"text", ('absent'::character varying)::"text", ('late'::character varying)::"text", ('excused'::character varying)::"text"])))
);


ALTER TABLE "public"."club_attendance_records" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."club_certificates" (
    "certificate_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_email" character varying(255) NOT NULL,
    "school_id" "uuid" NOT NULL,
    "title" character varying(255) NOT NULL,
    "description" "text",
    "certificate_type" character varying(50),
    "issuer" character varying(255),
    "issued_date" "date" NOT NULL,
    "valid_until" "date",
    "credential_id" character varying(100),
    "verification_url" "text",
    "qr_code_url" "text",
    "related_club_id" "uuid",
    "related_comp_id" "uuid",
    "related_badge_id" "uuid",
    "certificate_pdf_url" "text",
    "certificate_image_url" "text",
    "template_used" character varying(100),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "issued_by_type" character varying(20),
    "issued_by_educator_id" "uuid",
    "issued_by_admin_id" "uuid",
    "is_verified" boolean DEFAULT true,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "check_single_certificate_issuer" CHECK (((("issued_by_educator_id" IS NOT NULL) AND ("issued_by_admin_id" IS NULL) AND (("issued_by_type")::"text" = 'educator'::"text")) OR (("issued_by_educator_id" IS NULL) AND ("issued_by_admin_id" IS NOT NULL) AND (("issued_by_type")::"text" = 'admin'::"text")))),
    CONSTRAINT "club_certificates_certificate_type_check" CHECK ((("certificate_type")::"text" = ANY (ARRAY[('course_completion'::character varying)::"text", ('skill_achievement'::character varying)::"text", ('competition'::character varying)::"text", ('workshop'::character varying)::"text", ('leadership'::character varying)::"text", ('participation'::character varying)::"text", ('excellence'::character varying)::"text"]))),
    CONSTRAINT "club_certificates_issued_by_type_check" CHECK ((("issued_by_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('admin'::character varying)::"text"])))
);


ALTER TABLE "public"."club_certificates" OWNER TO "postgres";


COMMENT ON TABLE "public"."club_certificates" IS 'Stores generated club_certificates with verification support';



CREATE TABLE IF NOT EXISTS "public"."club_memberships" (
    "membership_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "club_id" "uuid" NOT NULL,
    "student_email" character varying(255) NOT NULL,
    "enrolled_at" timestamp with time zone DEFAULT "now"(),
    "enrolled_by_type" character varying(20),
    "enrolled_by_educator_id" "uuid",
    "enrolled_by_admin_id" "uuid",
    "status" character varying(20) DEFAULT 'active'::character varying,
    "withdrawn_at" timestamp with time zone,
    "withdrawal_reason" "text",
    "total_sessions_attended" integer DEFAULT 0,
    "total_sessions_held" integer DEFAULT 0,
    "attendance_percentage" numeric(5,2) DEFAULT 0,
    "performance_score" numeric(5,2) DEFAULT 0,
    "achievements" "jsonb" DEFAULT '[]'::"jsonb",
    CONSTRAINT "check_single_enroller" CHECK (((("enrolled_by_educator_id" IS NOT NULL) AND ("enrolled_by_admin_id" IS NULL) AND (("enrolled_by_type")::"text" = 'educator'::"text")) OR (("enrolled_by_educator_id" IS NULL) AND ("enrolled_by_admin_id" IS NOT NULL) AND (("enrolled_by_type")::"text" = 'admin'::"text")) OR (("enrolled_by_educator_id" IS NULL) AND ("enrolled_by_admin_id" IS NULL) AND (("enrolled_by_type")::"text" = 'self'::"text")))),
    CONSTRAINT "club_memberships_enrolled_by_type_check" CHECK ((("enrolled_by_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('admin'::character varying)::"text", ('self'::character varying)::"text"]))),
    CONSTRAINT "club_memberships_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('active'::character varying)::"text", ('withdrawn'::character varying)::"text", ('suspended'::character varying)::"text"])))
);


ALTER TABLE "public"."club_memberships" OWNER TO "postgres";


COMMENT ON TABLE "public"."club_memberships" IS 'Tracks student enrollment in clubs with attendance and performance metrics';



CREATE TABLE IF NOT EXISTS "public"."clubs" (
    "club_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "school_id" "uuid" NOT NULL,
    "name" character varying(255) NOT NULL,
    "category" character varying(50) NOT NULL,
    "description" "text",
    "capacity" integer DEFAULT 30 NOT NULL,
    "meeting_day" character varying(100),
    "meeting_time" character varying(50),
    "location" character varying(255),
    "mentor_type" character varying(20),
    "mentor_educator_id" "uuid",
    "mentor_school_id" "uuid",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by_type" character varying(20),
    "created_by_educator_id" "uuid",
    "created_by_admin_id" "uuid",
    CONSTRAINT "check_single_creator" CHECK (((("created_by_educator_id" IS NOT NULL) AND ("created_by_admin_id" IS NULL) AND (("created_by_type")::"text" = 'educator'::"text")) OR (("created_by_educator_id" IS NULL) AND ("created_by_admin_id" IS NOT NULL) AND (("created_by_type")::"text" = 'admin'::"text")) OR (("created_by_educator_id" IS NULL) AND ("created_by_admin_id" IS NULL) AND ("created_by_type" IS NULL)))),
    CONSTRAINT "check_single_mentor" CHECK (((("mentor_educator_id" IS NOT NULL) AND ("mentor_school_id" IS NULL) AND (("mentor_type")::"text" = 'educator'::"text")) OR (("mentor_educator_id" IS NULL) AND ("mentor_school_id" IS NOT NULL) AND (("mentor_type")::"text" = 'school'::"text")) OR (("mentor_educator_id" IS NULL) AND ("mentor_school_id" IS NULL) AND ("mentor_type" IS NULL)))),
    CONSTRAINT "clubs_category_check" CHECK ((("category")::"text" = ANY (ARRAY[('arts'::character varying)::"text", ('sports'::character varying)::"text", ('robotics'::character varying)::"text", ('science'::character varying)::"text", ('literature'::character varying)::"text"]))),
    CONSTRAINT "clubs_created_by_type_check" CHECK ((("created_by_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('admin'::character varying)::"text"]))),
    CONSTRAINT "clubs_mentor_type_check" CHECK ((("mentor_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('school'::character varying)::"text"])))
);


ALTER TABLE "public"."clubs" OWNER TO "postgres";


COMMENT ON TABLE "public"."clubs" IS 'Stores all club information with polymorphic mentor support (educator or school)';



CREATE TABLE IF NOT EXISTS "public"."students" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "universityId" "uuid",
    "createdAt" timestamp with time zone DEFAULT "now"(),
    "updatedAt" timestamp with time zone DEFAULT "now"(),
    "email" "text" NOT NULL,
    "name" character varying(150),
    "age" integer,
    "date_of_birth" "date",
    "contact_number" character varying(20),
    "alternate_number" character varying(20),
    "district_name" character varying(100),
    "university" character varying(150),
    "branch_field" character varying(150),
    "college_school_name" character varying(150),
    "registration_number" character varying(100),
    "github_link" "text",
    "linkedin_link" "text",
    "twitter_link" "text",
    "facebook_link" "text",
    "instagram_link" "text",
    "portfolio_link" "text",
    "other_social_links" "jsonb" DEFAULT '[]'::"jsonb",
    "approval_status" "public"."user_approval_status",
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"(),
    "embedding" "extensions"."vector"(1536),
    "universityCollegeId" "uuid",
    "schoolClassId" "uuid",
    "collegeCourseId" "uuid",
    "universityCourseId" "uuid",
    "enrollmentNumber" character varying(100),
    "guardianName" character varying(200),
    "guardianPhone" character varying(20),
    "guardianEmail" character varying(255),
    "guardianRelation" character varying(50),
    "dateOfBirth" "date",
    "gender" character varying(20),
    "bloodGroup" character varying(5),
    "enrollmentDate" "date",
    "expectedGraduationDate" "date",
    "currentCgpa" numeric(4,2),
    "contactNumber" character varying(20),
    "address" "text",
    "city" character varying(100),
    "state" character varying(100),
    "country" character varying(100) DEFAULT 'India'::character varying,
    "pincode" character varying(10),
    "resumeUrl" "text",
    "profilePicture" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "university_college_id" "uuid",
    "school_id" "uuid",
    "school_class_id" "uuid",
    "student_type" character varying(30) DEFAULT 'direct'::character varying,
    "user_id" "uuid",
    "student_id" "text",
    "bio" "text",
    "university_main" character varying(150),
    "imported_at" timestamp with time zone,
    "resume_imported_at" timestamp with time zone,
    "skill_summary" "text",
    "course_name" character varying(150),
    "contact_dial_code" character varying(10),
    "trainer_name" character varying(150),
    "is_deleted" boolean DEFAULT false,
    "deleted_at" timestamp with time zone,
    "deleted_by" "uuid",
    "grade" character varying(10),
    "section" character varying(10),
    "roll_number" character varying(50),
    "admission_number" character varying(100),
    "college_id" "uuid",
    "hobbies" "jsonb" DEFAULT '[]'::"jsonb",
    "languages" "jsonb" DEFAULT '[]'::"jsonb",
    "interests" "jsonb" DEFAULT '[]'::"jsonb",
    "category" character varying(50),
    "quota" character varying(50),
    "youtube_link" "text",
    "notification_settings" "jsonb" DEFAULT '{"weeklyDigest": false, "monthlyReport": false, "newOpportunities": true, "applicationUpdates": true, "emailNotifications": true, "recruitingMessages": true}'::"jsonb",
    "documents" "jsonb" DEFAULT '[]'::"jsonb",
    "semester" integer,
    "program_id" "uuid",
    "grade_start_date" "date",
    "admission_academic_year" character varying(10),
    "college_class_id" "uuid",
    "program_section_id" "uuid",
    "tour_progress" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "gap_in_studies" boolean DEFAULT false,
    "gap_years" integer DEFAULT 0,
    "gap_reason" "text",
    "work_experience" "text",
    "aadhar_number" character varying(12),
    "backlogs_history" "text",
    "current_backlogs" integer DEFAULT 0,
    CONSTRAINT "chk_aadhar_format" CHECK ((("aadhar_number" IS NULL) OR (("aadhar_number")::"text" ~ '^[0-9]{12}$'::"text"))),
    CONSTRAINT "chk_current_backlogs_positive" CHECK (("current_backlogs" >= 0)),
    CONSTRAINT "chk_gap_consistency" CHECK (((NOT "gap_in_studies") OR ("gap_years" > 0))),
    CONSTRAINT "chk_gap_years_positive" CHECK (("gap_years" >= 0)),
    CONSTRAINT "chk_only_one_class" CHECK (((("school_class_id" IS NOT NULL) AND ("college_class_id" IS NULL)) OR (("school_class_id" IS NULL) AND ("college_id" IS NOT NULL)) OR (("school_class_id" IS NULL) AND ("college_id" IS NULL) AND ("university_college_id" IS NOT NULL) AND ("college_class_id" IS NULL)) OR (("school_class_id" IS NULL) AND ("university_college_id" IS NULL) AND ("college_class_id" IS NULL))))
);


ALTER TABLE "public"."students" OWNER TO "postgres";


COMMENT ON TABLE "public"."students" IS 'Students table - students are linked to programs via program_id, not directly to departments';



COMMENT ON COLUMN "public"."students"."grade" IS 'Student grade/class level (e.g., 1, 2, 10, 12)';



COMMENT ON COLUMN "public"."students"."section" IS 'Class section (e.g., A, B, C)';



COMMENT ON COLUMN "public"."students"."roll_number" IS 'Student roll number within the class';



COMMENT ON COLUMN "public"."students"."admission_number" IS 'School admission/enrollment number';



COMMENT ON COLUMN "public"."students"."hobbies" IS 'Array of hobby strings, e.g., ["Reading", "Photography", "Coding"]';



COMMENT ON COLUMN "public"."students"."languages" IS 'Array of language objects with name and proficiency, e.g., [{"name": "English", "proficiency": "Native"}]';



COMMENT ON COLUMN "public"."students"."interests" IS 'Array of interest/passion strings, e.g., ["Machine Learning", "Web Development"]';



COMMENT ON COLUMN "public"."students"."notification_settings" IS 'Student notification preferences stored as JSONB';



COMMENT ON COLUMN "public"."students"."documents" IS 'Student documents stored as JSONB array of objects with url, name, type, uploadedAt fields';



COMMENT ON COLUMN "public"."students"."semester" IS 'Semester number for college students (1-8 typically)';



COMMENT ON COLUMN "public"."students"."program_id" IS 'Foreign key reference to programs table - students belong to specific programs, not directly to departments';



COMMENT ON COLUMN "public"."students"."grade_start_date" IS 'Date when student started their current grade. Used to determine assessment eligibility (e.g., 12th grade students with >6 months show After 12th assessment)';



COMMENT ON COLUMN "public"."students"."admission_academic_year" IS 'Academic year when student was admitted (e.g., 2024-25). Used to calculate current academic year based on semester progression.';



COMMENT ON COLUMN "public"."students"."tour_progress" IS 'Stores Joyride tour progress data including completion status, last step, etc. Format: {"tourId": {"status": "completed|in_progress|not_started|skipped", "completedAt": "ISO_DATE", "lastStepIndex": number}}';



COMMENT ON COLUMN "public"."students"."gap_in_studies" IS 'Whether student has gap years in education';



COMMENT ON COLUMN "public"."students"."gap_years" IS 'Number of gap years in education';



COMMENT ON COLUMN "public"."students"."gap_reason" IS 'Reason for gap in studies';



COMMENT ON COLUMN "public"."students"."work_experience" IS 'Work experience details during gap or alongside studies';



COMMENT ON COLUMN "public"."students"."aadhar_number" IS 'Aadhar card number (12 digits)';



COMMENT ON COLUMN "public"."students"."backlogs_history" IS 'History of academic backlogs/failures';



COMMENT ON COLUMN "public"."students"."current_backlogs" IS 'Number of current pending backlogs';



CREATE OR REPLACE VIEW "public"."club_participation_report" AS
 SELECT "c"."club_id",
    "c"."school_id",
    "c"."name" AS "club_name",
    "c"."category",
    "count"(DISTINCT "cm"."student_email") AS "student_count",
    "round"("avg"("cm"."attendance_percentage"), 2) AS "avg_attendance",
    "round"("avg"("cm"."performance_score"), 2) AS "avg_performance_score",
    "round"(((("count"(DISTINCT "cm"."student_email"))::numeric / (NULLIF("c"."capacity", 0))::numeric) * (100)::numeric), 2) AS "participation_score",
    ( SELECT "string_agg"((((("s"."name")::"text" || ' ('::"text") || "round"((("cm2"."attendance_percentage" * 0.6) + (COALESCE("cm2"."performance_score", (0)::numeric) * 0.4)), 1)) || '% score)'::"text"), ', '::"text") AS "string_agg"
           FROM (( SELECT "cm_inner"."student_email",
                    "cm_inner"."attendance_percentage",
                    "cm_inner"."performance_score",
                    (("cm_inner"."attendance_percentage" * 0.6) + (COALESCE("cm_inner"."performance_score", (0)::numeric) * 0.4)) AS "composite_score"
                   FROM "public"."club_memberships" "cm_inner"
                  WHERE (("cm_inner"."club_id" = "c"."club_id") AND (("cm_inner"."status")::"text" = 'active'::"text") AND ("cm_inner"."attendance_percentage" >= (70)::numeric))
                  ORDER BY (("cm_inner"."attendance_percentage" * 0.6) + (COALESCE("cm_inner"."performance_score", (0)::numeric) * 0.4)) DESC
                 LIMIT 5) "cm2"
             JOIN "public"."students" "s" ON ((("cm2"."student_email")::"text" = "s"."email")))) AS "top_performers",
    "c"."capacity",
    "c"."meeting_day",
    "c"."meeting_time",
    "c"."location",
    "c"."is_active"
   FROM ("public"."clubs" "c"
     LEFT JOIN "public"."club_memberships" "cm" ON ((("c"."club_id" = "cm"."club_id") AND (("cm"."status")::"text" = 'active'::"text"))))
  GROUP BY "c"."club_id", "c"."school_id", "c"."name", "c"."category", "c"."capacity", "c"."meeting_day", "c"."meeting_time", "c"."location", "c"."is_active";


ALTER VIEW "public"."club_participation_report" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_assignment_attachments" (
    "attachment_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "assignment_id" "uuid" NOT NULL,
    "file_name" "text" NOT NULL,
    "file_type" "text",
    "file_size" integer,
    "file_url" "text",
    "uploaded_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "uploaded_by" "uuid"
);


ALTER TABLE "public"."college_assignment_attachments" OWNER TO "postgres";


COMMENT ON TABLE "public"."college_assignment_attachments" IS 'File attachments for college assignments';



COMMENT ON COLUMN "public"."college_assignment_attachments"."uploaded_by" IS 'Reference to college lecturer who uploaded the file';



CREATE TABLE IF NOT EXISTS "public"."college_assignments" (
    "assignment_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "instructions" "text",
    "course_name" "text" NOT NULL,
    "course_code" "text",
    "college_id" "uuid" NOT NULL,
    "college_educator_id" "uuid" NOT NULL,
    "program_section_id" "uuid" NOT NULL,
    "department_id" "uuid" NOT NULL,
    "program_id" "uuid" NOT NULL,
    "educator_name" "text",
    "total_points" numeric(7,2) DEFAULT 100 NOT NULL,
    "assignment_type" "text",
    "skill_outcomes" "text"[],
    "document_pdf" "text",
    "due_date" timestamp with time zone NOT NULL,
    "available_from" timestamp with time zone,
    "created_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "allow_late_submission" boolean DEFAULT true NOT NULL,
    "is_deleted" boolean DEFAULT false NOT NULL,
    "instruction_files" "jsonb" DEFAULT '[]'::"jsonb",
    CONSTRAINT "college_assignments_assignment_type_check" CHECK (("assignment_type" = ANY (ARRAY['homework'::"text", 'project'::"text", 'quiz'::"text", 'exam'::"text", 'lab'::"text", 'essay'::"text", 'presentation'::"text", 'other'::"text"])))
);


ALTER TABLE "public"."college_assignments" OWNER TO "postgres";


COMMENT ON TABLE "public"."college_assignments" IS 'College-specific assignments separate from school assignments';



COMMENT ON COLUMN "public"."college_assignments"."college_id" IS 'Reference to college/organization';



COMMENT ON COLUMN "public"."college_assignments"."college_educator_id" IS 'Reference to college lecturer user_id';



COMMENT ON COLUMN "public"."college_assignments"."program_section_id" IS 'Reference to program section (semester-section combination)';



COMMENT ON COLUMN "public"."college_assignments"."department_id" IS 'Reference to academic department';



COMMENT ON COLUMN "public"."college_assignments"."program_id" IS 'Reference to degree program';



COMMENT ON COLUMN "public"."college_assignments"."instruction_files" IS 'Array of instruction file metadata: [{"name": "file.pdf", "url": "https://...", "size": 1024, "type": "application/pdf"}]';



CREATE OR REPLACE VIEW "public"."college_assignments_view" AS
SELECT
    NULL::"uuid" AS "assignment_id",
    NULL::"text" AS "title",
    NULL::"text" AS "description",
    NULL::"text" AS "instructions",
    NULL::"text" AS "course_name",
    NULL::"text" AS "course_code",
    NULL::"uuid" AS "college_id",
    NULL::"uuid" AS "college_educator_id",
    NULL::"uuid" AS "program_section_id",
    NULL::"uuid" AS "department_id",
    NULL::"uuid" AS "program_id",
    NULL::"text" AS "educator_name",
    NULL::numeric(7,2) AS "total_points",
    NULL::"text" AS "assignment_type",
    NULL::"text"[] AS "skill_outcomes",
    NULL::"text" AS "document_pdf",
    NULL::timestamp with time zone AS "due_date",
    NULL::timestamp with time zone AS "available_from",
    NULL::timestamp with time zone AS "created_date",
    NULL::timestamp with time zone AS "updated_date",
    NULL::boolean AS "allow_late_submission",
    NULL::boolean AS "is_deleted",
    NULL::integer AS "semester",
    NULL::character varying(10) AS "section",
    NULL::character varying(20) AS "academic_year",
    NULL::integer AS "current_students",
    NULL::character varying(255) AS "program_name",
    NULL::character varying(50) AS "program_code",
    NULL::character varying(255) AS "department_name",
    NULL::character varying(50) AS "department_code",
    NULL::"text" AS "educator_full_name",
    NULL::character varying(255) AS "educator_email",
    NULL::character varying(255) AS "college_name",
    NULL::bigint AS "total_assigned",
    NULL::bigint AS "total_submitted",
    NULL::bigint AS "total_graded";


ALTER VIEW "public"."college_assignments_view" OWNER TO "postgres";


COMMENT ON VIEW "public"."college_assignments_view" IS 'Comprehensive view of college assignments with related data and statistics';



CREATE TABLE IF NOT EXISTS "public"."college_attendance_records" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "session_id" "uuid",
    "student_id" "uuid",
    "student_name" character varying(255) NOT NULL,
    "roll_number" character varying(50) NOT NULL,
    "department_name" character varying(255) NOT NULL,
    "program_name" character varying(255) NOT NULL,
    "semester" integer NOT NULL,
    "section" character varying(10) NOT NULL,
    "date" "date" NOT NULL,
    "status" character varying(20) NOT NULL,
    "time_in" time without time zone,
    "time_out" time without time zone,
    "subject_name" character varying(255) NOT NULL,
    "subject_code" character varying(50),
    "faculty_id" "uuid",
    "faculty_name" character varying(255) NOT NULL,
    "location" character varying(255),
    "remarks" "text",
    "marked_by" "uuid",
    "marked_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "college_id" "uuid" NOT NULL,
    CONSTRAINT "college_attendance_records_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('present'::character varying)::"text", ('absent'::character varying)::"text", ('late'::character varying)::"text", ('excused'::character varying)::"text"])))
);


ALTER TABLE "public"."college_attendance_records" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_attendance_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "date" "date" NOT NULL,
    "start_time" time without time zone NOT NULL,
    "end_time" time without time zone NOT NULL,
    "subject_name" character varying(255) NOT NULL,
    "subject_code" character varying(50),
    "course_type" character varying(20),
    "faculty_id" "uuid",
    "faculty_name" character varying(255) NOT NULL,
    "department_name" character varying(255) NOT NULL,
    "program_name" character varying(255) NOT NULL,
    "program_code" character varying(50),
    "semester" integer NOT NULL,
    "section" character varying(10) NOT NULL,
    "room_number" character varying(50),
    "academic_year" character varying(20) DEFAULT '2024-25'::character varying,
    "total_students" integer DEFAULT 0,
    "present_count" integer DEFAULT 0,
    "absent_count" integer DEFAULT 0,
    "late_count" integer DEFAULT 0,
    "excused_count" integer DEFAULT 0,
    "attendance_percentage" numeric(5,2) DEFAULT 0.00,
    "status" character varying(20) DEFAULT 'scheduled'::character varying,
    "remarks" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "college_id" "uuid" NOT NULL,
    CONSTRAINT "college_attendance_sessions_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('scheduled'::character varying)::"text", ('ongoing'::character varying)::"text", ('completed'::character varying)::"text", ('cancelled'::character varying)::"text"])))
);


ALTER TABLE "public"."college_attendance_sessions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_attendance_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "minimum_attendance_percentage" numeric(5,2) DEFAULT 75.00,
    "late_arrival_threshold_minutes" integer DEFAULT 15,
    "auto_mark_absent_after_minutes" integer DEFAULT 30,
    "allow_retroactive_marking" boolean DEFAULT true,
    "retroactive_days_limit" integer DEFAULT 7,
    "require_remarks_for_excused" boolean DEFAULT true,
    "enable_biometric_integration" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."college_attendance_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_breaks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "timetable_id" "uuid",
    "break_type" character varying(20) NOT NULL,
    "name" character varying(255) NOT NULL,
    "description" "text",
    "start_time" time without time zone,
    "end_time" time without time zone,
    "start_date" "date",
    "end_date" "date",
    "applies_to_all" boolean DEFAULT true,
    "class_ids" "uuid"[],
    "is_recurring" boolean DEFAULT false,
    "recurring_days" integer[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "college_breaks_break_type_check" CHECK ((("break_type")::"text" = ANY (ARRAY[('lunch'::character varying)::"text", ('short'::character varying)::"text", ('holiday'::character varying)::"text", ('exam'::character varying)::"text", ('event'::character varying)::"text"])))
);


ALTER TABLE "public"."college_breaks" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_circulars" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid",
    "title" character varying(255) NOT NULL,
    "content" "text" NOT NULL,
    "audience" character varying(50) DEFAULT 'all'::character varying,
    "priority" character varying(20) DEFAULT 'medium'::character varying,
    "publish_date" "date" NOT NULL,
    "expire_date" "date",
    "attachment_url" "text",
    "status" character varying(20) DEFAULT 'draft'::character varying,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "attachment_filename" "text",
    "attachment_file_size" bigint,
    CONSTRAINT "college_circulars_audience_check" CHECK ((("audience")::"text" = ANY (ARRAY[('all'::character varying)::"text", ('students'::character varying)::"text", ('faculty'::character varying)::"text", ('staff'::character varying)::"text"]))),
    CONSTRAINT "college_circulars_priority_check" CHECK ((("priority")::"text" = ANY (ARRAY[('low'::character varying)::"text", ('medium'::character varying)::"text", ('high'::character varying)::"text", ('urgent'::character varying)::"text"]))),
    CONSTRAINT "college_circulars_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('published'::character varying)::"text", ('archived'::character varying)::"text"])))
);


ALTER TABLE "public"."college_circulars" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_classes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "name" character varying(255) NOT NULL,
    "grade" character varying(50) NOT NULL,
    "section" character varying(50),
    "academic_year" character varying(20) NOT NULL,
    "max_students" integer DEFAULT 60,
    "current_students" integer DEFAULT 0,
    "status" character varying(20) DEFAULT 'active'::character varying,
    "room_no" character varying(50),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "department_id" "uuid"
);


ALTER TABLE "public"."college_classes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_course_mappings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "program_id" "uuid" NOT NULL,
    "semester" integer NOT NULL,
    "offering_type" character varying(20) NOT NULL,
    "faculty_id" "uuid",
    "capacity" integer,
    "is_locked" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "updated_by" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "course_id" "uuid" NOT NULL,
    "current_enrollment" integer DEFAULT 0,
    CONSTRAINT "college_course_mappings_type_check" CHECK ((("offering_type")::"text" = ANY (ARRAY[('core'::character varying)::"text", ('dept_elective'::character varying)::"text", ('open_elective'::character varying)::"text"]))),
    CONSTRAINT "elective_capacity_required" CHECK ((((("offering_type")::"text" = 'core'::"text") AND ("capacity" IS NULL)) OR ((("offering_type")::"text" = ANY (ARRAY[('dept_elective'::character varying)::"text", ('open_elective'::character varying)::"text"])) AND ("capacity" IS NOT NULL))))
);


ALTER TABLE "public"."college_course_mappings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_courses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "course_name" character varying(255) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "course_code" character varying(20) DEFAULT 'TBD'::character varying NOT NULL,
    "credits" numeric(3,1) DEFAULT 3.0 NOT NULL,
    "description" "text",
    "prerequisites" "jsonb" DEFAULT '[]'::"jsonb",
    "course_type" character varying(20) DEFAULT 'theory'::character varying,
    "is_active" boolean DEFAULT true,
    "created_by" "uuid",
    "updated_by" "uuid",
    CONSTRAINT "check_course_type_valid" CHECK ((("course_type")::"text" = ANY (ARRAY[('theory'::character varying)::"text", ('lab'::character varying)::"text", ('project'::character varying)::"text", ('seminar'::character varying)::"text", ('workshop'::character varying)::"text", ('practical'::character varying)::"text"]))),
    CONSTRAINT "check_credits_positive" CHECK (("credits" > (0)::numeric))
);


ALTER TABLE "public"."college_courses" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_curriculum_outcomes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "curriculum_id" "uuid" NOT NULL,
    "unit_id" "uuid" NOT NULL,
    "outcome_text" "text" NOT NULL,
    "bloom_level" character varying(20),
    "assessment_mappings" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_by" "uuid"
);


ALTER TABLE "public"."college_curriculum_outcomes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_curriculums" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "department_id" "uuid" NOT NULL,
    "program_id" "uuid" NOT NULL,
    "academic_year" character varying(20) NOT NULL,
    "status" character varying(20) DEFAULT 'draft'::character varying,
    "created_by" "uuid" NOT NULL,
    "approved_by" "uuid",
    "approval_date" timestamp with time zone,
    "rejection_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "published_date" timestamp with time zone,
    "archived_date" timestamp with time zone,
    "cloned_from_id" "uuid",
    "version" integer DEFAULT 1,
    "course_id" "uuid" NOT NULL,
    "requested_by" "uuid",
    "request_date" timestamp without time zone,
    "request_message" "text",
    "reviewed_by" "uuid",
    "review_date" timestamp without time zone,
    "review_notes" "text",
    "university_id" "uuid",
    "pending_changes" "jsonb" DEFAULT '[]'::"jsonb",
    "change_history" "jsonb" DEFAULT '[]'::"jsonb",
    "has_pending_changes" boolean DEFAULT false,
    CONSTRAINT "college_curriculums_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('submitted'::character varying)::"text", ('pending_approval'::character varying)::"text", ('approved'::character varying)::"text", ('published'::character varying)::"text", ('archived'::character varying)::"text", ('rejected'::character varying)::"text"])))
);


ALTER TABLE "public"."college_curriculums" OWNER TO "postgres";


COMMENT ON COLUMN "public"."college_curriculums"."pending_changes" IS 'Array of pending change requests awaiting university approval';



COMMENT ON COLUMN "public"."college_curriculums"."change_history" IS 'Array of approved/rejected changes for audit trail';



COMMENT ON COLUMN "public"."college_curriculums"."has_pending_changes" IS 'Quick flag to check if curriculum has any pending changes';



CREATE TABLE IF NOT EXISTS "public"."departments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "school_id" "uuid",
    "name" character varying(255) NOT NULL,
    "code" character varying(50) NOT NULL,
    "description" "text",
    "status" character varying(50) DEFAULT 'active'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "metadata" "jsonb",
    "created_by" "uuid",
    "updated_by" "uuid",
    "college_id" "uuid",
    CONSTRAINT "chk_departments_institution" CHECK (((("school_id" IS NOT NULL) AND ("college_id" IS NULL)) OR (("school_id" IS NULL) AND ("college_id" IS NOT NULL))))
);


ALTER TABLE "public"."departments" OWNER TO "postgres";


COMMENT ON COLUMN "public"."departments"."college_id" IS 'Reference to colleges table for college departments (NULL for school departments)';



COMMENT ON CONSTRAINT "chk_departments_institution" ON "public"."departments" IS 'Ensures department belongs to either a school OR a college, not both';



CREATE TABLE IF NOT EXISTS "public"."organizations" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "name" character varying(255) NOT NULL,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "email" "text",
    "phone" "text",
    "state" "text",
    "website" "text",
    "verification_status" "text" DEFAULT 'approved'::"text",
    "is_active" boolean DEFAULT true,
    "approval_status" character varying(20) DEFAULT 'approved'::character varying,
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "rejection_reason" "text",
    "account_status" character varying(20) DEFAULT 'active'::character varying,
    "organization_type" character varying(50),
    "admin_id" "uuid",
    "address" "text",
    "city" character varying(100),
    "country" character varying(100),
    "logo_url" "text",
    "code" character varying(50),
    "pincode" character varying(20),
    "established_year" integer,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."organizations" OWNER TO "postgres";


COMMENT ON TABLE "public"."organizations" IS 'Unified organizations table. Use this for all organization queries. Filter by organization_type for specific types (school, college, university).';



COMMENT ON COLUMN "public"."organizations"."organization_type" IS 'Type of organization: school, college, or university';



COMMENT ON COLUMN "public"."organizations"."code" IS 'Unique code for the organization (e.g., school code, college code)';



COMMENT ON COLUMN "public"."organizations"."pincode" IS 'Postal/ZIP code';



COMMENT ON COLUMN "public"."organizations"."established_year" IS 'Year the organization was established';



COMMENT ON COLUMN "public"."organizations"."metadata" IS 'Additional organization-specific data (principal info, dean info, etc.)';



CREATE TABLE IF NOT EXISTS "public"."programs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "department_id" "uuid",
    "name" character varying(255) NOT NULL,
    "code" character varying(50) NOT NULL,
    "description" "text",
    "degree_level" character varying(50) NOT NULL,
    "status" character varying(50) DEFAULT 'active'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "metadata" "jsonb",
    "created_by" "uuid",
    "updated_by" "uuid"
);


ALTER TABLE "public"."programs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."university_colleges" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "university_id" "uuid" NOT NULL,
    "name" character varying(255) NOT NULL,
    "code" character varying(50) NOT NULL,
    "dean_name" character varying(200),
    "dean_email" character varying(255),
    "dean_phone" character varying(20),
    "established_year" integer,
    "account_status" character varying(20) DEFAULT 'active'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_by" "uuid",
    "college_id" "uuid"
);


ALTER TABLE "public"."university_colleges" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."college_curriculum_status" AS
 SELECT "c"."id" AS "curriculum_id",
    "c"."academic_year",
    "c"."status",
    "c"."request_date",
    "c"."request_message",
    "c"."review_date",
    "c"."review_notes",
    "c"."published_date",
    "cc"."course_name",
    "cc"."course_code",
    "cm"."semester",
        CASE
            WHEN ("uc"."university_id" IS NOT NULL) THEN true
            ELSE false
        END AS "is_affiliated",
    "uc"."university_id",
    "univ_org"."name" AS "university_name",
    "dept"."name" AS "department_name",
    "prog"."name" AS "program_name"
   FROM (((((("public"."college_curriculums" "c"
     LEFT JOIN "public"."college_course_mappings" "cm" ON (("cm"."id" = "c"."course_id")))
     LEFT JOIN "public"."college_courses" "cc" ON (("cc"."id" = "cm"."course_id")))
     LEFT JOIN "public"."university_colleges" "uc" ON ((("uc"."college_id" = "c"."college_id") AND (("uc"."account_status")::"text" = 'active'::"text"))))
     LEFT JOIN "public"."organizations" "univ_org" ON (("univ_org"."id" = "uc"."university_id")))
     LEFT JOIN "public"."departments" "dept" ON (("dept"."id" = "c"."department_id")))
     LEFT JOIN "public"."programs" "prog" ON (("prog"."id" = "c"."program_id")));


ALTER VIEW "public"."college_curriculum_status" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_curriculum_units" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "curriculum_id" "uuid" NOT NULL,
    "name" character varying(255) NOT NULL,
    "code" character varying(50),
    "description" "text" NOT NULL,
    "credits" numeric(4,2),
    "estimated_duration" integer,
    "duration_unit" character varying(10),
    "order_index" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_by" "uuid",
    CONSTRAINT "college_curriculum_units_duration_unit_check" CHECK ((("duration_unit")::"text" = ANY (ARRAY[('hours'::character varying)::"text", ('weeks'::character varying)::"text"])))
);


ALTER TABLE "public"."college_curriculum_units" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."college_daily_attendance_summary" AS
 SELECT "date",
    "department_name" AS "department",
    "program_name" AS "course",
    "semester",
    "section",
    "count"(DISTINCT "session_id") AS "total_sessions",
    "count"(*) AS "total_records",
    "count"(
        CASE
            WHEN (("status")::"text" = 'present'::"text") THEN 1
            ELSE NULL::integer
        END) AS "present_count",
    "count"(
        CASE
            WHEN (("status")::"text" = 'absent'::"text") THEN 1
            ELSE NULL::integer
        END) AS "absent_count",
    "count"(
        CASE
            WHEN (("status")::"text" = 'late'::"text") THEN 1
            ELSE NULL::integer
        END) AS "late_count",
    "count"(
        CASE
            WHEN (("status")::"text" = 'excused'::"text") THEN 1
            ELSE NULL::integer
        END) AS "excused_count",
    "round"(((("count"(
        CASE
            WHEN (("status")::"text" = ANY (ARRAY[('present'::character varying)::"text", ('late'::character varying)::"text", ('excused'::character varying)::"text"])) THEN 1
            ELSE NULL::integer
        END))::numeric * 100.0) / ("count"(*))::numeric), 2) AS "daily_attendance_percentage",
    "college_id"
   FROM "public"."college_attendance_records"
  GROUP BY "date", "department_name", "program_name", "semester", "section", "college_id"
  ORDER BY "date" DESC;


ALTER VIEW "public"."college_daily_attendance_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_event_registrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "event_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "registered_at" timestamp with time zone DEFAULT "now"(),
    "attended" boolean DEFAULT false,
    "attendance_marked_at" timestamp with time zone,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."college_event_registrations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid",
    "title" character varying(255) NOT NULL,
    "description" "text",
    "event_type" character varying(50) NOT NULL,
    "start_date" timestamp with time zone NOT NULL,
    "end_date" timestamp with time zone NOT NULL,
    "venue" character varying(255),
    "capacity" integer,
    "status" character varying(20) DEFAULT 'draft'::character varying,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "college_events_event_type_check" CHECK ((("event_type")::"text" = ANY (ARRAY[('seminar'::character varying)::"text", ('workshop'::character varying)::"text", ('cultural'::character varying)::"text", ('sports'::character varying)::"text", ('placement'::character varying)::"text", ('guest_lecture'::character varying)::"text", ('orientation'::character varying)::"text", ('other'::character varying)::"text"]))),
    CONSTRAINT "college_events_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('published'::character varying)::"text", ('cancelled'::character varying)::"text", ('completed'::character varying)::"text"])))
);


ALTER TABLE "public"."college_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_faculty_class_assignments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "faculty_id" "uuid" NOT NULL,
    "class_id" "uuid" NOT NULL,
    "subject_name" character varying(255),
    "is_class_teacher" boolean DEFAULT false,
    "academic_year" character varying(20),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."college_faculty_class_assignments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_faculty_leave_balances" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "faculty_id" "uuid" NOT NULL,
    "leave_type_id" "uuid" NOT NULL,
    "academic_year" character varying(20) NOT NULL,
    "total_days" numeric(5,1) DEFAULT 0,
    "used_days" numeric(5,1) DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."college_faculty_leave_balances" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_faculty_leaves" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "faculty_id" "uuid" NOT NULL,
    "leave_type_id" "uuid" NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date" NOT NULL,
    "total_days" numeric(5,1) NOT NULL,
    "reason" "text",
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "applied_at" timestamp with time zone DEFAULT "now"(),
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "review_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "college_faculty_leaves_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('approved'::character varying)::"text", ('rejected'::character varying)::"text", ('cancelled'::character varying)::"text"])))
);


ALTER TABLE "public"."college_faculty_leaves" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_faculty_substitutions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "leave_id" "uuid",
    "original_faculty_id" "uuid" NOT NULL,
    "substitute_faculty_id" "uuid",
    "timetable_slot_id" "uuid",
    "substitution_date" "date" NOT NULL,
    "period_number" integer NOT NULL,
    "class_id" "uuid",
    "subject_name" character varying(255),
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "college_faculty_substitutions_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('assigned'::character varying)::"text", ('confirmed'::character varying)::"text", ('completed'::character varying)::"text", ('cancelled'::character varying)::"text"])))
);


ALTER TABLE "public"."college_faculty_substitutions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_leave_types" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "name" character varying(100) NOT NULL,
    "code" character varying(20) NOT NULL,
    "max_days_per_year" integer DEFAULT 12,
    "is_paid" boolean DEFAULT true,
    "requires_approval" boolean DEFAULT true,
    "color" character varying(20) DEFAULT '#6366f1'::character varying,
    "description" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."college_leave_types" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_lecturer_course_assignments" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "lecturerId" "uuid" NOT NULL,
    "courseId" "uuid" NOT NULL,
    "subject" character varying(100) NOT NULL,
    "academicYear" character varying(20) NOT NULL,
    "assignedAt" timestamp with time zone DEFAULT "now"(),
    "assignedBy" "uuid",
    "createdAt" timestamp with time zone DEFAULT "now"(),
    "updatedAt" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."college_lecturer_course_assignments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_lecturers" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "collegeId" "uuid" NOT NULL,
    "employeeId" character varying(50),
    "department" character varying(100),
    "specialization" character varying(100),
    "qualification" character varying(255),
    "experienceYears" integer,
    "dateOfJoining" "date",
    "accountStatus" "public"."account_status" DEFAULT 'active'::"public"."account_status",
    "createdAt" timestamp with time zone DEFAULT "now"(),
    "updatedAt" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "user_id" "uuid",
    "degree_certificate_url" "text",
    "id_proof_url" "text",
    "experience_letters_url" "jsonb" DEFAULT '[]'::"jsonb",
    "first_name" character varying(255),
    "last_name" character varying(255),
    "email" character varying(255),
    "phone" character varying(20),
    "address" "text",
    "date_of_birth" "date",
    "gender" character varying(10),
    "designation" character varying(100),
    "subject_expertise" "jsonb" DEFAULT '[]'::"jsonb",
    "temporary_password" character varying(255),
    "password_created_at" timestamp with time zone,
    "created_by" "uuid",
    "verification_status" character varying(50) DEFAULT 'pending'::character varying,
    "verified_by" "uuid",
    "verified_at" timestamp with time zone,
    CONSTRAINT "chk_college_lecturers_email_format" CHECK ((("email" IS NULL) OR (("email")::"text" ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'::"text")))
);


ALTER TABLE "public"."college_lecturers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_lecturers_backup" (
    "id" "uuid",
    "userId" "uuid",
    "collegeId" "uuid",
    "employeeId" character varying(50),
    "department" character varying(100),
    "specialization" character varying(100),
    "qualification" character varying(255),
    "experienceYears" integer,
    "dateOfJoining" "date",
    "accountStatus" "public"."account_status",
    "createdAt" timestamp with time zone,
    "updatedAt" timestamp with time zone,
    "metadata" "jsonb",
    "user_id" "uuid",
    "degree_certificate_url" "text",
    "id_proof_url" "text",
    "experience_letters_url" "jsonb"
);


ALTER TABLE "public"."college_lecturers_backup" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_lesson_plans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" character varying(255) NOT NULL,
    "session_date" "date" NOT NULL,
    "duration_minutes" integer,
    "college_id" "uuid" NOT NULL,
    "department_id" "uuid" NOT NULL,
    "program_id" "uuid" NOT NULL,
    "course_id" "uuid" NOT NULL,
    "semester" integer NOT NULL,
    "academic_year" character varying(20) NOT NULL,
    "curriculum_id" "uuid",
    "unit_id" "uuid",
    "selected_learning_outcomes" "uuid"[] DEFAULT '{}'::"uuid"[],
    "session_objectives" "text" NOT NULL,
    "teaching_methodology" "text" NOT NULL,
    "required_materials" "text",
    "resource_files" "jsonb" DEFAULT '[]'::"jsonb",
    "resource_links" "jsonb" DEFAULT '[]'::"jsonb",
    "evaluation_criteria" "text",
    "evaluation_items" "jsonb" DEFAULT '[]'::"jsonb",
    "follow_up_activities" "text",
    "additional_notes" "text",
    "status" character varying(20) DEFAULT 'draft'::character varying,
    "created_by" "uuid" NOT NULL,
    "updated_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "published_at" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "college_lesson_plans_semester_check" CHECK ((("semester" >= 1) AND ("semester" <= 8))),
    CONSTRAINT "college_lesson_plans_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('published'::character varying)::"text", ('archived'::character varying)::"text"])))
);


ALTER TABLE "public"."college_lesson_plans" OWNER TO "postgres";


COMMENT ON TABLE "public"."college_lesson_plans" IS 'Stores lesson plans for college courses with curriculum integration';



COMMENT ON COLUMN "public"."college_lesson_plans"."selected_learning_outcomes" IS 'Array of UUIDs referencing college_curriculum_outcomes.id';



COMMENT ON COLUMN "public"."college_lesson_plans"."resource_files" IS 'JSON array of file objects with id, name, size, type, url';



COMMENT ON COLUMN "public"."college_lesson_plans"."resource_links" IS 'JSON array of link objects with id, title, url';



COMMENT ON COLUMN "public"."college_lesson_plans"."evaluation_items" IS 'JSON array of evaluation criteria with id, criterion, percentage';



CREATE TABLE IF NOT EXISTS "public"."college_mentor_notes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "allocation_id" "uuid" NOT NULL,
    "mentor_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "title" character varying(255),
    "note_text" "text" NOT NULL,
    "outcome" "text",
    "intervention_type" character varying(50) DEFAULT 'academic'::character varying,
    "status" character varying(20) DEFAULT 'pending'::character varying,
    "is_private" boolean DEFAULT false,
    "note_date" "date" DEFAULT CURRENT_DATE,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by_role" character varying(20) DEFAULT 'admin'::character varying,
    "created_by_id" "uuid",
    "last_updated_by" "uuid",
    "last_updated_at" timestamp with time zone DEFAULT "now"(),
    "priority" character varying(20) DEFAULT 'medium'::character varying,
    "follow_up_required" boolean DEFAULT false,
    "follow_up_date" "date",
    "admin_feedback" "text",
    "educator_response" "text",
    "action_taken" "text",
    "next_steps" "text",
    "resolved_at" timestamp with time zone,
    "resolved_by" "uuid",
    CONSTRAINT "college_mentor_notes_intervention_type_check" CHECK ((("intervention_type")::"text" = ANY (ARRAY[('academic'::character varying)::"text", ('personal'::character varying)::"text", ('career'::character varying)::"text", ('attendance'::character varying)::"text", ('behavioral'::character varying)::"text", ('financial'::character varying)::"text", ('other'::character varying)::"text"]))),
    CONSTRAINT "college_mentor_notes_priority_check" CHECK ((("priority")::"text" = ANY (ARRAY[('low'::character varying)::"text", ('medium'::character varying)::"text", ('high'::character varying)::"text", ('urgent'::character varying)::"text"]))),
    CONSTRAINT "college_mentor_notes_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('acknowledged'::character varying)::"text", ('in_progress'::character varying)::"text", ('completed'::character varying)::"text", ('escalated'::character varying)::"text"])))
);


ALTER TABLE "public"."college_mentor_notes" OWNER TO "postgres";


COMMENT ON COLUMN "public"."college_mentor_notes"."status" IS 'Workflow: pending â†’ acknowledged â†’ in_progress â†’ action_taken â†’ completed (or escalated at any point). Only admin can mark as completed.';



CREATE TABLE IF NOT EXISTS "public"."college_mentor_periods" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "name" character varying(100) NOT NULL,
    "academic_year" character varying(20) NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date" NOT NULL,
    "default_mentor_capacity" integer DEFAULT 15,
    "default_office_location" character varying(255),
    "default_available_hours" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid"
);


ALTER TABLE "public"."college_mentor_periods" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_mentor_student_allocations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "mentor_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "period_id" "uuid" NOT NULL,
    "assigned_date" "date" DEFAULT CURRENT_DATE,
    "assigned_by" "uuid",
    "status" character varying(20) DEFAULT 'active'::character varying,
    "transfer_reason" "text",
    "completion_date" "date",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "college_mentor_student_allocations_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('active'::character varying)::"text", ('completed'::character varying)::"text", ('transferred'::character varying)::"text", ('cancelled'::character varying)::"text"])))
);


ALTER TABLE "public"."college_mentor_student_allocations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_role_module_permissions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "role_type" "public"."user_role" NOT NULL,
    "module_id" "uuid",
    "permission_id" "uuid",
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."college_role_module_permissions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_role_scope_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "role_type" "public"."user_role" NOT NULL,
    "scope_type" character varying(20) NOT NULL,
    "scope_value" character varying(100) NOT NULL,
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."college_role_scope_rules" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_setting_modules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "module_name" character varying(100) NOT NULL,
    "description" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."college_setting_modules" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_setting_permissions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "permission_name" character varying(50) NOT NULL,
    "description" "text",
    "created_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."college_setting_permissions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_student_assignments" (
    "student_assignment_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "assignment_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "status" "text" DEFAULT 'todo'::"text" NOT NULL,
    "priority" "text" DEFAULT 'medium'::"text" NOT NULL,
    "grade_received" numeric(7,2),
    "grade_percentage" numeric(5,2),
    "instructor_feedback" "text",
    "feedback_date" timestamp with time zone,
    "graded_by" "uuid",
    "graded_date" timestamp with time zone,
    "submission_date" timestamp with time zone,
    "submission_type" "text",
    "submission_content" "text",
    "submission_url" "text",
    "submission_files" "jsonb",
    "is_late" boolean DEFAULT false NOT NULL,
    "late_penalty" numeric(5,2),
    "assigned_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "started_date" timestamp with time zone,
    "completed_date" timestamp with time zone,
    "updated_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "is_deleted" boolean DEFAULT false NOT NULL,
    CONSTRAINT "chk_college_grade_percentage_range" CHECK ((("grade_percentage" IS NULL) OR (("grade_percentage" >= (0)::numeric) AND ("grade_percentage" <= (100)::numeric)))),
    CONSTRAINT "chk_college_status_dates" CHECK (((("status" <> 'submitted'::"text") OR ("completed_date" IS NOT NULL)) AND (("status" <> 'graded'::"text") OR ("graded_date" IS NOT NULL)))),
    CONSTRAINT "college_student_assignments_priority_check" CHECK (("priority" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text"]))),
    CONSTRAINT "college_student_assignments_status_check" CHECK (("status" = ANY (ARRAY['todo'::"text", 'in-progress'::"text", 'submitted'::"text", 'graded'::"text"]))),
    CONSTRAINT "college_student_assignments_submission_type_check" CHECK (("submission_type" = ANY (ARRAY['file'::"text", 'text'::"text", 'url'::"text", 'code'::"text", 'other'::"text"])))
);


ALTER TABLE "public"."college_student_assignments" OWNER TO "postgres";


COMMENT ON TABLE "public"."college_student_assignments" IS 'Junction table for college assignments and students with submission tracking';



COMMENT ON COLUMN "public"."college_student_assignments"."assignment_id" IS 'Reference to college assignment';



COMMENT ON COLUMN "public"."college_student_assignments"."student_id" IS 'Reference to student user_id';



COMMENT ON COLUMN "public"."college_student_assignments"."graded_by" IS 'Reference to college lecturer who graded';



COMMENT ON COLUMN "public"."college_student_assignments"."submission_files" IS 'JSONB array of submitted files: [{"file_url": "...", "original_filename": "...", "file_size": 123, "file_type": "...", "uploaded_date": "..."}]';



CREATE OR REPLACE VIEW "public"."college_student_attendance_stats" AS
 SELECT "student_id",
    "student_name",
    "roll_number",
    "subject_name" AS "subject",
    "subject_code",
    "department_name" AS "department",
    "program_name" AS "course",
    "semester",
    "section",
    "count"(*) AS "total_classes",
    "count"(
        CASE
            WHEN (("status")::"text" = 'present'::"text") THEN 1
            ELSE NULL::integer
        END) AS "present_count",
    "count"(
        CASE
            WHEN (("status")::"text" = 'absent'::"text") THEN 1
            ELSE NULL::integer
        END) AS "absent_count",
    "count"(
        CASE
            WHEN (("status")::"text" = 'late'::"text") THEN 1
            ELSE NULL::integer
        END) AS "late_count",
    "count"(
        CASE
            WHEN (("status")::"text" = 'excused'::"text") THEN 1
            ELSE NULL::integer
        END) AS "excused_count",
    "round"(((("count"(
        CASE
            WHEN (("status")::"text" = ANY (ARRAY[('present'::character varying)::"text", ('late'::character varying)::"text", ('excused'::character varying)::"text"])) THEN 1
            ELSE NULL::integer
        END))::numeric * 100.0) / ("count"(*))::numeric), 2) AS "attendance_percentage",
    "college_id"
   FROM "public"."college_attendance_records" "ar"
  GROUP BY "student_id", "student_name", "roll_number", "subject_name", "subject_code", "department_name", "program_name", "semester", "section", "college_id";


ALTER VIEW "public"."college_student_attendance_stats" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."college_subject_attendance_summary" AS
 SELECT "subject_name" AS "subject",
    "subject_code",
    "department_name" AS "department",
    "program_name" AS "course",
    "program_code",
    "semester",
    "section",
    "faculty_name" AS "faculty",
    "faculty_id",
    "count"(DISTINCT "id") AS "total_sessions",
    COALESCE("avg"("attendance_percentage"), (0)::numeric) AS "avg_attendance_percentage",
    COALESCE("sum"("present_count"), (0)::bigint) AS "total_present_count",
    COALESCE("sum"("absent_count"), (0)::bigint) AS "total_absent_count",
    COALESCE("sum"("late_count"), (0)::bigint) AS "total_late_count",
    COALESCE("sum"("excused_count"), (0)::bigint) AS "total_excused_count",
    "min"("date") AS "first_date",
    "max"("date") AS "last_date",
    COALESCE(( SELECT "college_attendance_sessions"."status"
           FROM "public"."college_attendance_sessions"
          WHERE ((("college_attendance_sessions"."subject_name")::"text" = ("ats"."subject_name")::"text") AND (("college_attendance_sessions"."department_name")::"text" = ("ats"."department_name")::"text") AND (("college_attendance_sessions"."program_name")::"text" = ("ats"."program_name")::"text") AND ("college_attendance_sessions"."semester" = "ats"."semester") AND (("college_attendance_sessions"."section")::"text" = ("ats"."section")::"text") AND ("college_attendance_sessions"."college_id" = "ats"."college_id"))
          ORDER BY "college_attendance_sessions"."date" DESC, "college_attendance_sessions"."start_time" DESC
         LIMIT 1), 'scheduled'::character varying) AS "latest_status",
    COALESCE("max"("total_students"), 0) AS "total_students",
    "college_id",
    "course_type"
   FROM "public"."college_attendance_sessions" "ats"
  GROUP BY "subject_name", "subject_code", "department_name", "program_name", "program_code", "semester", "section", "faculty_name", "faculty_id", "college_id", "course_type";


ALTER VIEW "public"."college_subject_attendance_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_time_periods" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "timetable_id" "uuid",
    "period_number" integer NOT NULL,
    "period_name" character varying(50),
    "start_time" time without time zone NOT NULL,
    "end_time" time without time zone NOT NULL,
    "is_break" boolean DEFAULT false,
    "break_type" character varying(20),
    "sort_order" integer,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."college_time_periods" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_timetable_slots" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "timetable_id" "uuid",
    "educator_id" "uuid",
    "class_id" "uuid",
    "day_of_week" integer NOT NULL,
    "period_number" integer NOT NULL,
    "start_time" time without time zone NOT NULL,
    "end_time" time without time zone NOT NULL,
    "subject_name" character varying(255) NOT NULL,
    "room_number" character varying(50),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "schedule_date" "date",
    "is_recurring" boolean DEFAULT true,
    "recurring_end_date" "date",
    "color" character varying(20),
    CONSTRAINT "college_timetable_slots_day_of_week_check" CHECK ((("day_of_week" >= 1) AND ("day_of_week" <= 7))),
    CONSTRAINT "college_timetable_slots_period_number_check" CHECK ((("period_number" >= 1) AND ("period_number" <= 15)))
);


ALTER TABLE "public"."college_timetable_slots" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."college_timetables" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "college_id" "uuid",
    "academic_year" character varying(20) NOT NULL,
    "term" character varying(50) NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date" NOT NULL,
    "status" character varying(20) DEFAULT 'draft'::character varying,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."college_timetables" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."companies" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "name" character varying(255) NOT NULL,
    "code" character varying(50) NOT NULL,
    "industry" character varying(100),
    "companySize" character varying(50),
    "hqAddress" "text",
    "hqCity" character varying(100),
    "hqState" character varying(100),
    "hqCountry" character varying(100) DEFAULT 'India'::character varying,
    "hqPincode" character varying(10),
    "phone" character varying(20),
    "email" character varying(255),
    "website" character varying(255),
    "establishedYear" integer,
    "contactPersonName" character varying(200),
    "contactPersonDesignation" character varying(100),
    "contactPersonEmail" character varying(255),
    "contactPersonPhone" character varying(20),
    "accountStatus" "public"."account_status" DEFAULT 'pending'::"public"."account_status",
    "createdAt" timestamp with time zone DEFAULT "now"(),
    "updatedAt" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "approvalStatus" "public"."approval_status" DEFAULT 'pending'::"public"."approval_status",
    "approvedBy" "uuid",
    "approvedAt" timestamp with time zone,
    "totalBranches" integer DEFAULT 0,
    "totalRecruiters" integer DEFAULT 0,
    "hqRecruiters" integer DEFAULT 0,
    "branchRecruiters" integer DEFAULT 0,
    "created_by" "uuid",
    "updated_by" "uuid"
);


ALTER TABLE "public"."companies" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."company_branches" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "companyId" "uuid" NOT NULL,
    "name" character varying(255) NOT NULL,
    "code" character varying(50) NOT NULL,
    "branchType" character varying(50),
    "address" "text",
    "city" character varying(100),
    "state" character varying(100),
    "country" character varying(100) DEFAULT 'India'::character varying,
    "pincode" character varying(10),
    "phone" character varying(20),
    "email" character varying(255),
    "branchHeadName" character varying(200),
    "branchHeadEmail" character varying(255),
    "branchHeadPhone" character varying(20),
    "accountStatus" "public"."account_status" DEFAULT 'active'::"public"."account_status",
    "createdAt" timestamp with time zone DEFAULT "now"(),
    "updatedAt" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."company_branches" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."competition_clubs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "comp_id" "uuid" NOT NULL,
    "club_id" "uuid" NOT NULL,
    "registered_at" timestamp with time zone DEFAULT "now"(),
    "registered_by_type" character varying(20),
    "registered_by_educator_id" "uuid",
    "registered_by_admin_id" "uuid",
    CONSTRAINT "check_single_comp_club_registrar" CHECK (((("registered_by_educator_id" IS NOT NULL) AND ("registered_by_admin_id" IS NULL) AND (("registered_by_type")::"text" = 'educator'::"text")) OR (("registered_by_educator_id" IS NULL) AND ("registered_by_admin_id" IS NOT NULL) AND (("registered_by_type")::"text" = 'admin'::"text")))),
    CONSTRAINT "competition_clubs_registered_by_type_check" CHECK ((("registered_by_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('admin'::character varying)::"text"])))
);


ALTER TABLE "public"."competition_clubs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."competition_results" (
    "result_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "comp_id" "uuid" NOT NULL,
    "registration_id" "uuid",
    "student_email" character varying(255) NOT NULL,
    "rank" integer,
    "score" numeric(10,2),
    "award" character varying(255),
    "category" character varying(100),
    "performance_notes" "text",
    "certificate_issued" boolean DEFAULT false,
    "certificate_id" "uuid",
    "recorded_at" timestamp with time zone DEFAULT "now"(),
    "recorded_by_type" character varying(20),
    "recorded_by_educator_id" "uuid",
    "recorded_by_admin_id" "uuid",
    CONSTRAINT "check_single_result_recorder" CHECK (((("recorded_by_educator_id" IS NOT NULL) AND ("recorded_by_admin_id" IS NULL) AND (("recorded_by_type")::"text" = 'educator'::"text")) OR (("recorded_by_educator_id" IS NULL) AND ("recorded_by_admin_id" IS NOT NULL) AND (("recorded_by_type")::"text" = 'admin'::"text")))),
    CONSTRAINT "competition_results_recorded_by_type_check" CHECK ((("recorded_by_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('admin'::character varying)::"text"])))
);


ALTER TABLE "public"."competition_results" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."competitions" (
    "comp_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "school_id" "uuid" NOT NULL,
    "name" character varying(255) NOT NULL,
    "description" "text",
    "level" character varying(50) NOT NULL,
    "category" character varying(50),
    "competition_date" "date" NOT NULL,
    "registration_deadline" "date",
    "venue" character varying(255),
    "team_size_min" integer DEFAULT 1,
    "team_size_max" integer DEFAULT 1,
    "eligibility_criteria" "text",
    "rules" "text",
    "prizes" "jsonb" DEFAULT '[]'::"jsonb",
    "status" character varying(20) DEFAULT 'upcoming'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by_type" character varying(20),
    "created_by_educator_id" "uuid",
    "created_by_admin_id" "uuid",
    CONSTRAINT "check_single_comp_creator" CHECK (((("created_by_educator_id" IS NOT NULL) AND ("created_by_admin_id" IS NULL) AND (("created_by_type")::"text" = 'educator'::"text")) OR (("created_by_educator_id" IS NULL) AND ("created_by_admin_id" IS NOT NULL) AND (("created_by_type")::"text" = 'admin'::"text")))),
    CONSTRAINT "competitions_created_by_type_check" CHECK ((("created_by_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('admin'::character varying)::"text"]))),
    CONSTRAINT "competitions_level_check" CHECK ((("level")::"text" = ANY (ARRAY[('intraschool'::character varying)::"text", ('interschool'::character varying)::"text", ('district'::character varying)::"text", ('state'::character varying)::"text", ('national'::character varying)::"text", ('international'::character varying)::"text"]))),
    CONSTRAINT "competitions_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('upcoming'::character varying)::"text", ('ongoing'::character varying)::"text", ('completed'::character varying)::"text", ('cancelled'::character varying)::"text"])))
);


ALTER TABLE "public"."competitions" OWNER TO "postgres";


COMMENT ON TABLE "public"."competitions" IS 'Stores competition information with multi-level support';



CREATE OR REPLACE VIEW "public"."competition_performance_report" AS
 SELECT "comp"."comp_id",
    "comp"."school_id",
    "comp"."name" AS "competition_name",
    "comp"."level",
    "comp"."category",
    "comp"."competition_date",
    "count"(DISTINCT "cr"."student_email") AS "total_participants",
    "count"(DISTINCT
        CASE
            WHEN ("cr"."award" IS NOT NULL) THEN "cr"."student_email"
            ELSE NULL::character varying
        END) AS "award_winners",
    "string_agg"(DISTINCT ("cr"."award")::"text", ', '::"text") AS "awards_won",
    "round"("avg"("cr"."score"), 2) AS "avg_score",
    ( SELECT "string_agg"("ranked_results"."student_result", ', '::"text") AS "string_agg"
           FROM ( SELECT (((("s"."name")::"text" || ' (Rank: '::"text") || COALESCE(("cr2"."rank")::"text", 'N/A'::"text")) || ')'::"text") AS "student_result"
                   FROM ("public"."competition_results" "cr2"
                     JOIN "public"."students" "s" ON ((("cr2"."student_email")::"text" = "s"."email")))
                  WHERE ("cr2"."comp_id" = "comp"."comp_id")
                  ORDER BY "cr2"."rank"
                 LIMIT 10) "ranked_results") AS "student_results"
   FROM ("public"."competitions" "comp"
     LEFT JOIN "public"."competition_results" "cr" ON (("comp"."comp_id" = "cr"."comp_id")))
  GROUP BY "comp"."comp_id", "comp"."school_id", "comp"."name", "comp"."level", "comp"."category", "comp"."competition_date";


ALTER VIEW "public"."competition_performance_report" OWNER TO "postgres";


COMMENT ON VIEW "public"."competition_performance_report" IS 'Report view for competition performance metrics (Requirement 9.5.2)';



CREATE TABLE IF NOT EXISTS "public"."competition_registrations" (
    "registration_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "comp_id" "uuid" NOT NULL,
    "student_email" character varying(255) NOT NULL,
    "team_name" character varying(255),
    "team_members" "jsonb" DEFAULT '[]'::"jsonb",
    "registration_date" timestamp with time zone DEFAULT "now"(),
    "registered_by_type" character varying(20),
    "registered_by_educator_id" "uuid",
    "registered_by_admin_id" "uuid",
    "status" character varying(20) DEFAULT 'registered'::character varying,
    "notes" "text",
    "special_requirements" "text",
    CONSTRAINT "check_single_comp_registrar" CHECK (((("registered_by_educator_id" IS NOT NULL) AND ("registered_by_admin_id" IS NULL) AND (("registered_by_type")::"text" = 'educator'::"text")) OR (("registered_by_educator_id" IS NULL) AND ("registered_by_admin_id" IS NOT NULL) AND (("registered_by_type")::"text" = 'admin'::"text")) OR (("registered_by_educator_id" IS NULL) AND ("registered_by_admin_id" IS NULL) AND (("registered_by_type")::"text" = 'self'::"text")))),
    CONSTRAINT "competition_registrations_registered_by_type_check" CHECK ((("registered_by_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('admin'::character varying)::"text", ('self'::character varying)::"text"]))),
    CONSTRAINT "competition_registrations_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('registered'::character varying)::"text", ('confirmed'::character varying)::"text", ('withdrawn'::character varying)::"text", ('disqualified'::character varying)::"text"])))
);


ALTER TABLE "public"."competition_registrations" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."competition_results_with_students" AS
 SELECT "cr"."result_id",
    "cr"."comp_id",
    "comp"."name" AS "competition_name",
    "comp"."level",
    "comp"."category",
    "cr"."student_email",
    "s"."name" AS "student_name",
    "s"."grade",
    "s"."section",
    "cr"."rank",
    "cr"."score",
    "cr"."award",
    "cr"."certificate_issued",
    "cr"."recorded_at"
   FROM (("public"."competition_results" "cr"
     JOIN "public"."competitions" "comp" ON (("cr"."comp_id" = "comp"."comp_id")))
     JOIN "public"."students" "s" ON ((("cr"."student_email")::"text" = "s"."email")));


ALTER VIEW "public"."competition_results_with_students" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."conversations" (
    "id" "text" NOT NULL,
    "student_id" "uuid",
    "recruiter_id" "uuid",
    "application_id" integer,
    "opportunity_id" integer,
    "subject" "text",
    "status" "text" DEFAULT 'active'::"text",
    "last_message_at" timestamp with time zone,
    "last_message_preview" "text",
    "last_message_sender" "text",
    "student_unread_count" integer DEFAULT 0,
    "recruiter_unread_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "deleted_by_student" boolean DEFAULT false NOT NULL,
    "deleted_by_recruiter" boolean DEFAULT false NOT NULL,
    "student_deleted_at" timestamp with time zone,
    "recruiter_deleted_at" timestamp with time zone,
    "educator_id" "uuid",
    "class_id" "uuid",
    "conversation_type" character varying(50) DEFAULT 'student_recruiter'::character varying,
    "educator_unread_count" integer DEFAULT 0,
    "deleted_by_educator" boolean DEFAULT false,
    "educator_deleted_at" timestamp with time zone,
    "school_id" "uuid",
    "admin_unread_count" integer DEFAULT 0,
    "deleted_by_admin" boolean DEFAULT false,
    "admin_deleted_at" timestamp with time zone,
    "college_id" "uuid",
    "college_admin_unread_count" integer DEFAULT 0,
    "deleted_by_college_admin" boolean DEFAULT false,
    "college_admin_deleted_at" timestamp with time zone,
    "program_section_id" "uuid",
    "college_educator_unread_count" integer DEFAULT 0,
    "deleted_by_college_educator" boolean DEFAULT false,
    "college_educator_deleted_at" timestamp with time zone,
    CONSTRAINT "conversations_participant_check" CHECK (((("student_id" IS NOT NULL) AND ("recruiter_id" IS NOT NULL) AND ("educator_id" IS NULL) AND ("school_id" IS NULL) AND ("college_id" IS NULL) AND (("conversation_type")::"text" = 'student_recruiter'::"text")) OR (("student_id" IS NOT NULL) AND ("educator_id" IS NOT NULL) AND ("recruiter_id" IS NULL) AND ("school_id" IS NULL) AND ("college_id" IS NULL) AND (("conversation_type")::"text" = 'student_educator'::"text")) OR (("student_id" IS NOT NULL) AND ("school_id" IS NOT NULL) AND ("recruiter_id" IS NULL) AND ("educator_id" IS NULL) AND ("college_id" IS NULL) AND (("conversation_type")::"text" = 'student_admin'::"text")) OR (("student_id" IS NOT NULL) AND ("college_id" IS NOT NULL) AND ("recruiter_id" IS NULL) AND ("educator_id" IS NULL) AND ("school_id" IS NULL) AND (("conversation_type")::"text" = 'student_college_admin'::"text")) OR (("student_id" IS NOT NULL) AND ("recruiter_id" IS NOT NULL) AND ("educator_id" IS NOT NULL) AND ("school_id" IS NULL) AND ("college_id" IS NULL) AND (("conversation_type")::"text" = 'educator_recruiter'::"text")) OR (("student_id" IS NULL) AND ("educator_id" IS NOT NULL) AND ("school_id" IS NOT NULL) AND ("recruiter_id" IS NULL) AND ("college_id" IS NULL) AND (("conversation_type")::"text" = 'educator_admin'::"text")) OR (("student_id" IS NOT NULL) AND ("educator_id" IS NOT NULL) AND ("college_id" IS NOT NULL) AND ("recruiter_id" IS NULL) AND ("school_id" IS NULL) AND (("conversation_type")::"text" = 'student_college_educator'::"text")) OR (("student_id" IS NULL) AND ("educator_id" IS NOT NULL) AND ("college_id" IS NOT NULL) AND ("recruiter_id" IS NULL) AND ("school_id" IS NULL) AND (("conversation_type")::"text" = 'college_educator_admin'::"text"))))
);


ALTER TABLE "public"."conversations" OWNER TO "postgres";


COMMENT ON TABLE "public"."conversations" IS 'RLS temporarily disabled for student-educator messaging testing. Re-enable after authentication is properly configured.';



COMMENT ON COLUMN "public"."conversations"."subject" IS 'Subject being discussed (from school_educator_class_assignments)';



COMMENT ON COLUMN "public"."conversations"."deleted_by_student" IS 'Indicates if the student has deleted this conversation from their view';



COMMENT ON COLUMN "public"."conversations"."deleted_by_recruiter" IS 'Indicates if the recruiter has deleted this conversation from their view';



COMMENT ON COLUMN "public"."conversations"."student_deleted_at" IS 'Timestamp when student deleted the conversation';



COMMENT ON COLUMN "public"."conversations"."recruiter_deleted_at" IS 'Timestamp when recruiter deleted the conversation';



COMMENT ON COLUMN "public"."conversations"."educator_id" IS 'Reference to school_educators for student-educator conversations';



COMMENT ON COLUMN "public"."conversations"."class_id" IS 'Reference to school_classes for class context';



COMMENT ON COLUMN "public"."conversations"."conversation_type" IS 'Type of conversation: student_recruiter, student_educator, or educator_recruiter';



COMMENT ON COLUMN "public"."conversations"."educator_unread_count" IS 'Number of unread messages for the educator';



COMMENT ON COLUMN "public"."conversations"."deleted_by_educator" IS 'Whether the educator has soft-deleted this conversation';



COMMENT ON COLUMN "public"."conversations"."educator_deleted_at" IS 'When the educator deleted the conversation';



COMMENT ON COLUMN "public"."conversations"."school_id" IS 'Reference to schools table for student-admin conversations (all admins in school can see)';



COMMENT ON COLUMN "public"."conversations"."admin_unread_count" IS 'Number of unread messages for the school admin';



COMMENT ON COLUMN "public"."conversations"."deleted_by_admin" IS 'Whether the school admin has soft-deleted this conversation';



COMMENT ON COLUMN "public"."conversations"."admin_deleted_at" IS 'When the school admin deleted the conversation';



COMMENT ON COLUMN "public"."conversations"."college_id" IS 'Reference to colleges table for student-college_admin conversations (all admins in college can see)';



COMMENT ON COLUMN "public"."conversations"."college_admin_unread_count" IS 'Number of unread messages for the college admin';



COMMENT ON COLUMN "public"."conversations"."deleted_by_college_admin" IS 'Whether the college admin has soft-deleted this conversation';



COMMENT ON COLUMN "public"."conversations"."college_admin_deleted_at" IS 'When the college admin deleted the conversation';



CREATE TABLE IF NOT EXISTS "public"."conversations_backup_20251106" (
    "id" "text",
    "student_id" "uuid",
    "recruiter_id" "uuid",
    "application_id" integer,
    "opportunity_id" integer,
    "subject" "text",
    "status" "text",
    "last_message_at" timestamp with time zone,
    "last_message_preview" "text",
    "last_message_sender" "text",
    "student_unread_count" integer,
    "recruiter_unread_count" integer,
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone
);


ALTER TABLE "public"."conversations_backup_20251106" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."opportunities" (
    "id_old" integer,
    "title" "text" NOT NULL,
    "company_name" "text" NOT NULL,
    "company_logo" "text",
    "employment_type" "text" NOT NULL,
    "location" "text" NOT NULL,
    "mode" "text",
    "stipend_or_salary" "text",
    "experience_required" "text",
    "skills_required" "jsonb",
    "description" "text",
    "application_link" "text",
    "deadline" timestamp with time zone,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "department" "text" NOT NULL,
    "experience_level" "text",
    "salary_range_min" integer,
    "salary_range_max" integer,
    "status" "text" DEFAULT 'draft'::"text",
    "posted_date" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "closing_date" timestamp with time zone,
    "requirements" "jsonb",
    "responsibilities" "jsonb",
    "benefits" "jsonb",
    "applications_count" integer DEFAULT 0,
    "messages_count" integer DEFAULT 0,
    "views_count" integer DEFAULT 0,
    "created_by" "text",
    "job_title" "text" NOT NULL,
    "recruiter_id" "uuid",
    "embedding" "extensions"."vector"(1536),
    "requisition_id" "text",
    "requisition_id_uuid" "uuid",
    "sector" "text",
    "exposure_type" "text",
    "total_hours" integer,
    "duration_weeks" integer,
    "duration_days" integer,
    "schedule_note" "text",
    "what_youll_learn" "text",
    "what_youll_do" "text",
    "final_artifact_type" "text",
    "final_artifact_description" "text",
    "mentor_bio" "text",
    "safety_note" "text",
    "parent_role" "text",
    "cost_inr" integer,
    "cost_note" "text",
    "prerequiste" character varying,
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL
);


ALTER TABLE "public"."opportunities" OWNER TO "postgres";


COMMENT ON COLUMN "public"."opportunities"."sector" IS 'Industry sector (e.g., Technology, Healthcare, Education)';



COMMENT ON COLUMN "public"."opportunities"."exposure_type" IS 'Type of exposure (e.g., Hands-on, Observation, Hybrid)';



COMMENT ON COLUMN "public"."opportunities"."total_hours" IS 'Total hours for the internship/opportunity';



COMMENT ON COLUMN "public"."opportunities"."duration_weeks" IS 'Duration in weeks';



COMMENT ON COLUMN "public"."opportunities"."duration_days" IS 'Duration in days';



COMMENT ON COLUMN "public"."opportunities"."what_youll_learn" IS 'Learning outcomes description';



COMMENT ON COLUMN "public"."opportunities"."what_youll_do" IS 'Activities and tasks description';



COMMENT ON COLUMN "public"."opportunities"."cost_inr" IS 'Cost in Indian Rupees';



CREATE TABLE IF NOT EXISTS "public"."recruiters" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "email" "text",
    "phone" "text",
    "state" "text",
    "website" "text",
    "verificationstatus" "text" DEFAULT 'approved'::"text",
    "isactive" boolean DEFAULT true,
    "createdat" timestamp with time zone DEFAULT "now"(),
    "updatedat" timestamp with time zone DEFAULT "now"(),
    "approval_status" character varying(20) DEFAULT 'approved'::character varying,
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "rejection_reason" "text",
    "account_status" character varying(20) DEFAULT 'active'::character varying,
    "user_id" "uuid" NOT NULL,
    "company_id" "uuid"
);


ALTER TABLE "public"."recruiters" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."conversations_detailed" AS
 SELECT "c"."id",
    "c"."student_id",
    "c"."recruiter_id",
    "c"."application_id",
    "c"."opportunity_id",
    "c"."subject",
    "c"."status",
    "c"."last_message_at",
    "c"."last_message_preview",
    "c"."last_message_sender",
    "c"."student_unread_count",
    "c"."recruiter_unread_count",
    "c"."created_at",
    "c"."updated_at",
    "s"."name" AS "student_name",
    "s"."email" AS "student_email",
    COALESCE("s"."university_main", "s"."university") AS "student_university",
    "s"."course_name" AS "student_course",
    "s"."branch_field" AS "student_department",
    "r"."name" AS "recruiter_name",
    "r"."email" AS "recruiter_email",
    "r"."phone" AS "recruiter_phone",
    "r"."website" AS "recruiter_website",
    "aj"."application_status",
    "o"."job_title",
    "o"."company_name"
   FROM (((("public"."conversations" "c"
     LEFT JOIN "public"."students" "s" ON (("c"."student_id" = "s"."id")))
     LEFT JOIN "public"."recruiters" "r" ON (("c"."recruiter_id" = "r"."id")))
     LEFT JOIN "public"."applied_jobs" "aj" ON (("c"."application_id" = "aj"."id_old")))
     LEFT JOIN "public"."opportunities" "o" ON (("c"."opportunity_id" = "o"."id_old")))
  WHERE ("c"."status" = 'active'::"text");


ALTER VIEW "public"."conversations_detailed" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."course_classes" (
    "course_class_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "course_id" "uuid" NOT NULL,
    "class_name" character varying(100) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"())
);


ALTER TABLE "public"."course_classes" OWNER TO "postgres";


COMMENT ON TABLE "public"."course_classes" IS 'Classes/groups enrolled in the course';



CREATE TABLE IF NOT EXISTS "public"."course_co_educators" (
    "co_educator_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "course_id" "uuid" NOT NULL,
    "educator_id" "uuid" NOT NULL,
    "educator_name" character varying(255),
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"())
);


ALTER TABLE "public"."course_co_educators" OWNER TO "postgres";


COMMENT ON TABLE "public"."course_co_educators" IS 'Co-educators who can manage the course';



CREATE TABLE IF NOT EXISTS "public"."course_modules" (
    "module_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "course_id" "uuid" NOT NULL,
    "title" character varying(255) NOT NULL,
    "description" "text",
    "order_index" integer DEFAULT 0 NOT NULL,
    "skill_tags" "jsonb" DEFAULT '[]'::"jsonb",
    "activities" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"())
);


ALTER TABLE "public"."course_modules" OWNER TO "postgres";


COMMENT ON TABLE "public"."course_modules" IS 'Course modules/sections';



CREATE TABLE IF NOT EXISTS "public"."course_skills" (
    "course_skill_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "course_id" "uuid" NOT NULL,
    "skill_name" character varying(100) NOT NULL,
    "proficiency_level" character varying(50),
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"())
);


ALTER TABLE "public"."course_skills" OWNER TO "postgres";


COMMENT ON TABLE "public"."course_skills" IS 'Skills covered in the course';



CREATE OR REPLACE VIEW "public"."course_summary" AS
SELECT
    NULL::"uuid" AS "course_id",
    NULL::character varying(255) AS "title",
    NULL::character varying(50) AS "code",
    NULL::"text" AS "description",
    NULL::character varying(20) AS "status",
    NULL::character varying(50) AS "duration",
    NULL::"uuid" AS "educator_id",
    NULL::"text" AS "educator_name",
    NULL::integer AS "enrollment_count",
    NULL::integer AS "completion_rate",
    NULL::integer AS "evidence_pending",
    NULL::timestamp with time zone AS "created_at",
    NULL::timestamp with time zone AS "updated_at",
    NULL::bigint AS "module_count",
    NULL::bigint AS "lesson_count",
    NULL::bigint AS "resource_count",
    NULL::json AS "skills",
    NULL::json AS "classes";


ALTER VIEW "public"."course_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."courses" (
    "course_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" character varying(255) NOT NULL,
    "code" character varying(50) NOT NULL,
    "description" "text" NOT NULL,
    "thumbnail" "text",
    "status" character varying(20) DEFAULT 'Draft'::character varying,
    "duration" character varying(50) NOT NULL,
    "enrollment_count" integer DEFAULT 0,
    "completion_rate" integer DEFAULT 0,
    "evidence_pending" integer DEFAULT 0,
    "skills_mapped" integer DEFAULT 0,
    "total_skills" integer DEFAULT 0,
    "educator_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "deleted_at" timestamp with time zone,
    "target_outcomes" "jsonb" DEFAULT '[]'::"jsonb",
    "university" "text",
    "credits" numeric,
    "category" "text",
    "approval_status" "text" DEFAULT 'pending'::"text",
    "rejection_reason" "text",
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "rejected_by" "uuid",
    "rejected_at" timestamp with time zone,
    "skill_type" character varying(20) DEFAULT 'soft'::character varying,
    "school_id" "uuid",
    "embedding" "extensions"."vector"(1536),
    CONSTRAINT "courses_completion_rate_check" CHECK ((("completion_rate" >= 0) AND ("completion_rate" <= 100))),
    CONSTRAINT "courses_skill_type_check" CHECK ((("skill_type")::"text" = ANY (ARRAY[('technical'::character varying)::"text", ('soft'::character varying)::"text"]))),
    CONSTRAINT "courses_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('Active'::character varying)::"text", ('Draft'::character varying)::"text", ('Upcoming'::character varying)::"text", ('Archived'::character varying)::"text"])))
);


ALTER TABLE "public"."courses" OWNER TO "postgres";


COMMENT ON TABLE "public"."courses" IS 'Main courses table containing course information';



COMMENT ON COLUMN "public"."courses"."skill_type" IS 'Course classification: technical or soft skills';



COMMENT ON COLUMN "public"."courses"."embedding" IS 'Course embedding vector (1536 dimensions, text-embedding-3-small model)';



CREATE TABLE IF NOT EXISTS "public"."curriculum_academic_years" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "school_id" "uuid",
    "year" character varying(20) NOT NULL,
    "start_date" "date",
    "end_date" "date",
    "is_active" boolean DEFAULT true,
    "is_current" boolean DEFAULT false,
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."curriculum_academic_years" OWNER TO "postgres";


COMMENT ON TABLE "public"."curriculum_academic_years" IS 'Configurable academic years for curriculum builder';



COMMENT ON COLUMN "public"."curriculum_academic_years"."school_id" IS 'NULL for global years, specific school_id for school-specific years';



COMMENT ON COLUMN "public"."curriculum_academic_years"."is_current" IS 'Only one academic year should be current at a time';



CREATE TABLE IF NOT EXISTS "public"."users" (
    "email" "text" NOT NULL,
    "organizationId" "uuid",
    "isActive" boolean DEFAULT true,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "createdAt" timestamp with time zone DEFAULT "now"(),
    "updatedAt" timestamp with time zone DEFAULT "now"(),
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "firstName" character varying,
    "lastName" character varying,
    "last_activity_at" timestamp with time zone,
    "role" "public"."user_role" NOT NULL,
    "temporary_password" character varying(255),
    "password_changed" boolean DEFAULT false,
    "phone" character varying(20)
);


ALTER TABLE "public"."users" OWNER TO "postgres";


COMMENT ON COLUMN "public"."users"."organizationId" IS 'References organizations.id - NULL for users not yet associated with an organization (e.g., during signup before org setup)';



COMMENT ON COLUMN "public"."users"."firstName" IS 'User''s first name';



COMMENT ON COLUMN "public"."users"."lastName" IS 'User''s last name';



CREATE OR REPLACE VIEW "public"."curriculum_approval_dashboard" AS
 SELECT "c"."id" AS "curriculum_id",
    "c"."academic_year",
    "c"."status",
    "c"."request_date",
    "c"."request_message",
    "c"."review_date",
    "c"."review_notes",
    "c"."published_date",
    "cc"."course_name",
    "cc"."course_code",
    "cm"."semester",
    "college_org"."name" AS "college_name",
    "college_org"."id" AS "college_id",
    "univ_org"."name" AS "university_name",
    "univ_org"."id" AS "university_id",
    "requester"."email" AS "requester_email",
    "concat"("requester"."firstName", ' ', "requester"."lastName") AS "requester_name",
    "reviewer"."email" AS "reviewer_email",
    "concat"("reviewer"."firstName", ' ', "reviewer"."lastName") AS "reviewer_name",
    "dept"."name" AS "department_name",
    "prog"."name" AS "program_name"
   FROM (((((((("public"."college_curriculums" "c"
     LEFT JOIN "public"."college_course_mappings" "cm" ON (("cm"."id" = "c"."course_id")))
     LEFT JOIN "public"."college_courses" "cc" ON (("cc"."id" = "cm"."course_id")))
     LEFT JOIN "public"."organizations" "college_org" ON (("college_org"."id" = "c"."college_id")))
     LEFT JOIN "public"."organizations" "univ_org" ON (("univ_org"."id" = "c"."university_id")))
     LEFT JOIN "public"."users" "requester" ON (("requester"."id" = "c"."requested_by")))
     LEFT JOIN "public"."users" "reviewer" ON (("reviewer"."id" = "c"."reviewed_by")))
     LEFT JOIN "public"."departments" "dept" ON (("dept"."id" = "c"."department_id")))
     LEFT JOIN "public"."programs" "prog" ON (("prog"."id" = "c"."program_id")))
  WHERE (("c"."status")::"text" = ANY (ARRAY[('pending_approval'::character varying)::"text", ('rejected'::character varying)::"text", ('published'::character varying)::"text"]));


ALTER VIEW "public"."curriculum_approval_dashboard" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."curriculum_chapters" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "curriculum_id" "uuid" NOT NULL,
    "name" character varying(200) NOT NULL,
    "code" character varying(50),
    "description" "text" NOT NULL,
    "order_number" integer NOT NULL,
    "estimated_duration" integer,
    "duration_unit" character varying(10),
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"(),
    CONSTRAINT "curriculum_chapters_duration_unit_check" CHECK ((("duration_unit")::"text" = ANY (ARRAY[('hours'::character varying)::"text", ('weeks'::character varying)::"text"])))
);


ALTER TABLE "public"."curriculum_chapters" OWNER TO "postgres";


COMMENT ON TABLE "public"."curriculum_chapters" IS 'Chapters within a curriculum with order and duration';



CREATE TABLE IF NOT EXISTS "public"."curriculum_classes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "school_id" "uuid",
    "name" character varying(50) NOT NULL,
    "description" "text",
    "is_active" boolean DEFAULT true,
    "display_order" integer DEFAULT 0,
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."curriculum_classes" OWNER TO "postgres";


COMMENT ON TABLE "public"."curriculum_classes" IS 'Configurable classes/grades for curriculum builder';



COMMENT ON COLUMN "public"."curriculum_classes"."school_id" IS 'NULL for global classes, specific school_id for school-specific classes';



CREATE TABLE IF NOT EXISTS "public"."curriculum_courses" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "college_id" "uuid",
    "department_id" "uuid",
    "program_id" "uuid",
    "course_code" character varying(50) NOT NULL,
    "course_name" character varying(255) NOT NULL,
    "course_type" character varying(50),
    "semester" integer,
    "credits" numeric(4,2) DEFAULT 0,
    "contact_hours" integer DEFAULT 0,
    "syllabus" "text",
    "learning_outcomes" "jsonb" DEFAULT '[]'::"jsonb",
    "prerequisites" "jsonb" DEFAULT '[]'::"jsonb",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    CONSTRAINT "curriculum_courses_course_type_check" CHECK ((("course_type")::"text" = ANY (ARRAY[('Theory'::character varying)::"text", ('Practical'::character varying)::"text", ('Lab'::character varying)::"text", ('Project'::character varying)::"text", ('Elective'::character varying)::"text", ('Core'::character varying)::"text"]))),
    CONSTRAINT "curriculum_courses_semester_check" CHECK ((("semester" >= 1) AND ("semester" <= 12)))
);


ALTER TABLE "public"."curriculum_courses" OWNER TO "postgres";


COMMENT ON TABLE "public"."curriculum_courses" IS 'Master table for college subjects/courses offered in different programs and semesters';



CREATE TABLE IF NOT EXISTS "public"."curriculum_learning_outcomes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "chapter_id" "uuid" NOT NULL,
    "outcome" "text" NOT NULL,
    "bloom_level" character varying(20),
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"(),
    CONSTRAINT "curriculum_learning_outcomes_bloom_level_check" CHECK ((("bloom_level")::"text" = ANY (ARRAY[('Remember'::character varying)::"text", ('Understand'::character varying)::"text", ('Apply'::character varying)::"text", ('Analyze'::character varying)::"text", ('Evaluate'::character varying)::"text", ('Create'::character varying)::"text"])))
);


ALTER TABLE "public"."curriculum_learning_outcomes" OWNER TO "postgres";


COMMENT ON TABLE "public"."curriculum_learning_outcomes" IS 'Learning outcomes mapped to chapters with Bloom taxonomy';



COMMENT ON COLUMN "public"."curriculum_learning_outcomes"."bloom_level" IS 'Bloom''s Taxonomy cognitive level';



CREATE TABLE IF NOT EXISTS "public"."curriculum_subjects" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "school_id" "uuid",
    "name" character varying(100) NOT NULL,
    "description" "text",
    "is_active" boolean DEFAULT true,
    "display_order" integer DEFAULT 0,
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."curriculum_subjects" OWNER TO "postgres";


COMMENT ON TABLE "public"."curriculum_subjects" IS 'Configurable subjects for curriculum builder';



COMMENT ON COLUMN "public"."curriculum_subjects"."school_id" IS 'NULL for global subjects, specific school_id for school-specific subjects';



CREATE OR REPLACE VIEW "public"."curriculum_summary" AS
SELECT
    NULL::"uuid" AS "id",
    NULL::"uuid" AS "school_id",
    NULL::character varying(100) AS "subject",
    NULL::character varying(10) AS "class",
    NULL::character varying(20) AS "academic_year",
    NULL::character varying(20) AS "status",
    NULL::"uuid" AS "created_by",
    NULL::"uuid" AS "approved_by",
    NULL::timestamp without time zone AS "approval_date",
    NULL::"text" AS "rejection_reason",
    NULL::timestamp without time zone AS "last_modified",
    NULL::timestamp without time zone AS "created_at",
    NULL::"text" AS "created_by_name",
    NULL::character varying(255) AS "created_by_email",
    NULL::bigint AS "total_chapters",
    NULL::bigint AS "total_outcomes",
    NULL::bigint AS "total_assessment_mappings",
    NULL::numeric AS "completion_percentage";


ALTER VIEW "public"."curriculum_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."curriculums" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "school_id" "uuid" NOT NULL,
    "subject" character varying(100) NOT NULL,
    "class" character varying(10) NOT NULL,
    "academic_year" character varying(20) NOT NULL,
    "status" character varying(20) DEFAULT 'draft'::character varying,
    "created_by" "uuid",
    "approved_by" "uuid",
    "approval_date" timestamp without time zone,
    "rejection_reason" "text",
    "last_modified" timestamp without time zone DEFAULT "now"(),
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"(),
    CONSTRAINT "curriculums_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('pending_approval'::character varying)::"text", ('approved'::character varying)::"text", ('rejected'::character varying)::"text"])))
);


ALTER TABLE "public"."curriculums" OWNER TO "postgres";


COMMENT ON TABLE "public"."curriculums" IS 'Main curriculum table storing subject-wise curriculum for each class';



COMMENT ON COLUMN "public"."curriculums"."status" IS 'Workflow status: draft, pending_approval, approved, rejected';



CREATE TABLE IF NOT EXISTS "public"."department_budgets" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "department_id" "uuid" NOT NULL,
    "department_name" "text" NOT NULL,
    "financial_year" "text" NOT NULL,
    "period_from" "date" NOT NULL,
    "period_to" "date" NOT NULL,
    "quarter" "text",
    "budget_heads" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "total_allocated" numeric(12,2) NOT NULL,
    "total_spent" numeric(12,2) DEFAULT 0,
    "total_remaining" numeric(12,2) GENERATED ALWAYS AS (("total_allocated" - "total_spent")) STORED,
    "utilization_percentage" numeric(5,2) GENERATED ALWAYS AS (
CASE
    WHEN ("total_allocated" > (0)::numeric) THEN (("total_spent" / "total_allocated") * (100)::numeric)
    ELSE (0)::numeric
END) STORED,
    "carry_forward_amount" numeric(12,2) DEFAULT 0,
    "carry_forward_from" "text",
    "status" "text" DEFAULT 'draft'::"text",
    "is_locked" boolean DEFAULT false,
    "submitted_by" "uuid",
    "submitted_at" timestamp with time zone,
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "approval_remarks" "text",
    "revision_number" integer DEFAULT 1,
    "previous_budget_id" "uuid",
    "revision_reason" "text",
    "alert_threshold_percentage" numeric(5,2) DEFAULT 80,
    "alert_sent" boolean DEFAULT false,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "department_budgets_quarter_check" CHECK (("quarter" = ANY (ARRAY['Q1'::"text", 'Q2'::"text", 'Q3'::"text", 'Q4'::"text", 'Annual'::"text"]))),
    CONSTRAINT "department_budgets_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'pending_approval'::"text", 'approved'::"text", 'active'::"text", 'closed'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "valid_budget_amounts" CHECK ((("total_allocated" >= (0)::numeric) AND ("total_spent" >= (0)::numeric) AND ("carry_forward_amount" >= (0)::numeric))),
    CONSTRAINT "valid_period" CHECK (("period_to" > "period_from")),
    CONSTRAINT "valid_threshold" CHECK ((("alert_threshold_percentage" >= (0)::numeric) AND ("alert_threshold_percentage" <= (100)::numeric)))
);


ALTER TABLE "public"."department_budgets" OWNER TO "postgres";


COMMENT ON TABLE "public"."department_budgets" IS 'Department budget allocation with approval workflow and utilization tracking';



CREATE TABLE IF NOT EXISTS "public"."department_faculty_assignments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "department_id" "uuid" NOT NULL,
    "lecturer_id" "uuid" NOT NULL,
    "assignment_type" character varying(50) DEFAULT 'faculty'::character varying,
    "assigned_at" timestamp with time zone DEFAULT "now"(),
    "assigned_by" "uuid",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "is_hod" boolean DEFAULT false,
    CONSTRAINT "department_faculty_assignments_assignment_type_check" CHECK ((("assignment_type")::"text" = ANY (ARRAY[('faculty'::character varying)::"text", ('hod'::character varying)::"text", ('coordinator'::character varying)::"text", ('assistant'::character varying)::"text"])))
);


ALTER TABLE "public"."department_faculty_assignments" OWNER TO "postgres";


COMMENT ON TABLE "public"."department_faculty_assignments" IS 'Manages the assignment of faculty/lecturers to departments';



COMMENT ON COLUMN "public"."department_faculty_assignments"."assignment_type" IS 'Type of assignment: faculty, hod, coordinator, assistant';



COMMENT ON COLUMN "public"."department_faculty_assignments"."is_active" IS 'Whether the assignment is currently active';



COMMENT ON COLUMN "public"."department_faculty_assignments"."metadata" IS 'Additional assignment metadata (workload, subjects, etc.)';



CREATE TABLE IF NOT EXISTS "public"."document_access_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "document_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "access_type" character varying(50) NOT NULL,
    "accessed_at" timestamp with time zone DEFAULT "now"(),
    "ip_address" "text",
    "user_agent" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."document_access_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."education" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "level" character varying(50),
    "degree" character varying(100),
    "department" character varying(100),
    "university" character varying(150),
    "year_of_passing" character varying(10),
    "cgpa" character varying(10),
    "status" character varying(50),
    "approval_status" character varying(20) DEFAULT 'pending'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "enabled" boolean DEFAULT true,
    "pending_edit_data" "jsonb",
    "has_pending_edit" boolean DEFAULT false,
    "verified_data" "jsonb"
);


ALTER TABLE "public"."education" OWNER TO "postgres";


COMMENT ON COLUMN "public"."education"."enabled" IS 'Controls visibility of education record in UI (eye icon toggle)';



COMMENT ON COLUMN "public"."education"."pending_edit_data" IS 'Stores the edited version of data awaiting verification';



COMMENT ON COLUMN "public"."education"."has_pending_edit" IS 'Flag to indicate if there is a pending edit for this record';



COMMENT ON COLUMN "public"."education"."verified_data" IS 'Stores the last verified version of the data';



CREATE TABLE IF NOT EXISTS "public"."embedding_cache" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "text_hash" "text" NOT NULL,
    "cache_type" "text" NOT NULL,
    "embedding" "extensions"."vector"(768) NOT NULL,
    "text_preview" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "embedding_cache_cache_type_check" CHECK (("cache_type" = ANY (ARRAY['profile'::"text", 'skill'::"text", 'course'::"text"])))
);


ALTER TABLE "public"."embedding_cache" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."embedding_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "table_name" "text" NOT NULL,
    "record_id" "uuid" NOT NULL,
    "priority" integer DEFAULT 5,
    "status" "text" DEFAULT 'pending'::"text",
    "attempts" integer DEFAULT 0,
    "max_attempts" integer DEFAULT 3,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "processed_at" timestamp with time zone,
    "operation" "text" DEFAULT 'update'::"text" NOT NULL,
    "max_retries" integer DEFAULT 3 NOT NULL,
    "model_used" "text",
    "started_at" timestamp with time zone,
    "next_retry_at" timestamp with time zone,
    CONSTRAINT "embedding_queue_priority_check" CHECK ((("priority" >= 1) AND ("priority" <= 10))),
    CONSTRAINT "embedding_queue_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text"]))),
    CONSTRAINT "embedding_queue_table_name_check" CHECK (("table_name" = ANY (ARRAY['students'::"text", 'opportunities'::"text", 'courses'::"text"])))
);


ALTER TABLE "public"."embedding_queue" OWNER TO "postgres";


COMMENT ON TABLE "public"."embedding_queue" IS 'Queue for async embedding generation. Processed by Cloudflare Worker cron job every 5 minutes.';



CREATE TABLE IF NOT EXISTS "public"."program_sections" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "department_id" "uuid" NOT NULL,
    "program_id" "uuid" NOT NULL,
    "semester" integer NOT NULL,
    "section" character varying(10) NOT NULL,
    "academic_year" character varying(20) NOT NULL,
    "max_students" integer DEFAULT 60 NOT NULL,
    "current_students" integer DEFAULT 0 NOT NULL,
    "faculty_id" "uuid",
    "status" character varying(20) DEFAULT 'active'::character varying NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "updated_by" "uuid",
    CONSTRAINT "program_sections_current_students_check" CHECK (("current_students" >= 0)),
    CONSTRAINT "program_sections_max_students_check" CHECK (("max_students" > 0)),
    CONSTRAINT "program_sections_semester_check" CHECK ((("semester" >= 1) AND ("semester" <= 12))),
    CONSTRAINT "program_sections_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('active'::character varying)::"text", ('inactive'::character varying)::"text"])))
);


ALTER TABLE "public"."program_sections" OWNER TO "postgres";


COMMENT ON TABLE "public"."program_sections" IS 'Stores program sections with semester, section, and capacity information';



CREATE TABLE IF NOT EXISTS "public"."student_enrollments" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "program_id" "uuid" NOT NULL,
    "section_id" "uuid",
    "semester" integer NOT NULL,
    "academic_year" character varying(20) NOT NULL,
    "enrollment_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "enrollment_status" character varying(50) DEFAULT 'active'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_by" "uuid",
    CONSTRAINT "student_enrollments_enrollment_status_check" CHECK ((("enrollment_status")::"text" = ANY (ARRAY[('active'::character varying)::"text", ('inactive'::character varying)::"text", ('graduated'::character varying)::"text", ('transferred'::character varying)::"text", ('withdrawn'::character varying)::"text"])))
);


ALTER TABLE "public"."student_enrollments" OWNER TO "postgres";


COMMENT ON TABLE "public"."student_enrollments" IS 'Tracks student enrollment in programs and sections';



CREATE OR REPLACE VIEW "public"."enrolled_students_view" AS
 SELECT "se"."id" AS "enrollment_id",
    "s"."id" AS "student_id",
    "s"."name" AS "student_name",
    "s"."roll_number",
    "s"."email",
    "s"."contact_number",
    "s"."college_id",
    "d"."id" AS "department_id",
    "d"."name" AS "department_name",
    "d"."code" AS "department_code",
    "p"."id" AS "program_id",
    "p"."name" AS "program_name",
    "p"."code" AS "program_code",
    "ps"."id" AS "section_id",
    "ps"."section",
    "ps"."max_students" AS "section_capacity",
    "se"."semester",
    "se"."academic_year",
    "se"."enrollment_date",
    "se"."enrollment_status",
    "se"."created_at",
    "se"."updated_at"
   FROM (((("public"."student_enrollments" "se"
     JOIN "public"."students" "s" ON (("se"."student_id" = "s"."id")))
     JOIN "public"."programs" "p" ON (("se"."program_id" = "p"."id")))
     JOIN "public"."departments" "d" ON (("p"."department_id" = "d"."id")))
     LEFT JOIN "public"."program_sections" "ps" ON (("se"."section_id" = "ps"."id")))
  WHERE ("s"."is_deleted" = false);


ALTER VIEW "public"."enrolled_students_view" OWNER TO "postgres";


COMMENT ON VIEW "public"."enrolled_students_view" IS 'Comprehensive view of enrolled students with department, program, and section details';



CREATE TABLE IF NOT EXISTS "public"."event_registrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "full_name" character varying(255) NOT NULL,
    "email" character varying(255) NOT NULL,
    "phone" character varying(20) NOT NULL,
    "plan_type" character varying(50) NOT NULL,
    "plan_amount" integer NOT NULL,
    "razorpay_order_id" character varying(255),
    "razorpay_payment_id" character varying(255),
    "event_name" character varying(255),
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "role_type" character varying(50),
    "address" "text",
    "city" "text",
    "state" "text",
    "student_tier_id" "uuid",
    "student_count_min" integer,
    "student_count_max" integer,
    "role_details" "jsonb" DEFAULT '{}'::"jsonb",
    "pincode" character varying(10),
    "institution_name" character varying(255),
    "user_id" "uuid",
    "student_count" integer,
    "price_per_student" numeric(10,2),
    "payment_status" "public"."payment_status_enum" DEFAULT 'pending'::"public"."payment_status_enum" NOT NULL
);


ALTER TABLE "public"."event_registrations" OWNER TO "postgres";


COMMENT ON COLUMN "public"."event_registrations"."role_type" IS 'User role type (e.g., school-student, college-educator, recruitment-admin)';



COMMENT ON COLUMN "public"."event_registrations"."student_count" IS 'Actual number of students entered by the institution admin';



COMMENT ON COLUMN "public"."event_registrations"."price_per_student" IS 'Price per student at time of registration (from institution_pricing_tiers.price or esfe_price)';



CREATE TABLE IF NOT EXISTS "public"."exam_registrations" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "exam_window_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "assessment_id" "uuid",
    "student_name" "text" NOT NULL,
    "roll_number" "text" NOT NULL,
    "program_id" "uuid",
    "semester" integer NOT NULL,
    "registration_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "registration_number" "text" NOT NULL,
    "registration_type" "text" DEFAULT 'regular'::"text",
    "registration_fee" numeric(10,2) DEFAULT 0,
    "late_fee" numeric(10,2) DEFAULT 0,
    "total_fee" numeric(10,2) DEFAULT 0,
    "fee_paid" boolean DEFAULT false,
    "payment_reference" "text",
    "payment_date" "date",
    "status" "text" DEFAULT 'registered'::"text",
    "hall_ticket_number" "text",
    "hall_ticket_issued" boolean DEFAULT false,
    "hall_ticket_issued_date" "date",
    "hall_ticket_url" "text",
    "special_requirements" "text",
    "has_disability" boolean DEFAULT false,
    "disability_details" "text",
    "extra_time_minutes" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "student_record_id" "uuid",
    CONSTRAINT "exam_registrations_registration_type_check" CHECK (("registration_type" = ANY (ARRAY['regular'::"text", 'arrear'::"text", 'improvement'::"text", 'supplementary'::"text"]))),
    CONSTRAINT "exam_registrations_status_check" CHECK (("status" = ANY (ARRAY['registered'::"text", 'confirmed'::"text", 'cancelled'::"text", 'appeared'::"text", 'absent'::"text"])))
);


ALTER TABLE "public"."exam_registrations" OWNER TO "postgres";


COMMENT ON TABLE "public"."exam_registrations" IS 'Student exam registrations with hall ticket management';



COMMENT ON COLUMN "public"."exam_registrations"."student_record_id" IS 'Direct reference to students table - auto-populated via trigger';



CREATE TABLE IF NOT EXISTS "public"."exam_rooms" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "room_code" "text" NOT NULL,
    "room_name" "text" NOT NULL,
    "building" "text",
    "floor" "text",
    "school_id" "uuid",
    "college_id" "uuid",
    "total_capacity" integer NOT NULL,
    "exam_capacity" integer NOT NULL,
    "has_projector" boolean DEFAULT false,
    "has_ac" boolean DEFAULT false,
    "has_cctv" boolean DEFAULT false,
    "has_backup_power" boolean DEFAULT false,
    "is_accessible" boolean DEFAULT true,
    "accessibility_features" "text"[],
    "status" "text" DEFAULT 'active'::"text",
    "location_description" "text",
    "map_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "chk_exam_room_institution" CHECK (((("school_id" IS NOT NULL) AND ("college_id" IS NULL)) OR (("school_id" IS NULL) AND ("college_id" IS NOT NULL)))),
    CONSTRAINT "exam_rooms_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'maintenance'::"text", 'unavailable'::"text", 'retired'::"text"]))),
    CONSTRAINT "valid_capacity" CHECK (("exam_capacity" <= "total_capacity"))
);


ALTER TABLE "public"."exam_rooms" OWNER TO "postgres";


COMMENT ON TABLE "public"."exam_rooms" IS 'Exam venue definitions with capacity and facilities';



CREATE TABLE IF NOT EXISTS "public"."exam_seating_arrangements" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "exam_timetable_id" "uuid" NOT NULL,
    "exam_room_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "student_name" "text" NOT NULL,
    "roll_number" "text" NOT NULL,
    "hall_ticket_number" "text",
    "seat_number" "text" NOT NULL,
    "row_number" "text",
    "column_number" "text",
    "attendance_status" "text" DEFAULT 'expected'::"text",
    "marked_at" timestamp with time zone,
    "marked_by" "uuid",
    "has_special_arrangement" boolean DEFAULT false,
    "special_arrangement_details" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "student_record_id" "uuid",
    CONSTRAINT "exam_seating_arrangements_attendance_status_check" CHECK (("attendance_status" = ANY (ARRAY['expected'::"text", 'present'::"text", 'absent'::"text", 'late'::"text"])))
);


ALTER TABLE "public"."exam_seating_arrangements" OWNER TO "postgres";


COMMENT ON TABLE "public"."exam_seating_arrangements" IS 'Student seating assignments for exams';



COMMENT ON COLUMN "public"."exam_seating_arrangements"."student_record_id" IS 'Direct reference to students table - auto-populated via trigger';



CREATE TABLE IF NOT EXISTS "public"."exam_timetable" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "assessment_id" "uuid" NOT NULL,
    "course_id" "uuid",
    "course_name" "text" NOT NULL,
    "course_code" "text" NOT NULL,
    "exam_date" "date" NOT NULL,
    "start_time" time without time zone NOT NULL,
    "end_time" time without time zone NOT NULL,
    "duration_minutes" integer NOT NULL,
    "room" "text" NOT NULL,
    "building" "text",
    "capacity" integer,
    "batch_section" "text",
    "invigilators" "uuid"[] DEFAULT '{}'::"uuid"[],
    "chief_invigilator" "uuid",
    "status" "text" DEFAULT 'scheduled'::"text",
    "special_instructions" "text",
    "seating_arrangement" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "subject_id" "uuid",
    "school_id" "uuid",
    "class_id" "uuid",
    CONSTRAINT "exam_timetable_status_check" CHECK (("status" = ANY (ARRAY['scheduled'::"text", 'ongoing'::"text", 'completed'::"text", 'cancelled'::"text", 'rescheduled'::"text"]))),
    CONSTRAINT "valid_capacity" CHECK ((("capacity" IS NULL) OR ("capacity" > 0))),
    CONSTRAINT "valid_time_range" CHECK (("end_time" > "start_time"))
);


ALTER TABLE "public"."exam_timetable" OWNER TO "postgres";


COMMENT ON TABLE "public"."exam_timetable" IS 'Exam scheduling with room allocation and invigilator assignment';



CREATE TABLE IF NOT EXISTS "public"."exam_windows" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "window_name" "text" NOT NULL,
    "window_code" "text" NOT NULL,
    "academic_year" "text" NOT NULL,
    "semester" "text" NOT NULL,
    "assessment_type_id" "uuid",
    "assessment_type_name" "text" NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date" NOT NULL,
    "registration_start_date" "date",
    "registration_end_date" "date",
    "department_id" "uuid",
    "program_id" "uuid",
    "school_id" "uuid",
    "college_id" "uuid",
    "status" "text" DEFAULT 'draft'::"text",
    "is_published" boolean DEFAULT false,
    "allow_late_registration" boolean DEFAULT false,
    "late_fee_amount" numeric(10,2) DEFAULT 0,
    "instructions" "text",
    "special_notes" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "chk_exam_window_institution" CHECK (((("school_id" IS NOT NULL) AND ("college_id" IS NULL)) OR (("school_id" IS NULL) AND ("college_id" IS NOT NULL)) OR (("school_id" IS NULL) AND ("college_id" IS NULL)))),
    CONSTRAINT "exam_windows_semester_check" CHECK (("semester" = ANY (ARRAY['Odd'::"text", 'Even'::"text", 'Summer'::"text", '1'::"text", '2'::"text"]))),
    CONSTRAINT "exam_windows_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'scheduled'::"text", 'ongoing'::"text", 'completed'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "valid_exam_window_dates" CHECK (("end_date" >= "start_date")),
    CONSTRAINT "valid_registration_dates" CHECK ((("registration_start_date" IS NULL) OR ("registration_end_date" IS NULL) OR ("registration_end_date" >= "registration_start_date")))
);


ALTER TABLE "public"."exam_windows" OWNER TO "postgres";


COMMENT ON TABLE "public"."exam_windows" IS 'Exam scheduling windows with registration periods for both school and college';



CREATE TABLE IF NOT EXISTS "public"."expenditures" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "department_id" "uuid" NOT NULL,
    "budget_id" "uuid" NOT NULL,
    "budget_head_id" "text" NOT NULL,
    "budget_head_name" "text" NOT NULL,
    "expenditure_number" "text" NOT NULL,
    "expenditure_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "vendor_name" "text" NOT NULL,
    "vendor_contact" "text",
    "vendor_email" "text",
    "vendor_gstin" "text",
    "amount" numeric(12,2) NOT NULL,
    "tax_amount" numeric(12,2) DEFAULT 0,
    "total_amount" numeric(12,2) GENERATED ALWAYS AS (("amount" + "tax_amount")) STORED,
    "category" "text" NOT NULL,
    "sub_category" "text",
    "description" "text" NOT NULL,
    "purpose" "text",
    "invoice_number" "text",
    "invoice_date" "date",
    "invoice_file_id" "text",
    "invoice_url" "text",
    "payment_mode" "text",
    "payment_reference" "text",
    "payment_date" "date",
    "payment_status" "text" DEFAULT 'pending'::"text",
    "status" "text" DEFAULT 'draft'::"text",
    "submitted_by" "uuid",
    "submitted_at" timestamp with time zone,
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "approval_remarks" "text",
    "rejected_reason" "text",
    "is_override" boolean DEFAULT false,
    "override_reason" "text",
    "override_approved_by" "uuid",
    "override_approved_at" timestamp with time zone,
    "is_reimbursement" boolean DEFAULT false,
    "reimbursement_to" "uuid",
    "reimbursement_status" "text",
    "attachments" "jsonb" DEFAULT '[]'::"jsonb",
    "remarks" "text",
    "recorded_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "expenditures_category_check" CHECK (("category" = ANY (ARRAY['Salaries'::"text", 'Equipment'::"text", 'Maintenance'::"text", 'Supplies'::"text", 'Travel'::"text", 'Training'::"text", 'Software'::"text", 'Infrastructure'::"text", 'Events'::"text", 'Research'::"text", 'Consultancy'::"text", 'Other'::"text"]))),
    CONSTRAINT "expenditures_payment_mode_check" CHECK (("payment_mode" = ANY (ARRAY['cash'::"text", 'cheque'::"text", 'bank_transfer'::"text", 'upi'::"text", 'card'::"text", 'dd'::"text"]))),
    CONSTRAINT "expenditures_payment_status_check" CHECK (("payment_status" = ANY (ARRAY['pending'::"text", 'paid'::"text", 'partial'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "expenditures_reimbursement_status_check" CHECK (("reimbursement_status" = ANY (ARRAY['pending'::"text", 'processed'::"text", 'paid'::"text"]))),
    CONSTRAINT "expenditures_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'pending_approval'::"text", 'approved'::"text", 'rejected'::"text", 'paid'::"text"]))),
    CONSTRAINT "valid_expenditure_amounts" CHECK ((("amount" >= (0)::numeric) AND ("tax_amount" >= (0)::numeric))),
    CONSTRAINT "valid_payment_date" CHECK ((("payment_date" IS NULL) OR ("payment_date" >= "expenditure_date")))
);


ALTER TABLE "public"."expenditures" OWNER TO "postgres";


COMMENT ON TABLE "public"."expenditures" IS 'Department expenses with invoice management and approval workflow';



CREATE TABLE IF NOT EXISTS "public"."experience" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "organization" character varying(150),
    "role" character varying(150),
    "start_date" "date",
    "end_date" "date",
    "duration" character varying(100),
    "verified" boolean DEFAULT false,
    "approval_status" character varying(20) DEFAULT 'pending'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "approval_authority" character varying(20),
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "rejected_by" "uuid",
    "rejected_at" timestamp with time zone,
    "approval_notes" "text",
    "description" "text",
    "enabled" boolean DEFAULT true,
    "pending_edit_data" "jsonb",
    "has_pending_edit" boolean DEFAULT false,
    "verified_data" "jsonb"
);


ALTER TABLE "public"."experience" OWNER TO "postgres";


COMMENT ON COLUMN "public"."experience"."approval_status" IS 'Approval status of experience (pending, approved, verified, rejected)';



COMMENT ON COLUMN "public"."experience"."enabled" IS 'Controls visibility of experience item on profile (true = visible, false = hidden)';



COMMENT ON COLUMN "public"."experience"."pending_edit_data" IS 'Stores the edited version of data awaiting verification';



COMMENT ON COLUMN "public"."experience"."has_pending_edit" IS 'Flag to indicate if there is a pending edit for this record';



COMMENT ON COLUMN "public"."experience"."verified_data" IS 'Stores the last verified version of the data';



CREATE TABLE IF NOT EXISTS "public"."export_activities" (
    "id" integer NOT NULL,
    "shortlist_id" "text" NOT NULL,
    "export_format" "text" NOT NULL,
    "export_type" "text" NOT NULL,
    "exported_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "exported_by" "text",
    "include_pii" boolean DEFAULT false
);


ALTER TABLE "public"."export_activities" OWNER TO "postgres";


COMMENT ON TABLE "public"."export_activities" IS 'Audit log for shortlist exports';



CREATE SEQUENCE IF NOT EXISTS "public"."export_activities_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."export_activities_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."export_activities_id_seq" OWNED BY "public"."export_activities"."id";



CREATE TABLE IF NOT EXISTS "public"."external_assessment_attempts" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "course_name" "text" NOT NULL,
    "course_id" "uuid",
    "assessment_level" "text" NOT NULL,
    "total_questions" integer DEFAULT 15 NOT NULL,
    "questions" "jsonb" NOT NULL,
    "student_answers" "jsonb" NOT NULL,
    "score" integer,
    "correct_answers" integer,
    "time_taken" integer,
    "started_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "completed_at" timestamp with time zone DEFAULT "now"(),
    "difficulty_breakdown" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "current_question_index" integer DEFAULT 0,
    "status" "text" DEFAULT 'in_progress'::"text",
    "time_remaining" integer DEFAULT 900,
    "last_activity_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."external_assessment_attempts" OWNER TO "postgres";


COMMENT ON TABLE "public"."external_assessment_attempts" IS 'Stores all student external course assessment attempts with questions, answers, and scores';



COMMENT ON COLUMN "public"."external_assessment_attempts"."questions" IS 'JSONB array of question objects with id, text, options, correct_answer, difficulty';



COMMENT ON COLUMN "public"."external_assessment_attempts"."student_answers" IS 'Array of answer objects: [{question_id, selected_answer, is_correct, time_taken}]. Updates after each answer.';



COMMENT ON COLUMN "public"."external_assessment_attempts"."difficulty_breakdown" IS 'JSONB object showing performance by difficulty level';



COMMENT ON COLUMN "public"."external_assessment_attempts"."current_question_index" IS 'Current question index (0-based). Saves after each answer selection.';



COMMENT ON COLUMN "public"."external_assessment_attempts"."status" IS 'Assessment status: in_progress or completed. Use in_progress for resumable assessments.';



CREATE TABLE IF NOT EXISTS "public"."external_courses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "course_name" character varying(255) NOT NULL,
    "organization" character varying(255) NOT NULL,
    "course_url" "text",
    "start_date" "date",
    "completion_date" "date",
    "duration" character varying(100),
    "certificate_url" "text",
    "grade" character varying(10),
    "skills_acquired" "jsonb" DEFAULT '[]'::"jsonb",
    "training_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."external_courses" OWNER TO "postgres";


COMMENT ON TABLE "public"."external_courses" IS 'Tracks external course completions (Coursera, Udemy, etc.) with automatic skill creation';



COMMENT ON COLUMN "public"."external_courses"."skills_acquired" IS 'JSON array of skill names acquired from this external course';



CREATE OR REPLACE VIEW "public"."faculty_with_user_data" AS
 SELECT "cl"."id",
    "cl"."employeeId",
    "cl"."collegeId",
    "cl"."specialization",
    "cl"."qualification",
    "cl"."experienceYears",
    "cl"."designation",
    "cl"."accountStatus",
    "cl"."first_name",
    "cl"."last_name",
    "cl"."email",
    "cl"."phone",
    "cl"."subject_expertise",
    "u"."id" AS "user_id",
    "u"."firstName" AS "user_first_name",
    "u"."lastName" AS "user_last_name",
    "u"."email" AS "user_email",
    "u"."phone" AS "user_phone",
    COALESCE("cl"."first_name", "u"."firstName") AS "display_first_name",
    COALESCE("cl"."last_name", "u"."lastName") AS "display_last_name",
    COALESCE("cl"."email", ("u"."email")::character varying) AS "display_email",
    COALESCE("cl"."phone", "u"."phone") AS "display_phone"
   FROM ("public"."college_lecturers" "cl"
     LEFT JOIN "public"."users" "u" ON (("cl"."user_id" = "u"."id")));


ALTER VIEW "public"."faculty_with_user_data" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."fee_payments" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "ledger_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "amount" numeric(10,2) NOT NULL,
    "mode" "text" NOT NULL,
    "reference_number" "text",
    "transaction_id" "text",
    "bank_name" "text",
    "cheque_number" "text",
    "cheque_date" "date",
    "dd_number" "text",
    "receipt_number" "text" NOT NULL,
    "receipt_url" "text",
    "paid_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "payment_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "is_verified" boolean DEFAULT false,
    "verified_by" "uuid",
    "verified_at" timestamp with time zone,
    "is_reconciled" boolean DEFAULT false,
    "reconciled_by" "uuid",
    "reconciled_at" timestamp with time zone,
    "status" "text" DEFAULT 'completed'::"text",
    "remarks" "text",
    "recorded_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "fee_payments_mode_check" CHECK (("mode" = ANY (ARRAY['cash'::"text", 'upi'::"text", 'card'::"text", 'cheque'::"text", 'bank_transfer'::"text", 'dd'::"text", 'online'::"text"]))),
    CONSTRAINT "fee_payments_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'completed'::"text", 'failed'::"text", 'refunded'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "valid_payment_amount" CHECK (("amount" > (0)::numeric))
);


ALTER TABLE "public"."fee_payments" OWNER TO "postgres";


COMMENT ON TABLE "public"."fee_payments" IS 'Fee payment records with receipt generation and reconciliation';



CREATE TABLE IF NOT EXISTS "public"."fee_structures" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "program_id" "uuid",
    "program_name" "text" NOT NULL,
    "semester" integer NOT NULL,
    "academic_year" "text" NOT NULL,
    "category" "text" NOT NULL,
    "quota" "text",
    "fee_heads" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "total_amount" numeric(10,2) NOT NULL,
    "due_schedule" "jsonb" DEFAULT '[]'::"jsonb",
    "scholarship_applicable" boolean DEFAULT false,
    "scholarship_amount" numeric(10,2) DEFAULT 0,
    "discount_percentage" numeric(5,2) DEFAULT 0,
    "is_active" boolean DEFAULT true,
    "effective_from" "date" NOT NULL,
    "effective_to" "date",
    "created_by" "uuid",
    "approved_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "college_id" "uuid",
    CONSTRAINT "fee_structures_category_check" CHECK (("category" = ANY (ARRAY['General'::"text", 'OBC'::"text", 'SC'::"text", 'ST'::"text", 'EWS'::"text", 'Management'::"text", 'NRI'::"text", 'Foreign'::"text"]))),
    CONSTRAINT "fee_structures_quota_check" CHECK (("quota" = ANY (ARRAY['Merit'::"text", 'Management'::"text", 'NRI'::"text", 'Sports'::"text", 'Defense'::"text"]))),
    CONSTRAINT "fee_structures_semester_check" CHECK ((("semester" >= 1) AND ("semester" <= 12))),
    CONSTRAINT "valid_discount" CHECK ((("discount_percentage" >= (0)::numeric) AND ("discount_percentage" <= (100)::numeric))),
    CONSTRAINT "valid_scholarship" CHECK ((("scholarship_amount" >= (0)::numeric) AND ("scholarship_amount" <= "total_amount"))),
    CONSTRAINT "valid_total" CHECK (("total_amount" >= (0)::numeric))
);


ALTER TABLE "public"."fee_structures" OWNER TO "postgres";


COMMENT ON TABLE "public"."fee_structures" IS 'Program-wise fee structure with category-based fees';



CREATE TABLE IF NOT EXISTS "public"."generated_external_assessment" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "certificate_name" "text" NOT NULL,
    "course_id" "uuid",
    "assessment_level" "text" DEFAULT 'Intermediate'::"text" NOT NULL,
    "total_questions" integer DEFAULT 15 NOT NULL,
    "questions" "jsonb" NOT NULL,
    "generated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "generated_by" "text",
    "version" integer DEFAULT 1,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."generated_external_assessment" OWNER TO "postgres";


COMMENT ON TABLE "public"."generated_external_assessment" IS 'Master questions for each certificate - shared across all students';



CREATE TABLE IF NOT EXISTS "public"."grading_systems" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "system_name" "text" NOT NULL,
    "system_code" "text" NOT NULL,
    "grade_label" "text" NOT NULL,
    "min_marks" numeric(5,2) NOT NULL,
    "max_marks" numeric(5,2) NOT NULL,
    "grade_point" numeric(3,2) NOT NULL,
    "is_pass" boolean DEFAULT true,
    "is_distinction" boolean DEFAULT false,
    "applicable_to" "text" DEFAULT 'all'::"text",
    "is_default" boolean DEFAULT false,
    "is_active" boolean DEFAULT true,
    "display_order" integer DEFAULT 0,
    "color_code" "text",
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "grading_systems_applicable_to_check" CHECK (("applicable_to" = ANY (ARRAY['all'::"text", 'school'::"text", 'college'::"text", 'university'::"text"]))),
    CONSTRAINT "valid_grade_point" CHECK ((("grade_point" >= (0)::numeric) AND ("grade_point" <= (10)::numeric))),
    CONSTRAINT "valid_marks_range" CHECK (("max_marks" > "min_marks"))
);


ALTER TABLE "public"."grading_systems" OWNER TO "postgres";


COMMENT ON TABLE "public"."grading_systems" IS 'Grading scales and grade point mappings for both school and college';



CREATE TABLE IF NOT EXISTS "public"."institution_pricing_tiers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "role_type" "text" NOT NULL,
    "tier_name" "text" NOT NULL,
    "min_students" integer NOT NULL,
    "max_students" integer NOT NULL,
    "price" integer NOT NULL,
    "price_per_student" numeric(10,2),
    "duration" "text" DEFAULT 'month'::"text" NOT NULL,
    "features" "jsonb" DEFAULT '[]'::"jsonb",
    "is_recommended" boolean DEFAULT false,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "esfe_price" integer,
    "esfe_discount_percent" integer DEFAULT 0,
    "esfe_active" boolean DEFAULT false
);


ALTER TABLE "public"."institution_pricing_tiers" OWNER TO "postgres";


COMMENT ON COLUMN "public"."institution_pricing_tiers"."price" IS 'Legacy column - use price_per_student instead for per-student pricing';



COMMENT ON COLUMN "public"."institution_pricing_tiers"."price_per_student" IS 'Price per individual student per month';



COMMENT ON COLUMN "public"."institution_pricing_tiers"."duration" IS 'Billing period - default is month';



CREATE TABLE IF NOT EXISTS "public"."internships" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid",
    "student_email" "text" NOT NULL,
    "company_name" "text" NOT NULL,
    "role" "text" NOT NULL,
    "location" "text",
    "internship_type" "text",
    "start_date" "date",
    "end_date" "date",
    "duration" "text",
    "stipend" "text",
    "responsibilities" "text",
    "achievements" "text",
    "skills_learned" "text",
    "offer_letter_url" "text",
    "recommendation_letter_url" "text",
    "enabled" boolean DEFAULT true,
    "approval_status" "text" DEFAULT 'pending'::"text",
    "processing" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "rejection_reason" "text",
    "admin_notes" "text",
    CONSTRAINT "internships_approval_status_check" CHECK (("approval_status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"]))),
    CONSTRAINT "internships_internship_type_check" CHECK (("internship_type" = ANY (ARRAY['Full-time'::"text", 'Part-time'::"text", 'Remote'::"text", 'Hybrid'::"text"])))
);


ALTER TABLE "public"."internships" OWNER TO "postgres";


COMMENT ON TABLE "public"."internships" IS 'Stores student internship experiences';



COMMENT ON COLUMN "public"."internships"."student_email" IS 'Email of the student who owns this internship record';



COMMENT ON COLUMN "public"."internships"."company_name" IS 'Name of the company where internship was done';



COMMENT ON COLUMN "public"."internships"."role" IS 'Job title/role during the internship';



COMMENT ON COLUMN "public"."internships"."duration" IS 'Auto-calculated duration string based on start and end dates';



COMMENT ON COLUMN "public"."internships"."enabled" IS 'Whether this internship is visible on student profile';



COMMENT ON COLUMN "public"."internships"."approval_status" IS 'Admin approval status: pending, approved, or rejected';



CREATE TABLE IF NOT EXISTS "public"."interview_reminders" (
    "id" integer NOT NULL,
    "interview_id" "text" NOT NULL,
    "sent_to" "text" NOT NULL,
    "sent_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "reminder_type" "text" NOT NULL,
    "status" "text" DEFAULT 'sent'::"text",
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL
);


ALTER TABLE "public"."interview_reminders" OWNER TO "postgres";


COMMENT ON TABLE "public"."interview_reminders" IS 'Audit log for interview reminder activities';



CREATE SEQUENCE IF NOT EXISTS "public"."interview_reminders_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."interview_reminders_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."interview_reminders_id_seq" OWNED BY "public"."interview_reminders"."id";



CREATE TABLE IF NOT EXISTS "public"."interviews" (
    "id" "text" NOT NULL,
    "student_id" "uuid",
    "candidate_name" "text" NOT NULL,
    "candidate_email" "text",
    "candidate_phone" "text",
    "job_title" "text" NOT NULL,
    "interviewer" "text" NOT NULL,
    "interviewer_email" "text",
    "date" timestamp with time zone NOT NULL,
    "duration" integer DEFAULT 60,
    "status" "text" DEFAULT 'scheduled'::"text",
    "type" "text" NOT NULL,
    "meeting_type" "text",
    "meeting_link" "text",
    "meeting_notes" "text",
    "reminders_sent" integer DEFAULT 0,
    "completed_date" timestamp with time zone,
    "scorecard" "jsonb",
    "created_by" "text",
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL
);


ALTER TABLE "public"."interviews" OWNER TO "postgres";


COMMENT ON TABLE "public"."interviews" IS 'Interview scheduling and tracking for candidates';



COMMENT ON COLUMN "public"."interviews"."status" IS 'scheduled: Initial state, confirmed: Candidate confirmed, completed: Interview done, cancelled: Interview cancelled, pending: Waiting for confirmation';



COMMENT ON COLUMN "public"."interviews"."meeting_type" IS 'Type of meeting platform: teams, meet, zoom, phone, in-person';



COMMENT ON COLUMN "public"."interviews"."scorecard" IS 'JSONB object containing interview evaluation: {technical_skills, communication, problem_solving, cultural_fit, overall_rating, notes, recommendation}';



CREATE TABLE IF NOT EXISTS "public"."invigilator_assignments" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "exam_timetable_id" "uuid" NOT NULL,
    "exam_room_id" "uuid",
    "invigilator_id" "uuid" NOT NULL,
    "invigilator_name" "text" NOT NULL,
    "invigilator_type" "text" DEFAULT 'regular'::"text",
    "duty_date" "date" NOT NULL,
    "duty_start_time" time without time zone NOT NULL,
    "duty_end_time" time without time zone NOT NULL,
    "attendance_status" "text" DEFAULT 'assigned'::"text",
    "check_in_time" timestamp with time zone,
    "check_out_time" timestamp with time zone,
    "duty_hours" numeric(4,2),
    "compensation_amount" numeric(10,2) DEFAULT 0,
    "compensation_paid" boolean DEFAULT false,
    "remarks" "text",
    "issues_reported" "text",
    "assigned_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "lecturer_record_id" "uuid",
    CONSTRAINT "invigilator_assignments_attendance_status_check" CHECK (("attendance_status" = ANY (ARRAY['assigned'::"text", 'present'::"text", 'absent'::"text", 'relieved'::"text"]))),
    CONSTRAINT "invigilator_assignments_invigilator_type_check" CHECK (("invigilator_type" = ANY (ARRAY['chief'::"text", 'regular'::"text", 'relief'::"text", 'external'::"text"]))),
    CONSTRAINT "valid_duty_time" CHECK (("duty_end_time" > "duty_start_time"))
);


ALTER TABLE "public"."invigilator_assignments" OWNER TO "postgres";


COMMENT ON TABLE "public"."invigilator_assignments" IS 'Invigilator duty assignments with attendance tracking';



COMMENT ON COLUMN "public"."invigilator_assignments"."lecturer_record_id" IS 'Direct reference to college_lecturers table - auto-populated via trigger';



CREATE OR REPLACE VIEW "public"."learning_outcome_details" AS
SELECT
    NULL::"uuid" AS "id",
    NULL::"uuid" AS "chapter_id",
    NULL::"text" AS "outcome",
    NULL::character varying(20) AS "bloom_level",
    NULL::character varying(200) AS "chapter_name",
    NULL::"uuid" AS "curriculum_id",
    NULL::character varying(100) AS "subject",
    NULL::character varying(10) AS "class",
    NULL::character varying(20) AS "academic_year",
    NULL::bigint AS "assessment_count",
    NULL::"jsonb"[] AS "assessment_mappings";


ALTER VIEW "public"."learning_outcome_details" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."lesson_plans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "educator_id" "uuid",
    "class_id" "uuid",
    "title" character varying(200) NOT NULL,
    "subject" character varying(100) NOT NULL,
    "class_name" character varying(50) NOT NULL,
    "date" "date" NOT NULL,
    "duration" integer NOT NULL,
    "learning_objectives" "text" NOT NULL,
    "activities" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "resources" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "assessment_methods" "text",
    "homework" "text",
    "notes" "text",
    "status" character varying(20) DEFAULT 'draft'::character varying,
    "submitted_at" timestamp without time zone,
    "reviewed_by" "uuid",
    "reviewed_at" timestamp without time zone,
    "review_comments" "text",
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"(),
    "chapter_id" "uuid",
    "chapter_name" character varying(255),
    "selected_learning_outcomes" "jsonb" DEFAULT '[]'::"jsonb",
    "teaching_methodology" "text",
    "required_materials" "text",
    "resource_files" "jsonb" DEFAULT '[]'::"jsonb",
    "resource_links" "jsonb" DEFAULT '[]'::"jsonb",
    "evaluation_criteria" "text",
    "evaluation_items" "jsonb" DEFAULT '[]'::"jsonb",
    "differentiation_notes" "text",
    CONSTRAINT "lesson_plans_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('submitted'::character varying)::"text", ('approved'::character varying)::"text", ('rejected'::character varying)::"text", ('revision_required'::character varying)::"text"])))
);


ALTER TABLE "public"."lesson_plans" OWNER TO "postgres";


COMMENT ON TABLE "public"."lesson_plans" IS 'Lesson plans created by educators, linked to school_educators';



COMMENT ON COLUMN "public"."lesson_plans"."chapter_id" IS 'Reference to curriculum chapter';



COMMENT ON COLUMN "public"."lesson_plans"."chapter_name" IS 'Display name from curriculum chapter';



COMMENT ON COLUMN "public"."lesson_plans"."selected_learning_outcomes" IS 'Array of learning outcome IDs from curriculum';



COMMENT ON COLUMN "public"."lesson_plans"."teaching_methodology" IS 'Teaching methodology and approach description';



COMMENT ON COLUMN "public"."lesson_plans"."required_materials" IS 'Text description of required materials';



COMMENT ON COLUMN "public"."lesson_plans"."resource_files" IS 'Array of file attachments with metadata {id, name, size, type, url}';



COMMENT ON COLUMN "public"."lesson_plans"."resource_links" IS 'Array of external links {id, title, url}';



COMMENT ON COLUMN "public"."lesson_plans"."evaluation_criteria" IS 'Evaluation criteria description';



COMMENT ON COLUMN "public"."lesson_plans"."evaluation_items" IS 'Structured evaluation items with percentages {id, criterion, percentage}';



COMMENT ON COLUMN "public"."lesson_plans"."differentiation_notes" IS 'Differentiation strategies and notes';



CREATE TABLE IF NOT EXISTS "public"."lesson_resources" (
    "resource_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "lesson_id" "uuid" NOT NULL,
    "name" character varying(255) NOT NULL,
    "type" character varying(20) NOT NULL,
    "url" "text" NOT NULL,
    "file_size" character varying(50),
    "thumbnail_url" "text",
    "embed_url" "text",
    "order_index" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "content" "text",
    CONSTRAINT "lesson_resources_type_check" CHECK ((("type")::"text" = ANY (ARRAY[('pdf'::character varying)::"text", ('video'::character varying)::"text", ('image'::character varying)::"text", ('document'::character varying)::"text", ('link'::character varying)::"text", ('youtube'::character varying)::"text", ('drive'::character varying)::"text"])))
);


ALTER TABLE "public"."lesson_resources" OWNER TO "postgres";


COMMENT ON TABLE "public"."lesson_resources" IS 'Learning resources attached to lessons (files, links, videos)';



COMMENT ON COLUMN "public"."lesson_resources"."content" IS 'Extracted text content from PDF/document resources for AI tutor context';



CREATE TABLE IF NOT EXISTS "public"."lessons" (
    "lesson_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "module_id" "uuid" NOT NULL,
    "title" character varying(255) NOT NULL,
    "description" "text",
    "content" "text",
    "duration" character varying(50),
    "order_index" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"())
);


ALTER TABLE "public"."lessons" OWNER TO "postgres";


COMMENT ON TABLE "public"."lessons" IS 'Individual lessons within modules';



CREATE TABLE IF NOT EXISTS "public"."library_book_issues" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "book_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "student_name" "text" NOT NULL,
    "roll_number" "text" NOT NULL,
    "class" "text" NOT NULL,
    "academic_year" "text" NOT NULL,
    "issue_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "due_date" "date" NOT NULL,
    "return_date" "date",
    "status" "text" DEFAULT 'issued'::"text",
    "fine_amount" numeric(10,2) DEFAULT 0,
    "fine_paid" boolean DEFAULT false,
    "remarks" "text",
    "issued_by" "text",
    "returned_by" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "check_return_date" CHECK ((("return_date" IS NULL) OR ("return_date" >= "issue_date"))),
    CONSTRAINT "library_book_issues_status_check" CHECK (("status" = ANY (ARRAY['issued'::"text", 'returned'::"text", 'overdue'::"text"])))
);


ALTER TABLE "public"."library_book_issues" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."library_book_issues_college" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "book_id" "uuid" NOT NULL,
    "student_id" "text" NOT NULL,
    "student_name" "text" NOT NULL,
    "roll_number" "text" NOT NULL,
    "class" "text" NOT NULL,
    "academic_year" "text" NOT NULL,
    "issue_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "due_date" "date" NOT NULL,
    "return_date" "date",
    "status" "text" DEFAULT 'issued'::"text",
    "fine_amount" numeric(10,2) DEFAULT 0,
    "fine_paid" boolean DEFAULT false,
    "remarks" "text",
    "issued_by" "text",
    "returned_by" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "check_return_date" CHECK ((("return_date" IS NULL) OR ("return_date" >= "issue_date"))),
    CONSTRAINT "library_book_issues_college_status_check" CHECK (("status" = ANY (ARRAY['issued'::"text", 'returned'::"text", 'overdue'::"text"])))
);


ALTER TABLE "public"."library_book_issues_college" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."library_book_issues_school" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "school_id" "uuid" NOT NULL,
    "book_id" "uuid" NOT NULL,
    "student_id" "text" NOT NULL,
    "student_name" "text" NOT NULL,
    "roll_number" "text" NOT NULL,
    "class" "text" NOT NULL,
    "academic_year" "text" NOT NULL,
    "issue_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "due_date" "date" NOT NULL,
    "return_date" "date",
    "status" "text" DEFAULT 'issued'::"text",
    "fine_amount" numeric(10,2) DEFAULT 0,
    "fine_paid" boolean DEFAULT false,
    "remarks" "text",
    "issued_by" "text",
    "returned_by" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "check_return_date_school" CHECK ((("return_date" IS NULL) OR ("return_date" >= "issue_date"))),
    CONSTRAINT "library_book_issues_school_status_check" CHECK (("status" = ANY (ARRAY['issued'::"text", 'returned'::"text", 'overdue'::"text"])))
);


ALTER TABLE "public"."library_book_issues_school" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."library_books" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "book_id" "text" NOT NULL,
    "isbn" "text",
    "isbn13" "text",
    "title" "text" NOT NULL,
    "subtitle" "text",
    "author" "text" NOT NULL,
    "co_authors" "text"[],
    "publisher" "text",
    "edition" "text",
    "publication_year" integer,
    "language" "text" DEFAULT 'English'::"text",
    "category" "text" NOT NULL,
    "sub_category" "text",
    "subject" "text",
    "department_id" "uuid",
    "pages" integer,
    "binding_type" "text",
    "dimensions" "text",
    "weight" "text",
    "total_copies" integer DEFAULT 1 NOT NULL,
    "available_copies" integer DEFAULT 1 NOT NULL,
    "issued_copies" integer GENERATED ALWAYS AS (("total_copies" - "available_copies")) STORED,
    "damaged_copies" integer DEFAULT 0,
    "lost_copies" integer DEFAULT 0,
    "location" "text" NOT NULL,
    "rack_number" "text",
    "floor" "text",
    "section" "text",
    "price" numeric(10,2),
    "currency" "text" DEFAULT 'INR'::"text",
    "acquisition_date" "date",
    "acquisition_type" "text",
    "vendor_name" "text",
    "bill_number" "text",
    "description" "text",
    "keywords" "text"[],
    "table_of_contents" "text",
    "cover_image_url" "text",
    "ebook_url" "text",
    "has_ebook" boolean DEFAULT false,
    "status" "text" DEFAULT 'available'::"text",
    "is_reference_only" boolean DEFAULT false,
    "is_popular" boolean DEFAULT false,
    "average_rating" numeric(2,1) DEFAULT 0,
    "total_reviews" integer DEFAULT 0,
    "total_issues" integer DEFAULT 0,
    "total_reservations" integer DEFAULT 0,
    "last_issued_date" "date",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "college_id" "uuid",
    CONSTRAINT "library_books_acquisition_type_check" CHECK (("acquisition_type" = ANY (ARRAY['Purchase'::"text", 'Donation'::"text", 'Exchange'::"text", 'Gift'::"text"]))),
    CONSTRAINT "library_books_binding_type_check" CHECK (("binding_type" = ANY (ARRAY['Hardcover'::"text", 'Paperback'::"text", 'Spiral'::"text", 'Leather'::"text"]))),
    CONSTRAINT "library_books_status_check" CHECK (("status" = ANY (ARRAY['available'::"text", 'issued'::"text", 'reserved'::"text", 'maintenance'::"text", 'lost'::"text", 'damaged'::"text", 'withdrawn'::"text"]))),
    CONSTRAINT "valid_copies" CHECK ((("total_copies" >= 0) AND ("available_copies" >= 0) AND ("available_copies" <= "total_copies") AND ("damaged_copies" >= 0) AND ("lost_copies" >= 0))),
    CONSTRAINT "valid_rating" CHECK ((("average_rating" >= (0)::numeric) AND ("average_rating" <= (5)::numeric))),
    CONSTRAINT "valid_year" CHECK ((("publication_year" IS NULL) OR (("publication_year")::numeric <= EXTRACT(year FROM CURRENT_DATE))))
);


ALTER TABLE "public"."library_books" OWNER TO "postgres";


COMMENT ON TABLE "public"."library_books" IS 'Book catalog with inventory and location tracking';



COMMENT ON COLUMN "public"."library_books"."college_id" IS 'College reference for multi-college library support';



CREATE TABLE IF NOT EXISTS "public"."library_books_college" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "author" "text" NOT NULL,
    "isbn" "text" NOT NULL,
    "total_copies" integer DEFAULT 1 NOT NULL,
    "available_copies" integer DEFAULT 1 NOT NULL,
    "status" "text" DEFAULT 'available'::"text",
    "category" "text",
    "publisher" "text",
    "publication_year" integer,
    "description" "text",
    "location_shelf" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "check_available_copies" CHECK ((("available_copies" >= 0) AND ("available_copies" <= "total_copies"))),
    CONSTRAINT "library_books_college_status_check" CHECK (("status" = ANY (ARRAY['available'::"text", 'all_issued'::"text", 'maintenance'::"text"])))
);


ALTER TABLE "public"."library_books_college" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."library_books_school" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "school_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "author" "text" NOT NULL,
    "isbn" "text" NOT NULL,
    "total_copies" integer DEFAULT 1 NOT NULL,
    "available_copies" integer DEFAULT 1 NOT NULL,
    "status" "text" DEFAULT 'available'::"text",
    "category" "text",
    "publisher" "text",
    "publication_year" integer,
    "description" "text",
    "location_shelf" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "check_available_copies_school" CHECK ((("available_copies" >= 0) AND ("available_copies" <= "total_copies"))),
    CONSTRAINT "library_books_school_status_check" CHECK (("status" = ANY (ARRAY['available'::"text", 'all_issued'::"text", 'maintenance'::"text"])))
);


ALTER TABLE "public"."library_books_school" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."library_categories" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "color_code" "text" DEFAULT '#3B82F6'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."library_categories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."library_categories_college" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "color_code" "text" DEFAULT '#3B82F6'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."library_categories_college" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."library_categories_school" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "school_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "color_code" "text" DEFAULT '#3B82F6'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."library_categories_school" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."library_history" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "book_id" "uuid",
    "book_title" "text" NOT NULL,
    "book_author" "text" NOT NULL,
    "book_isbn" "text",
    "book_category" "text",
    "student_id" "uuid",
    "student_name" "text" NOT NULL,
    "roll_number" "text" NOT NULL,
    "email" "text" NOT NULL,
    "department_id" "uuid",
    "program" "text",
    "semester" "text",
    "academic_year" "text" NOT NULL,
    "issue_date" "date" NOT NULL,
    "due_date" "date" NOT NULL,
    "return_date" "date",
    "days_borrowed" integer DEFAULT 0,
    "days_overdue" integer DEFAULT 0,
    "fine_amount" numeric(10,2) DEFAULT 0,
    "fine_paid" boolean DEFAULT false,
    "fine_waived" boolean DEFAULT false,
    "issue_condition" "text",
    "return_condition" "text",
    "damage_charges" numeric(10,2) DEFAULT 0,
    "status" "text" NOT NULL,
    "renewal_count" integer DEFAULT 0,
    "issued_by" "uuid",
    "issued_by_name" "text",
    "returned_to" "uuid",
    "returned_to_name" "text",
    "remarks" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "student_record_id" "uuid",
    CONSTRAINT "library_history_status_check" CHECK (("status" = ANY (ARRAY['returned'::"text", 'lost'::"text", 'damaged'::"text"]))),
    CONSTRAINT "valid_history_dates" CHECK ((("return_date" IS NULL) OR ("return_date" >= "issue_date")))
);


ALTER TABLE "public"."library_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."library_history" IS 'Complete borrow history for analytics and reporting';



COMMENT ON COLUMN "public"."library_history"."student_record_id" IS 'Reference to students table (nullable for historical data)';



CREATE TABLE IF NOT EXISTS "public"."library_issued_books" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "book_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "student_name" "text" NOT NULL,
    "roll_number" "text" NOT NULL,
    "email" "text" NOT NULL,
    "phone" "text",
    "class" "text",
    "department_id" "uuid",
    "academic_year" "text" NOT NULL,
    "issue_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "due_date" "date" NOT NULL,
    "expected_return_date" "date" GENERATED ALWAYS AS (("issue_date" + '14 days'::interval)) STORED,
    "return_date" "date",
    "actual_return_date" "date",
    "days_overdue" integer DEFAULT 0,
    "fine_per_day" numeric(10,2) DEFAULT 10.00,
    "fine_amount" numeric(10,2) DEFAULT 0,
    "fine_paid" boolean DEFAULT false,
    "fine_paid_amount" numeric(10,2) DEFAULT 0,
    "fine_waived" boolean DEFAULT false,
    "fine_waiver_reason" "text",
    "issue_condition" "text" DEFAULT 'good'::"text",
    "return_condition" "text",
    "damage_charges" numeric(10,2) DEFAULT 0,
    "damage_description" "text",
    "status" "text" DEFAULT 'issued'::"text",
    "renewal_count" integer DEFAULT 0,
    "max_renewals" integer DEFAULT 2,
    "last_renewed_date" "date",
    "reminder_sent_count" integer DEFAULT 0,
    "last_reminder_sent_at" timestamp with time zone,
    "issued_by" "uuid" NOT NULL,
    "returned_to" "uuid",
    "issue_remarks" "text",
    "return_remarks" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "student_record_id" "uuid",
    CONSTRAINT "library_issued_books_issue_condition_check" CHECK (("issue_condition" = ANY (ARRAY['excellent'::"text", 'good'::"text", 'fair'::"text", 'poor'::"text", 'damaged'::"text"]))),
    CONSTRAINT "library_issued_books_return_condition_check" CHECK (("return_condition" = ANY (ARRAY['excellent'::"text", 'good'::"text", 'fair'::"text", 'poor'::"text", 'damaged'::"text", 'lost'::"text"]))),
    CONSTRAINT "library_issued_books_status_check" CHECK (("status" = ANY (ARRAY['issued'::"text", 'returned'::"text", 'overdue'::"text", 'lost'::"text", 'renewed'::"text"]))),
    CONSTRAINT "valid_dates" CHECK (("due_date" >= "issue_date")),
    CONSTRAINT "valid_fine" CHECK ((("fine_paid_amount" >= (0)::numeric) AND ("fine_paid_amount" <= "fine_amount"))),
    CONSTRAINT "valid_renewal" CHECK ((("renewal_count" >= 0) AND ("renewal_count" <= "max_renewals"))),
    CONSTRAINT "valid_return_date" CHECK ((("return_date" IS NULL) OR ("return_date" >= "issue_date")))
);


ALTER TABLE "public"."library_issued_books" OWNER TO "postgres";


COMMENT ON TABLE "public"."library_issued_books" IS 'Currently issued books with fine calculation';



COMMENT ON COLUMN "public"."library_issued_books"."student_record_id" IS 'Direct reference to students table - auto-populated via trigger';



CREATE TABLE IF NOT EXISTS "public"."library_reservations" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "book_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "student_name" "text" NOT NULL,
    "roll_number" "text" NOT NULL,
    "reserved_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "expiry_date" "date" NOT NULL,
    "priority" integer DEFAULT 1,
    "status" "text" DEFAULT 'active'::"text",
    "fulfilled_date" "date",
    "issued_book_id" "uuid",
    "notification_sent" boolean DEFAULT false,
    "notification_sent_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "library_reservations_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'fulfilled'::"text", 'expired'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "valid_reservation_dates" CHECK (("expiry_date" >= "reserved_date"))
);


ALTER TABLE "public"."library_reservations" OWNER TO "postgres";


COMMENT ON TABLE "public"."library_reservations" IS 'Book reservation queue system';



CREATE TABLE IF NOT EXISTS "public"."library_reviews" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "book_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "student_name" "text" NOT NULL,
    "rating" integer NOT NULL,
    "review_text" "text",
    "is_approved" boolean DEFAULT false,
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "library_reviews_rating_check" CHECK ((("rating" >= 1) AND ("rating" <= 5)))
);


ALTER TABLE "public"."library_reviews" OWNER TO "postgres";


COMMENT ON TABLE "public"."library_reviews" IS 'Student book reviews and ratings';



CREATE TABLE IF NOT EXISTS "public"."library_settings" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "setting_key" "text" NOT NULL,
    "setting_value" "text" NOT NULL,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."library_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."library_settings_college" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "college_id" "uuid" NOT NULL,
    "setting_key" "text" NOT NULL,
    "setting_value" "text" NOT NULL,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."library_settings_college" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."library_settings_school" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "school_id" "uuid" NOT NULL,
    "setting_key" "text" NOT NULL,
    "setting_value" "text" NOT NULL,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."library_settings_school" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."overdue_books" AS
 SELECT "lbi"."id",
    "lbi"."book_id",
    "lbi"."student_id",
    "lbi"."student_name",
    "lbi"."roll_number",
    "lbi"."class",
    "lbi"."academic_year",
    "lbi"."issue_date",
    "lbi"."due_date",
    "lbi"."return_date",
    "lbi"."status",
    "lbi"."fine_amount",
    "lbi"."fine_paid",
    "lbi"."remarks",
    "lbi"."issued_by",
    "lbi"."returned_by",
    "lbi"."created_at",
    "lbi"."updated_at",
    "lb"."title",
    "lb"."author",
    "lb"."isbn",
    "public"."calculate_fine"("lbi"."issue_date", CURRENT_DATE) AS "current_fine",
    (CURRENT_DATE - "lbi"."due_date") AS "days_overdue"
   FROM ("public"."library_book_issues" "lbi"
     JOIN "public"."library_books" "lb" ON (("lbi"."book_id" = "lb"."id")))
  WHERE (("lbi"."status" = 'issued'::"text") AND ("lbi"."due_date" < CURRENT_DATE));


ALTER VIEW "public"."overdue_books" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."library_stats" AS
 SELECT ( SELECT "count"(*) AS "count"
           FROM "public"."library_books") AS "total_books",
    ( SELECT "sum"("library_books"."total_copies") AS "sum"
           FROM "public"."library_books") AS "total_copies",
    ( SELECT "sum"("library_books"."available_copies") AS "sum"
           FROM "public"."library_books") AS "available_copies",
    ( SELECT "count"(*) AS "count"
           FROM "public"."library_book_issues"
          WHERE ("library_book_issues"."status" = 'issued'::"text")) AS "currently_issued",
    ( SELECT "count"(*) AS "count"
           FROM "public"."overdue_books") AS "overdue_count",
    ( SELECT "sum"("overdue_books"."current_fine") AS "sum"
           FROM "public"."overdue_books") AS "total_pending_fines";


ALTER VIEW "public"."library_stats" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."overdue_books_college" AS
 SELECT "lbi"."id",
    "lbi"."college_id",
    "lbi"."book_id",
    "lbi"."student_id",
    "lbi"."student_name",
    "lbi"."roll_number",
    "lbi"."class",
    "lbi"."academic_year",
    "lbi"."issue_date",
    "lbi"."due_date",
    "lbi"."return_date",
    "lbi"."status",
    "lbi"."fine_amount",
    "lbi"."fine_paid",
    "lbi"."remarks",
    "lbi"."issued_by",
    "lbi"."returned_by",
    "lbi"."created_at",
    "lbi"."updated_at",
    "lb"."title",
    "lb"."author",
    "lb"."isbn",
    "public"."calculate_fine_college"("lbi"."college_id", "lbi"."issue_date", CURRENT_DATE) AS "current_fine",
    (CURRENT_DATE - "lbi"."due_date") AS "days_overdue"
   FROM ("public"."library_book_issues_college" "lbi"
     JOIN "public"."library_books_college" "lb" ON (("lbi"."book_id" = "lb"."id")))
  WHERE (("lbi"."status" = 'issued'::"text") AND ("lbi"."due_date" < CURRENT_DATE));


ALTER VIEW "public"."overdue_books_college" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."library_stats_college" AS
 SELECT "college_id",
    ( SELECT "count"(*) AS "count"
           FROM "public"."library_books_college"
          WHERE ("library_books_college"."college_id" = "main"."college_id")) AS "total_books",
    ( SELECT "sum"("library_books_college"."total_copies") AS "sum"
           FROM "public"."library_books_college"
          WHERE ("library_books_college"."college_id" = "main"."college_id")) AS "total_copies",
    ( SELECT "sum"("library_books_college"."available_copies") AS "sum"
           FROM "public"."library_books_college"
          WHERE ("library_books_college"."college_id" = "main"."college_id")) AS "available_copies",
    ( SELECT "count"(*) AS "count"
           FROM "public"."library_book_issues_college"
          WHERE (("library_book_issues_college"."college_id" = "main"."college_id") AND ("library_book_issues_college"."status" = 'issued'::"text"))) AS "currently_issued",
    ( SELECT "count"(*) AS "count"
           FROM "public"."overdue_books_college"
          WHERE ("overdue_books_college"."college_id" = "main"."college_id")) AS "overdue_count",
    ( SELECT COALESCE("sum"("overdue_books_college"."current_fine"), (0)::numeric) AS "coalesce"
           FROM "public"."overdue_books_college"
          WHERE ("overdue_books_college"."college_id" = "main"."college_id")) AS "total_pending_fines"
   FROM ( SELECT DISTINCT "library_books_college"."college_id"
           FROM "public"."library_books_college"
        UNION
         SELECT DISTINCT "library_book_issues_college"."college_id"
           FROM "public"."library_book_issues_college") "main";


ALTER VIEW "public"."library_stats_college" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."overdue_books_school" AS
 SELECT "lbi"."id",
    "lbi"."school_id",
    "lbi"."book_id",
    "lbi"."student_id",
    "lbi"."student_name",
    "lbi"."roll_number",
    "lbi"."class",
    "lbi"."academic_year",
    "lbi"."issue_date",
    "lbi"."due_date",
    "lbi"."return_date",
    "lbi"."status",
    "lbi"."fine_amount",
    "lbi"."fine_paid",
    "lbi"."remarks",
    "lbi"."issued_by",
    "lbi"."returned_by",
    "lbi"."created_at",
    "lbi"."updated_at",
    "lb"."title",
    "lb"."author",
    "lb"."isbn",
    "public"."calculate_fine_school"("lbi"."school_id", "lbi"."issue_date", CURRENT_DATE) AS "current_fine",
    (CURRENT_DATE - "lbi"."due_date") AS "days_overdue"
   FROM ("public"."library_book_issues_school" "lbi"
     JOIN "public"."library_books_school" "lb" ON (("lbi"."book_id" = "lb"."id")))
  WHERE (("lbi"."status" = 'issued'::"text") AND ("lbi"."due_date" < CURRENT_DATE));


ALTER VIEW "public"."overdue_books_school" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."library_stats_school" AS
 SELECT "school_id",
    ( SELECT "count"(*) AS "count"
           FROM "public"."library_books_school" "lbs"
          WHERE ("lbs"."school_id" = "main"."school_id")) AS "total_books",
    ( SELECT "sum"("lbs"."total_copies") AS "sum"
           FROM "public"."library_books_school" "lbs"
          WHERE ("lbs"."school_id" = "main"."school_id")) AS "total_copies",
    ( SELECT "sum"("lbs"."available_copies") AS "sum"
           FROM "public"."library_books_school" "lbs"
          WHERE ("lbs"."school_id" = "main"."school_id")) AS "available_copies",
    ( SELECT "count"(*) AS "count"
           FROM "public"."library_book_issues_school" "lbis"
          WHERE (("lbis"."school_id" = "main"."school_id") AND ("lbis"."status" = 'issued'::"text"))) AS "currently_issued",
    ( SELECT "count"(*) AS "count"
           FROM "public"."overdue_books_school" "obs"
          WHERE ("obs"."school_id" = "main"."school_id")) AS "overdue_count",
    ( SELECT "sum"("obs"."current_fine") AS "sum"
           FROM "public"."overdue_books_school" "obs"
          WHERE ("obs"."school_id" = "main"."school_id")) AS "total_pending_fines"
   FROM ( SELECT DISTINCT "library_books_school"."school_id"
           FROM "public"."library_books_school"
        UNION
         SELECT DISTINCT "library_book_issues_school"."school_id"
           FROM "public"."library_book_issues_school") "main";


ALTER VIEW "public"."library_stats_school" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."license_assignments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "license_pool_id" "uuid" NOT NULL,
    "organization_subscription_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "member_type" character varying(20) NOT NULL,
    "status" character varying(20) DEFAULT 'active'::character varying NOT NULL,
    "assigned_at" timestamp with time zone DEFAULT "now"(),
    "assigned_by" "uuid" NOT NULL,
    "expires_at" timestamp with time zone,
    "revoked_at" timestamp with time zone,
    "revoked_by" "uuid",
    "revocation_reason" "text",
    "transferred_from" "uuid",
    "transferred_to" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "license_assignments_member_type_check" CHECK ((("member_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('student'::character varying)::"text"]))),
    CONSTRAINT "license_assignments_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('active'::character varying)::"text", ('suspended'::character varying)::"text", ('revoked'::character varying)::"text", ('expired'::character varying)::"text"]))),
    CONSTRAINT "valid_expiration" CHECK ((("expires_at" IS NULL) OR ("expires_at" > "assigned_at"))),
    CONSTRAINT "valid_revocation" CHECK ((((("status")::"text" = 'revoked'::"text") AND ("revoked_at" IS NOT NULL) AND ("revoked_by" IS NOT NULL)) OR ((("status")::"text" <> 'revoked'::"text") AND ("revoked_at" IS NULL))))
);


ALTER TABLE "public"."license_assignments" OWNER TO "postgres";


COMMENT ON TABLE "public"."license_assignments" IS 'Tracks which members have been assigned subscription seats with full audit trail';



COMMENT ON COLUMN "public"."license_assignments"."status" IS 'active: currently assigned, suspended: temporarily disabled, revoked: permanently removed, expired: past expiration date';



COMMENT ON COLUMN "public"."license_assignments"."revocation_reason" IS 'Admin-provided reason for revoking access (for compliance and audit)';



COMMENT ON COLUMN "public"."license_assignments"."transferred_from" IS 'References the assignment this was transferred from (for audit trail)';



COMMENT ON COLUMN "public"."license_assignments"."transferred_to" IS 'References the assignment this was transferred to (for audit trail)';



CREATE TABLE IF NOT EXISTS "public"."license_pools" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_subscription_id" "uuid" NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "organization_type" character varying(20) NOT NULL,
    "pool_name" character varying(100),
    "member_type" character varying(20) NOT NULL,
    "allocated_seats" integer NOT NULL,
    "assigned_seats" integer DEFAULT 0,
    "available_seats" integer GENERATED ALWAYS AS (("allocated_seats" - "assigned_seats")) STORED,
    "auto_assign_new_members" boolean DEFAULT false,
    "assignment_criteria" "jsonb" DEFAULT '{}'::"jsonb",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    CONSTRAINT "license_pools_allocated_seats_check" CHECK (("allocated_seats" > 0)),
    CONSTRAINT "license_pools_assigned_seats_check" CHECK (("assigned_seats" >= 0)),
    CONSTRAINT "license_pools_member_type_check" CHECK ((("member_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('student'::character varying)::"text"]))),
    CONSTRAINT "license_pools_organization_type_check" CHECK ((("organization_type")::"text" = ANY (ARRAY[('school'::character varying)::"text", ('college'::character varying)::"text", ('university'::character varying)::"text"]))),
    CONSTRAINT "valid_pool_name" CHECK ((("pool_name" IS NULL) OR ("length"(("pool_name")::"text") > 0))),
    CONSTRAINT "valid_pool_seats" CHECK (("assigned_seats" <= "allocated_seats"))
);


ALTER TABLE "public"."license_pools" OWNER TO "postgres";


COMMENT ON TABLE "public"."license_pools" IS 'Manages available subscription seats for organizations with optional auto-assignment rules';



COMMENT ON COLUMN "public"."license_pools"."pool_name" IS 'Optional name for the pool (e.g., "Computer Science Department", "Grade 10")';



COMMENT ON COLUMN "public"."license_pools"."available_seats" IS 'Automatically calculated as allocated_seats - assigned_seats';



COMMENT ON COLUMN "public"."license_pools"."auto_assign_new_members" IS 'If true, new members matching criteria will automatically get assigned';



COMMENT ON COLUMN "public"."license_pools"."assignment_criteria" IS 'JSONB field for auto-assignment rules (e.g., {"department": "CS", "grade": "10"})';



CREATE TABLE IF NOT EXISTS "public"."mark_entries" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "assessment_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "marks_obtained" numeric(5,2),
    "total_marks" numeric(5,2) NOT NULL,
    "percentage" numeric(5,2) GENERATED ALWAYS AS (
CASE
    WHEN (("marks_obtained" IS NOT NULL) AND ("total_marks" > (0)::numeric)) THEN (("marks_obtained" / "total_marks") * (100)::numeric)
    ELSE NULL::numeric
END) STORED,
    "grade" "text",
    "grade_point" numeric(3,2),
    "is_absent" boolean DEFAULT false,
    "is_exempt" boolean DEFAULT false,
    "is_pass" boolean GENERATED ALWAYS AS (
CASE
    WHEN ("is_absent" OR "is_exempt") THEN NULL::boolean
    WHEN ("marks_obtained" IS NOT NULL) THEN ("marks_obtained" >= ("total_marks" * 0.4))
    ELSE NULL::boolean
END) STORED,
    "remarks" "text",
    "exemption_reason" "text",
    "original_marks" numeric(5,2),
    "moderated_by" "uuid",
    "moderation_reason" "text",
    "moderation_date" timestamp with time zone,
    "entered_by" "uuid" NOT NULL,
    "entered_at" timestamp with time zone DEFAULT "now"(),
    "is_locked" boolean DEFAULT false,
    "locked_by" "uuid",
    "locked_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "student_record_id" "uuid",
    "subject_id" "text",
    CONSTRAINT "absent_or_marks" CHECK ((NOT (("is_absent" = true) AND ("marks_obtained" IS NOT NULL)))),
    CONSTRAINT "valid_grade_point" CHECK ((("grade_point" IS NULL) OR (("grade_point" >= (0)::numeric) AND ("grade_point" <= (10)::numeric)))),
    CONSTRAINT "valid_marks" CHECK ((("marks_obtained" IS NULL) OR (("marks_obtained" >= (0)::numeric) AND ("marks_obtained" <= "total_marks"))))
);


ALTER TABLE "public"."mark_entries" OWNER TO "postgres";


COMMENT ON TABLE "public"."mark_entries" IS 'Student marks with grade calculation and moderation support';



COMMENT ON COLUMN "public"."mark_entries"."student_record_id" IS 'Direct reference to students table - auto-populated via trigger';



COMMENT ON COLUMN "public"."mark_entries"."subject_id" IS 'ID of the specific subject these marks are for (from syllabus_coverage.subjects)';



CREATE TABLE IF NOT EXISTS "public"."mark_entry_batches" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "assessment_id" "uuid" NOT NULL,
    "batch_name" "text" NOT NULL,
    "batch_number" "text" NOT NULL,
    "total_students" integer DEFAULT 0 NOT NULL,
    "entries_completed" integer DEFAULT 0,
    "entries_pending" integer DEFAULT 0,
    "completion_percentage" numeric(5,2) DEFAULT 0,
    "status" "text" DEFAULT 'in_progress'::"text",
    "is_locked" boolean DEFAULT false,
    "entered_by" "uuid" NOT NULL,
    "started_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "locked_by" "uuid",
    "locked_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "mark_entry_batches_status_check" CHECK (("status" = ANY (ARRAY['in_progress'::"text", 'completed'::"text", 'locked'::"text", 'cancelled'::"text"])))
);


ALTER TABLE "public"."mark_entry_batches" OWNER TO "postgres";


COMMENT ON TABLE "public"."mark_entry_batches" IS 'Batch processing for mark entry operations';



CREATE TABLE IF NOT EXISTS "public"."mark_moderation_log" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "mark_entry_id" "uuid" NOT NULL,
    "assessment_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "original_marks" numeric(5,2) NOT NULL,
    "moderated_marks" numeric(5,2) NOT NULL,
    "difference" numeric(5,2) DEFAULT 0,
    "moderation_type" "text" NOT NULL,
    "reason" "text" NOT NULL,
    "justification" "text",
    "moderated_by" "uuid" NOT NULL,
    "moderator_name" "text" NOT NULL,
    "moderated_at" timestamp with time zone DEFAULT "now"(),
    "requires_approval" boolean DEFAULT false,
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "approval_status" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "subject_id" "text",
    CONSTRAINT "mark_moderation_log_approval_status_check" CHECK (("approval_status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"]))),
    CONSTRAINT "mark_moderation_log_moderation_type_check" CHECK (("moderation_type" = ANY (ARRAY['correction'::"text", 'revaluation'::"text", 'grace_marks'::"text", 'normalization'::"text", 'appeal'::"text"])))
);


ALTER TABLE "public"."mark_moderation_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."mark_moderation_log" IS 'Audit trail for all mark moderation activities';



CREATE TABLE IF NOT EXISTS "public"."mentor_notes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "mentor_type" "text" NOT NULL,
    "school_educator_id" "uuid",
    "college_lecturer_id" "uuid",
    "quick_notes" "text"[],
    "feedback" "text",
    "action_points" "text",
    "note_date" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "mentor_notes_mentor_type_check" CHECK (("mentor_type" = ANY (ARRAY['school'::"text", 'college'::"text"])))
);


ALTER TABLE "public"."mentor_notes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."messages" (
    "id" integer NOT NULL,
    "conversation_id" "text" NOT NULL,
    "sender_id" "uuid" NOT NULL,
    "sender_type" "text" NOT NULL,
    "receiver_id" "uuid" NOT NULL,
    "receiver_type" "text" NOT NULL,
    "message_text" "text" NOT NULL,
    "attachments" "jsonb",
    "application_id" integer,
    "opportunity_id" integer,
    "is_read" boolean DEFAULT false,
    "read_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "class_id" "uuid",
    "subject" character varying(100),
    "program_section_id" "uuid",
    CONSTRAINT "messages_receiver_type_check" CHECK (("receiver_type" = ANY (ARRAY['student'::"text", 'recruiter'::"text", 'educator'::"text", 'college_educator'::"text", 'school_admin'::"text", 'college_admin'::"text"]))),
    CONSTRAINT "messages_sender_type_check" CHECK (("sender_type" = ANY (ARRAY['student'::"text", 'recruiter'::"text", 'educator'::"text", 'college_educator'::"text", 'school_admin'::"text", 'college_admin'::"text"])))
);


ALTER TABLE "public"."messages" OWNER TO "postgres";


COMMENT ON TABLE "public"."messages" IS 'RLS temporarily disabled for student-educator messaging testing. Re-enable after authentication is properly configured.';



COMMENT ON COLUMN "public"."messages"."class_id" IS 'Reference to school_classes for class context';



COMMENT ON COLUMN "public"."messages"."subject" IS 'Subject being discussed (from school_educator_class_assignments)';



CREATE TABLE IF NOT EXISTS "public"."messages_backup" (
    "id" integer,
    "conversation_id" "text",
    "sender_id" "uuid",
    "sender_type" "text",
    "receiver_id" "uuid",
    "receiver_type" "text",
    "message_text" "text",
    "attachments" "jsonb",
    "application_id" integer,
    "opportunity_id" integer,
    "is_read" boolean,
    "read_at" timestamp with time zone,
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone
);


ALTER TABLE "public"."messages_backup" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."messages_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."messages_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."messages_id_seq" OWNED BY "public"."messages"."id";



CREATE TABLE IF NOT EXISTS "public"."metrics_snapshots" (
    "id" "text" DEFAULT ("gen_random_uuid"())::"text" NOT NULL,
    "snapshotDate" "date" DEFAULT CURRENT_DATE NOT NULL,
    "activeUniversities" integer DEFAULT 0,
    "registeredStudents" integer DEFAULT 0,
    "verifiedPassports" integer DEFAULT 0,
    "aiVerifiedPercent" numeric(5,2) DEFAULT 0,
    "employabilityIndex" numeric(5,2) DEFAULT 0,
    "activeRecruiters" integer DEFAULT 0,
    "createdAt" timestamp with time zone DEFAULT "now"(),
    "totalSchools" integer DEFAULT 0,
    "totalColleges" integer DEFAULT 0,
    "totalCompanies" integer DEFAULT 0,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "jobsecured" integer DEFAULT 0
);


ALTER TABLE "public"."metrics_snapshots" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "recipient_id" "uuid" NOT NULL,
    "type" "text" NOT NULL,
    "title" "text" NOT NULL,
    "message" "text" NOT NULL,
    "read" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "assessment_id" "uuid",
    "scheduled_for" timestamp with time zone,
    "status" character varying(20) DEFAULT 'sent'::character varying,
    CONSTRAINT "notifications_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('scheduled'::character varying)::"text", ('sent'::character varying)::"text", ('cancelled'::character varying)::"text"])))
);


ALTER TABLE "public"."notifications" OWNER TO "postgres";


COMMENT ON TABLE "public"."notifications" IS 'User notifications for various events including job opportunities, pipeline updates, messages, etc.';



CREATE TABLE IF NOT EXISTS "public"."notifications_backup_20251106" (
    "id" "uuid",
    "recruiter_id" "uuid",
    "type" "text",
    "title" "text",
    "message" "text",
    "read" boolean,
    "created_at" timestamp with time zone
);


ALTER TABLE "public"."notifications_backup_20251106" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."offers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "inserted_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "candidate_id" "uuid",
    "candidate_name" "text" NOT NULL,
    "job_id" "text",
    "job_title" "text" NOT NULL,
    "template" "text",
    "ctc_band" "text",
    "offered_ctc" "text",
    "offer_date" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "expiry_date" timestamp with time zone NOT NULL,
    "status" "text" DEFAULT 'pending'::"text",
    "sent_via" "text" DEFAULT 'email'::"text",
    "benefits" "text"[],
    "notes" "text",
    "response_deadline" timestamp with time zone,
    "acceptance_notes" "text",
    "response_date" timestamp with time zone,
    CONSTRAINT "offers_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'accepted'::"text", 'rejected'::"text", 'expired'::"text", 'withdrawn'::"text"])))
);


ALTER TABLE "public"."offers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."opportunities_backup_migration" (
    "id" integer,
    "title" "text",
    "company_name" "text",
    "company_logo" "text",
    "employment_type" "text",
    "location" "text",
    "mode" "text",
    "stipend_or_salary" "text",
    "experience_required" "text",
    "skills_required" "jsonb",
    "description" "text",
    "application_link" "text",
    "deadline" timestamp with time zone,
    "is_active" boolean,
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone,
    "department" "text",
    "experience_level" "text",
    "salary_range_min" integer,
    "salary_range_max" integer,
    "status" "text",
    "posted_date" timestamp with time zone,
    "closing_date" timestamp with time zone,
    "requirements" "jsonb",
    "responsibilities" "jsonb",
    "benefits" "jsonb",
    "applications_count" integer,
    "messages_count" integer,
    "views_count" integer,
    "created_by" "text",
    "job_title" "text",
    "recruiter_id" "uuid",
    "embedding" "extensions"."vector"(1536),
    "requisition_id" "text",
    "requisition_id_uuid" "uuid",
    "sector" "text",
    "exposure_type" "text",
    "total_hours" integer,
    "duration_weeks" integer,
    "duration_days" integer,
    "schedule_note" "text",
    "what_youll_learn" "text",
    "what_youll_do" "text",
    "final_artifact_type" "text",
    "final_artifact_description" "text",
    "mentor_bio" "text",
    "safety_note" "text",
    "parent_role" "text",
    "cost_inr" integer,
    "cost_note" "text",
    "prerequiste" character varying
);


ALTER TABLE "public"."opportunities_backup_migration" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."opportunities_duplicate" (
    "id" integer NOT NULL,
    "title" "text" NOT NULL,
    "company_name" "text" NOT NULL,
    "company_logo" "text",
    "employment_type" "text" NOT NULL,
    "location" "text" NOT NULL,
    "mode" "text",
    "stipend_or_salary" "text",
    "experience_required" "text",
    "skills_required" "jsonb",
    "description" "text",
    "application_link" "text",
    "deadline" timestamp with time zone,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "department" "text" NOT NULL,
    "experience_level" "text",
    "salary_range_min" integer,
    "salary_range_max" integer,
    "status" "text" DEFAULT 'draft'::"text",
    "posted_date" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "closing_date" timestamp with time zone,
    "requirements" "jsonb",
    "responsibilities" "jsonb",
    "benefits" "jsonb",
    "applications_count" integer DEFAULT 0,
    "messages_count" integer DEFAULT 0,
    "views_count" integer DEFAULT 0,
    "created_by" "text",
    "job_title" "text" NOT NULL,
    "recruiter_id" "uuid",
    "embedding" "extensions"."vector"(1536),
    "requisition_id" "text",
    "requisition_id_uuid" "uuid",
    "sector" "text",
    "exposure_type" "text",
    "total_hours" integer,
    "duration_weeks" integer,
    "duration_days" integer,
    "schedule_note" "text",
    "what_youll_learn" "text",
    "what_youll_do" "text",
    "final_artifact_type" "text",
    "final_artifact_description" "text",
    "mentor_bio" "text",
    "safety_note" "text",
    "parent_role" "text",
    "cost_inr" integer,
    "cost_note" "text",
    "prerequiste" character varying
);


ALTER TABLE "public"."opportunities_duplicate" OWNER TO "postgres";


COMMENT ON TABLE "public"."opportunities_duplicate" IS 'This is a duplicate of opportunities';



COMMENT ON COLUMN "public"."opportunities_duplicate"."sector" IS 'Industry sector (e.g., Technology, Healthcare, Education)';



COMMENT ON COLUMN "public"."opportunities_duplicate"."exposure_type" IS 'Type of exposure (e.g., Hands-on, Observation, Hybrid)';



COMMENT ON COLUMN "public"."opportunities_duplicate"."total_hours" IS 'Total hours for the internship/opportunity';



COMMENT ON COLUMN "public"."opportunities_duplicate"."duration_weeks" IS 'Duration in weeks';



COMMENT ON COLUMN "public"."opportunities_duplicate"."duration_days" IS 'Duration in days';



COMMENT ON COLUMN "public"."opportunities_duplicate"."what_youll_learn" IS 'Learning outcomes description';



COMMENT ON COLUMN "public"."opportunities_duplicate"."what_youll_do" IS 'Activities and tasks description';



COMMENT ON COLUMN "public"."opportunities_duplicate"."cost_inr" IS 'Cost in Indian Rupees';



CREATE TABLE IF NOT EXISTS "public"."opportunity_interactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "action" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "opportunity_id" "uuid",
    CONSTRAINT "opportunity_interactions_action_check" CHECK (("action" = ANY (ARRAY['view'::"text", 'apply'::"text", 'dismiss'::"text", 'save'::"text"])))
);


ALTER TABLE "public"."opportunity_interactions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."opportunity_interactions_backup_uuid_migration" (
    "id" "uuid",
    "student_id" "uuid",
    "opportunity_id" integer,
    "action" "text",
    "created_at" timestamp with time zone
);


ALTER TABLE "public"."opportunity_interactions_backup_uuid_migration" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."organization_invitations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "organization_type" "text" NOT NULL,
    "invited_by" "uuid" NOT NULL,
    "invited_by_role" "text" NOT NULL,
    "invitee_email" "text" NOT NULL,
    "invitee_name" "text",
    "invitee_role" "text" NOT NULL,
    "license_pool_id" "uuid",
    "subscription_plan_id" "uuid",
    "addon_ids" "uuid"[] DEFAULT '{}'::"uuid"[],
    "invitation_token" "text" DEFAULT "encode"("extensions"."gen_random_bytes"(32), 'hex'::"text") NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "expires_at" timestamp with time zone DEFAULT ("now"() + '7 days'::interval) NOT NULL,
    "accepted_at" timestamp with time zone,
    "accepted_by_user_id" "uuid",
    "invitation_message" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "cancelled_at" timestamp with time zone,
    "cancelled_by" "uuid",
    "cancellation_reason" "text",
    CONSTRAINT "accepted_requires_user" CHECK (((("status" = 'accepted'::"text") AND ("accepted_at" IS NOT NULL) AND ("accepted_by_user_id" IS NOT NULL)) OR ("status" <> 'accepted'::"text"))),
    CONSTRAINT "cancelled_requires_info" CHECK (((("status" = 'cancelled'::"text") AND ("cancelled_at" IS NOT NULL) AND ("cancelled_by" IS NOT NULL)) OR ("status" <> 'cancelled'::"text"))),
    CONSTRAINT "organization_invitations_invited_by_role_check" CHECK (("invited_by_role" = ANY (ARRAY['school_admin'::"text", 'college_admin'::"text", 'university_admin'::"text", 'company_admin'::"text"]))),
    CONSTRAINT "organization_invitations_invitee_role_check" CHECK (("invitee_role" = ANY (ARRAY['school_student'::"text", 'school_educator'::"text", 'school_admin'::"text", 'college_student'::"text", 'college_educator'::"text", 'college_admin'::"text", 'university_admin'::"text", 'recruiter'::"text", 'company_admin'::"text"]))),
    CONSTRAINT "organization_invitations_organization_type_check" CHECK (("organization_type" = ANY (ARRAY['school'::"text", 'college'::"text", 'university'::"text", 'company'::"text"]))),
    CONSTRAINT "organization_invitations_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'accepted'::"text", 'expired'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "valid_expiration" CHECK (("expires_at" > "created_at"))
);


ALTER TABLE "public"."organization_invitations" OWNER TO "postgres";


COMMENT ON TABLE "public"."organization_invitations" IS 'Manages invitations sent by organization admins to members for license assignment';



COMMENT ON COLUMN "public"."organization_invitations"."addon_ids" IS 'Array of add-on subscription plan IDs to be assigned with the license';



COMMENT ON COLUMN "public"."organization_invitations"."invitation_token" IS 'Unique token for accepting invitation via email link';



COMMENT ON COLUMN "public"."organization_invitations"."expires_at" IS 'Invitation expiration timestamp (default 7 days from creation)';



COMMENT ON COLUMN "public"."organization_invitations"."metadata" IS 'Additional invitation metadata (welcome message, custom fields, etc.)';



CREATE TABLE IF NOT EXISTS "public"."organization_subscriptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "organization_type" character varying(20) NOT NULL,
    "subscription_plan_id" "uuid" NOT NULL,
    "purchased_by" "uuid" NOT NULL,
    "total_seats" integer NOT NULL,
    "assigned_seats" integer DEFAULT 0,
    "available_seats" integer GENERATED ALWAYS AS (("total_seats" - "assigned_seats")) STORED,
    "target_member_type" character varying(20) NOT NULL,
    "status" character varying(20) DEFAULT 'active'::character varying NOT NULL,
    "start_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "end_date" timestamp with time zone NOT NULL,
    "auto_renew" boolean DEFAULT true,
    "price_per_seat" numeric(10,2) NOT NULL,
    "total_amount" numeric(10,2) NOT NULL,
    "discount_percentage" integer DEFAULT 0,
    "final_amount" numeric(10,2) NOT NULL,
    "razorpay_subscription_id" character varying(100),
    "razorpay_order_id" character varying(100),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "cancelled_at" timestamp with time zone,
    "cancellation_reason" "text",
    "razorpay_payment_id" character varying(255),
    CONSTRAINT "organization_subscriptions_assigned_seats_check" CHECK (("assigned_seats" >= 0)),
    CONSTRAINT "organization_subscriptions_organization_type_check" CHECK ((("organization_type")::"text" = ANY (ARRAY[('school'::character varying)::"text", ('college'::character varying)::"text", ('university'::character varying)::"text"]))),
    CONSTRAINT "organization_subscriptions_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('active'::character varying)::"text", ('paused'::character varying)::"text", ('cancelled'::character varying)::"text", ('expired'::character varying)::"text", ('grace_period'::character varying)::"text"]))),
    CONSTRAINT "organization_subscriptions_target_member_type_check" CHECK ((("target_member_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('student'::character varying)::"text", ('both'::character varying)::"text"]))),
    CONSTRAINT "organization_subscriptions_total_seats_check" CHECK (("total_seats" > 0)),
    CONSTRAINT "valid_dates" CHECK (("end_date" > "start_date")),
    CONSTRAINT "valid_pricing" CHECK ((("final_amount" >= (0)::numeric) AND ("total_amount" >= (0)::numeric) AND ("price_per_seat" >= (0)::numeric))),
    CONSTRAINT "valid_seat_count" CHECK (("assigned_seats" <= "total_seats"))
);


ALTER TABLE "public"."organization_subscriptions" OWNER TO "postgres";


COMMENT ON TABLE "public"."organization_subscriptions" IS 'Tracks subscriptions purchased by organization admins for their members';



COMMENT ON COLUMN "public"."organization_subscriptions"."organization_id" IS 'References schools.id, colleges.id, or universities.id depending on organization_type';



COMMENT ON COLUMN "public"."organization_subscriptions"."available_seats" IS 'Automatically calculated as total_seats - assigned_seats';



COMMENT ON COLUMN "public"."organization_subscriptions"."target_member_type" IS 'Specifies whether subscription is for educators, students, or both';



COMMENT ON COLUMN "public"."organization_subscriptions"."discount_percentage" IS 'Volume discount percentage applied (0-30%)';



COMMENT ON COLUMN "public"."organization_subscriptions"."razorpay_payment_id" IS 'Razorpay payment ID for tracking the payment';



CREATE TABLE IF NOT EXISTS "public"."otp_requests_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "phone" character varying(20) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."otp_requests_log" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."outcome_assessment_mappings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "learning_outcome_id" "uuid" NOT NULL,
    "assessment_type_id" "uuid" NOT NULL,
    "weightage" numeric(5,2),
    "created_at" timestamp without time zone DEFAULT "now"(),
    CONSTRAINT "outcome_assessment_mappings_weightage_check" CHECK ((("weightage" >= (0)::numeric) AND ("weightage" <= (100)::numeric)))
);


ALTER TABLE "public"."outcome_assessment_mappings" OWNER TO "postgres";


COMMENT ON TABLE "public"."outcome_assessment_mappings" IS 'Maps learning outcomes to assessment types with weightage';



COMMENT ON COLUMN "public"."outcome_assessment_mappings"."weightage" IS 'Assessment weightage percentage (0-100)';



CREATE TABLE IF NOT EXISTS "public"."payment_transactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "subscription_id" "uuid",
    "user_id" "uuid" NOT NULL,
    "razorpay_payment_id" character varying(255),
    "razorpay_order_id" character varying(255),
    "amount" numeric(10,2) NOT NULL,
    "currency" character varying(10) DEFAULT 'INR'::character varying,
    "status" character varying(50) NOT NULL,
    "payment_method" character varying(50),
    "failure_reason" "text",
    "refund_id" character varying(255),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "organization_id" "uuid",
    "organization_type" "text",
    "seat_count" integer DEFAULT 1,
    "is_bulk_purchase" boolean DEFAULT false,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "transaction_type" character varying(50) DEFAULT 'subscription'::character varying,
    CONSTRAINT "check_bulk_purchase_has_org" CHECK (((("is_bulk_purchase" = true) AND ("organization_id" IS NOT NULL) AND ("organization_type" IS NOT NULL)) OR ("is_bulk_purchase" = false))),
    CONSTRAINT "check_bulk_purchase_seat_count" CHECK (((("is_bulk_purchase" = true) AND ("seat_count" > 1)) OR (("is_bulk_purchase" = false) AND ("seat_count" = 1)))),
    CONSTRAINT "payment_transactions_organization_type_check" CHECK (("organization_type" = ANY (ARRAY['school'::"text", 'college'::"text", 'university'::"text", 'company'::"text"]))),
    CONSTRAINT "payment_transactions_seat_count_check" CHECK (("seat_count" > 0))
);


ALTER TABLE "public"."payment_transactions" OWNER TO "postgres";


COMMENT ON COLUMN "public"."payment_transactions"."organization_id" IS 'ID of the organization making the bulk purchase';



COMMENT ON COLUMN "public"."payment_transactions"."organization_type" IS 'Type of organization (school, college, university, company)';



COMMENT ON COLUMN "public"."payment_transactions"."seat_count" IS 'Number of seats/licenses purchased in this transaction';



COMMENT ON COLUMN "public"."payment_transactions"."is_bulk_purchase" IS 'Flag indicating if this is an organization bulk purchase';



COMMENT ON COLUMN "public"."payment_transactions"."metadata" IS 'Additional metadata for the transaction';



COMMENT ON COLUMN "public"."payment_transactions"."transaction_type" IS 'Type of transaction: subscription, organization_subscription, addon, etc.';



CREATE OR REPLACE VIEW "public"."pending_scorecards" AS
 SELECT "i"."id",
    "i"."student_id",
    "i"."candidate_name",
    "i"."candidate_email",
    "i"."candidate_phone",
    "i"."job_title",
    "i"."interviewer",
    "i"."interviewer_email",
    "i"."date",
    "i"."duration",
    "i"."status",
    "i"."type",
    "i"."meeting_type",
    "i"."meeting_link",
    "i"."meeting_notes",
    "i"."reminders_sent",
    "i"."completed_date",
    "i"."scorecard",
    "i"."created_by",
    "i"."created_at",
    "i"."updated_at",
    "s"."name" AS "student_name",
    "s"."branch_field" AS "department"
   FROM ("public"."interviews" "i"
     LEFT JOIN "public"."students" "s" ON (("i"."student_id" = "s"."id")))
  WHERE (("i"."status" = 'completed'::"text") AND (("i"."scorecard" IS NULL) OR (("i"."scorecard" ->> 'overall_rating'::"text") IS NULL)))
  ORDER BY "i"."completed_date" DESC;


ALTER VIEW "public"."pending_scorecards" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."permissions" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "name" character varying(100) NOT NULL,
    "resource" character varying(50) NOT NULL,
    "action" character varying(50) NOT NULL,
    "description" "text",
    "createdAt" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."permissions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."personal_assessment_attempts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "stream_id" character varying(20) NOT NULL,
    "started_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "status" character varying(20) DEFAULT 'in_progress'::character varying,
    "current_section_index" integer DEFAULT 0,
    "current_question_index" integer DEFAULT 0,
    "section_timings" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "timer_remaining" integer,
    "elapsed_time" integer DEFAULT 0,
    "grade_level" "text" DEFAULT 'after12'::"text" NOT NULL,
    "adaptive_aptitude_session_id" "uuid",
    "all_responses" "jsonb" DEFAULT '{}'::"jsonb",
    "aptitude_scores" "jsonb",
    "knowledge_scores" "jsonb",
    "aptitude_question_timer" integer,
    "total_time_minutes" numeric GENERATED ALWAYS AS ("round"(((((((((COALESCE((("section_timings" ->> 'riasec'::"text"))::integer, 0) + COALESCE((("section_timings" ->> 'bigfive'::"text"))::integer, 0)) + COALESCE((("section_timings" ->> 'aptitude'::"text"))::integer, 0)) + COALESCE((("section_timings" ->> 'values'::"text"))::integer, 0)) + COALESCE((("section_timings" ->> 'work_values'::"text"))::integer, 0)) + COALESCE((("section_timings" ->> 'employability'::"text"))::integer, 0)) + COALESCE((("section_timings" ->> 'knowledge'::"text"))::integer, 0)))::numeric / (60)::numeric), 2)) STORED,
    "student_context" "jsonb",
    CONSTRAINT "assessment_attempts_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('in_progress'::character varying)::"text", ('completed'::character varying)::"text", ('abandoned'::character varying)::"text"]))),
    CONSTRAINT "personal_assessment_attempts_grade_level_check" CHECK (("grade_level" = ANY (ARRAY['middle'::"text", 'highschool'::"text", 'higher_secondary'::"text", 'after10'::"text", 'after12'::"text", 'college'::"text"])))
);


ALTER TABLE "public"."personal_assessment_attempts" OWNER TO "postgres";


COMMENT ON TABLE "public"."personal_assessment_attempts" IS 'Tracks student assessment sessions with progress';



COMMENT ON COLUMN "public"."personal_assessment_attempts"."timer_remaining" IS 'Remaining seconds for current timed section (aptitude/knowledge)';



COMMENT ON COLUMN "public"."personal_assessment_attempts"."elapsed_time" IS 'Elapsed seconds for current non-timed section';



COMMENT ON COLUMN "public"."personal_assessment_attempts"."adaptive_aptitude_session_id" IS 'Links to the adaptive aptitude test session if the student took the adaptive test as part of this assessment';



COMMENT ON COLUMN "public"."personal_assessment_attempts"."all_responses" IS 'Stores all assessment responses including hardcoded questions (RIASEC, BigFive, Values, Employability) that have non-UUID IDs. Format: {"riasec_r1": 4, "bigfive_o1": 3, ...}';



COMMENT ON COLUMN "public"."personal_assessment_attempts"."aptitude_scores" IS 'Pre-calculated aptitude scores saved when section completes';



COMMENT ON COLUMN "public"."personal_assessment_attempts"."knowledge_scores" IS 'Pre-calculated knowledge scores saved when section completes';



COMMENT ON COLUMN "public"."personal_assessment_attempts"."aptitude_question_timer" IS 'Remaining time in seconds for current aptitude question (60s per question). Used to restore timer state when resuming assessment.';



COMMENT ON COLUMN "public"."personal_assessment_attempts"."total_time_minutes" IS 'Total time taken to complete the assessment in minutes (auto-calculated from section_timings, rounded to 2 decimals)';



COMMENT ON COLUMN "public"."personal_assessment_attempts"."student_context" IS 'Student academic context for enhanced AI recommendations. Contains: rawGrade, programName, programCode, degreeLevel';



CREATE TABLE IF NOT EXISTS "public"."personal_assessment_questions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "section_id" "uuid" NOT NULL,
    "stream_id" character varying(20),
    "question_text" "text" NOT NULL,
    "question_type" character varying(20) NOT NULL,
    "options" "jsonb",
    "correct_answer" character varying(255),
    "subtype" character varying(50),
    "module_title" character varying(100),
    "part_type" character varying(30),
    "best_answer" character varying(255),
    "worst_answer" character varying(255),
    "scenario" "text",
    "order_number" integer DEFAULT 0 NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "placeholder" "text",
    "description" "text",
    "strength_type" "text",
    "task_type" "text",
    "max_selections" integer,
    "category_mapping" "jsonb",
    CONSTRAINT "assessment_questions_question_type_check" CHECK ((("question_type")::"text" = ANY (ARRAY[('likert'::character varying)::"text", ('mcq'::character varying)::"text", ('sjt'::character varying)::"text", ('rating'::character varying)::"text", ('multiselect'::character varying)::"text", ('singleselect'::character varying)::"text", ('text'::character varying)::"text"])))
);


ALTER TABLE "public"."personal_assessment_questions" OWNER TO "postgres";


COMMENT ON TABLE "public"."personal_assessment_questions" IS 'All assessment questions with section and optional stream references';



CREATE TABLE IF NOT EXISTS "public"."personal_assessment_response_scales" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "section_id" "uuid",
    "scale_name" "text" NOT NULL,
    "scale_values" "jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."personal_assessment_response_scales" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."personal_assessment_responses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "attempt_id" "uuid" NOT NULL,
    "question_id" "uuid" NOT NULL,
    "response_value" "jsonb" NOT NULL,
    "is_correct" boolean,
    "responded_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."personal_assessment_responses" OWNER TO "postgres";


COMMENT ON TABLE "public"."personal_assessment_responses" IS 'Individual question responses for each attempt';



COMMENT ON COLUMN "public"."personal_assessment_responses"."question_id" IS 'Question ID - can be from personal_assessment_questions table OR AI-generated UUID from career_assessment_ai_questions';



CREATE TABLE IF NOT EXISTS "public"."personal_assessment_restrictions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "text" NOT NULL,
    "last_attempt_date" timestamp with time zone NOT NULL,
    "next_allowed_date" timestamp with time zone NOT NULL,
    "grade_level" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "personal_assessment_restrictions_grade_level_check" CHECK (("grade_level" = ANY (ARRAY['middle'::"text", 'highschool'::"text", 'higher_secondary'::"text", 'after10'::"text", 'after12'::"text", 'college'::"text"])))
);


ALTER TABLE "public"."personal_assessment_restrictions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."personal_assessment_results" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "attempt_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "stream_id" character varying(50) NOT NULL,
    "riasec_scores" "jsonb",
    "riasec_code" character varying(10),
    "aptitude_scores" "jsonb",
    "aptitude_overall" numeric(5,2),
    "bigfive_scores" "jsonb",
    "work_values_scores" "jsonb",
    "employability_scores" "jsonb",
    "employability_readiness" character varying(20),
    "knowledge_score" numeric(5,2),
    "knowledge_details" "jsonb",
    "career_fit" "jsonb",
    "skill_gap" "jsonb",
    "roadmap" "jsonb",
    "profile_snapshot" "jsonb",
    "timing_analysis" "jsonb",
    "final_note" "jsonb",
    "overall_summary" "text",
    "gemini_results" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "status" "public"."assessment_status" DEFAULT 'pending'::"public"."assessment_status",
    "grade_level" "text" DEFAULT 'after12'::"text" NOT NULL,
    "skill_gap_courses" "jsonb",
    "platform_courses" "jsonb",
    "courses_by_type" "jsonb",
    CONSTRAINT "personal_assessment_results_grade_level_check" CHECK (("grade_level" = ANY (ARRAY['middle'::"text", 'highschool'::"text", 'higher_secondary'::"text", 'after10'::"text", 'after12'::"text", 'college'::"text"])))
);


ALTER TABLE "public"."personal_assessment_results" OWNER TO "postgres";


COMMENT ON TABLE "public"."personal_assessment_results" IS 'AI-analyzed results and scores for completed assessments';



COMMENT ON COLUMN "public"."personal_assessment_results"."platform_courses" IS 'Stores recommended platform courses (array of course objects with relevance scores)';



COMMENT ON COLUMN "public"."personal_assessment_results"."courses_by_type" IS 'Stores courses separated by type: {technical: [], soft: []}';



CREATE TABLE IF NOT EXISTS "public"."personal_assessment_sections" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(50) NOT NULL,
    "title" character varying(100) NOT NULL,
    "description" "text",
    "icon" character varying(50),
    "color" character varying(30),
    "order_number" integer NOT NULL,
    "is_timed" boolean DEFAULT false,
    "time_limit_seconds" integer,
    "instruction" "text",
    "response_scale" "jsonb",
    "is_stream_specific" boolean DEFAULT false,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "grade_level" "text" DEFAULT 'after12'::"text" NOT NULL,
    CONSTRAINT "personal_assessment_sections_grade_level_check" CHECK (("grade_level" = ANY (ARRAY['middle'::"text", 'highschool'::"text", 'higher_secondary'::"text", 'after10'::"text", 'after12'::"text", 'college'::"text"])))
);


ALTER TABLE "public"."personal_assessment_sections" OWNER TO "postgres";


COMMENT ON TABLE "public"."personal_assessment_sections" IS 'Defines the 6 assessment sections (RIASEC, Aptitude, Big Five, Values, Employability, Knowledge)';



CREATE TABLE IF NOT EXISTS "public"."personal_assessment_streams" (
    "id" character varying(50) NOT NULL,
    "label" character varying(100) NOT NULL,
    "description" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "name" "text",
    "grade_level" "text",
    "display_order" integer DEFAULT 0,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "personal_assessment_streams_grade_level_check" CHECK (("grade_level" = ANY (ARRAY['middle'::"text", 'highschool'::"text", 'higher_secondary'::"text", 'after10'::"text", 'after12'::"text", 'college'::"text"])))
);


ALTER TABLE "public"."personal_assessment_streams" OWNER TO "postgres";


COMMENT ON TABLE "public"."personal_assessment_streams" IS 'Available streams/courses for stream-specific questions';



CREATE TABLE IF NOT EXISTS "public"."phone_otps" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "phone" character varying(20) NOT NULL,
    "otp_hash" character varying(64) NOT NULL,
    "expires_at" timestamp with time zone NOT NULL,
    "attempts" integer DEFAULT 0,
    "verified" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."phone_otps" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."pipeline_activities" (
    "id" integer NOT NULL,
    "pipeline_candidate_id" integer NOT NULL,
    "activity_type" "text" NOT NULL,
    "from_stage" "text",
    "to_stage" "text",
    "activity_details" "jsonb",
    "performed_by" "text",
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "student_id" "uuid"
);


ALTER TABLE "public"."pipeline_activities" OWNER TO "postgres";


COMMENT ON TABLE "public"."pipeline_activities" IS 'Audit log for all pipeline activities and stage changes';



CREATE SEQUENCE IF NOT EXISTS "public"."pipeline_activities_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."pipeline_activities_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."pipeline_activities_id_seq" OWNED BY "public"."pipeline_activities"."id";



CREATE TABLE IF NOT EXISTS "public"."pipeline_candidates" (
    "id_old" integer,
    "student_id" "uuid" NOT NULL,
    "candidate_name" "text" NOT NULL,
    "candidate_email" "text",
    "candidate_phone" "text",
    "stage" "text" DEFAULT 'sourced'::"text" NOT NULL,
    "previous_stage" "text",
    "stage_changed_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "stage_changed_by" "text",
    "status" "text" DEFAULT 'active'::"text",
    "rejection_reason" "text",
    "rejection_date" timestamp with time zone,
    "next_action" "text",
    "next_action_date" timestamp with time zone,
    "next_action_notes" "text",
    "recruiter_rating" integer,
    "recruiter_notes" "text",
    "assigned_to" "text",
    "source" "text",
    "added_by" "text",
    "added_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "opportunity_id_old" integer,
    "requisition_id" "uuid",
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "opportunity_id" "uuid" NOT NULL
);


ALTER TABLE "public"."pipeline_candidates" OWNER TO "postgres";


COMMENT ON TABLE "public"."pipeline_candidates" IS 'Candidates in recruitment pipeline with stage tracking';



COMMENT ON COLUMN "public"."pipeline_candidates"."stage" IS 'Current stage of candidate in pipeline';



COMMENT ON COLUMN "public"."pipeline_candidates"."next_action" IS 'Next planned recruiter action';



COMMENT ON COLUMN "public"."pipeline_candidates"."source" IS 'How the candidate entered the pipeline';



CREATE TABLE IF NOT EXISTS "public"."pipeline_candidates_backup_migration" (
    "id" integer,
    "student_id" "uuid",
    "candidate_name" "text",
    "candidate_email" "text",
    "candidate_phone" "text",
    "stage" "text",
    "previous_stage" "text",
    "stage_changed_at" timestamp with time zone,
    "stage_changed_by" "text",
    "status" "text",
    "rejection_reason" "text",
    "rejection_date" timestamp with time zone,
    "next_action" "text",
    "next_action_date" timestamp with time zone,
    "next_action_notes" "text",
    "recruiter_rating" integer,
    "recruiter_notes" "text",
    "assigned_to" "text",
    "source" "text",
    "added_by" "text",
    "added_at" timestamp with time zone,
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone,
    "opportunity_id" integer,
    "requisition_id" "uuid"
);


ALTER TABLE "public"."pipeline_candidates_backup_migration" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."pipeline_candidates_detailed" AS
 SELECT "pc"."id",
    "pc"."opportunity_id",
    "pc"."student_id",
    "pc"."candidate_name",
    "pc"."candidate_email",
    "pc"."candidate_phone",
    "pc"."stage",
    "pc"."previous_stage",
    "pc"."status",
    "pc"."source",
    "pc"."recruiter_rating",
    "pc"."recruiter_notes",
    "pc"."next_action",
    "pc"."next_action_date",
    "pc"."next_action_notes",
    "pc"."rejection_reason",
    "pc"."rejection_date",
    "pc"."assigned_to",
    "pc"."added_at",
    "pc"."updated_at",
    "pc"."added_by",
    "pc"."stage_changed_at",
    "pc"."stage_changed_by",
    "s"."name" AS "student_name",
    "s"."email" AS "student_email",
    "s"."contact_number" AS "student_phone",
    "s"."university" AS "student_university",
    "s"."branch_field" AS "student_department",
    "s"."course_name" AS "student_course",
    "s"."college_school_name" AS "student_college",
    "s"."district_name" AS "student_location",
    "o"."job_title" AS "opportunity_title",
    "o"."company_name",
    "o"."location" AS "opportunity_location",
    "o"."employment_type",
    "o"."experience_level"
   FROM (("public"."pipeline_candidates" "pc"
     LEFT JOIN "public"."students" "s" ON (("pc"."student_id" = "s"."id")))
     LEFT JOIN "public"."opportunities" "o" ON (("pc"."opportunity_id" = "o"."id")))
  WHERE ("pc"."status" = 'active'::"text");


ALTER VIEW "public"."pipeline_candidates_detailed" OWNER TO "postgres";


COMMENT ON VIEW "public"."pipeline_candidates_detailed" IS 'Pipeline candidates with full details - Fixed student join (2025-01-23)';



CREATE TABLE IF NOT EXISTS "public"."placements" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "studentId" "uuid",
    "recruiterId" "uuid",
    "jobTitle" "text" NOT NULL,
    "salaryOffered" numeric(10,2),
    "appliedDate" timestamp with time zone,
    "hiredDate" timestamp with time zone,
    "retentionDate" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "createdAt" timestamp with time zone DEFAULT "now"(),
    "updatedAt" timestamp with time zone DEFAULT "now"(),
    "placementStatus" "public"."placement_status" DEFAULT 'applied'::"public"."placement_status",
    CONSTRAINT "placements_hiredate_status_check" CHECK (((("hiredDate" IS NULL) AND ("placementStatus" <> ALL (ARRAY['offered'::"public"."placement_status", 'hired'::"public"."placement_status"]))) OR ("placementStatus" = ANY (ARRAY['offered'::"public"."placement_status", 'hired'::"public"."placement_status"])))),
    CONSTRAINT "placements_retentiondate_status_check" CHECK (((("retentionDate" IS NULL) AND ("placementStatus" <> 'hired'::"public"."placement_status")) OR ("placementStatus" = 'hired'::"public"."placement_status")))
);


ALTER TABLE "public"."placements" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."pre_registration_email_tracking" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "pre_registration_id" "uuid" NOT NULL,
    "email_status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "scheduled_at" timestamp with time zone NOT NULL,
    "sent_at" timestamp with time zone,
    "delivered_at" timestamp with time zone,
    "failed_at" timestamp with time zone,
    "error_message" "text",
    "retry_count" integer DEFAULT 0,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "pre_registration_email_tracking_email_status_check" CHECK (("email_status" = ANY (ARRAY['pending'::"text", 'queued'::"text", 'sending'::"text", 'sent'::"text", 'delivered'::"text", 'failed'::"text", 'bounced'::"text", 'rejected'::"text", 'deferred'::"text"])))
);


ALTER TABLE "public"."pre_registration_email_tracking" OWNER TO "postgres";


COMMENT ON TABLE "public"."pre_registration_email_tracking" IS 'Tracks countdown emails sent to pre-registered users';



COMMENT ON COLUMN "public"."pre_registration_email_tracking"."email_status" IS 'Status: pending (not sent), queued (ready to send), sending (in progress), sent (successfully sent), delivered (confirmed delivery), failed (send failed), bounced (email bounced), rejected (rejected by recipient server), deferred (temporarily delayed)';



COMMENT ON COLUMN "public"."pre_registration_email_tracking"."metadata" IS 'Additional data: countdown_day, campaign info, template version, etc.';



CREATE TABLE IF NOT EXISTS "public"."pre_registrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "full_name" "text" NOT NULL,
    "email" "text" NOT NULL,
    "phone" "text" NOT NULL,
    "amount" numeric DEFAULT 250,
    "razorpay_order_id" "text",
    "razorpay_payment_id" "text",
    "campaign" "text",
    "role_type" "text" DEFAULT 'pre_registration'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "payment_status" "public"."payment_status_enum" DEFAULT 'pending'::"public"."payment_status_enum" NOT NULL,
    "payment_history" "jsonb" DEFAULT '[]'::"jsonb"
);


ALTER TABLE "public"."pre_registrations" OWNER TO "postgres";


COMMENT ON COLUMN "public"."pre_registrations"."payment_history" IS 'Array of payment attempts: [{"order_id": "order_xxx", "payment_id": "pay_xxx", "status": "pending", "created_at": "2026-01-23T10:00:00Z", "error": null}]';



CREATE TABLE IF NOT EXISTS "public"."profile_views" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "viewer_type" "text" NOT NULL,
    "viewer_id" "uuid",
    "viewed_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."profile_views" OWNER TO "postgres";


COMMENT ON TABLE "public"."profile_views" IS 'Tracks profile views for analytics and notifications';



CREATE TABLE IF NOT EXISTS "public"."profile_views_backup_20251106" (
    "id" "uuid",
    "student_id" "uuid",
    "viewer_type" "text",
    "viewer_id" "uuid",
    "viewed_at" timestamp with time zone
);


ALTER TABLE "public"."profile_views_backup_20251106" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."program_sections_view" AS
 SELECT "ps"."id",
    "ps"."department_id",
    "d"."name" AS "department_name",
    "ps"."program_id",
    "p"."name" AS "program_name",
    "p"."code" AS "program_code",
    "ps"."semester",
    "ps"."section",
    "ps"."academic_year",
    "ps"."max_students",
    "ps"."current_students",
    "ps"."faculty_id",
    COALESCE(((("u"."firstName")::"text" || ' '::"text") || ("u"."lastName")::"text"), "u"."email") AS "faculty_name",
    "ps"."status",
    "ps"."created_at",
    "ps"."updated_at"
   FROM ((("public"."program_sections" "ps"
     LEFT JOIN "public"."departments" "d" ON (("ps"."department_id" = "d"."id")))
     LEFT JOIN "public"."programs" "p" ON (("ps"."program_id" = "p"."id")))
     LEFT JOIN "public"."users" "u" ON (("ps"."faculty_id" = "u"."id")))
  ORDER BY "d"."name", "p"."name", "ps"."semester", "ps"."section";


ALTER VIEW "public"."program_sections_view" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."promotional_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "event_code" "text" NOT NULL,
    "event_name" "text" NOT NULL,
    "description" "text",
    "start_date" timestamp with time zone NOT NULL,
    "end_date" timestamp with time zone NOT NULL,
    "discount_type" "text" DEFAULT 'percentage'::"text",
    "is_active" boolean DEFAULT true,
    "banner_text" "text",
    "banner_subtitle" "text",
    "banner_emoji" "text" DEFAULT 'ðŸŽ‰'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "promotional_events_discount_type_check" CHECK (("discount_type" = ANY (ARRAY['percentage'::"text", 'fixed'::"text"])))
);


ALTER TABLE "public"."promotional_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."quizzes" (
    "quiz_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "lesson_id" "uuid",
    "title" character varying(255) NOT NULL,
    "description" "text",
    "passing_score" numeric DEFAULT 70,
    "time_limit_seconds" integer DEFAULT 600,
    "max_attempts" integer DEFAULT 3,
    "questions" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."quizzes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."razorpay_orders" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "order_id" "text" NOT NULL,
    "amount" integer NOT NULL,
    "currency" "text" DEFAULT 'INR'::"text" NOT NULL,
    "receipt" "text" NOT NULL,
    "status" "text" DEFAULT 'created'::"text" NOT NULL,
    "plan_id" "text" NOT NULL,
    "plan_name" "text" NOT NULL,
    "user_email" "text" NOT NULL,
    "user_name" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "razorpay_payment_id" "text",
    "payment_method" "text",
    "failure_reason" "text",
    "refund_id" "text",
    "refund_status" "text",
    "subscription_id" "uuid"
);


ALTER TABLE "public"."razorpay_orders" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."recent_updates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updates" "jsonb" DEFAULT '{"updates": []}'::"jsonb",
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."recent_updates" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."recruiter_activities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "recruiterId" "uuid",
    "activityType" "text" NOT NULL,
    "targetStudentId" "uuid",
    "searchCriteria" "jsonb" DEFAULT '{}'::"jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "createdAt" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "recruiter_activities_activityType_check" CHECK (("activityType" = ANY (ARRAY['search'::"text", 'profile_view'::"text", 'contact'::"text", 'shortlist'::"text", 'hire_intent'::"text"])))
);


ALTER TABLE "public"."recruiter_activities" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."recruiter_saved_searches" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "recruiter_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "search_criteria" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "last_used" timestamp with time zone,
    "use_count" integer DEFAULT 0,
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."recruiter_saved_searches" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."requisitions" (
    "id" "text" NOT NULL,
    "title" "text" NOT NULL,
    "department" "text" NOT NULL,
    "location" "text" NOT NULL,
    "job_type" "text" DEFAULT 'Full-time'::"text",
    "openings" integer DEFAULT 1,
    "status" "text" DEFAULT 'active'::"text",
    "priority" "text" DEFAULT 'medium'::"text",
    "description" "text",
    "requirements" "text",
    "salary_range" "text",
    "owner" "text",
    "hiring_manager" "text",
    "created_by" "text",
    "created_date" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "target_date" timestamp with time zone,
    "filled_date" timestamp with time zone,
    "tags" "text"[],
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "id_uuid" "uuid"
);


ALTER TABLE "public"."requisitions" OWNER TO "postgres";


COMMENT ON TABLE "public"."requisitions" IS 'Job requisitions/openings for recruitment';



CREATE OR REPLACE VIEW "public"."requisitions_with_pipeline_stats" AS
 SELECT "r"."id",
    "r"."title",
    "r"."department",
    "r"."location",
    "r"."job_type",
    "r"."openings",
    "r"."status",
    "r"."priority",
    "r"."description",
    "r"."requirements",
    "r"."salary_range",
    "r"."owner",
    "r"."hiring_manager",
    "r"."created_by",
    "r"."created_date",
    "r"."target_date",
    "r"."filled_date",
    "r"."tags",
    "r"."created_at",
    "r"."updated_at",
    "count"("pc"."id_old") AS "total_candidates",
    "count"(
        CASE
            WHEN ("pc"."stage" = 'sourced'::"text") THEN 1
            ELSE NULL::integer
        END) AS "sourced_count",
    "count"(
        CASE
            WHEN ("pc"."stage" = 'screened'::"text") THEN 1
            ELSE NULL::integer
        END) AS "screened_count",
    "count"(
        CASE
            WHEN ("pc"."stage" = 'interview_1'::"text") THEN 1
            ELSE NULL::integer
        END) AS "interview_1_count",
    "count"(
        CASE
            WHEN ("pc"."stage" = 'interview_2'::"text") THEN 1
            ELSE NULL::integer
        END) AS "interview_2_count",
    "count"(
        CASE
            WHEN ("pc"."stage" = 'offer'::"text") THEN 1
            ELSE NULL::integer
        END) AS "offer_count",
    "count"(
        CASE
            WHEN ("pc"."stage" = 'hired'::"text") THEN 1
            ELSE NULL::integer
        END) AS "hired_count"
   FROM ("public"."requisitions" "r"
     LEFT JOIN "public"."pipeline_candidates" "pc" ON (("r"."id_uuid" = "pc"."requisition_id")))
  GROUP BY "r"."id", "r"."title", "r"."department", "r"."location", "r"."job_type", "r"."openings", "r"."status", "r"."priority", "r"."description", "r"."requirements", "r"."salary_range", "r"."owner", "r"."hiring_manager", "r"."created_by", "r"."created_date", "r"."target_date", "r"."filled_date", "r"."tags", "r"."created_at", "r"."updated_at";


ALTER VIEW "public"."requisitions_with_pipeline_stats" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."reset_tokens" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "email" "text" NOT NULL,
    "token" "text" NOT NULL,
    "expires_at" timestamp with time zone NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."reset_tokens" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."role_permissions" (
    "role" character varying(50) NOT NULL,
    "permission_name" character varying(100) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."role_permissions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."roles" (
    "name" character varying(50) NOT NULL,
    "description" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."roles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."saved_jobs" (
    "id_old" integer,
    "student_id_old" "uuid",
    "opportunity_id_old" integer,
    "saved_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "opportunity_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL
);


ALTER TABLE "public"."saved_jobs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."saved_jobs_backup_migration" (
    "id" integer,
    "student_id" "uuid",
    "opportunity_id" integer,
    "saved_at" timestamp with time zone,
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone
);


ALTER TABLE "public"."saved_jobs_backup_migration" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."school_classes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "school_id" "uuid" NOT NULL,
    "name" character varying(100) NOT NULL,
    "grade" character varying(20) NOT NULL,
    "section" character varying(10),
    "academic_year" character varying(20) NOT NULL,
    "max_students" integer DEFAULT 40,
    "current_students" integer DEFAULT 0,
    "account_status" character varying(20) DEFAULT 'active'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "room_no" character varying(50)
);


ALTER TABLE "public"."school_classes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."school_educator_class_assignments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "educator_id" "uuid" NOT NULL,
    "class_id" "uuid" NOT NULL,
    "subject" character varying(100) NOT NULL,
    "academic_year" character varying(20) NOT NULL,
    "is_primary" boolean DEFAULT false,
    "assigned_at" timestamp with time zone DEFAULT "now"(),
    "assigned_by" "uuid"
);


ALTER TABLE "public"."school_educator_class_assignments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."school_educators" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "school_id" "uuid" NOT NULL,
    "employee_id" character varying(50),
    "specialization" character varying(100),
    "qualification" character varying(255),
    "experience_years" integer,
    "date_of_joining" "date",
    "account_status" character varying(20) DEFAULT 'active'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "designation" character varying(100),
    "department" character varying(100),
    "first_name" character varying(100),
    "last_name" character varying(100),
    "email" character varying(255),
    "phone_number" character varying(20),
    "dob" "date",
    "gender" character varying(20),
    "address" "text",
    "city" character varying(100),
    "state" character varying(100),
    "country" character varying(100),
    "pincode" character varying(10),
    "subjects_handled" "text"[],
    "resume_url" "text",
    "id_proof_url" "text",
    "photo_url" "text",
    "verification_status" "public"."user_approval_status",
    "verified_by" "uuid",
    "verified_at" timestamp with time zone,
    "role" character varying(20) DEFAULT 'subject_teacher'::character varying,
    "onboarding_status" character varying(20) DEFAULT 'active'::character varying,
    "degree_certificate_url" "text",
    "experience_letters_url" "text"[],
    "subject_expertise" "jsonb" DEFAULT '[]'::"jsonb",
    "teacher_id" character varying(20),
    CONSTRAINT "school_educators_onboarding_status_check" CHECK ((("onboarding_status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('documents_uploaded'::character varying)::"text", ('verified'::character varying)::"text", ('active'::character varying)::"text", ('inactive'::character varying)::"text"]))),
    CONSTRAINT "school_educators_role_check" CHECK ((("role")::"text" = ANY (ARRAY[('school_admin'::character varying)::"text", ('principal'::character varying)::"text", ('it_admin'::character varying)::"text", ('class_teacher'::character varying)::"text", ('subject_teacher'::character varying)::"text"])))
);


ALTER TABLE "public"."school_educators" OWNER TO "postgres";


COMMENT ON COLUMN "public"."school_educators"."role" IS 'Educator role: school_admin, principal, it_admin, class_teacher, subject_teacher';



COMMENT ON COLUMN "public"."school_educators"."subject_expertise" IS 'JSONB array of subjects with proficiency and experience';



COMMENT ON COLUMN "public"."school_educators"."teacher_id" IS 'Auto-generated unique teacher identifier (e.g., SPR-T-0001)';



CREATE TABLE IF NOT EXISTS "public"."search_history" (
    "id" bigint NOT NULL,
    "student_id" "uuid" NOT NULL,
    "search_term" "text" NOT NULL,
    "search_count" integer DEFAULT 1,
    "last_searched_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."search_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."search_history" IS 'Stores student job search history with search count tracking';



COMMENT ON COLUMN "public"."search_history"."search_term" IS 'The search term entered by the student';



COMMENT ON COLUMN "public"."search_history"."search_count" IS 'Number of times this term has been searched';



COMMENT ON COLUMN "public"."search_history"."last_searched_at" IS 'Timestamp of the most recent search with this term';



CREATE SEQUENCE IF NOT EXISTS "public"."search_history_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."search_history_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."search_history_id_seq" OWNED BY "public"."search_history"."id";



CREATE TABLE IF NOT EXISTS "public"."shortlist_candidates" (
    "id" integer NOT NULL,
    "shortlist_id" "text" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "added_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "added_by" "text",
    "notes" "text"
);


ALTER TABLE "public"."shortlist_candidates" OWNER TO "postgres";


COMMENT ON TABLE "public"."shortlist_candidates" IS 'Junction table linking shortlists to students';



CREATE SEQUENCE IF NOT EXISTS "public"."shortlist_candidates_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."shortlist_candidates_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."shortlist_candidates_id_seq" OWNED BY "public"."shortlist_candidates"."id";



CREATE TABLE IF NOT EXISTS "public"."shortlists" (
    "id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "created_by" "text",
    "created_date" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL,
    "status" "text" DEFAULT 'active'::"text",
    "shared" boolean DEFAULT false,
    "share_link" "text",
    "share_expiry" timestamp with time zone,
    "watermark" boolean DEFAULT false,
    "include_pii" boolean DEFAULT false,
    "notify_on_access" boolean DEFAULT false,
    "tags" "text"[],
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()) NOT NULL
);


ALTER TABLE "public"."shortlists" OWNER TO "postgres";


COMMENT ON TABLE "public"."shortlists" IS 'Shortlists created by recruiters to organize candidates';



CREATE OR REPLACE VIEW "public"."shortlists_with_counts" AS
 SELECT "s"."id",
    "s"."name",
    "s"."description",
    "s"."created_by",
    "s"."created_date",
    "s"."status",
    "s"."shared",
    "s"."share_link",
    "s"."share_expiry",
    "s"."watermark",
    "s"."include_pii",
    "s"."notify_on_access",
    "s"."tags",
    "s"."updated_at",
    "count"("sc"."id") AS "candidate_count"
   FROM ("public"."shortlists" "s"
     LEFT JOIN "public"."shortlist_candidates" "sc" ON (("s"."id" = "sc"."shortlist_id")))
  GROUP BY "s"."id", "s"."name", "s"."description", "s"."created_by", "s"."created_date", "s"."status", "s"."shared", "s"."share_link", "s"."share_expiry", "s"."watermark", "s"."include_pii", "s"."notify_on_access", "s"."tags", "s"."updated_at";


ALTER VIEW "public"."shortlists_with_counts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."skill_assessments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "school_id" "uuid" NOT NULL,
    "assessment_type" "text" NOT NULL,
    "assessment_date" "date" NOT NULL,
    "score" numeric(5,2) NOT NULL,
    "max_score" numeric(5,2) DEFAULT 100,
    "subject" "text",
    "topic" "text",
    "remarks" "text",
    "assessed_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."skill_assessments" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."skill_badges" (
    "badge_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "school_id" "uuid",
    "name" character varying(255) NOT NULL,
    "description" "text",
    "icon" character varying(50),
    "category" character varying(50),
    "level" character varying(20),
    "criteria" "jsonb" DEFAULT '{}'::"jsonb",
    "points_required" integer,
    "auto_award_enabled" boolean DEFAULT false,
    "auto_award_conditions" "jsonb" DEFAULT '{}'::"jsonb",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by_type" character varying(20),
    "created_by_educator_id" "uuid",
    "created_by_admin_id" "uuid",
    CONSTRAINT "check_single_badge_creator" CHECK (((("created_by_educator_id" IS NOT NULL) AND ("created_by_admin_id" IS NULL) AND (("created_by_type")::"text" = 'educator'::"text")) OR (("created_by_educator_id" IS NULL) AND ("created_by_admin_id" IS NOT NULL) AND (("created_by_type")::"text" = 'admin'::"text")))),
    CONSTRAINT "skill_badges_created_by_type_check" CHECK ((("created_by_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('admin'::character varying)::"text"]))),
    CONSTRAINT "skill_badges_level_check" CHECK ((("level")::"text" = ANY (ARRAY[('bronze'::character varying)::"text", ('silver'::character varying)::"text", ('gold'::character varying)::"text", ('platinum'::character varying)::"text"])))
);


ALTER TABLE "public"."skill_badges" OWNER TO "postgres";


COMMENT ON TABLE "public"."skill_badges" IS 'Defines available skill badges with auto-award capability';



CREATE TABLE IF NOT EXISTS "public"."skill_passports" (
    "studentId" "uuid" NOT NULL,
    "status" "text" NOT NULL,
    "aiVerification" boolean DEFAULT false,
    "nsqfLevel" integer,
    "skills" "jsonb" DEFAULT '[]'::"jsonb",
    "createdAt" timestamp with time zone DEFAULT "now"(),
    "updatedAt" timestamp with time zone DEFAULT "now"(),
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "projects" "jsonb" DEFAULT '[]'::"jsonb",
    "certificates" "jsonb" DEFAULT '[]'::"jsonb",
    "assessments" "jsonb" DEFAULT '[]'::"jsonb",
    CONSTRAINT "skill_passports_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'verified'::"text", 'rejected'::"text", 'suspended'::"text"])))
);


ALTER TABLE "public"."skill_passports" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."skill_trends" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "skillName" "text" NOT NULL,
    "category" "text" NOT NULL,
    "demandScore" integer DEFAULT 0,
    "trendDirection" "text",
    "weeklyGrowth" numeric(5,2) DEFAULT 0,
    "monthlyGrowth" numeric(5,2) DEFAULT 0,
    "snapshotDate" "date" DEFAULT CURRENT_DATE NOT NULL,
    "createdAt" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "skill_trends_trendDirection_check" CHECK (("trendDirection" = ANY (ARRAY['rising'::"text", 'stable'::"text", 'declining'::"text"])))
);


ALTER TABLE "public"."skill_trends" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."skill_verification_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "skill_name" "text" NOT NULL,
    "skill_type" "text" NOT NULL,
    "skill_level" integer NOT NULL,
    "skill_icon" "text",
    "skill_category" "text",
    "institution_admin_status" "text" DEFAULT 'pending'::"text",
    "institution_admin_id" "uuid",
    "institution_admin_reviewed_at" timestamp with time zone,
    "institution_admin_notes" "text",
    "rareminds_admin_status" "text" DEFAULT 'pending'::"text",
    "rareminds_admin_id" "uuid",
    "rareminds_admin_reviewed_at" timestamp with time zone,
    "rareminds_admin_notes" "text",
    "overall_status" "text" DEFAULT 'pending'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "skill_verification_requests_institution_admin_status_check" CHECK (("institution_admin_status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"]))),
    CONSTRAINT "skill_verification_requests_rareminds_admin_status_check" CHECK (("rareminds_admin_status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text"]))),
    CONSTRAINT "skill_verification_requests_skill_level_check" CHECK ((("skill_level" >= 1) AND ("skill_level" <= 5))),
    CONSTRAINT "skill_verification_requests_skill_type_check" CHECK (("skill_type" = ANY (ARRAY['technical'::"text", 'soft'::"text"])))
);


ALTER TABLE "public"."skill_verification_requests" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."streak_notification_log" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "notification_type" character varying(20) DEFAULT 'email'::character varying,
    "email_template_number" integer,
    "sent_at" timestamp with time zone DEFAULT "now"(),
    "notification_date" "date" DEFAULT CURRENT_DATE,
    "status" character varying(20) DEFAULT 'sent'::character varying,
    "opened_at" timestamp with time zone,
    "clicked_at" timestamp with time zone,
    "error_message" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "streak_notification_log_email_template_number_check" CHECK ((("email_template_number" >= 1) AND ("email_template_number" <= 4)))
);


ALTER TABLE "public"."streak_notification_log" OWNER TO "postgres";


COMMENT ON TABLE "public"."streak_notification_log" IS 'Logs all streak reminder notifications sent to students';



CREATE TABLE IF NOT EXISTS "public"."stream_recommendation_reports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "academic_year" character varying(20) NOT NULL,
    "current_grade" character varying(10) NOT NULL,
    "subject_marks" "jsonb" DEFAULT '{}'::"jsonb",
    "projects_summary" "jsonb" DEFAULT '[]'::"jsonb",
    "experiences_summary" "jsonb" DEFAULT '[]'::"jsonb",
    "interests" "jsonb" DEFAULT '[]'::"jsonb",
    "hobbies" "jsonb" DEFAULT '[]'::"jsonb",
    "extracurriculars" "jsonb" DEFAULT '[]'::"jsonb",
    "science_score" numeric(5,2),
    "commerce_score" numeric(5,2),
    "arts_score" numeric(5,2),
    "science_breakdown" "jsonb" DEFAULT '{}'::"jsonb",
    "commerce_breakdown" "jsonb" DEFAULT '{}'::"jsonb",
    "arts_breakdown" "jsonb" DEFAULT '{}'::"jsonb",
    "recommended_stream" character varying(20),
    "confidence_level" character varying(20),
    "alternative_stream" character varying(20),
    "ai_analysis" "text",
    "strengths" "jsonb" DEFAULT '[]'::"jsonb",
    "areas_to_improve" "jsonb" DEFAULT '[]'::"jsonb",
    "career_suggestions" "jsonb" DEFAULT '[]'::"jsonb",
    "recommended_subjects" "jsonb" DEFAULT '{}'::"jsonb",
    "ai_model_used" character varying(100),
    "generation_timestamp" timestamp with time zone DEFAULT "now"(),
    "is_latest" boolean DEFAULT true,
    "status" character varying(20) DEFAULT 'generated'::character varying,
    "reviewed_by" "uuid",
    "reviewed_at" timestamp with time zone,
    "reviewer_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."stream_recommendation_reports" OWNER TO "postgres";


COMMENT ON TABLE "public"."stream_recommendation_reports" IS 'AI-generated stream recommendation reports (Science/Commerce/Arts) for students based on marks, projects, experiences, and interests';



COMMENT ON COLUMN "public"."stream_recommendation_reports"."science_score" IS 'AI-calculated suitability score (0-100) for Science stream';



COMMENT ON COLUMN "public"."stream_recommendation_reports"."commerce_score" IS 'AI-calculated suitability score (0-100) for Commerce stream';



COMMENT ON COLUMN "public"."stream_recommendation_reports"."arts_score" IS 'AI-calculated suitability score (0-100) for Arts/Humanities stream';



CREATE OR REPLACE VIEW "public"."student_applications_with_pipeline" AS
 SELECT "s"."id" AS "student_id",
    "s"."name" AS "student_name",
    "s"."email" AS "student_email",
    "o"."id_old" AS "opportunity_id",
    "o"."title" AS "opportunity_title",
    "o"."company_name",
    "o"."requisition_id",
    "pc"."stage",
    "pc"."status",
    "pc"."added_at",
    "pc"."stage_changed_at",
    "pc"."next_action",
    "pc"."next_action_date"
   FROM (("public"."students" "s"
     LEFT JOIN "public"."pipeline_candidates" "pc" ON (("s"."id" = "pc"."student_id")))
     LEFT JOIN "public"."opportunities" "o" ON (("pc"."opportunity_id_old" = "o"."id_old")));


ALTER VIEW "public"."student_applications_with_pipeline" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."student_assignments" (
    "student_assignment_id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "assignment_id" "uuid" NOT NULL,
    "student_id" "uuid" NOT NULL,
    "status" "text" DEFAULT 'todo'::"text" NOT NULL,
    "priority" "text" DEFAULT 'medium'::"text" NOT NULL,
    "grade_received" numeric(7,2),
    "grade_percentage" numeric(5,2),
    "instructor_feedback" "text",
    "feedback_date" timestamp with time zone,
    "graded_by" "uuid",
    "graded_date" timestamp with time zone,
    "submission_date" timestamp with time zone,
    "submission_type" "text",
    "submission_content" "text",
    "submission_url" "text",
    "is_late" boolean DEFAULT false NOT NULL,
    "late_penalty" numeric(5,2),
    "assigned_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "started_date" timestamp with time zone,
    "completed_date" timestamp with time zone,
    "is_deleted" boolean DEFAULT false NOT NULL,
    "updated_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "chk_grade_percentage_range" CHECK ((("grade_percentage" IS NULL) OR (("grade_percentage" >= (0)::numeric) AND ("grade_percentage" <= (100)::numeric)))),
    CONSTRAINT "chk_status_dates" CHECK (((("status" <> 'submitted'::"text") OR ("completed_date" IS NOT NULL)) AND (("status" <> 'graded'::"text") OR ("graded_date" IS NOT NULL)))),
    CONSTRAINT "student_assignments_priority_check" CHECK (("priority" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text"]))),
    CONSTRAINT "student_assignments_status_check" CHECK (("status" = ANY (ARRAY['todo'::"text", 'in-progress'::"text", 'submitted'::"text", 'graded'::"text"]))),
    CONSTRAINT "student_assignments_submission_type_check" CHECK (("submission_type" = ANY (ARRAY['file'::"text", 'text'::"text", 'url'::"text", 'code'::"text", 'other'::"text"])))
);


ALTER TABLE "public"."student_assignments" OWNER TO "postgres";


COMMENT ON TABLE "public"."student_assignments" IS 'Links students to assignments and tracks their individual progress and submissions';



COMMENT ON COLUMN "public"."student_assignments"."status" IS 'Student status: todo, in-progress, submitted, graded, returned';



COMMENT ON COLUMN "public"."student_assignments"."grade_percentage" IS 'Auto-calculated from grade_received and assignment total_points';



COMMENT ON COLUMN "public"."student_assignments"."is_late" IS 'Auto-calculated by comparing submission_date with assignment due_date';



CREATE TABLE IF NOT EXISTS "public"."student_skill_badges" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "badge_id" "uuid" NOT NULL,
    "student_email" character varying(255) NOT NULL,
    "current_points" integer DEFAULT 0,
    "progress_percentage" numeric(5,2) DEFAULT 0,
    "status" character varying(20) DEFAULT 'in_progress'::character varying,
    "earned_at" timestamp with time zone,
    "expires_at" timestamp with time zone,
    "started_at" timestamp with time zone DEFAULT "now"(),
    "achievement_data" "jsonb" DEFAULT '{}'::"jsonb",
    "awarded_by_type" character varying(20),
    "awarded_by_educator_id" "uuid",
    "awarded_by_admin_id" "uuid",
    CONSTRAINT "check_single_badge_awarder" CHECK (((("awarded_by_educator_id" IS NOT NULL) AND ("awarded_by_admin_id" IS NULL) AND (("awarded_by_type")::"text" = 'educator'::"text")) OR (("awarded_by_educator_id" IS NULL) AND ("awarded_by_admin_id" IS NOT NULL) AND (("awarded_by_type")::"text" = 'admin'::"text")) OR (("awarded_by_educator_id" IS NULL) AND ("awarded_by_admin_id" IS NULL) AND (("awarded_by_type")::"text" = 'auto'::"text")))),
    CONSTRAINT "student_skill_badges_awarded_by_type_check" CHECK ((("awarded_by_type")::"text" = ANY (ARRAY[('educator'::character varying)::"text", ('admin'::character varying)::"text", ('auto'::character varying)::"text"]))),
    CONSTRAINT "student_skill_badges_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('in_progress'::character varying)::"text", ('earned'::character varying)::"text", ('expired'::character varying)::"text"])))
);


ALTER TABLE "public"."student_skill_badges" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."student_badges_summary" AS
 SELECT "ssb"."student_email",
    "s"."name" AS "student_name",
    "s"."grade",
    "s"."section",
    "sb"."name" AS "badge_name",
    "sb"."level" AS "badge_level",
    "sb"."category" AS "badge_category",
    "ssb"."status",
    "ssb"."progress_percentage",
    "ssb"."earned_at"
   FROM (("public"."student_skill_badges" "ssb"
     JOIN "public"."skill_badges" "sb" ON (("ssb"."badge_id" = "sb"."badge_id")))
     JOIN "public"."students" "s" ON ((("ssb"."student_email")::"text" = "s"."email")));


ALTER VIEW "public"."student_badges_summary" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."student_course_progress" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "course_id" "uuid" NOT NULL,
    "lesson_id" "uuid" NOT NULL,
    "status" character varying(20) DEFAULT 'not_started'::character varying,
    "time_spent_seconds" integer DEFAULT 0,
    "last_accessed" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "video_position_seconds" integer DEFAULT 0,
    "video_duration_seconds" integer DEFAULT 0,
    "video_completed" boolean DEFAULT false,
    "scroll_position_percent" numeric(5,2) DEFAULT 0,
    "content_completed" boolean DEFAULT false,
    "notes" "text",
    "bookmarked" boolean DEFAULT false,
    CONSTRAINT "student_course_progress_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('not_started'::character varying)::"text", ('in_progress'::character varying)::"text", ('completed'::character varying)::"text"])))
);


ALTER TABLE "public"."student_course_progress" OWNER TO "postgres";


COMMENT ON TABLE "public"."student_course_progress" IS 'Tracks student progress through course lessons for AI tutor context';



COMMENT ON COLUMN "public"."student_course_progress"."status" IS 'Progress status: not_started, in_progress, or completed';



COMMENT ON COLUMN "public"."student_course_progress"."time_spent_seconds" IS 'Total time spent on this lesson in seconds';



COMMENT ON COLUMN "public"."student_course_progress"."video_position_seconds" IS 'Last video playback position in seconds';



COMMENT ON COLUMN "public"."student_course_progress"."video_duration_seconds" IS 'Total video duration for percentage calculation';



COMMENT ON COLUMN "public"."student_course_progress"."video_completed" IS 'True if video watched >= 90%';



COMMENT ON COLUMN "public"."student_course_progress"."scroll_position_percent" IS 'Scroll position in lesson content (0-100)';



COMMENT ON COLUMN "public"."student_course_progress"."content_completed" IS 'True if content fully scrolled/read';



CREATE TABLE IF NOT EXISTS "public"."student_course_recommendations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "course_id" "uuid" NOT NULL,
    "assessment_result_id" "uuid",
    "relevance_score" integer,
    "match_reasons" "jsonb" DEFAULT '[]'::"jsonb",
    "skill_gaps_addressed" "jsonb" DEFAULT '[]'::"jsonb",
    "recommendation_type" character varying(50) DEFAULT 'assessment'::character varying,
    "status" character varying(20) DEFAULT 'active'::character varying,
    "dismissed_at" timestamp with time zone,
    "dismissed_reason" "text",
    "recommended_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "student_course_recommendations_recommendation_type_check" CHECK ((("recommendation_type")::"text" = ANY (ARRAY[('assessment'::character varying)::"text", ('skill_gap'::character varying)::"text", ('career_path'::character varying)::"text", ('manual'::character varying)::"text"]))),
    CONSTRAINT "student_course_recommendations_relevance_score_check" CHECK ((("relevance_score" >= 0) AND ("relevance_score" <= 100))),
    CONSTRAINT "student_course_recommendations_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('active'::character varying)::"text", ('enrolled'::character varying)::"text", ('dismissed'::character varying)::"text", ('completed'::character varying)::"text"])))
);


ALTER TABLE "public"."student_course_recommendations" OWNER TO "postgres";


COMMENT ON TABLE "public"."student_course_recommendations" IS 'Stores RAG-based course recommendations for students based on assessment results';



COMMENT ON COLUMN "public"."student_course_recommendations"."recommendation_type" IS 'Source of recommendation: assessment (from assessment results), skill_gap (from specific skill gap), career_path (from career fit), manual (admin assigned)';



COMMENT ON COLUMN "public"."student_course_recommendations"."status" IS 'Recommendation status: active (shown to student), enrolled (student enrolled), dismissed (student dismissed), completed (course completed)';



CREATE SEQUENCE IF NOT EXISTS "public"."student_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."student_id_seq" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."student_job_matches" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "matches" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "match_count" integer DEFAULT 0 NOT NULL,
    "algorithm_version" character varying(50) DEFAULT 'v1.0'::character varying NOT NULL,
    "student_profile_hash" character varying(64),
    "is_valid" boolean DEFAULT true NOT NULL,
    "invalidation_reason" character varying(255),
    "computed_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "expires_at" timestamp with time zone DEFAULT ("now"() + '24:00:00'::interval) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."student_job_matches" OWNER TO "postgres";


COMMENT ON TABLE "public"."student_job_matches" IS 'Cache table for AI-computed job matches. Automatically invalidated when student data or opportunities change.';



CREATE TABLE IF NOT EXISTS "public"."student_ledgers" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "student_name" "text" NOT NULL,
    "roll_number" "text" NOT NULL,
    "fee_structure_id" "uuid" NOT NULL,
    "fee_head_id" "text" NOT NULL,
    "fee_head_name" "text" NOT NULL,
    "due_amount" numeric(10,2) NOT NULL,
    "paid_amount" numeric(10,2) DEFAULT 0,
    "balance" numeric(10,2) GENERATED ALWAYS AS (("due_amount" - "paid_amount")) STORED,
    "due_date" "date" NOT NULL,
    "installment_number" integer,
    "payment_status" "text" DEFAULT 'pending'::"text",
    "is_overdue" boolean DEFAULT false,
    "late_fee_amount" numeric(10,2) DEFAULT 0,
    "late_fee_waived" boolean DEFAULT false,
    "waiver_amount" numeric(10,2) DEFAULT 0,
    "waiver_reason" "text",
    "waived_by" "uuid",
    "waived_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "student_record_id" "uuid",
    "college_id" "uuid",
    CONSTRAINT "student_ledgers_payment_status_check" CHECK (("payment_status" = ANY (ARRAY['pending'::"text", 'partial'::"text", 'paid'::"text", 'overdue'::"text", 'waived'::"text"]))),
    CONSTRAINT "valid_amounts" CHECK ((("due_amount" >= (0)::numeric) AND ("paid_amount" >= (0)::numeric) AND ("paid_amount" <= "due_amount") AND ("late_fee_amount" >= (0)::numeric) AND ("waiver_amount" >= (0)::numeric) AND ("waiver_amount" <= "due_amount")))
);


ALTER TABLE "public"."student_ledgers" OWNER TO "postgres";


COMMENT ON TABLE "public"."student_ledgers" IS 'Student fee tracking with automatic balance calculation';



COMMENT ON COLUMN "public"."student_ledgers"."student_record_id" IS 'Direct reference to students table - auto-populated via trigger';



COMMENT ON COLUMN "public"."student_ledgers"."college_id" IS 'College reference for multi-college support';



CREATE TABLE IF NOT EXISTS "public"."student_management_records" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "school_id" "uuid" NOT NULL,
    "enrollment_number" "text",
    "class" "text",
    "section" "text",
    "roll_number" "text",
    "admission_date" "date",
    "academic_year" "text",
    "blood_group" "text",
    "allergies" "text"[],
    "chronic_conditions" "text"[],
    "medications" "text"[],
    "emergency_contact" "text",
    "emergency_phone" "text",
    "primary_interest" "text",
    "secondary_interest" "text",
    "career_skills" "text"[],
    "aspirations" "text",
    "total_fee" numeric(10,2),
    "paid_amount" numeric(10,2) DEFAULT 0,
    "pending_amount" numeric(10,2),
    "status" "text" DEFAULT 'active'::"text",
    "photo_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "student_management_records_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'inactive'::"text", 'transferred'::"text", 'graduated'::"text"])))
);


ALTER TABLE "public"."student_management_records" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."student_promotions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "academic_year" character varying(20) NOT NULL,
    "from_grade" character varying(10) NOT NULL,
    "to_grade" character varying(10),
    "school_id" "uuid",
    "college_id" "uuid",
    "overall_percentage" numeric(5,2),
    "overall_grade" character varying(5),
    "overall_grade_point" numeric(4,2),
    "total_marks_obtained" numeric(10,2),
    "total_max_marks" numeric(10,2),
    "is_passed" boolean DEFAULT false NOT NULL,
    "is_promoted" boolean DEFAULT false NOT NULL,
    "is_detained" boolean DEFAULT false,
    "is_compartment" boolean DEFAULT false,
    "compartment_subjects" "jsonb" DEFAULT '[]'::"jsonb",
    "promotion_date" "date",
    "promotion_order_number" character varying(50),
    "promoted_by" "uuid",
    "remarks" "text",
    "attendance_percentage" numeric(5,2),
    "conduct_grade" character varying(10),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."student_promotions" OWNER TO "postgres";


COMMENT ON TABLE "public"."student_promotions" IS 'Tracks student class pass/fail results and promotion to next class for each academic year';



COMMENT ON COLUMN "public"."student_promotions"."from_grade" IS 'The grade/class student was in during this academic year';



COMMENT ON COLUMN "public"."student_promotions"."to_grade" IS 'The grade/class student is promoted to (NULL if not promoted)';



COMMENT ON COLUMN "public"."student_promotions"."is_passed" IS 'Whether student passed the overall class (all subjects combined)';



COMMENT ON COLUMN "public"."student_promotions"."is_promoted" IS 'Whether student was officially promoted to next class';



COMMENT ON COLUMN "public"."student_promotions"."is_compartment" IS 'Whether student has compartment/reappear in some subjects';



CREATE TABLE IF NOT EXISTS "public"."student_quiz_progress" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "course_id" "uuid" NOT NULL,
    "lesson_id" "uuid" NOT NULL,
    "quiz_id" "uuid" NOT NULL,
    "attempt_number" integer DEFAULT 1,
    "answers" "jsonb" DEFAULT '{}'::"jsonb",
    "current_question_index" integer DEFAULT 0,
    "total_questions" integer DEFAULT 0,
    "correct_answers" integer DEFAULT 0,
    "score_percentage" numeric(5,2),
    "passing_score" numeric(5,2) DEFAULT 70.00,
    "passed" boolean DEFAULT false,
    "status" character varying(20) DEFAULT 'in_progress'::character varying,
    "time_limit_seconds" integer,
    "time_spent_seconds" integer DEFAULT 0,
    "started_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "student_quiz_progress_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('not_started'::character varying)::"text", ('in_progress'::character varying)::"text", ('completed'::character varying)::"text", ('abandoned'::character varying)::"text", ('timed_out'::character varying)::"text"])))
);


ALTER TABLE "public"."student_quiz_progress" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."student_reports" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "school_id" "uuid" NOT NULL,
    "report_type" "text" NOT NULL,
    "title" "text" NOT NULL,
    "generated_date" timestamp with time zone DEFAULT "now"(),
    "generated_by" "uuid",
    "academic_year" "text" NOT NULL,
    "term" "text",
    "data" "jsonb" NOT NULL,
    "pdf_url" "text",
    "has_school_logo" boolean DEFAULT true,
    "is_parent_friendly" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "student_reports_report_type_check" CHECK (("report_type" = ANY (ARRAY['attendance'::"text", 'academic'::"text", 'behavioral'::"text", 'skill_assessment'::"text", 'career_readiness'::"text"])))
);


ALTER TABLE "public"."student_reports" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."student_streaks" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "current_streak" integer DEFAULT 0,
    "longest_streak" integer DEFAULT 0,
    "last_activity_date" "date",
    "streak_completed_today" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "student_streaks_current_streak_check" CHECK (("current_streak" >= 0)),
    CONSTRAINT "student_streaks_longest_streak_check" CHECK (("longest_streak" >= 0))
);


ALTER TABLE "public"."student_streaks" OWNER TO "postgres";


COMMENT ON TABLE "public"."student_streaks" IS 'Tracks each student''s learning streak progress';



CREATE TABLE IF NOT EXISTS "public"."subscription_cancellations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "subscription_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "cancellation_reason" character varying(100) NOT NULL,
    "additional_feedback" "text",
    "cancelled_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "access_until" timestamp with time zone,
    "reactivated_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."subscription_cancellations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."subscription_migrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "old_plan_code" character varying(50) NOT NULL,
    "old_subscription_id" "uuid",
    "migrated_feature_keys" "text"[] NOT NULL,
    "original_price" numeric(10,2) NOT NULL,
    "new_price" numeric(10,2) NOT NULL,
    "price_protected_until" timestamp with time zone,
    "migration_date" timestamp with time zone NOT NULL,
    "notification_sent_at" timestamp with time zone,
    "migration_status" character varying(20) DEFAULT 'pending'::character varying,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "subscription_migrations_migration_status_check" CHECK ((("migration_status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('notified'::character varying)::"text", ('completed'::character varying)::"text", ('opted_out'::character varying)::"text"])))
);


ALTER TABLE "public"."subscription_migrations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."subscription_plan_features" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "plan_id" "uuid" NOT NULL,
    "category" "text" NOT NULL,
    "feature_key" "text" NOT NULL,
    "feature_name" "text" NOT NULL,
    "feature_value" "text",
    "is_included" boolean DEFAULT true,
    "is_addon" boolean DEFAULT false,
    "addon_price" integer,
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "addon_price_monthly" numeric(10,2),
    "addon_price_annual" numeric(10,2),
    "addon_description" "text",
    "target_roles" "text"[] DEFAULT '{}'::"text"[],
    "icon_url" "text",
    "sort_order_addon" integer DEFAULT 0,
    CONSTRAINT "subscription_plan_features_category_check" CHECK (("category" = ANY (ARRAY['capacity'::"text", 'branding'::"text", 'content'::"text", 'learning'::"text", 'assessments'::"text", 'certificates'::"text", 'analytics'::"text", 'integrations'::"text", 'security'::"text", 'support'::"text"])))
);


ALTER TABLE "public"."subscription_plan_features" OWNER TO "postgres";


COMMENT ON TABLE "public"."subscription_plan_features" IS 'Normalized features for subscription plans by category';



CREATE TABLE IF NOT EXISTS "public"."subscription_plans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "plan_code" "text" NOT NULL,
    "name" character varying(100) NOT NULL,
    "business_type" "text" NOT NULL,
    "entity_type" "text" NOT NULL,
    "role_type" "text" NOT NULL,
    "price_monthly" integer NOT NULL,
    "price_yearly" integer,
    "currency" character varying(3) DEFAULT 'INR'::character varying,
    "max_users" integer,
    "features" "jsonb" DEFAULT '[]'::"jsonb",
    "description" "text",
    "is_recommended" boolean DEFAULT false,
    "is_active" boolean DEFAULT true,
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "tagline" "text",
    "positioning" "text",
    "color" "text" DEFAULT 'bg-slate-600'::"text",
    "max_admins" integer,
    "storage_limit" "text",
    "ideal_for" "text",
    CONSTRAINT "subscription_plans_business_type_check" CHECK (("business_type" = ANY (ARRAY['b2b'::"text", 'b2c'::"text"]))),
    CONSTRAINT "subscription_plans_entity_type_check" CHECK (("entity_type" = ANY (ARRAY['school'::"text", 'college'::"text", 'university'::"text", 'recruitment'::"text", 'all'::"text"]))),
    CONSTRAINT "subscription_plans_role_type_check" CHECK (("role_type" = ANY (ARRAY['student'::"text", 'educator'::"text", 'admin'::"text", 'recruiter'::"text", 'all'::"text"])))
);


ALTER TABLE "public"."subscription_plans" OWNER TO "postgres";


COMMENT ON TABLE "public"."subscription_plans" IS 'Master table for subscription plan definitions. Supports B2B (institutional) and B2C (individual) pricing models.';



COMMENT ON COLUMN "public"."subscription_plans"."business_type" IS 'b2b = institutional subscriptions, b2c = individual subscriptions';



COMMENT ON COLUMN "public"."subscription_plans"."entity_type" IS 'Target institution type: school, college, university, recruitment, or all';



COMMENT ON COLUMN "public"."subscription_plans"."role_type" IS 'Target user role: student, educator, admin, recruiter, or all';



COMMENT ON COLUMN "public"."subscription_plans"."max_users" IS 'For B2B plans: maximum users/seats included. NULL for B2C individual plans.';



COMMENT ON COLUMN "public"."subscription_plans"."features" IS 'JSONB array of feature strings displayed on pricing page';



CREATE TABLE IF NOT EXISTS "public"."subscriptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "full_name" character varying(255) NOT NULL,
    "email" character varying(255) NOT NULL,
    "phone" character varying(20),
    "plan_type" character varying(50) NOT NULL,
    "plan_amount" numeric(10,2) NOT NULL,
    "billing_cycle" character varying(20) NOT NULL,
    "razorpay_subscription_id" character varying(255),
    "razorpay_customer_id" character varying(255),
    "razorpay_payment_id" character varying(255),
    "razorpay_order_id" character varying(255),
    "status" "public"."subscription_status" DEFAULT 'pending'::"public"."subscription_status" NOT NULL,
    "auto_renew" boolean DEFAULT true,
    "subscription_start_date" timestamp with time zone,
    "subscription_end_date" timestamp with time zone,
    "cancelled_at" timestamp with time zone,
    "last_webhook_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "cancellation_reason" character varying(100),
    "paused_at" timestamp with time zone,
    "paused_until" timestamp with time zone,
    "receipt_url" "text",
    "plan_id" "uuid",
    "organization_id" "uuid",
    "organization_type" "text",
    "purchased_by" "uuid",
    "seat_count" integer DEFAULT 1,
    "is_organization_subscription" boolean DEFAULT false,
    CONSTRAINT "check_end_after_start" CHECK ((("subscription_end_date" IS NULL) OR ("subscription_start_date" IS NULL) OR ("subscription_end_date" > "subscription_start_date"))),
    CONSTRAINT "check_org_subscription_has_org_id" CHECK (((("is_organization_subscription" = true) AND ("organization_id" IS NOT NULL) AND ("organization_type" IS NOT NULL)) OR ("is_organization_subscription" = false))),
    CONSTRAINT "check_org_subscription_seat_count" CHECK (((("is_organization_subscription" = true) AND ("seat_count" > 1)) OR (("is_organization_subscription" = false) AND ("seat_count" = 1)))),
    CONSTRAINT "check_paused_fields_together" CHECK (((("paused_at" IS NULL) AND ("paused_until" IS NULL)) OR (("paused_at" IS NOT NULL) AND ("paused_until" IS NOT NULL)))),
    CONSTRAINT "check_paused_until_valid" CHECK ((("paused_until" IS NULL) OR ("paused_at" IS NULL) OR ("paused_until" > "paused_at"))),
    CONSTRAINT "check_plan_amount_positive" CHECK (("plan_amount" > (0)::numeric)),
    CONSTRAINT "subscriptions_organization_type_check" CHECK (("organization_type" = ANY (ARRAY['school'::"text", 'college'::"text", 'university'::"text", 'company'::"text"]))),
    CONSTRAINT "subscriptions_seat_count_check" CHECK (("seat_count" > 0))
);


ALTER TABLE "public"."subscriptions" OWNER TO "postgres";


COMMENT ON TABLE "public"."subscriptions" IS 'User subscription records with RLS enabled. Access controlled by user_id matching auth.uid().';



COMMENT ON COLUMN "public"."subscriptions"."plan_type" IS 'DEPRECATED: Use plan_id instead. Kept for backward compatibility.';



COMMENT ON COLUMN "public"."subscriptions"."status" IS 'Subscription status: pending, active, cancelled, expired, or paused';



COMMENT ON COLUMN "public"."subscriptions"."receipt_url" IS 'URL to the payment receipt PDF stored in Cloudflare R2';



COMMENT ON COLUMN "public"."subscriptions"."plan_id" IS 'Foreign key reference to subscription_plans.id - the plan definition for this subscription';



COMMENT ON COLUMN "public"."subscriptions"."organization_id" IS 'ID of the organization (school_id, college_id, university_id, or company_id)';



COMMENT ON COLUMN "public"."subscriptions"."organization_type" IS 'Type of organization (school, college, university, company)';



COMMENT ON COLUMN "public"."subscriptions"."purchased_by" IS 'Admin user who purchased the subscription for the organization';



COMMENT ON COLUMN "public"."subscriptions"."seat_count" IS 'Number of seats/licenses purchased (1 for individual, >1 for organization)';



COMMENT ON COLUMN "public"."subscriptions"."is_organization_subscription" IS 'Flag to distinguish organization subscriptions from individual subscriptions';



COMMENT ON CONSTRAINT "check_end_after_start" ON "public"."subscriptions" IS 'Ensures end date is after start date';



COMMENT ON CONSTRAINT "check_paused_fields_together" ON "public"."subscriptions" IS 'Ensures pause fields are set together';



COMMENT ON CONSTRAINT "check_paused_until_valid" ON "public"."subscriptions" IS 'Ensures paused_until is after paused_at';



COMMENT ON CONSTRAINT "check_plan_amount_positive" ON "public"."subscriptions" IS 'Ensures plan amount is positive';



CREATE TABLE IF NOT EXISTS "public"."teacher_journal" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "educator_id" "uuid",
    "lesson_plan_id" "uuid",
    "date" "date" NOT NULL,
    "reflection" "text",
    "student_engagement" character varying(20),
    "objectives_met" boolean DEFAULT false,
    "challenges" "text",
    "improvements" "text",
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"(),
    CONSTRAINT "teacher_journal_student_engagement_check" CHECK ((("student_engagement")::"text" = ANY (ARRAY[('low'::character varying)::"text", ('medium'::character varying)::"text", ('high'::character varying)::"text"])))
);


ALTER TABLE "public"."teacher_journal" OWNER TO "postgres";


COMMENT ON TABLE "public"."teacher_journal" IS 'Teacher reflection journal for approved lesson plans';



CREATE TABLE IF NOT EXISTS "public"."timetable_slots" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "timetable_id" "uuid",
    "educator_id" "uuid",
    "class_id" "uuid",
    "day_of_week" integer NOT NULL,
    "period_number" integer NOT NULL,
    "start_time" time without time zone NOT NULL,
    "end_time" time without time zone NOT NULL,
    "subject_name" character varying(100) NOT NULL,
    "room_number" character varying(20),
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"(),
    CONSTRAINT "timetable_slots_day_of_week_check" CHECK ((("day_of_week" >= 1) AND ("day_of_week" <= 7))),
    CONSTRAINT "timetable_slots_period_number_check" CHECK ((("period_number" >= 1) AND ("period_number" <= 10)))
);


ALTER TABLE "public"."timetable_slots" OWNER TO "postgres";


COMMENT ON TABLE "public"."timetable_slots" IS 'Individual time slots in timetables, linked to school_educators and school_classes';



CREATE TABLE IF NOT EXISTS "public"."timetables" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "school_id" "uuid",
    "academic_year" character varying(20) NOT NULL,
    "term" character varying(20) NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date" NOT NULL,
    "status" character varying(20) DEFAULT 'draft'::character varying,
    "created_at" timestamp without time zone DEFAULT "now"(),
    "updated_at" timestamp without time zone DEFAULT "now"(),
    "created_by" "uuid",
    CONSTRAINT "timetables_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('published'::character varying)::"text", ('archived'::character varying)::"text"])))
);


ALTER TABLE "public"."timetables" OWNER TO "postgres";


COMMENT ON TABLE "public"."timetables" IS 'Academic timetables for schools';



CREATE OR REPLACE VIEW "public"."teacher_weekly_timetable" AS
 SELECT "ts"."id" AS "slot_id",
    "ts"."educator_id",
    "se"."teacher_id" AS "teacher_code",
    ((("se"."first_name")::"text" || ' '::"text") || ("se"."last_name")::"text") AS "teacher_name",
    "ts"."day_of_week",
    "ts"."period_number",
    "ts"."start_time",
    "ts"."end_time",
    "sc"."name" AS "class_name",
    "ts"."subject_name",
    "ts"."room_number",
    "tt"."academic_year",
    "tt"."term",
    "lp"."id" AS "lesson_plan_id",
    "lp"."title" AS "lesson_plan_title",
    "lp"."status" AS "lesson_plan_status",
    "lp"."chapter_name",
    "lp"."teaching_methodology"
   FROM (((("public"."timetable_slots" "ts"
     JOIN "public"."school_educators" "se" ON (("ts"."educator_id" = "se"."id")))
     JOIN "public"."school_classes" "sc" ON (("ts"."class_id" = "sc"."id")))
     JOIN "public"."timetables" "tt" ON (("ts"."timetable_id" = "tt"."id")))
     LEFT JOIN "public"."lesson_plans" "lp" ON ((("lp"."educator_id" = "ts"."educator_id") AND ("lp"."class_id" = "ts"."class_id") AND (("lp"."subject")::"text" = ("ts"."subject_name")::"text") AND (EXTRACT(dow FROM "lp"."date") = ("ts"."day_of_week")::numeric))))
  WHERE (("tt"."status")::"text" = 'published'::"text")
  ORDER BY "ts"."day_of_week", "ts"."period_number";


ALTER VIEW "public"."teacher_weekly_timetable" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."teacher_workload" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "educator_id" "uuid",
    "timetable_id" "uuid",
    "total_periods_per_week" integer DEFAULT 0,
    "max_consecutive_classes" integer DEFAULT 0,
    "last_calculated" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."teacher_workload" OWNER TO "postgres";


COMMENT ON TABLE "public"."teacher_workload" IS 'Tracks educator workload (30 periods/week limit)';



CREATE TABLE IF NOT EXISTS "public"."timetable_conflicts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "timetable_id" "uuid",
    "conflict_type" character varying(50) NOT NULL,
    "educator_id" "uuid",
    "slot_id" "uuid",
    "conflict_details" "jsonb",
    "resolved" boolean DEFAULT false,
    "resolved_at" timestamp without time zone,
    "created_at" timestamp without time zone DEFAULT "now"()
);


ALTER TABLE "public"."timetable_conflicts" OWNER TO "postgres";


COMMENT ON TABLE "public"."timetable_conflicts" IS 'Logs timetable scheduling conflicts';



CREATE TABLE IF NOT EXISTS "public"."training_notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "training_id" "uuid",
    "recipient_type" character varying(20) NOT NULL,
    "school_id" "uuid",
    "message" "text" NOT NULL,
    "is_read" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "experience_id" "uuid",
    "project_id" "uuid",
    "college_id" "uuid",
    CONSTRAINT "training_notifications_recipient_type_check" CHECK ((("recipient_type")::"text" = ANY (ARRAY[('school_admin'::character varying)::"text", ('college_admin'::character varying)::"text", ('rareminds_admin'::character varying)::"text"]))),
    CONSTRAINT "training_notifications_reference_check" CHECK (((("training_id" IS NOT NULL) AND ("experience_id" IS NULL) AND ("project_id" IS NULL)) OR (("training_id" IS NULL) AND ("experience_id" IS NOT NULL) AND ("project_id" IS NULL)) OR (("training_id" IS NULL) AND ("experience_id" IS NULL) AND ("project_id" IS NOT NULL))))
);


ALTER TABLE "public"."training_notifications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."transcript_requests" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "student_name" "text" NOT NULL,
    "roll_number" "text" NOT NULL,
    "request_number" "text" NOT NULL,
    "request_date" "date" DEFAULT CURRENT_DATE NOT NULL,
    "transcript_type" "text" NOT NULL,
    "purpose" "text" NOT NULL,
    "purpose_details" "text",
    "number_of_copies" integer DEFAULT 1,
    "delivery_method" "text" DEFAULT 'collect'::"text",
    "delivery_address" "text",
    "delivery_email" "text",
    "processing_fee" numeric(10,2) DEFAULT 0,
    "courier_charges" numeric(10,2) DEFAULT 0,
    "total_fee" numeric(10,2) DEFAULT 0,
    "fee_paid" boolean DEFAULT false,
    "payment_reference" "text",
    "payment_date" "date",
    "status" "text" DEFAULT 'pending'::"text",
    "processed_by" "uuid",
    "processed_at" timestamp with time zone,
    "ready_date" "date",
    "dispatch_date" "date",
    "delivery_date" "date",
    "transcript_id" "uuid",
    "remarks" "text",
    "rejection_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "transcript_requests_delivery_method_check" CHECK (("delivery_method" = ANY (ARRAY['collect'::"text", 'post'::"text", 'email'::"text", 'courier'::"text"]))),
    CONSTRAINT "transcript_requests_purpose_check" CHECK (("purpose" = ANY (ARRAY['higher_studies'::"text", 'employment'::"text", 'visa'::"text", 'personal'::"text", 'other'::"text"]))),
    CONSTRAINT "transcript_requests_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'ready'::"text", 'dispatched'::"text", 'delivered'::"text", 'rejected'::"text"]))),
    CONSTRAINT "transcript_requests_transcript_type_check" CHECK (("transcript_type" = ANY (ARRAY['provisional'::"text", 'final'::"text", 'consolidated'::"text", 'semester'::"text", 'degree'::"text"]))),
    CONSTRAINT "valid_copies" CHECK (("number_of_copies" > 0))
);


ALTER TABLE "public"."transcript_requests" OWNER TO "postgres";


COMMENT ON TABLE "public"."transcript_requests" IS 'Student transcript requests with delivery tracking';



CREATE TABLE IF NOT EXISTS "public"."transcripts" (
    "id" "uuid" DEFAULT "extensions"."uuid_generate_v4"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "student_name" "text" NOT NULL,
    "roll_number" "text" NOT NULL,
    "program_id" "uuid",
    "program_name" "text" NOT NULL,
    "department_id" "uuid",
    "type" "text" NOT NULL,
    "template_id" "text",
    "academic_year" "text" NOT NULL,
    "semester_from" integer NOT NULL,
    "semester_to" integer NOT NULL,
    "cgpa" numeric(4,2),
    "sgpa" "jsonb",
    "total_credits_earned" integer,
    "total_credits_required" integer,
    "include_qr" boolean DEFAULT true,
    "verification_id" "text",
    "qr_code_url" "text",
    "status" "text" DEFAULT 'draft'::"text",
    "is_published" boolean DEFAULT false,
    "file_url" "text",
    "file_size" integer,
    "generated_at" timestamp with time zone,
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "approval_remarks" "text",
    "issue_date" "date",
    "issue_number" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "student_record_id" "uuid",
    CONSTRAINT "transcripts_check" CHECK (("semester_to" >= "semester_from")),
    CONSTRAINT "transcripts_semester_from_check" CHECK (("semester_from" >= 1)),
    CONSTRAINT "transcripts_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'pending_approval'::"text", 'approved'::"text", 'issued'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "transcripts_type_check" CHECK (("type" = ANY (ARRAY['provisional'::"text", 'final'::"text", 'consolidated'::"text", 'semester'::"text"]))),
    CONSTRAINT "valid_cgpa" CHECK ((("cgpa" IS NULL) OR (("cgpa" >= (0)::numeric) AND ("cgpa" <= (10)::numeric)))),
    CONSTRAINT "valid_credits" CHECK ((("total_credits_earned" IS NULL) OR ("total_credits_required" IS NULL) OR ("total_credits_earned" <= "total_credits_required")))
);


ALTER TABLE "public"."transcripts" OWNER TO "postgres";


COMMENT ON TABLE "public"."transcripts" IS 'Student transcript generation and management with verification';



COMMENT ON COLUMN "public"."transcripts"."student_record_id" IS 'Direct reference to students table - auto-populated via trigger';



CREATE TABLE IF NOT EXISTS "public"."tutor_conversations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "student_id" "uuid" NOT NULL,
    "course_id" "uuid" NOT NULL,
    "lesson_id" "uuid",
    "title" character varying(255),
    "messages" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."tutor_conversations" OWNER TO "postgres";


COMMENT ON TABLE "public"."tutor_conversations" IS 'Stores AI tutor chat conversations for students';



COMMENT ON COLUMN "public"."tutor_conversations"."messages" IS 'JSONB array of message objects with id, role, content, timestamp';



CREATE TABLE IF NOT EXISTS "public"."tutor_feedback" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "conversation_id" "uuid" NOT NULL,
    "message_index" integer NOT NULL,
    "rating" integer,
    "feedback_text" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "tutor_feedback_rating_check" CHECK (("rating" = ANY (ARRAY['-1'::integer, 1])))
);


ALTER TABLE "public"."tutor_feedback" OWNER TO "postgres";


COMMENT ON TABLE "public"."tutor_feedback" IS 'Stores student feedback (thumbs up/down) on AI tutor responses';



COMMENT ON COLUMN "public"."tutor_feedback"."message_index" IS 'Index of the message in the conversation messages array';



COMMENT ON COLUMN "public"."tutor_feedback"."rating" IS 'Rating: 1 for thumbs up, -1 for thumbs down';



CREATE TABLE IF NOT EXISTS "public"."university_courses" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "university_id" "uuid" NOT NULL,
    "name" character varying(255) NOT NULL,
    "code" character varying(50) NOT NULL,
    "duration" integer,
    "course_type" character varying(50),
    "description" "text",
    "approval_status" "public"."approval_status" DEFAULT 'pending'::"public"."approval_status",
    "approved_by" "uuid",
    "approved_at" timestamp with time zone,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "total_students" integer DEFAULT 0,
    "total_batches" integer DEFAULT 0
);


ALTER TABLE "public"."university_courses" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."university_performance" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "universityId" "uuid" NOT NULL,
    "enrollmentCount" integer DEFAULT 0,
    "completionRate" numeric(5,2) DEFAULT 0,
    "verificationRate" numeric(5,2) DEFAULT 0,
    "placementRate" numeric(5,2) DEFAULT 0,
    "avgSalary" numeric(10,2) DEFAULT 0,
    "performanceScore" numeric(5,2) DEFAULT 0,
    "rankPosition" integer,
    "snapshotDate" "date" DEFAULT CURRENT_DATE NOT NULL,
    "createdAt" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."university_performance" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."upcoming_interviews" AS
 SELECT "i"."id",
    "i"."student_id",
    "i"."candidate_name",
    "i"."candidate_email",
    "i"."candidate_phone",
    "i"."job_title",
    "i"."interviewer",
    "i"."interviewer_email",
    "i"."date",
    "i"."duration",
    "i"."status",
    "i"."type",
    "i"."meeting_type",
    "i"."meeting_link",
    "i"."meeting_notes",
    "i"."reminders_sent",
    "i"."completed_date",
    "i"."scorecard",
    "i"."created_by",
    "i"."created_at",
    "i"."updated_at",
    "s"."name" AS "student_name",
    "s"."email" AS "student_email",
    COALESCE("s"."contactNumber", "s"."contact_number") AS "student_phone",
    "s"."branch_field" AS "department",
    COALESCE("s"."university_main", "s"."university") AS "university"
   FROM ("public"."interviews" "i"
     LEFT JOIN "public"."students" "s" ON (("i"."student_id" = "s"."id")))
  WHERE (("i"."date" > "now"()) AND ("i"."status" <> ALL (ARRAY['completed'::"text", 'cancelled'::"text"])))
  ORDER BY "i"."date";


ALTER VIEW "public"."upcoming_interviews" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_categories" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" character varying(100) NOT NULL,
    "description" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_by" "uuid"
);


ALTER TABLE "public"."user_categories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_entitlements" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "feature_key" "text" NOT NULL,
    "bundle_id" "uuid",
    "status" character varying(20) DEFAULT 'active'::character varying NOT NULL,
    "billing_period" character varying(10) NOT NULL,
    "start_date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "end_date" timestamp with time zone NOT NULL,
    "auto_renew" boolean DEFAULT true,
    "price_at_purchase" numeric(10,2) NOT NULL,
    "razorpay_subscription_id" character varying(100),
    "is_grandfathered" boolean DEFAULT false,
    "grandfathered_until" timestamp with time zone,
    "cancelled_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "granted_by_organization" boolean DEFAULT false,
    "organization_subscription_id" "uuid",
    "granted_by" "uuid",
    CONSTRAINT "check_org_entitlement_has_subscription" CHECK (((("granted_by_organization" = true) AND ("organization_subscription_id" IS NOT NULL)) OR ("granted_by_organization" = false))),
    CONSTRAINT "user_entitlements_billing_period_check" CHECK ((("billing_period")::"text" = ANY (ARRAY[('monthly'::character varying)::"text", ('annual'::character varying)::"text"]))),
    CONSTRAINT "user_entitlements_status_check" CHECK ((("status")::"text" = ANY (ARRAY[('active'::character varying)::"text", ('cancelled'::character varying)::"text", ('expired'::character varying)::"text", ('grace_period'::character varying)::"text"])))
);


ALTER TABLE "public"."user_entitlements" OWNER TO "postgres";


COMMENT ON COLUMN "public"."user_entitlements"."granted_by_organization" IS 'Flag indicating if this entitlement was provided by an organization';



COMMENT ON COLUMN "public"."user_entitlements"."organization_subscription_id" IS 'Reference to the organization subscription that granted this entitlement';



COMMENT ON COLUMN "public"."user_entitlements"."granted_by" IS 'Admin user who granted this entitlement on behalf of the organization';



CREATE TABLE IF NOT EXISTS "public"."user_login_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "login_at" timestamp with time zone DEFAULT "now"(),
    "ip_address" "text",
    "user_agent" "text",
    "success" boolean NOT NULL,
    "failure_reason" "text",
    "location_data" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."user_login_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "avatar_url" "text",
    "bio" "text",
    "skills" "text"[],
    "interests" "text"[],
    "social_links" "jsonb" DEFAULT '{}'::"jsonb",
    "preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "additional_contact" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "updated_by" "uuid"
);


ALTER TABLE "public"."user_profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "session_token" "text" NOT NULL,
    "ip_address" "text",
    "user_agent" "text",
    "started_at" timestamp with time zone DEFAULT "now"(),
    "ended_at" timestamp with time zone,
    "is_valid" boolean DEFAULT true,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."user_sessions" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "notification_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "privacy_settings" "jsonb" DEFAULT '{}'::"jsonb",
    "ui_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "communication_preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "updated_by" "uuid"
);


ALTER TABLE "public"."user_settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_state_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "previous_state" character varying(50),
    "new_state" character varying(50) NOT NULL,
    "change_reason" "text",
    "changed_at" timestamp with time zone DEFAULT "now"(),
    "changed_by" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."user_state_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."verifications" (
    "id" "text" DEFAULT ("gen_random_uuid"())::"text" NOT NULL,
    "targetTable" "text" NOT NULL,
    "targetId" "text" NOT NULL,
    "action" "text" NOT NULL,
    "performedBy" "uuid",
    "note" "text",
    "createdAt" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."verifications" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."video_summaries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "lesson_id" "uuid",
    "course_id" "uuid",
    "video_url" "text" NOT NULL,
    "video_type" character varying(50) DEFAULT 'uploaded'::character varying,
    "transcript" "text",
    "transcript_segments" "jsonb" DEFAULT '[]'::"jsonb",
    "summary" "text",
    "key_points" "jsonb" DEFAULT '[]'::"jsonb",
    "chapters" "jsonb" DEFAULT '[]'::"jsonb",
    "topics" "jsonb" DEFAULT '[]'::"jsonb",
    "duration_seconds" integer,
    "language" character varying(10) DEFAULT 'en'::character varying,
    "processing_status" character varying(50) DEFAULT 'pending'::character varying,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "processed_at" timestamp with time zone,
    "sentiment_data" "jsonb" DEFAULT '{}'::"jsonb",
    "speakers" "jsonb" DEFAULT '[]'::"jsonb",
    "deepgram_summary" "text",
    "notable_quotes" "jsonb" DEFAULT '[]'::"jsonb",
    "quiz_questions" "jsonb" DEFAULT '[]'::"jsonb",
    "flashcards" "jsonb" DEFAULT '[]'::"jsonb",
    "srt_content" "text",
    "vtt_content" "text",
    CONSTRAINT "video_summaries_processing_status_check" CHECK ((("processing_status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('processing'::character varying)::"text", ('completed'::character varying)::"text", ('failed'::character varying)::"text"]))),
    CONSTRAINT "video_summaries_video_type_check" CHECK ((("video_type")::"text" = ANY (ARRAY[('youtube'::character varying)::"text", ('uploaded'::character varying)::"text", ('vimeo'::character varying)::"text"])))
);


ALTER TABLE "public"."video_summaries" OWNER TO "postgres";


COMMENT ON COLUMN "public"."video_summaries"."sentiment_data" IS 'Sentiment analysis data from Deepgram (segments with sentiment scores)';



COMMENT ON COLUMN "public"."video_summaries"."speakers" IS 'Speaker diarization data (speaker IDs and their utterances)';



COMMENT ON COLUMN "public"."video_summaries"."deepgram_summary" IS 'Native summary from Deepgram API';



COMMENT ON COLUMN "public"."video_summaries"."notable_quotes" IS 'Notable quotes extracted from the transcript with timestamps';



COMMENT ON COLUMN "public"."video_summaries"."quiz_questions" IS 'AI-generated quiz questions from the content';



COMMENT ON COLUMN "public"."video_summaries"."flashcards" IS 'AI-generated flashcards for learning';



COMMENT ON COLUMN "public"."video_summaries"."srt_content" IS 'SRT subtitle format content';



COMMENT ON COLUMN "public"."video_summaries"."vtt_content" IS 'WebVTT subtitle format content';



ALTER TABLE ONLY "public"."export_activities" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."export_activities_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."interview_reminders" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."interview_reminders_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."messages" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."messages_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."pipeline_activities" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."pipeline_activities_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."search_history" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."search_history_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."shortlist_candidates" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."shortlist_candidates_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."adaptive_aptitude_questions_cache"
    ADD CONSTRAINT "adaptive_aptitude_questions_cache_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."adaptive_aptitude_questions_cache"
    ADD CONSTRAINT "adaptive_aptitude_questions_cache_question_id_key" UNIQUE ("question_id");



ALTER TABLE ONLY "public"."adaptive_aptitude_responses"
    ADD CONSTRAINT "adaptive_aptitude_responses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."adaptive_aptitude_results"
    ADD CONSTRAINT "adaptive_aptitude_results_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."adaptive_aptitude_results"
    ADD CONSTRAINT "adaptive_aptitude_results_session_id_key" UNIQUE ("session_id");



ALTER TABLE ONLY "public"."adaptive_aptitude_sessions"
    ADD CONSTRAINT "adaptive_aptitude_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."addon_discount_codes"
    ADD CONSTRAINT "addon_discount_codes_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."addon_discount_codes"
    ADD CONSTRAINT "addon_discount_codes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."addon_events"
    ADD CONSTRAINT "addon_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."addon_pending_orders"
    ADD CONSTRAINT "addon_pending_orders_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."addon_pending_orders"
    ADD CONSTRAINT "addon_pending_orders_razorpay_order_id_key" UNIQUE ("razorpay_order_id");



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_pkey" PRIMARY KEY ("id", "admin_role");



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_user_id_key" UNIQUE ("id");



ALTER TABLE ONLY "public"."admission_applications"
    ADD CONSTRAINT "admission_applications_application_number_key" UNIQUE ("application_number");



ALTER TABLE ONLY "public"."admission_applications"
    ADD CONSTRAINT "admission_applications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ai_evaluations"
    ADD CONSTRAINT "ai_evaluations_conversation_id_message_id_key" UNIQUE ("conversation_id", "message_id");



ALTER TABLE ONLY "public"."ai_evaluations"
    ADD CONSTRAINT "ai_evaluations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."app_config"
    ADD CONSTRAINT "app_config_pkey" PRIMARY KEY ("key");



ALTER TABLE ONLY "public"."applied_jobs"
    ADD CONSTRAINT "applied_jobs_id_old_unique" UNIQUE ("id_old");



ALTER TABLE ONLY "public"."applied_jobs"
    ADD CONSTRAINT "applied_jobs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."approval_actions"
    ADD CONSTRAINT "approval_actions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."approval_requests"
    ADD CONSTRAINT "approval_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."approval_types"
    ADD CONSTRAINT "approval_types_pkey" PRIMARY KEY ("name");



ALTER TABLE ONLY "public"."approval_workflows"
    ADD CONSTRAINT "approval_workflows_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."personal_assessment_attempts"
    ADD CONSTRAINT "assessment_attempts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."personal_assessment_questions"
    ADD CONSTRAINT "assessment_questions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."personal_assessment_responses"
    ADD CONSTRAINT "assessment_responses_attempt_id_question_id_key" UNIQUE ("attempt_id", "question_id");



ALTER TABLE ONLY "public"."personal_assessment_responses"
    ADD CONSTRAINT "assessment_responses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."personal_assessment_results"
    ADD CONSTRAINT "assessment_results_attempt_id_key" UNIQUE ("attempt_id");



ALTER TABLE ONLY "public"."personal_assessment_results"
    ADD CONSTRAINT "assessment_results_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."personal_assessment_sections"
    ADD CONSTRAINT "assessment_sections_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."personal_assessment_sections"
    ADD CONSTRAINT "assessment_sections_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."personal_assessment_streams"
    ADD CONSTRAINT "assessment_streams_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."assessment_types"
    ADD CONSTRAINT "assessment_types_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."assessments"
    ADD CONSTRAINT "assessments_assessment_code_key" UNIQUE ("assessment_code");



ALTER TABLE ONLY "public"."assessments"
    ADD CONSTRAINT "assessments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."assignment_attachments"
    ADD CONSTRAINT "assignment_attachments_pkey" PRIMARY KEY ("attachment_id");



ALTER TABLE ONLY "public"."assignments"
    ADD CONSTRAINT "assignments_pkey" PRIMARY KEY ("assignment_id");



ALTER TABLE ONLY "public"."attendance_alerts"
    ADD CONSTRAINT "attendance_alerts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."attendance_records"
    ADD CONSTRAINT "attendance_records_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."attendance_records"
    ADD CONSTRAINT "attendance_records_student_date_slot_key" UNIQUE ("student_id", "date", "slot_id");



ALTER TABLE ONLY "public"."audit_logs"
    ADD CONSTRAINT "audit_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."budget_alerts"
    ADD CONSTRAINT "budget_alerts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."budget_revisions"
    ADD CONSTRAINT "budget_revisions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bundle_features"
    ADD CONSTRAINT "bundle_features_bundle_id_feature_key_key" UNIQUE ("bundle_id", "feature_key");



ALTER TABLE ONLY "public"."bundle_features"
    ADD CONSTRAINT "bundle_features_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bundles"
    ADD CONSTRAINT "bundles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."bundles"
    ADD CONSTRAINT "bundles_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."career_ai_conversations"
    ADD CONSTRAINT "career_ai_conversations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."career_assessment_ai_questions"
    ADD CONSTRAINT "career_assessment_ai_questions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."career_assessment_ai_questions"
    ADD CONSTRAINT "career_assessment_ai_questions_student_stream_type_key" UNIQUE ("student_id", "stream_id", "question_type");



ALTER TABLE ONLY "public"."certificates"
    ADD CONSTRAINT "certificates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."class_swap_history"
    ADD CONSTRAINT "class_swap_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."class_swap_requests"
    ADD CONSTRAINT "class_swap_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."club_activities"
    ADD CONSTRAINT "club_activities_pkey" PRIMARY KEY ("activity_id");



ALTER TABLE ONLY "public"."club_attendance"
    ADD CONSTRAINT "club_attendance_pkey" PRIMARY KEY ("attendance_id");



ALTER TABLE ONLY "public"."club_attendance_records"
    ADD CONSTRAINT "club_attendance_records_pkey" PRIMARY KEY ("record_id");



ALTER TABLE ONLY "public"."club_certificates"
    ADD CONSTRAINT "club_certificates_credential_id_key" UNIQUE ("credential_id");



ALTER TABLE ONLY "public"."club_certificates"
    ADD CONSTRAINT "club_certificates_pkey" PRIMARY KEY ("certificate_id");



ALTER TABLE ONLY "public"."club_memberships"
    ADD CONSTRAINT "club_memberships_pkey" PRIMARY KEY ("membership_id");



ALTER TABLE ONLY "public"."clubs"
    ADD CONSTRAINT "clubs_pkey" PRIMARY KEY ("club_id");



ALTER TABLE ONLY "public"."college_assignment_attachments"
    ADD CONSTRAINT "college_assignment_attachments_pkey" PRIMARY KEY ("attachment_id");



ALTER TABLE ONLY "public"."college_assignments"
    ADD CONSTRAINT "college_assignments_pkey" PRIMARY KEY ("assignment_id");



ALTER TABLE ONLY "public"."college_attendance_records"
    ADD CONSTRAINT "college_attendance_records_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_attendance_sessions"
    ADD CONSTRAINT "college_attendance_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_attendance_settings"
    ADD CONSTRAINT "college_attendance_settings_college_id_key" UNIQUE ("college_id");



ALTER TABLE ONLY "public"."college_attendance_settings"
    ADD CONSTRAINT "college_attendance_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_breaks"
    ADD CONSTRAINT "college_breaks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_circulars"
    ADD CONSTRAINT "college_circulars_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_classes"
    ADD CONSTRAINT "college_classes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_course_mappings"
    ADD CONSTRAINT "college_course_mappings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_courses"
    ADD CONSTRAINT "college_courses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_curriculum_outcomes"
    ADD CONSTRAINT "college_curriculum_outcomes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_curriculum_units"
    ADD CONSTRAINT "college_curriculum_units_curriculum_id_order_index_key" UNIQUE ("curriculum_id", "order_index");



ALTER TABLE ONLY "public"."college_curriculum_units"
    ADD CONSTRAINT "college_curriculum_units_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "college_curriculums_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_event_registrations"
    ADD CONSTRAINT "college_event_registrations_event_id_student_id_key" UNIQUE ("event_id", "student_id");



ALTER TABLE ONLY "public"."college_event_registrations"
    ADD CONSTRAINT "college_event_registrations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_events"
    ADD CONSTRAINT "college_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_faculty_class_assignments"
    ADD CONSTRAINT "college_faculty_class_assignm_faculty_id_class_id_subject_n_key" UNIQUE ("faculty_id", "class_id", "subject_name");



ALTER TABLE ONLY "public"."college_faculty_class_assignments"
    ADD CONSTRAINT "college_faculty_class_assignments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_faculty_leave_balances"
    ADD CONSTRAINT "college_faculty_leave_balance_faculty_id_leave_type_id_acad_key" UNIQUE ("faculty_id", "leave_type_id", "academic_year");



ALTER TABLE ONLY "public"."college_faculty_leave_balances"
    ADD CONSTRAINT "college_faculty_leave_balances_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_faculty_leaves"
    ADD CONSTRAINT "college_faculty_leaves_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_faculty_substitutions"
    ADD CONSTRAINT "college_faculty_substitutions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_leave_types"
    ADD CONSTRAINT "college_leave_types_college_id_code_key" UNIQUE ("college_id", "code");



ALTER TABLE ONLY "public"."college_leave_types"
    ADD CONSTRAINT "college_leave_types_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_lecturers"
    ADD CONSTRAINT "college_lecturers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_lecturers"
    ADD CONSTRAINT "college_lecturers_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."college_lesson_plans"
    ADD CONSTRAINT "college_lesson_plans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_mentor_notes"
    ADD CONSTRAINT "college_mentor_notes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_mentor_periods"
    ADD CONSTRAINT "college_mentor_periods_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_mentor_student_allocations"
    ADD CONSTRAINT "college_mentor_student_allocations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_role_module_permissions"
    ADD CONSTRAINT "college_role_module_permissio_role_type_module_id_permissio_key" UNIQUE ("role_type", "module_id", "permission_id");



ALTER TABLE ONLY "public"."college_role_module_permissions"
    ADD CONSTRAINT "college_role_module_permissions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_role_scope_rules"
    ADD CONSTRAINT "college_role_scope_rules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_role_scope_rules"
    ADD CONSTRAINT "college_role_scope_rules_role_type_scope_type_scope_value_key" UNIQUE ("role_type", "scope_type", "scope_value");



ALTER TABLE ONLY "public"."college_setting_modules"
    ADD CONSTRAINT "college_setting_modules_module_name_key" UNIQUE ("module_name");



ALTER TABLE ONLY "public"."college_setting_modules"
    ADD CONSTRAINT "college_setting_modules_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_setting_permissions"
    ADD CONSTRAINT "college_setting_permissions_permission_name_key" UNIQUE ("permission_name");



ALTER TABLE ONLY "public"."college_setting_permissions"
    ADD CONSTRAINT "college_setting_permissions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_student_assignments"
    ADD CONSTRAINT "college_student_assignments_pkey" PRIMARY KEY ("student_assignment_id");



ALTER TABLE ONLY "public"."college_time_periods"
    ADD CONSTRAINT "college_time_periods_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_time_periods"
    ADD CONSTRAINT "college_time_periods_timetable_id_period_number_key" UNIQUE ("timetable_id", "period_number");



ALTER TABLE ONLY "public"."college_timetable_slots"
    ADD CONSTRAINT "college_timetable_slots_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_timetable_slots"
    ADD CONSTRAINT "college_timetable_slots_timetable_id_day_of_week_period_num_key" UNIQUE ("timetable_id", "day_of_week", "period_number", "educator_id");



ALTER TABLE ONLY "public"."college_timetables"
    ADD CONSTRAINT "college_timetables_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."competition_clubs"
    ADD CONSTRAINT "competition_clubs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."competition_registrations"
    ADD CONSTRAINT "competition_registrations_pkey" PRIMARY KEY ("registration_id");



ALTER TABLE ONLY "public"."competition_results"
    ADD CONSTRAINT "competition_results_pkey" PRIMARY KEY ("result_id");



ALTER TABLE ONLY "public"."competitions"
    ADD CONSTRAINT "competitions_pkey" PRIMARY KEY ("comp_id");



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_student_id_recruiter_id_application_id_key" UNIQUE ("student_id", "recruiter_id", "application_id");



ALTER TABLE ONLY "public"."course_classes"
    ADD CONSTRAINT "course_classes_pkey" PRIMARY KEY ("course_class_id");



ALTER TABLE ONLY "public"."course_co_educators"
    ADD CONSTRAINT "course_co_educators_pkey" PRIMARY KEY ("co_educator_id");



ALTER TABLE ONLY "public"."course_enrollments"
    ADD CONSTRAINT "course_enrollments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."course_enrollments"
    ADD CONSTRAINT "course_enrollments_student_id_course_id_key" UNIQUE ("student_id", "course_id");



ALTER TABLE ONLY "public"."course_modules"
    ADD CONSTRAINT "course_modules_pkey" PRIMARY KEY ("module_id");



ALTER TABLE ONLY "public"."course_skills"
    ADD CONSTRAINT "course_skills_pkey" PRIMARY KEY ("course_skill_id");



ALTER TABLE ONLY "public"."courses"
    ADD CONSTRAINT "courses_code_key" UNIQUE ("code");



ALTER TABLE ONLY "public"."courses"
    ADD CONSTRAINT "courses_pkey" PRIMARY KEY ("course_id");



ALTER TABLE ONLY "public"."curriculum_academic_years"
    ADD CONSTRAINT "curriculum_academic_years_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."curriculum_academic_years"
    ADD CONSTRAINT "curriculum_academic_years_school_id_year_key" UNIQUE ("school_id", "year");



ALTER TABLE ONLY "public"."curriculum_chapters"
    ADD CONSTRAINT "curriculum_chapters_curriculum_id_order_number_key" UNIQUE ("curriculum_id", "order_number");



ALTER TABLE ONLY "public"."curriculum_chapters"
    ADD CONSTRAINT "curriculum_chapters_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."curriculum_classes"
    ADD CONSTRAINT "curriculum_classes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."curriculum_classes"
    ADD CONSTRAINT "curriculum_classes_school_id_name_key" UNIQUE ("school_id", "name");



ALTER TABLE ONLY "public"."curriculum_courses"
    ADD CONSTRAINT "curriculum_courses_college_id_course_code_semester_key" UNIQUE ("college_id", "course_code", "semester");



ALTER TABLE ONLY "public"."curriculum_courses"
    ADD CONSTRAINT "curriculum_courses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."curriculum_learning_outcomes"
    ADD CONSTRAINT "curriculum_learning_outcomes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."curriculum_subjects"
    ADD CONSTRAINT "curriculum_subjects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."curriculum_subjects"
    ADD CONSTRAINT "curriculum_subjects_school_id_name_key" UNIQUE ("school_id", "name");



ALTER TABLE ONLY "public"."curriculums"
    ADD CONSTRAINT "curriculums_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."curriculums"
    ADD CONSTRAINT "curriculums_school_id_subject_class_academic_year_key" UNIQUE ("school_id", "subject", "class", "academic_year");



ALTER TABLE ONLY "public"."department_budgets"
    ADD CONSTRAINT "department_budgets_department_id_financial_year_quarter_key" UNIQUE ("department_id", "financial_year", "quarter");



ALTER TABLE ONLY "public"."department_budgets"
    ADD CONSTRAINT "department_budgets_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."department_faculty_assignments"
    ADD CONSTRAINT "department_faculty_assignments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."department_faculty_assignments"
    ADD CONSTRAINT "department_faculty_assignments_single_hod" EXCLUDE USING "btree" ("department_id" WITH =) WHERE ((("is_hod" = true) AND ("is_active" = true)));



ALTER TABLE ONLY "public"."department_faculty_assignments"
    ADD CONSTRAINT "department_faculty_assignments_unique_lecturer_dept" UNIQUE ("department_id", "lecturer_id");



ALTER TABLE ONLY "public"."departments"
    ADD CONSTRAINT "departments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."document_access_history"
    ADD CONSTRAINT "document_access_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."education"
    ADD CONSTRAINT "education_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."embedding_cache"
    ADD CONSTRAINT "embedding_cache_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."embedding_queue"
    ADD CONSTRAINT "embedding_queue_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."embedding_queue"
    ADD CONSTRAINT "embedding_queue_record_status_unique" UNIQUE ("record_id", "table_name", "status");



ALTER TABLE ONLY "public"."event_registrations"
    ADD CONSTRAINT "event_registrations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exam_registrations"
    ADD CONSTRAINT "exam_registrations_exam_window_id_student_id_assessment_id_key" UNIQUE ("exam_window_id", "student_id", "assessment_id");



ALTER TABLE ONLY "public"."exam_registrations"
    ADD CONSTRAINT "exam_registrations_hall_ticket_number_key" UNIQUE ("hall_ticket_number");



ALTER TABLE ONLY "public"."exam_registrations"
    ADD CONSTRAINT "exam_registrations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exam_registrations"
    ADD CONSTRAINT "exam_registrations_registration_number_key" UNIQUE ("registration_number");



ALTER TABLE ONLY "public"."exam_rooms"
    ADD CONSTRAINT "exam_rooms_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exam_rooms"
    ADD CONSTRAINT "exam_rooms_room_code_key" UNIQUE ("room_code");



ALTER TABLE ONLY "public"."exam_seating_arrangements"
    ADD CONSTRAINT "exam_seating_arrangements_exam_timetable_id_exam_room_id_se_key" UNIQUE ("exam_timetable_id", "exam_room_id", "seat_number");



ALTER TABLE ONLY "public"."exam_seating_arrangements"
    ADD CONSTRAINT "exam_seating_arrangements_exam_timetable_id_student_id_key" UNIQUE ("exam_timetable_id", "student_id");



ALTER TABLE ONLY "public"."exam_seating_arrangements"
    ADD CONSTRAINT "exam_seating_arrangements_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exam_timetable"
    ADD CONSTRAINT "exam_timetable_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exam_windows"
    ADD CONSTRAINT "exam_windows_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."exam_windows"
    ADD CONSTRAINT "exam_windows_window_code_key" UNIQUE ("window_code");



ALTER TABLE ONLY "public"."expenditures"
    ADD CONSTRAINT "expenditures_expenditure_number_key" UNIQUE ("expenditure_number");



ALTER TABLE ONLY "public"."expenditures"
    ADD CONSTRAINT "expenditures_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."experience"
    ADD CONSTRAINT "experience_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."export_activities"
    ADD CONSTRAINT "export_activities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."external_assessment_attempts"
    ADD CONSTRAINT "external_assessment_attempts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."external_courses"
    ADD CONSTRAINT "external_courses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."fee_payments"
    ADD CONSTRAINT "fee_payments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."fee_payments"
    ADD CONSTRAINT "fee_payments_receipt_number_key" UNIQUE ("receipt_number");



ALTER TABLE ONLY "public"."fee_structures"
    ADD CONSTRAINT "fee_structures_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."fee_structures"
    ADD CONSTRAINT "fee_structures_program_id_semester_category_academic_year_key" UNIQUE ("program_id", "semester", "category", "academic_year");



ALTER TABLE ONLY "public"."generated_external_assessment"
    ADD CONSTRAINT "generated_external_assessment_certificate_name_key" UNIQUE ("certificate_name");



ALTER TABLE ONLY "public"."generated_external_assessment"
    ADD CONSTRAINT "generated_external_assessment_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."grading_systems"
    ADD CONSTRAINT "grading_systems_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."grading_systems"
    ADD CONSTRAINT "grading_systems_system_code_grade_label_key" UNIQUE ("system_code", "grade_label");



ALTER TABLE ONLY "public"."grading_systems"
    ADD CONSTRAINT "grading_systems_system_code_key" UNIQUE ("system_code");



ALTER TABLE ONLY "public"."institution_pricing_tiers"
    ADD CONSTRAINT "institution_pricing_tiers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."internships"
    ADD CONSTRAINT "internships_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."interview_reminders"
    ADD CONSTRAINT "interview_reminders_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."interviews"
    ADD CONSTRAINT "interviews_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invigilator_assignments"
    ADD CONSTRAINT "invigilator_assignments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."lesson_plans"
    ADD CONSTRAINT "lesson_plans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."lesson_resources"
    ADD CONSTRAINT "lesson_resources_pkey" PRIMARY KEY ("resource_id");



ALTER TABLE ONLY "public"."lessons"
    ADD CONSTRAINT "lessons_pkey" PRIMARY KEY ("lesson_id");



ALTER TABLE ONLY "public"."library_book_issues_college"
    ADD CONSTRAINT "library_book_issues_college_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_book_issues"
    ADD CONSTRAINT "library_book_issues_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_book_issues_school"
    ADD CONSTRAINT "library_book_issues_school_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_books"
    ADD CONSTRAINT "library_books_book_id_key" UNIQUE ("book_id");



ALTER TABLE ONLY "public"."library_books_college"
    ADD CONSTRAINT "library_books_college_college_id_isbn_key" UNIQUE ("college_id", "isbn");



ALTER TABLE ONLY "public"."library_books_college"
    ADD CONSTRAINT "library_books_college_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_books"
    ADD CONSTRAINT "library_books_isbn_key" UNIQUE ("isbn");



ALTER TABLE ONLY "public"."library_books"
    ADD CONSTRAINT "library_books_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_books_school"
    ADD CONSTRAINT "library_books_school_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_categories_college"
    ADD CONSTRAINT "library_categories_college_college_id_name_key" UNIQUE ("college_id", "name");



ALTER TABLE ONLY "public"."library_categories_college"
    ADD CONSTRAINT "library_categories_college_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_categories"
    ADD CONSTRAINT "library_categories_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."library_categories"
    ADD CONSTRAINT "library_categories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_categories_school"
    ADD CONSTRAINT "library_categories_school_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_history"
    ADD CONSTRAINT "library_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_issued_books"
    ADD CONSTRAINT "library_issued_books_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_reservations"
    ADD CONSTRAINT "library_reservations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_reviews"
    ADD CONSTRAINT "library_reviews_book_id_student_id_key" UNIQUE ("book_id", "student_id");



ALTER TABLE ONLY "public"."library_reviews"
    ADD CONSTRAINT "library_reviews_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_settings_college"
    ADD CONSTRAINT "library_settings_college_college_id_setting_key_key" UNIQUE ("college_id", "setting_key");



ALTER TABLE ONLY "public"."library_settings_college"
    ADD CONSTRAINT "library_settings_college_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_settings"
    ADD CONSTRAINT "library_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_settings_school"
    ADD CONSTRAINT "library_settings_school_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."library_settings"
    ADD CONSTRAINT "library_settings_setting_key_key" UNIQUE ("setting_key");



ALTER TABLE ONLY "public"."license_assignments"
    ADD CONSTRAINT "license_assignments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."license_pools"
    ADD CONSTRAINT "license_pools_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mark_entries"
    ADD CONSTRAINT "mark_entries_assessment_student_subject_key" UNIQUE ("assessment_id", "student_id", "subject_id");



COMMENT ON CONSTRAINT "mark_entries_assessment_student_subject_key" ON "public"."mark_entries" IS 'Ensures one mark entry per student per subject per assessment';



ALTER TABLE ONLY "public"."mark_entries"
    ADD CONSTRAINT "mark_entries_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mark_entry_batches"
    ADD CONSTRAINT "mark_entry_batches_batch_number_key" UNIQUE ("batch_number");



ALTER TABLE ONLY "public"."mark_entry_batches"
    ADD CONSTRAINT "mark_entry_batches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mark_moderation_log"
    ADD CONSTRAINT "mark_moderation_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mentor_notes"
    ADD CONSTRAINT "mentor_notes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."metrics_snapshots"
    ADD CONSTRAINT "metrics_snapshots_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."offers"
    ADD CONSTRAINT "offers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."opportunities_duplicate"
    ADD CONSTRAINT "opportunities_duplicate_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."opportunities"
    ADD CONSTRAINT "opportunities_id_old_unique" UNIQUE ("id_old");



ALTER TABLE ONLY "public"."opportunities"
    ADD CONSTRAINT "opportunities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."opportunity_interactions"
    ADD CONSTRAINT "opportunity_interactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."opportunity_interactions"
    ADD CONSTRAINT "opportunity_interactions_student_id_opportunity_id_action_key" UNIQUE ("student_id", "opportunity_id", "action");



ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "organization_invitations_invitation_token_key" UNIQUE ("invitation_token");



ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "organization_invitations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."organization_subscriptions"
    ADD CONSTRAINT "organization_subscriptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."organizations"
    ADD CONSTRAINT "organizations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."otp_requests_log"
    ADD CONSTRAINT "otp_requests_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."outcome_assessment_mappings"
    ADD CONSTRAINT "outcome_assessment_mappings_learning_outcome_id_assessment__key" UNIQUE ("learning_outcome_id", "assessment_type_id");



ALTER TABLE ONLY "public"."outcome_assessment_mappings"
    ADD CONSTRAINT "outcome_assessment_mappings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_razorpay_payment_id_key" UNIQUE ("razorpay_payment_id");



ALTER TABLE ONLY "public"."permissions"
    ADD CONSTRAINT "permissions_pkey" PRIMARY KEY ("name");



ALTER TABLE ONLY "public"."personal_assessment_response_scales"
    ADD CONSTRAINT "personal_assessment_response_scales_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."personal_assessment_response_scales"
    ADD CONSTRAINT "personal_assessment_response_scales_section_id_scale_name_key" UNIQUE ("section_id", "scale_name");



ALTER TABLE ONLY "public"."personal_assessment_restrictions"
    ADD CONSTRAINT "personal_assessment_restrictions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."personal_assessment_restrictions"
    ADD CONSTRAINT "personal_assessment_restrictions_student_id_grade_level_key" UNIQUE ("student_id", "grade_level");



ALTER TABLE ONLY "public"."phone_otps"
    ADD CONSTRAINT "phone_otps_phone_key" UNIQUE ("phone");



ALTER TABLE ONLY "public"."phone_otps"
    ADD CONSTRAINT "phone_otps_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pipeline_activities"
    ADD CONSTRAINT "pipeline_activities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pipeline_candidates"
    ADD CONSTRAINT "pipeline_candidates_opportunity_id_student_id_key" UNIQUE ("opportunity_id", "student_id");



ALTER TABLE ONLY "public"."pipeline_candidates"
    ADD CONSTRAINT "pipeline_candidates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."placements"
    ADD CONSTRAINT "placements_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pre_registration_email_tracking"
    ADD CONSTRAINT "pre_registration_email_tracking_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pre_registrations"
    ADD CONSTRAINT "pre_registrations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profile_views"
    ADD CONSTRAINT "profile_views_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."program_sections"
    ADD CONSTRAINT "program_sections_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."program_sections"
    ADD CONSTRAINT "program_sections_program_id_semester_section_academic_year_key" UNIQUE ("program_id", "semester", "section", "academic_year");



ALTER TABLE ONLY "public"."programs"
    ADD CONSTRAINT "programs_department_id_code_key" UNIQUE ("department_id", "code");



ALTER TABLE ONLY "public"."programs"
    ADD CONSTRAINT "programs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."promotional_events"
    ADD CONSTRAINT "promotional_events_event_code_key" UNIQUE ("event_code");



ALTER TABLE ONLY "public"."promotional_events"
    ADD CONSTRAINT "promotional_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."quizzes"
    ADD CONSTRAINT "quizzes_pkey" PRIMARY KEY ("quiz_id");



ALTER TABLE ONLY "public"."razorpay_orders"
    ADD CONSTRAINT "razorpay_orders_order_id_key" UNIQUE ("order_id");



ALTER TABLE ONLY "public"."razorpay_orders"
    ADD CONSTRAINT "razorpay_orders_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."recent_updates"
    ADD CONSTRAINT "recent_updates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."recruiter_activities"
    ADD CONSTRAINT "recruiter_activities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."recruiter_saved_searches"
    ADD CONSTRAINT "recruiter_saved_searches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."recruiters"
    ADD CONSTRAINT "recruiters_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."recruiters"
    ADD CONSTRAINT "recruiters_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."requisitions"
    ADD CONSTRAINT "requisitions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."reset_tokens"
    ADD CONSTRAINT "reset_tokens_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."role_permissions"
    ADD CONSTRAINT "role_permissions_pkey" PRIMARY KEY ("role", "permission_name");



ALTER TABLE ONLY "public"."roles"
    ADD CONSTRAINT "roles_pkey" PRIMARY KEY ("name");



ALTER TABLE ONLY "public"."saved_jobs"
    ADD CONSTRAINT "saved_jobs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."school_classes"
    ADD CONSTRAINT "school_classes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."school_classes"
    ADD CONSTRAINT "school_classes_school_id_name_academic_year_key" UNIQUE ("school_id", "name", "academic_year");



ALTER TABLE ONLY "public"."school_educator_class_assignments"
    ADD CONSTRAINT "school_educator_class_assignm_educator_id_class_id_subject__key" UNIQUE ("educator_id", "class_id", "subject", "academic_year");



ALTER TABLE ONLY "public"."school_educator_class_assignments"
    ADD CONSTRAINT "school_educator_class_assignments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."school_educators"
    ADD CONSTRAINT "school_educators_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."school_educators"
    ADD CONSTRAINT "school_educators_school_id_employee_id_key" UNIQUE ("school_id", "employee_id");



ALTER TABLE ONLY "public"."school_educators"
    ADD CONSTRAINT "school_educators_teacher_id_key" UNIQUE ("teacher_id");



ALTER TABLE ONLY "public"."school_educators"
    ADD CONSTRAINT "school_educators_user_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."search_history"
    ADD CONSTRAINT "search_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."search_history"
    ADD CONSTRAINT "search_history_student_id_search_term_key" UNIQUE ("student_id", "search_term");



ALTER TABLE ONLY "public"."shortlist_candidates"
    ADD CONSTRAINT "shortlist_candidates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."shortlist_candidates"
    ADD CONSTRAINT "shortlist_candidates_shortlist_id_student_id_key" UNIQUE ("shortlist_id", "student_id");



ALTER TABLE ONLY "public"."shortlists"
    ADD CONSTRAINT "shortlists_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."skill_assessments"
    ADD CONSTRAINT "skill_assessments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."skill_badges"
    ADD CONSTRAINT "skill_badges_pkey" PRIMARY KEY ("badge_id");



ALTER TABLE ONLY "public"."skill_passports"
    ADD CONSTRAINT "skill_passports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."skill_passports"
    ADD CONSTRAINT "skill_passports_studentId_key" UNIQUE ("studentId");



ALTER TABLE ONLY "public"."skill_trends"
    ADD CONSTRAINT "skill_trends_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."skill_verification_requests"
    ADD CONSTRAINT "skill_verification_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."skills"
    ADD CONSTRAINT "skills_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."streak_notification_log"
    ADD CONSTRAINT "streak_notification_log_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."stream_recommendation_reports"
    ADD CONSTRAINT "stream_recommendation_reports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_assignments"
    ADD CONSTRAINT "student_assignments_pkey" PRIMARY KEY ("student_assignment_id");



ALTER TABLE ONLY "public"."student_course_progress"
    ADD CONSTRAINT "student_course_progress_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_course_progress"
    ADD CONSTRAINT "student_course_progress_student_id_course_id_lesson_id_key" UNIQUE ("student_id", "course_id", "lesson_id");



ALTER TABLE ONLY "public"."student_course_recommendations"
    ADD CONSTRAINT "student_course_recommendation_student_id_course_id_assessme_key" UNIQUE ("student_id", "course_id", "assessment_result_id");



ALTER TABLE ONLY "public"."student_course_recommendations"
    ADD CONSTRAINT "student_course_recommendations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_enrollments"
    ADD CONSTRAINT "student_enrollments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_enrollments"
    ADD CONSTRAINT "student_enrollments_student_id_program_id_academic_year_key" UNIQUE ("student_id", "program_id", "academic_year");



ALTER TABLE ONLY "public"."student_job_matches"
    ADD CONSTRAINT "student_job_matches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_ledgers"
    ADD CONSTRAINT "student_ledgers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_management_records"
    ADD CONSTRAINT "student_management_records_enrollment_number_key" UNIQUE ("enrollment_number");



ALTER TABLE ONLY "public"."student_management_records"
    ADD CONSTRAINT "student_management_records_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_management_records"
    ADD CONSTRAINT "student_management_records_student_id_school_id_key" UNIQUE ("student_id", "school_id");



ALTER TABLE ONLY "public"."student_promotions"
    ADD CONSTRAINT "student_promotions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_quiz_progress"
    ADD CONSTRAINT "student_quiz_progress_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_quiz_progress"
    ADD CONSTRAINT "student_quiz_progress_student_id_course_id_lesson_id_quiz_i_key" UNIQUE ("student_id", "course_id", "lesson_id", "quiz_id", "attempt_number");



ALTER TABLE ONLY "public"."student_reports"
    ADD CONSTRAINT "student_reports_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_skill_badges"
    ADD CONSTRAINT "student_skill_badges_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_streaks"
    ADD CONSTRAINT "student_streaks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_streaks"
    ADD CONSTRAINT "student_streaks_student_id_key" UNIQUE ("student_id");



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_student_id_key" UNIQUE ("student_id");



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."subscription_cancellations"
    ADD CONSTRAINT "subscription_cancellations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscription_migrations"
    ADD CONSTRAINT "subscription_migrations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscription_plan_features"
    ADD CONSTRAINT "subscription_plan_features_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscription_plan_features"
    ADD CONSTRAINT "subscription_plan_features_unique" UNIQUE ("plan_id", "category", "feature_key");



ALTER TABLE ONLY "public"."subscription_plans"
    ADD CONSTRAINT "subscription_plans_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscription_plans"
    ADD CONSTRAINT "subscription_plans_plan_code_business_type_entity_type_role_key" UNIQUE ("plan_code", "business_type", "entity_type", "role_type");



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_razorpay_subscription_id_key" UNIQUE ("razorpay_subscription_id");



ALTER TABLE ONLY "public"."teacher_journal"
    ADD CONSTRAINT "teacher_journal_educator_id_lesson_plan_id_date_key" UNIQUE ("educator_id", "lesson_plan_id", "date");



ALTER TABLE ONLY "public"."teacher_journal"
    ADD CONSTRAINT "teacher_journal_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."teacher_workload"
    ADD CONSTRAINT "teacher_workload_educator_id_timetable_id_key" UNIQUE ("educator_id", "timetable_id");



ALTER TABLE ONLY "public"."teacher_workload"
    ADD CONSTRAINT "teacher_workload_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."timetable_conflicts"
    ADD CONSTRAINT "timetable_conflicts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."timetable_slots"
    ADD CONSTRAINT "timetable_slots_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."timetable_slots"
    ADD CONSTRAINT "timetable_slots_timetable_id_day_of_week_period_number_educ_key" UNIQUE ("timetable_id", "day_of_week", "period_number", "educator_id");



ALTER TABLE ONLY "public"."timetables"
    ADD CONSTRAINT "timetables_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."training_notifications"
    ADD CONSTRAINT "training_notifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."trainings"
    ADD CONSTRAINT "trainings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."transcript_requests"
    ADD CONSTRAINT "transcript_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."transcript_requests"
    ADD CONSTRAINT "transcript_requests_request_number_key" UNIQUE ("request_number");



ALTER TABLE ONLY "public"."transcripts"
    ADD CONSTRAINT "transcripts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."transcripts"
    ADD CONSTRAINT "transcripts_verification_id_key" UNIQUE ("verification_id");



ALTER TABLE ONLY "public"."tutor_conversations"
    ADD CONSTRAINT "tutor_conversations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tutor_feedback"
    ADD CONSTRAINT "tutor_feedback_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."applied_jobs"
    ADD CONSTRAINT "unique_application" UNIQUE ("student_id", "opportunity_id");



ALTER TABLE ONLY "public"."skill_badges"
    ADD CONSTRAINT "unique_badge_name" UNIQUE ("school_id", "name", "level");



ALTER TABLE ONLY "public"."library_categories_school"
    ADD CONSTRAINT "unique_category_per_school" UNIQUE ("school_id", "name");



ALTER TABLE ONLY "public"."clubs"
    ADD CONSTRAINT "unique_club_name_per_school" UNIQUE ("school_id", "name");



ALTER TABLE ONLY "public"."club_attendance"
    ADD CONSTRAINT "unique_club_session" UNIQUE ("club_id", "session_date");



ALTER TABLE ONLY "public"."course_co_educators"
    ADD CONSTRAINT "unique_co_educator" UNIQUE ("course_id", "educator_id");



ALTER TABLE ONLY "public"."college_timetables"
    ADD CONSTRAINT "unique_college_academic_year" UNIQUE ("college_id", "academic_year");



ALTER TABLE ONLY "public"."competition_clubs"
    ADD CONSTRAINT "unique_comp_club" UNIQUE ("comp_id", "club_id");



ALTER TABLE ONLY "public"."course_classes"
    ADD CONSTRAINT "unique_course_class" UNIQUE ("course_id", "class_name");



ALTER TABLE ONLY "public"."college_courses"
    ADD CONSTRAINT "unique_course_code_per_college" UNIQUE ("college_id", "course_code");



ALTER TABLE ONLY "public"."college_course_mappings"
    ADD CONSTRAINT "unique_course_program_semester" UNIQUE ("course_id", "program_id", "semester");



ALTER TABLE ONLY "public"."course_skills"
    ADD CONSTRAINT "unique_course_skill" UNIQUE ("course_id", "skill_name");



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "unique_curriculum_per_course_year" UNIQUE ("course_id", "academic_year", "program_id");



ALTER TABLE ONLY "public"."library_books_school"
    ADD CONSTRAINT "unique_isbn_per_school" UNIQUE ("school_id", "isbn");



ALTER TABLE ONLY "public"."saved_jobs"
    ADD CONSTRAINT "unique_saved_job" UNIQUE ("student_id", "opportunity_id");



ALTER TABLE ONLY "public"."adaptive_aptitude_responses"
    ADD CONSTRAINT "unique_sequence_per_session" UNIQUE ("session_id", "sequence_number");



ALTER TABLE ONLY "public"."library_settings_school"
    ADD CONSTRAINT "unique_setting_per_school" UNIQUE ("school_id", "setting_key");



ALTER TABLE ONLY "public"."student_promotions"
    ADD CONSTRAINT "unique_student_academic_year" UNIQUE ("student_id", "academic_year");



ALTER TABLE ONLY "public"."student_skill_badges"
    ADD CONSTRAINT "unique_student_badge" UNIQUE ("badge_id", "student_email");



ALTER TABLE ONLY "public"."club_memberships"
    ADD CONSTRAINT "unique_student_club" UNIQUE ("club_id", "student_email");



ALTER TABLE ONLY "public"."competition_results"
    ADD CONSTRAINT "unique_student_comp_result" UNIQUE ("comp_id", "student_email", "category");



ALTER TABLE ONLY "public"."competition_registrations"
    ADD CONSTRAINT "unique_student_competition" UNIQUE ("comp_id", "student_email");



ALTER TABLE ONLY "public"."recent_updates"
    ADD CONSTRAINT "unique_student_id" UNIQUE ("student_id");



ALTER TABLE ONLY "public"."student_job_matches"
    ADD CONSTRAINT "unique_student_job_matches" UNIQUE ("student_id");



ALTER TABLE ONLY "public"."club_attendance_records"
    ADD CONSTRAINT "unique_student_session" UNIQUE ("attendance_id", "student_email");



ALTER TABLE ONLY "public"."embedding_cache"
    ADD CONSTRAINT "unique_text_hash_type" UNIQUE ("text_hash", "cache_type");



ALTER TABLE ONLY "public"."university_colleges"
    ADD CONSTRAINT "university_colleges_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."university_colleges"
    ADD CONSTRAINT "university_colleges_university_id_code_key" UNIQUE ("university_id", "code");



ALTER TABLE ONLY "public"."university_courses"
    ADD CONSTRAINT "university_courses_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."university_performance"
    ADD CONSTRAINT "university_performance_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."college_student_assignments"
    ADD CONSTRAINT "uq_college_student_assignment" UNIQUE ("assignment_id", "student_id");



ALTER TABLE ONLY "public"."student_assignments"
    ADD CONSTRAINT "uq_student_assignment" UNIQUE ("assignment_id", "student_id");



ALTER TABLE ONLY "public"."user_categories"
    ADD CONSTRAINT "user_categories_name_key" UNIQUE ("name");



ALTER TABLE ONLY "public"."user_categories"
    ADD CONSTRAINT "user_categories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_entitlements"
    ADD CONSTRAINT "user_entitlements_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_login_history"
    ADD CONSTRAINT "user_login_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."user_sessions"
    ADD CONSTRAINT "user_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_settings"
    ADD CONSTRAINT "user_settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_settings"
    ADD CONSTRAINT "user_settings_user_id_key" UNIQUE ("user_id");



ALTER TABLE ONLY "public"."user_state_history"
    ADD CONSTRAINT "user_state_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."verifications"
    ADD CONSTRAINT "verifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."video_summaries"
    ADD CONSTRAINT "video_summaries_pkey" PRIMARY KEY ("id");



CREATE INDEX "certificates_embedding_idx" ON "public"."certificates" USING "hnsw" ("embedding" "extensions"."vector_cosine_ops") WITH ("m"='16', "ef_construction"='64');



CREATE INDEX "course_enrollments_embedding_hnsw_idx" ON "public"."course_enrollments" USING "hnsw" ("embedding" "extensions"."vector_cosine_ops") WITH ("m"='16', "ef_construction"='64');



CREATE INDEX "courses_embedding_idx" ON "public"."courses" USING "ivfflat" ("embedding" "extensions"."vector_cosine_ops") WITH ("lists"='100');



CREATE INDEX "idx_adaptive_responses_difficulty" ON "public"."adaptive_aptitude_responses" USING "btree" ("difficulty_at_time");



CREATE INDEX "idx_adaptive_responses_phase" ON "public"."adaptive_aptitude_responses" USING "btree" ("phase");



CREATE INDEX "idx_adaptive_responses_question" ON "public"."adaptive_aptitude_responses" USING "btree" ("question_id");



CREATE INDEX "idx_adaptive_responses_session" ON "public"."adaptive_aptitude_responses" USING "btree" ("session_id");



CREATE INDEX "idx_adaptive_responses_session_sequence" ON "public"."adaptive_aptitude_responses" USING "btree" ("session_id", "sequence_number");



CREATE INDEX "idx_adaptive_responses_subtag" ON "public"."adaptive_aptitude_responses" USING "btree" ("subtag");



CREATE INDEX "idx_adaptive_results_accuracy_difficulty_gin" ON "public"."adaptive_aptitude_results" USING "gin" ("accuracy_by_difficulty");



CREATE INDEX "idx_adaptive_results_accuracy_subtag_gin" ON "public"."adaptive_aptitude_results" USING "gin" ("accuracy_by_subtag");



CREATE INDEX "idx_adaptive_results_aptitude_level" ON "public"."adaptive_aptitude_results" USING "btree" ("aptitude_level");



CREATE INDEX "idx_adaptive_results_completed_at" ON "public"."adaptive_aptitude_results" USING "btree" ("completed_at");



CREATE INDEX "idx_adaptive_results_confidence" ON "public"."adaptive_aptitude_results" USING "btree" ("confidence_tag");



CREATE INDEX "idx_adaptive_results_grade_level" ON "public"."adaptive_aptitude_results" USING "btree" ("grade_level");



CREATE INDEX "idx_adaptive_results_session" ON "public"."adaptive_aptitude_results" USING "btree" ("session_id");



CREATE INDEX "idx_adaptive_results_student" ON "public"."adaptive_aptitude_results" USING "btree" ("student_id");



CREATE INDEX "idx_adaptive_results_student_completed" ON "public"."adaptive_aptitude_results" USING "btree" ("student_id", "completed_at" DESC);



CREATE INDEX "idx_adaptive_sessions_grade_level" ON "public"."adaptive_aptitude_sessions" USING "btree" ("grade_level");



CREATE INDEX "idx_adaptive_sessions_started_at" ON "public"."adaptive_aptitude_sessions" USING "btree" ("started_at");



CREATE INDEX "idx_adaptive_sessions_status" ON "public"."adaptive_aptitude_sessions" USING "btree" ("status");



CREATE INDEX "idx_adaptive_sessions_student" ON "public"."adaptive_aptitude_sessions" USING "btree" ("student_id");



CREATE INDEX "idx_adaptive_sessions_student_status" ON "public"."adaptive_aptitude_sessions" USING "btree" ("student_id", "status");



CREATE INDEX "idx_addon_events_created_at" ON "public"."addon_events" USING "btree" ("created_at");



CREATE INDEX "idx_addon_events_event_type" ON "public"."addon_events" USING "btree" ("event_type");



CREATE INDEX "idx_addon_events_feature_key" ON "public"."addon_events" USING "btree" ("feature_key");



CREATE INDEX "idx_addon_events_user_id" ON "public"."addon_events" USING "btree" ("user_id");



CREATE INDEX "idx_addon_pending_orders_bulk_status" ON "public"."addon_pending_orders" USING "btree" ("is_bulk_order", "status", "created_at" DESC) WHERE ("is_bulk_order" = true);



CREATE INDEX "idx_addon_pending_orders_member_type" ON "public"."addon_pending_orders" USING "btree" ("organization_id", "target_member_type") WHERE ("is_bulk_order" = true);



CREATE INDEX "idx_addon_pending_orders_organization" ON "public"."addon_pending_orders" USING "btree" ("organization_id") WHERE ("is_bulk_order" = true);



CREATE INDEX "idx_addon_pending_orders_razorpay_order_id" ON "public"."addon_pending_orders" USING "btree" ("razorpay_order_id");



CREATE INDEX "idx_addon_pending_orders_status" ON "public"."addon_pending_orders" USING "btree" ("status");



CREATE INDEX "idx_addon_pending_orders_user_id" ON "public"."addon_pending_orders" USING "btree" ("user_id");



CREATE INDEX "idx_admission_applications_applied_date" ON "public"."admission_applications" USING "btree" ("applied_date");



CREATE INDEX "idx_admission_applications_school" ON "public"."admission_applications" USING "btree" ("school_id");



CREATE INDEX "idx_admission_applications_status" ON "public"."admission_applications" USING "btree" ("status");



CREATE INDEX "idx_ai_eval_conversation" ON "public"."ai_evaluations" USING "btree" ("conversation_id");



CREATE INDEX "idx_ai_eval_created" ON "public"."ai_evaluations" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_ai_eval_intent" ON "public"."ai_evaluations" USING "btree" ("detected_intent");



CREATE INDEX "idx_ai_eval_student" ON "public"."ai_evaluations" USING "btree" ("student_id");



CREATE INDEX "idx_ai_eval_thumbs" ON "public"."ai_evaluations" USING "btree" ("thumbs_up") WHERE ("thumbs_up" IS NOT NULL);



CREATE INDEX "idx_applied_jobs_applied_at" ON "public"."applied_jobs" USING "btree" ("applied_at" DESC);



CREATE INDEX "idx_applied_jobs_opportunity_id" ON "public"."applied_jobs" USING "btree" ("opportunity_id_old");



CREATE INDEX "idx_applied_jobs_opportunity_student" ON "public"."applied_jobs" USING "btree" ("opportunity_id_old", "student_id");



CREATE INDEX "idx_applied_jobs_status" ON "public"."applied_jobs" USING "btree" ("application_status");



CREATE INDEX "idx_applied_jobs_student_date" ON "public"."applied_jobs" USING "btree" ("student_id", "applied_at" DESC);



CREATE INDEX "idx_applied_jobs_student_id" ON "public"."applied_jobs" USING "btree" ("student_id");



CREATE INDEX "idx_approval_actions_request" ON "public"."approval_actions" USING "btree" ("request_id");



CREATE INDEX "idx_approval_requests_status" ON "public"."approval_requests" USING "btree" ("status");



CREATE INDEX "idx_approval_requests_workflow" ON "public"."approval_requests" USING "btree" ("workflow_id");



CREATE INDEX "idx_assessment_attempts_status" ON "public"."personal_assessment_attempts" USING "btree" ("status");



CREATE INDEX "idx_assessment_attempts_student" ON "public"."personal_assessment_attempts" USING "btree" ("student_id");



CREATE INDEX "idx_assessment_attempts_total_time_minutes" ON "public"."personal_assessment_attempts" USING "btree" ("total_time_minutes") WHERE ("total_time_minutes" IS NOT NULL);



CREATE INDEX "idx_assessment_questions_section" ON "public"."personal_assessment_questions" USING "btree" ("section_id");



CREATE INDEX "idx_assessment_questions_stream" ON "public"."personal_assessment_questions" USING "btree" ("stream_id");



CREATE INDEX "idx_assessment_responses_attempt" ON "public"."personal_assessment_responses" USING "btree" ("attempt_id");



CREATE INDEX "idx_assessment_results_stream" ON "public"."personal_assessment_results" USING "btree" ("stream_id");



CREATE INDEX "idx_assessment_results_student" ON "public"."personal_assessment_results" USING "btree" ("student_id");



CREATE INDEX "idx_assessment_types_active" ON "public"."assessment_types" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_assessment_types_institution" ON "public"."assessment_types" USING "btree" ("institution_id", "institution_type");



CREATE INDEX "idx_assessments_academic_year" ON "public"."assessments" USING "btree" ("academic_year");



CREATE INDEX "idx_assessments_college" ON "public"."assessments" USING "btree" ("college_id");



CREATE INDEX "idx_assessments_course" ON "public"."assessments" USING "btree" ("course_id");



CREATE INDEX "idx_assessments_department" ON "public"."assessments" USING "btree" ("department_id");



CREATE INDEX "idx_assessments_faculty" ON "public"."assessments" USING "btree" ("faculty_id");



CREATE INDEX "idx_assessments_program" ON "public"."assessments" USING "btree" ("program_id");



CREATE INDEX "idx_assessments_semester" ON "public"."assessments" USING "btree" ("semester");



CREATE INDEX "idx_assessments_status" ON "public"."assessments" USING "btree" ("status");



CREATE INDEX "idx_assessments_target_classes" ON "public"."assessments" USING "gin" ("target_classes");



CREATE INDEX "idx_assessments_type" ON "public"."assessments" USING "btree" ("type");



CREATE INDEX "idx_assignments_course" ON "public"."assignments" USING "btree" ("course_name");



CREATE INDEX "idx_assignments_due_date" ON "public"."assignments" USING "btree" ("due_date");



CREATE INDEX "idx_assignments_educator" ON "public"."assignments" USING "btree" ("educator_id");



CREATE INDEX "idx_attachments_assignment" ON "public"."assignment_attachments" USING "btree" ("assignment_id");



CREATE INDEX "idx_attempts_adaptive_session" ON "public"."personal_assessment_attempts" USING "btree" ("adaptive_aptitude_session_id") WHERE ("adaptive_aptitude_session_id" IS NOT NULL);



CREATE INDEX "idx_attempts_grade_level" ON "public"."personal_assessment_attempts" USING "btree" ("grade_level");



CREATE INDEX "idx_attempts_student_status" ON "public"."personal_assessment_attempts" USING "btree" ("student_id", "status");



CREATE INDEX "idx_attendance_alerts_notified" ON "public"."attendance_alerts" USING "btree" ("parent_notified");



CREATE INDEX "idx_attendance_alerts_school" ON "public"."attendance_alerts" USING "btree" ("school_id");



CREATE INDEX "idx_attendance_alerts_student" ON "public"."attendance_alerts" USING "btree" ("student_id");



CREATE INDEX "idx_attendance_records_date" ON "public"."attendance_records" USING "btree" ("date");



CREATE INDEX "idx_attendance_records_school" ON "public"."attendance_records" USING "btree" ("school_id");



CREATE INDEX "idx_attendance_records_school_date_slot" ON "public"."attendance_records" USING "btree" ("school_id", "date", "slot_id");



CREATE INDEX "idx_attendance_records_slot_id_date" ON "public"."attendance_records" USING "btree" ("slot_id", "date");



CREATE INDEX "idx_attendance_records_status" ON "public"."attendance_records" USING "btree" ("status");



CREATE INDEX "idx_attendance_records_student" ON "public"."attendance_records" USING "btree" ("student_id");



CREATE INDEX "idx_audit_action" ON "public"."audit_logs" USING "btree" ("action");



CREATE INDEX "idx_audit_action_date" ON "public"."audit_logs" USING "btree" ("action", "createdAt" DESC);



CREATE INDEX "idx_audit_actor" ON "public"."audit_logs" USING "btree" ("actorId");



CREATE INDEX "idx_audit_actor_action" ON "public"."audit_logs" USING "btree" ("actorId", "action");



CREATE INDEX "idx_audit_actorid" ON "public"."audit_logs" USING "btree" ("actorId");



CREATE INDEX "idx_audit_created" ON "public"."audit_logs" USING "btree" ("createdAt" DESC);



CREATE INDEX "idx_audit_createdat" ON "public"."audit_logs" USING "btree" ("createdAt" DESC);



CREATE INDEX "idx_audit_ip_trgm" ON "public"."audit_logs" USING "gin" ("ip" "extensions"."gin_trgm_ops");



CREATE INDEX "idx_audit_target" ON "public"."audit_logs" USING "btree" ("target");



CREATE INDEX "idx_audit_target_trgm" ON "public"."audit_logs" USING "gin" ("target" "extensions"."gin_trgm_ops");



CREATE INDEX "idx_budget_alerts_acknowledged" ON "public"."budget_alerts" USING "btree" ("is_acknowledged");



CREATE INDEX "idx_budget_alerts_budget" ON "public"."budget_alerts" USING "btree" ("budget_id");



CREATE INDEX "idx_budget_alerts_department" ON "public"."budget_alerts" USING "btree" ("department_id");



CREATE INDEX "idx_budget_alerts_level" ON "public"."budget_alerts" USING "btree" ("alert_level");



CREATE INDEX "idx_budget_alerts_type" ON "public"."budget_alerts" USING "btree" ("alert_type");



CREATE INDEX "idx_budget_revisions_budget" ON "public"."budget_revisions" USING "btree" ("budget_id");



CREATE INDEX "idx_budget_revisions_date" ON "public"."budget_revisions" USING "btree" ("requested_at");



CREATE INDEX "idx_budget_revisions_department" ON "public"."budget_revisions" USING "btree" ("department_id");



CREATE INDEX "idx_budget_revisions_status" ON "public"."budget_revisions" USING "btree" ("approval_status");



CREATE INDEX "idx_bundle_features_bundle_id" ON "public"."bundle_features" USING "btree" ("bundle_id");



CREATE INDEX "idx_bundle_features_feature_key" ON "public"."bundle_features" USING "btree" ("feature_key");



CREATE INDEX "idx_career_ai_conversations_student_id" ON "public"."career_ai_conversations" USING "btree" ("student_id");



CREATE INDEX "idx_career_ai_conversations_updated_at" ON "public"."career_ai_conversations" USING "btree" ("updated_at" DESC);



CREATE INDEX "idx_career_ai_questions_active" ON "public"."career_assessment_ai_questions" USING "btree" ("is_active");



CREATE INDEX "idx_career_ai_questions_stream" ON "public"."career_assessment_ai_questions" USING "btree" ("stream_id");



CREATE INDEX "idx_career_ai_questions_type" ON "public"."career_assessment_ai_questions" USING "btree" ("question_type");



CREATE INDEX "idx_career_assessment_ai_questions_grade_level" ON "public"."career_assessment_ai_questions" USING "btree" ("grade_level");



CREATE INDEX "idx_career_assessment_ai_questions_grade_stream" ON "public"."career_assessment_ai_questions" USING "btree" ("grade_level", "stream_id", "question_type");



CREATE INDEX "idx_career_assessment_ai_questions_student" ON "public"."career_assessment_ai_questions" USING "btree" ("student_id");



CREATE INDEX "idx_certificates_active" ON "public"."certificates" USING "btree" ("student_id", "created_at" DESC) WHERE ((("status" IS NULL) OR (("status")::"text" = 'active'::"text")) AND (("approval_status")::"text" <> 'rejected'::"text"));



CREATE INDEX "idx_certificates_approval" ON "public"."certificates" USING "btree" ("approval_status", "created_at" DESC) WHERE (("approval_status")::"text" = 'pending'::"text");



CREATE INDEX "idx_certificates_credential" ON "public"."club_certificates" USING "btree" ("credential_id");



CREATE INDEX "idx_certificates_issued_date" ON "public"."club_certificates" USING "btree" ("issued_date");



CREATE INDEX "idx_certificates_issued_on" ON "public"."certificates" USING "btree" ("student_id", "issued_on" DESC) WHERE ("enabled" = true);



CREATE INDEX "idx_certificates_school" ON "public"."club_certificates" USING "btree" ("school_id");



CREATE INDEX "idx_certificates_status" ON "public"."certificates" USING "btree" ("status") WHERE ("status" IS NOT NULL);



CREATE INDEX "idx_certificates_student" ON "public"."club_certificates" USING "btree" ("student_email");



CREATE INDEX "idx_certificates_student_created" ON "public"."certificates" USING "btree" ("student_id", "created_at" DESC);



CREATE UNIQUE INDEX "idx_certificates_student_credential_platform_unique" ON "public"."certificates" USING "btree" ("student_id", "credential_id", "platform") WHERE (("credential_id" IS NOT NULL) AND (("credential_id")::"text" <> ''::"text"));



CREATE INDEX "idx_certificates_student_id" ON "public"."certificates" USING "btree" ("student_id");



CREATE UNIQUE INDEX "idx_certificates_student_link_unique" ON "public"."certificates" USING "btree" ("student_id", "link") WHERE (("link" IS NOT NULL) AND ("link" <> ''::"text"));



CREATE INDEX "idx_certificates_student_lookup" ON "public"."certificates" USING "btree" ("student_id", "enabled", "approval_status") WHERE (("enabled" = true) AND (("approval_status")::"text" = ANY (ARRAY[('approved'::character varying)::"text", ('verified'::character varying)::"text"])));



CREATE INDEX "idx_certificates_training_id" ON "public"."certificates" USING "btree" ("training_id");



CREATE INDEX "idx_certificates_type" ON "public"."club_certificates" USING "btree" ("certificate_type");



CREATE INDEX "idx_chapters_curriculum" ON "public"."curriculum_chapters" USING "btree" ("curriculum_id");



CREATE INDEX "idx_chapters_order" ON "public"."curriculum_chapters" USING "btree" ("curriculum_id", "order_number");



CREATE INDEX "idx_club_activities_club" ON "public"."club_activities" USING "btree" ("club_id");



CREATE INDEX "idx_club_activities_date" ON "public"."club_activities" USING "btree" ("activity_date");



CREATE INDEX "idx_club_activities_status" ON "public"."club_activities" USING "btree" ("status");



CREATE INDEX "idx_club_attendance_club_date" ON "public"."club_attendance" USING "btree" ("club_id", "session_date");



CREATE INDEX "idx_club_attendance_created_by_admin" ON "public"."club_attendance" USING "btree" ("created_by_admin_id");



CREATE INDEX "idx_club_attendance_created_by_educator" ON "public"."club_attendance" USING "btree" ("created_by_educator_id");



CREATE INDEX "idx_club_attendance_records_attendance" ON "public"."club_attendance_records" USING "btree" ("attendance_id");



CREATE INDEX "idx_club_attendance_records_status" ON "public"."club_attendance_records" USING "btree" ("status");



CREATE INDEX "idx_club_attendance_records_student" ON "public"."club_attendance_records" USING "btree" ("student_email");



CREATE INDEX "idx_club_memberships_club" ON "public"."club_memberships" USING "btree" ("club_id");



CREATE INDEX "idx_club_memberships_enrolled_by_admin" ON "public"."club_memberships" USING "btree" ("enrolled_by_admin_id");



CREATE INDEX "idx_club_memberships_enrolled_by_educator" ON "public"."club_memberships" USING "btree" ("enrolled_by_educator_id");



CREATE INDEX "idx_club_memberships_status" ON "public"."club_memberships" USING "btree" ("status");



CREATE INDEX "idx_club_memberships_student" ON "public"."club_memberships" USING "btree" ("student_email");



CREATE INDEX "idx_clubs_category" ON "public"."clubs" USING "btree" ("category");



CREATE INDEX "idx_clubs_created_by_admin" ON "public"."clubs" USING "btree" ("created_by_admin_id");



CREATE INDEX "idx_clubs_created_by_educator" ON "public"."clubs" USING "btree" ("created_by_educator_id");



CREATE INDEX "idx_clubs_is_active" ON "public"."clubs" USING "btree" ("is_active");



CREATE INDEX "idx_clubs_mentor_educator" ON "public"."clubs" USING "btree" ("mentor_educator_id");



CREATE INDEX "idx_clubs_mentor_school" ON "public"."clubs" USING "btree" ("mentor_school_id");



CREATE INDEX "idx_clubs_mentor_type" ON "public"."clubs" USING "btree" ("mentor_type");



CREATE INDEX "idx_clubs_school" ON "public"."clubs" USING "btree" ("school_id");



CREATE INDEX "idx_co_educators_course" ON "public"."course_co_educators" USING "btree" ("course_id");



CREATE INDEX "idx_college_assignment_attachments_assignment" ON "public"."college_assignment_attachments" USING "btree" ("assignment_id");



CREATE INDEX "idx_college_assignment_attachments_uploaded_by" ON "public"."college_assignment_attachments" USING "btree" ("uploaded_by");



CREATE INDEX "idx_college_assignments_college_id" ON "public"."college_assignments" USING "btree" ("college_id");



CREATE INDEX "idx_college_assignments_course" ON "public"."college_assignments" USING "btree" ("course_name");



CREATE INDEX "idx_college_assignments_department_id" ON "public"."college_assignments" USING "btree" ("department_id");



CREATE INDEX "idx_college_assignments_due_date" ON "public"."college_assignments" USING "btree" ("due_date");



CREATE INDEX "idx_college_assignments_educator_id" ON "public"."college_assignments" USING "btree" ("college_educator_id");



CREATE INDEX "idx_college_assignments_program_id" ON "public"."college_assignments" USING "btree" ("program_id");



CREATE INDEX "idx_college_assignments_program_section_id" ON "public"."college_assignments" USING "btree" ("program_section_id");



CREATE INDEX "idx_college_attendance_records_class" ON "public"."college_attendance_records" USING "btree" ("department_name", "program_name", "semester", "section");



CREATE INDEX "idx_college_attendance_records_college" ON "public"."college_attendance_records" USING "btree" ("college_id");



CREATE INDEX "idx_college_attendance_records_date" ON "public"."college_attendance_records" USING "btree" ("date");



CREATE INDEX "idx_college_attendance_records_session" ON "public"."college_attendance_records" USING "btree" ("session_id");



CREATE INDEX "idx_college_attendance_records_status" ON "public"."college_attendance_records" USING "btree" ("status");



CREATE INDEX "idx_college_attendance_records_student" ON "public"."college_attendance_records" USING "btree" ("student_id");



CREATE INDEX "idx_college_attendance_records_subject" ON "public"."college_attendance_records" USING "btree" ("subject_name");



CREATE INDEX "idx_college_attendance_sessions_academic_year" ON "public"."college_attendance_sessions" USING "btree" ("academic_year");



CREATE INDEX "idx_college_attendance_sessions_class" ON "public"."college_attendance_sessions" USING "btree" ("department_name", "program_name", "semester", "section");



CREATE INDEX "idx_college_attendance_sessions_college" ON "public"."college_attendance_sessions" USING "btree" ("college_id");



CREATE INDEX "idx_college_attendance_sessions_date" ON "public"."college_attendance_sessions" USING "btree" ("date");



CREATE INDEX "idx_college_attendance_sessions_faculty" ON "public"."college_attendance_sessions" USING "btree" ("faculty_id");



CREATE INDEX "idx_college_attendance_sessions_status" ON "public"."college_attendance_sessions" USING "btree" ("status");



CREATE INDEX "idx_college_attendance_sessions_subject" ON "public"."college_attendance_sessions" USING "btree" ("subject_name");



CREATE INDEX "idx_college_breaks_college_id" ON "public"."college_breaks" USING "btree" ("college_id");



CREATE INDEX "idx_college_breaks_dates" ON "public"."college_breaks" USING "btree" ("start_date", "end_date");



CREATE INDEX "idx_college_breaks_timetable_id" ON "public"."college_breaks" USING "btree" ("timetable_id");



CREATE INDEX "idx_college_circulars_audience" ON "public"."college_circulars" USING "btree" ("audience");



CREATE INDEX "idx_college_circulars_college_id" ON "public"."college_circulars" USING "btree" ("college_id");



CREATE INDEX "idx_college_circulars_priority" ON "public"."college_circulars" USING "btree" ("priority");



CREATE INDEX "idx_college_circulars_publish_date" ON "public"."college_circulars" USING "btree" ("publish_date");



CREATE INDEX "idx_college_circulars_status" ON "public"."college_circulars" USING "btree" ("status");



CREATE INDEX "idx_college_classes_college_id" ON "public"."college_classes" USING "btree" ("college_id");



CREATE INDEX "idx_college_classes_department_id" ON "public"."college_classes" USING "btree" ("department_id");



CREATE INDEX "idx_college_classes_status" ON "public"."college_classes" USING "btree" ("status");



CREATE INDEX "idx_college_courses_active" ON "public"."college_courses" USING "btree" ("is_active");



CREATE INDEX "idx_college_courses_college_id" ON "public"."college_courses" USING "btree" ("college_id");



CREATE INDEX "idx_college_courses_course_code" ON "public"."college_courses" USING "btree" ("course_code");



CREATE INDEX "idx_college_courses_course_type" ON "public"."college_courses" USING "btree" ("course_type");



CREATE INDEX "idx_college_courses_created_by" ON "public"."college_courses" USING "btree" ("created_by");



CREATE INDEX "idx_college_curriculum_units_order" ON "public"."college_curriculum_units" USING "btree" ("curriculum_id", "order_index");



CREATE INDEX "idx_college_curriculums_academic_year" ON "public"."college_curriculums" USING "btree" ("academic_year");



CREATE INDEX "idx_college_curriculums_college_id" ON "public"."college_curriculums" USING "btree" ("college_id");



CREATE INDEX "idx_college_curriculums_course_id" ON "public"."college_curriculums" USING "btree" ("course_id");



CREATE INDEX "idx_college_curriculums_requested_by" ON "public"."college_curriculums" USING "btree" ("requested_by");



CREATE INDEX "idx_college_curriculums_reviewed_by" ON "public"."college_curriculums" USING "btree" ("reviewed_by");



CREATE INDEX "idx_college_curriculums_status" ON "public"."college_curriculums" USING "btree" ("status");



CREATE INDEX "idx_college_curriculums_university_id" ON "public"."college_curriculums" USING "btree" ("university_id");



CREATE INDEX "idx_college_events_college_id" ON "public"."college_events" USING "btree" ("college_id");



CREATE INDEX "idx_college_events_event_type" ON "public"."college_events" USING "btree" ("event_type");



CREATE INDEX "idx_college_events_start_date" ON "public"."college_events" USING "btree" ("start_date");



CREATE INDEX "idx_college_events_status" ON "public"."college_events" USING "btree" ("status");



CREATE INDEX "idx_college_lesson_plans_academic_year" ON "public"."college_lesson_plans" USING "btree" ("academic_year");



CREATE INDEX "idx_college_lesson_plans_college_id" ON "public"."college_lesson_plans" USING "btree" ("college_id");



CREATE INDEX "idx_college_lesson_plans_course_id" ON "public"."college_lesson_plans" USING "btree" ("course_id");



CREATE INDEX "idx_college_lesson_plans_course_semester" ON "public"."college_lesson_plans" USING "btree" ("course_id", "semester");



CREATE INDEX "idx_college_lesson_plans_curriculum_id" ON "public"."college_lesson_plans" USING "btree" ("curriculum_id");



CREATE INDEX "idx_college_lesson_plans_department_id" ON "public"."college_lesson_plans" USING "btree" ("department_id");



CREATE INDEX "idx_college_lesson_plans_program_id" ON "public"."college_lesson_plans" USING "btree" ("program_id");



CREATE INDEX "idx_college_lesson_plans_program_semester_year" ON "public"."college_lesson_plans" USING "btree" ("program_id", "semester", "academic_year");



CREATE INDEX "idx_college_lesson_plans_semester" ON "public"."college_lesson_plans" USING "btree" ("semester");



CREATE INDEX "idx_college_lesson_plans_session_date" ON "public"."college_lesson_plans" USING "btree" ("session_date");



CREATE INDEX "idx_college_lesson_plans_status" ON "public"."college_lesson_plans" USING "btree" ("status");



CREATE INDEX "idx_college_lesson_plans_unit_id" ON "public"."college_lesson_plans" USING "btree" ("unit_id");



CREATE INDEX "idx_college_mentor_notes_allocation_id" ON "public"."college_mentor_notes" USING "btree" ("allocation_id");



CREATE INDEX "idx_college_mentor_notes_date" ON "public"."college_mentor_notes" USING "btree" ("note_date");



CREATE INDEX "idx_college_mentor_notes_intervention_type" ON "public"."college_mentor_notes" USING "btree" ("intervention_type");



CREATE INDEX "idx_college_mentor_notes_mentor_id" ON "public"."college_mentor_notes" USING "btree" ("mentor_id");



CREATE INDEX "idx_college_mentor_notes_mentor_status" ON "public"."college_mentor_notes" USING "btree" ("mentor_id", "status");



CREATE INDEX "idx_college_mentor_notes_status" ON "public"."college_mentor_notes" USING "btree" ("status");



CREATE INDEX "idx_college_mentor_notes_student_id" ON "public"."college_mentor_notes" USING "btree" ("student_id");



CREATE INDEX "idx_college_mentor_periods_academic_year" ON "public"."college_mentor_periods" USING "btree" ("academic_year");



CREATE INDEX "idx_college_mentor_periods_active" ON "public"."college_mentor_periods" USING "btree" ("is_active");



CREATE INDEX "idx_college_mentor_periods_college_id" ON "public"."college_mentor_periods" USING "btree" ("college_id");



CREATE INDEX "idx_college_mentor_periods_dates" ON "public"."college_mentor_periods" USING "btree" ("start_date", "end_date");



CREATE INDEX "idx_college_mentor_student_allocations_mentor_id" ON "public"."college_mentor_student_allocations" USING "btree" ("mentor_id");



CREATE INDEX "idx_college_mentor_student_allocations_mentor_period" ON "public"."college_mentor_student_allocations" USING "btree" ("mentor_id", "period_id");



CREATE INDEX "idx_college_mentor_student_allocations_period_id" ON "public"."college_mentor_student_allocations" USING "btree" ("period_id");



CREATE INDEX "idx_college_mentor_student_allocations_status" ON "public"."college_mentor_student_allocations" USING "btree" ("status");



CREATE INDEX "idx_college_mentor_student_allocations_student_id" ON "public"."college_mentor_student_allocations" USING "btree" ("student_id");



CREATE INDEX "idx_college_role_module_permissions_module" ON "public"."college_role_module_permissions" USING "btree" ("module_id");



CREATE INDEX "idx_college_role_module_permissions_role" ON "public"."college_role_module_permissions" USING "btree" ("role_type");



CREATE INDEX "idx_college_role_scope_rules_role" ON "public"."college_role_scope_rules" USING "btree" ("role_type");



CREATE INDEX "idx_college_role_scope_rules_scope" ON "public"."college_role_scope_rules" USING "btree" ("scope_type", "scope_value");



CREATE INDEX "idx_college_setting_modules_active" ON "public"."college_setting_modules" USING "btree" ("is_active");



CREATE INDEX "idx_college_setting_modules_name" ON "public"."college_setting_modules" USING "btree" ("module_name");



CREATE INDEX "idx_college_student_assignments_assignment" ON "public"."college_student_assignments" USING "btree" ("assignment_id");



CREATE INDEX "idx_college_student_assignments_lookup" ON "public"."college_student_assignments" USING "btree" ("student_id", "is_deleted") WHERE ("is_deleted" = false);



CREATE INDEX "idx_college_student_assignments_status" ON "public"."college_student_assignments" USING "btree" ("status");



CREATE INDEX "idx_college_student_assignments_student" ON "public"."college_student_assignments" USING "btree" ("student_id");



CREATE INDEX "idx_college_student_assignments_student_status" ON "public"."college_student_assignments" USING "btree" ("student_id", "status");



CREATE INDEX "idx_college_student_assignments_submission_date" ON "public"."college_student_assignments" USING "btree" ("submission_date");



CREATE INDEX "idx_college_time_periods_timetable" ON "public"."college_time_periods" USING "btree" ("timetable_id");



CREATE INDEX "idx_college_timetable_slots_date" ON "public"."college_timetable_slots" USING "btree" ("schedule_date");



CREATE INDEX "idx_college_timetable_slots_educator_id" ON "public"."college_timetable_slots" USING "btree" ("educator_id");



CREATE INDEX "idx_college_timetable_slots_timetable_id" ON "public"."college_timetable_slots" USING "btree" ("timetable_id");



CREATE INDEX "idx_college_timetables_academic_year" ON "public"."college_timetables" USING "btree" ("academic_year");



CREATE INDEX "idx_college_timetables_college_id" ON "public"."college_timetables" USING "btree" ("college_id");



CREATE INDEX "idx_comp_clubs_club" ON "public"."competition_clubs" USING "btree" ("club_id");



CREATE INDEX "idx_comp_clubs_comp" ON "public"."competition_clubs" USING "btree" ("comp_id");



CREATE INDEX "idx_comp_registrations_comp" ON "public"."competition_registrations" USING "btree" ("comp_id");



CREATE INDEX "idx_comp_registrations_status" ON "public"."competition_registrations" USING "btree" ("status");



CREATE INDEX "idx_comp_registrations_student" ON "public"."competition_registrations" USING "btree" ("student_email");



CREATE INDEX "idx_comp_results_comp" ON "public"."competition_results" USING "btree" ("comp_id");



CREATE INDEX "idx_comp_results_registration" ON "public"."competition_results" USING "btree" ("registration_id");



CREATE INDEX "idx_comp_results_student" ON "public"."competition_results" USING "btree" ("student_email");



CREATE INDEX "idx_competitions_category" ON "public"."competitions" USING "btree" ("category");



CREATE INDEX "idx_competitions_created_by_admin" ON "public"."competitions" USING "btree" ("created_by_admin_id");



CREATE INDEX "idx_competitions_created_by_educator" ON "public"."competitions" USING "btree" ("created_by_educator_id");



CREATE INDEX "idx_competitions_date" ON "public"."competitions" USING "btree" ("competition_date");



CREATE INDEX "idx_competitions_level" ON "public"."competitions" USING "btree" ("level");



CREATE INDEX "idx_competitions_school" ON "public"."competitions" USING "btree" ("school_id");



CREATE INDEX "idx_competitions_status" ON "public"."competitions" USING "btree" ("status");



CREATE INDEX "idx_conversations_admin_active" ON "public"."conversations" USING "btree" ("school_id", "status", "deleted_by_admin") WHERE (("conversation_type")::"text" = 'student_admin'::"text");



CREATE INDEX "idx_conversations_admin_unread" ON "public"."conversations" USING "btree" ("admin_unread_count") WHERE ("admin_unread_count" > 0);



CREATE INDEX "idx_conversations_application_id" ON "public"."conversations" USING "btree" ("application_id");



CREATE INDEX "idx_conversations_class_id" ON "public"."conversations" USING "btree" ("class_id");



CREATE INDEX "idx_conversations_college_admin_active" ON "public"."conversations" USING "btree" ("college_id", "status", "deleted_by_college_admin") WHERE (("conversation_type")::"text" = 'student_college_admin'::"text");



CREATE INDEX "idx_conversations_college_admin_educator_active" ON "public"."conversations" USING "btree" ("college_id", "status", "deleted_by_college_admin") WHERE (("conversation_type")::"text" = 'college_educator_admin'::"text");



CREATE INDEX "idx_conversations_college_admin_unread" ON "public"."conversations" USING "btree" ("college_admin_unread_count") WHERE ("college_admin_unread_count" > 0);



CREATE INDEX "idx_conversations_college_educator_active" ON "public"."conversations" USING "btree" ("educator_id", "status", "deleted_by_college_educator") WHERE (("conversation_type")::"text" = 'student_college_educator'::"text");



CREATE INDEX "idx_conversations_college_educator_admin" ON "public"."conversations" USING "btree" ("educator_id", "college_id", "conversation_type") WHERE (("conversation_type")::"text" = 'college_educator_admin'::"text");



CREATE INDEX "idx_conversations_college_educator_admin_active" ON "public"."conversations" USING "btree" ("educator_id", "status", "deleted_by_educator") WHERE (("conversation_type")::"text" = 'college_educator_admin'::"text");



CREATE INDEX "idx_conversations_college_educator_unread" ON "public"."conversations" USING "btree" ("college_educator_unread_count") WHERE ("college_educator_unread_count" > 0);



CREATE INDEX "idx_conversations_college_id" ON "public"."conversations" USING "btree" ("college_id");



CREATE INDEX "idx_conversations_deleted_by_recruiter" ON "public"."conversations" USING "btree" ("recruiter_id", "deleted_by_recruiter") WHERE ("deleted_by_recruiter" = false);



CREATE INDEX "idx_conversations_deleted_by_student" ON "public"."conversations" USING "btree" ("student_id", "deleted_by_student") WHERE ("deleted_by_student" = false);



CREATE INDEX "idx_conversations_educator_active" ON "public"."conversations" USING "btree" ("educator_id", "status", "deleted_by_educator") WHERE (("conversation_type")::"text" = 'student_educator'::"text");



CREATE INDEX "idx_conversations_educator_admin" ON "public"."conversations" USING "btree" ("educator_id", "school_id", "conversation_type") WHERE (("conversation_type")::"text" = 'educator_admin'::"text");



CREATE INDEX "idx_conversations_educator_id" ON "public"."conversations" USING "btree" ("educator_id");



CREATE INDEX "idx_conversations_educator_unread" ON "public"."conversations" USING "btree" ("educator_unread_count") WHERE ("educator_unread_count" > 0);



CREATE INDEX "idx_conversations_last_message_at" ON "public"."conversations" USING "btree" ("last_message_at" DESC);



CREATE INDEX "idx_conversations_opportunity_id" ON "public"."conversations" USING "btree" ("opportunity_id");



CREATE INDEX "idx_conversations_program_section_id" ON "public"."conversations" USING "btree" ("program_section_id");



CREATE INDEX "idx_conversations_recruiter_active" ON "public"."conversations" USING "btree" ("recruiter_id", "deleted_by_recruiter", "last_message_at" DESC) WHERE (("deleted_by_recruiter" = false) AND ("status" <> 'archived'::"text"));



CREATE INDEX "idx_conversations_recruiter_id" ON "public"."conversations" USING "btree" ("recruiter_id");



CREATE INDEX "idx_conversations_school_id" ON "public"."conversations" USING "btree" ("school_id");



CREATE INDEX "idx_conversations_status" ON "public"."conversations" USING "btree" ("status");



CREATE INDEX "idx_conversations_student_active" ON "public"."conversations" USING "btree" ("student_id", "deleted_by_student", "last_message_at" DESC) WHERE (("deleted_by_student" = false) AND ("status" <> 'archived'::"text"));



CREATE INDEX "idx_conversations_student_admin" ON "public"."conversations" USING "btree" ("student_id", "school_id", "conversation_type") WHERE (("conversation_type")::"text" = 'student_admin'::"text");



CREATE INDEX "idx_conversations_student_college_admin" ON "public"."conversations" USING "btree" ("student_id", "college_id", "conversation_type") WHERE (("conversation_type")::"text" = 'student_college_admin'::"text");



CREATE INDEX "idx_conversations_student_college_educator" ON "public"."conversations" USING "btree" ("student_id", "educator_id", "college_id", "conversation_type") WHERE (("conversation_type")::"text" = 'student_college_educator'::"text");



CREATE INDEX "idx_conversations_student_educator" ON "public"."conversations" USING "btree" ("student_id", "educator_id", "conversation_type") WHERE (("conversation_type")::"text" = 'student_educator'::"text");



CREATE INDEX "idx_conversations_student_id" ON "public"."conversations" USING "btree" ("student_id");



CREATE INDEX "idx_conversations_subject" ON "public"."conversations" USING "btree" ("subject");



CREATE INDEX "idx_conversations_type" ON "public"."conversations" USING "btree" ("conversation_type");



CREATE INDEX "idx_course_classes_course" ON "public"."course_classes" USING "btree" ("course_id");



CREATE INDEX "idx_course_enrollments_course" ON "public"."course_enrollments" USING "btree" ("course_id");



CREATE INDEX "idx_course_enrollments_educator" ON "public"."course_enrollments" USING "btree" ("educator_id");



CREATE INDEX "idx_course_enrollments_status" ON "public"."course_enrollments" USING "btree" ("status");



CREATE INDEX "idx_course_enrollments_student" ON "public"."course_enrollments" USING "btree" ("student_id");



CREATE INDEX "idx_course_enrollments_student_status" ON "public"."course_enrollments" USING "btree" ("student_id", "status") WHERE ("status" = ANY (ARRAY['in_progress'::"text", 'active'::"text", 'completed'::"text"]));



COMMENT ON INDEX "public"."idx_course_enrollments_student_status" IS 'Speeds up course lookup for matching algorithm. Used in ARRAY subquery.';



CREATE INDEX "idx_course_enrollments_training" ON "public"."course_enrollments" USING "btree" ("training_id");



CREATE INDEX "idx_course_mappings_course_id" ON "public"."college_course_mappings" USING "btree" ("course_id");



CREATE INDEX "idx_course_mappings_faculty" ON "public"."college_course_mappings" USING "btree" ("faculty_id");



CREATE INDEX "idx_course_mappings_offering_type" ON "public"."college_course_mappings" USING "btree" ("offering_type");



CREATE INDEX "idx_course_mappings_program_semester" ON "public"."college_course_mappings" USING "btree" ("program_id", "semester");



CREATE INDEX "idx_course_skills_course" ON "public"."course_skills" USING "btree" ("course_id");



CREATE INDEX "idx_course_skills_name" ON "public"."course_skills" USING "btree" ("skill_name");



CREATE INDEX "idx_courses_approval_status" ON "public"."courses" USING "btree" ("approval_status");



CREATE INDEX "idx_courses_category" ON "public"."courses" USING "btree" ("category");



CREATE INDEX "idx_courses_code" ON "public"."courses" USING "btree" ("code");



CREATE INDEX "idx_courses_educator" ON "public"."courses" USING "btree" ("educator_id");



CREATE INDEX "idx_courses_educator_id" ON "public"."courses" USING "btree" ("educator_id");



CREATE INDEX "idx_courses_school_id" ON "public"."courses" USING "btree" ("school_id");



CREATE INDEX "idx_courses_status" ON "public"."courses" USING "btree" ("status");



CREATE INDEX "idx_courses_university" ON "public"."courses" USING "btree" ("university");



CREATE INDEX "idx_curriculum_academic_years_active" ON "public"."curriculum_academic_years" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_curriculum_academic_years_current" ON "public"."curriculum_academic_years" USING "btree" ("is_current") WHERE ("is_current" = true);



CREATE INDEX "idx_curriculum_academic_years_school" ON "public"."curriculum_academic_years" USING "btree" ("school_id");



CREATE INDEX "idx_curriculum_classes_active" ON "public"."curriculum_classes" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_curriculum_classes_order" ON "public"."curriculum_classes" USING "btree" ("display_order");



CREATE INDEX "idx_curriculum_classes_school" ON "public"."curriculum_classes" USING "btree" ("school_id");



CREATE INDEX "idx_curriculum_courses_active" ON "public"."curriculum_courses" USING "btree" ("is_active");



CREATE INDEX "idx_curriculum_courses_college" ON "public"."curriculum_courses" USING "btree" ("college_id");



CREATE INDEX "idx_curriculum_courses_department" ON "public"."curriculum_courses" USING "btree" ("department_id");



CREATE INDEX "idx_curriculum_courses_program" ON "public"."curriculum_courses" USING "btree" ("program_id");



CREATE INDEX "idx_curriculum_courses_semester" ON "public"."curriculum_courses" USING "btree" ("semester");



CREATE INDEX "idx_curriculum_subjects_active" ON "public"."curriculum_subjects" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_curriculum_subjects_order" ON "public"."curriculum_subjects" USING "btree" ("display_order");



CREATE INDEX "idx_curriculum_subjects_school" ON "public"."curriculum_subjects" USING "btree" ("school_id");



CREATE INDEX "idx_curriculums_academic_year" ON "public"."curriculums" USING "btree" ("academic_year");



CREATE INDEX "idx_curriculums_course_id" ON "public"."college_curriculums" USING "btree" ("course_id");



CREATE INDEX "idx_curriculums_created_by" ON "public"."curriculums" USING "btree" ("created_by");



CREATE INDEX "idx_curriculums_pending_changes" ON "public"."college_curriculums" USING "btree" ("has_pending_changes") WHERE ("has_pending_changes" = true);



CREATE INDEX "idx_curriculums_pending_changes_jsonb" ON "public"."college_curriculums" USING "gin" ("pending_changes");



CREATE INDEX "idx_curriculums_program_id" ON "public"."college_curriculums" USING "btree" ("program_id");



CREATE INDEX "idx_curriculums_school" ON "public"."curriculums" USING "btree" ("school_id");



CREATE INDEX "idx_curriculums_status" ON "public"."curriculums" USING "btree" ("status");



CREATE INDEX "idx_curriculums_subject_class" ON "public"."curriculums" USING "btree" ("subject", "class", "academic_year");



CREATE INDEX "idx_department_budgets_department" ON "public"."department_budgets" USING "btree" ("department_id");



CREATE INDEX "idx_department_budgets_financial_year" ON "public"."department_budgets" USING "btree" ("financial_year");



CREATE INDEX "idx_department_budgets_period" ON "public"."department_budgets" USING "btree" ("period_from", "period_to");



CREATE INDEX "idx_department_budgets_status" ON "public"."department_budgets" USING "btree" ("status");



CREATE INDEX "idx_department_budgets_utilization" ON "public"."department_budgets" USING "btree" ("utilization_percentage");



CREATE INDEX "idx_departments_college" ON "public"."departments" USING "btree" ("college_id");



CREATE UNIQUE INDEX "idx_departments_college_code_unique" ON "public"."departments" USING "btree" ("college_id", "code") WHERE ("college_id" IS NOT NULL);



COMMENT ON INDEX "public"."idx_departments_college_code_unique" IS 'Ensures unique department codes within each college';



CREATE INDEX "idx_departments_school" ON "public"."departments" USING "btree" ("school_id");



CREATE UNIQUE INDEX "idx_departments_school_code_unique" ON "public"."departments" USING "btree" ("school_id", "code") WHERE ("school_id" IS NOT NULL);



COMMENT ON INDEX "public"."idx_departments_school_code_unique" IS 'Ensures unique department codes within each school';



CREATE INDEX "idx_dept_faculty_assignments_active" ON "public"."department_faculty_assignments" USING "btree" ("is_active");



CREATE INDEX "idx_dept_faculty_assignments_department_id" ON "public"."department_faculty_assignments" USING "btree" ("department_id");



CREATE INDEX "idx_dept_faculty_assignments_lecturer_id" ON "public"."department_faculty_assignments" USING "btree" ("lecturer_id");



CREATE INDEX "idx_dept_faculty_assignments_type" ON "public"."department_faculty_assignments" USING "btree" ("assignment_type");



CREATE INDEX "idx_document_access_user" ON "public"."document_access_history" USING "btree" ("user_id");



CREATE INDEX "idx_education_student_id" ON "public"."education" USING "btree" ("student_id");



CREATE INDEX "idx_educator_assignments_class" ON "public"."school_educator_class_assignments" USING "btree" ("class_id");



CREATE INDEX "idx_educator_assignments_educator" ON "public"."school_educator_class_assignments" USING "btree" ("educator_id");



CREATE INDEX "idx_email_tracking_pre_reg_id" ON "public"."pre_registration_email_tracking" USING "btree" ("pre_registration_id");



CREATE INDEX "idx_email_tracking_scheduled" ON "public"."pre_registration_email_tracking" USING "btree" ("scheduled_at") WHERE ("email_status" = 'pending'::"text");



CREATE INDEX "idx_email_tracking_sent_at" ON "public"."pre_registration_email_tracking" USING "btree" ("sent_at");



CREATE INDEX "idx_email_tracking_status" ON "public"."pre_registration_email_tracking" USING "btree" ("email_status");



CREATE INDEX "idx_embedding_cache_created_at" ON "public"."embedding_cache" USING "btree" ("created_at");



CREATE INDEX "idx_embedding_cache_lookup" ON "public"."embedding_cache" USING "btree" ("text_hash", "cache_type");



CREATE INDEX "idx_embedding_cache_type" ON "public"."embedding_cache" USING "btree" ("cache_type");



CREATE INDEX "idx_embedding_queue_pending" ON "public"."embedding_queue" USING "btree" ("status", "priority" DESC, "created_at") WHERE ("status" = 'pending'::"text");



CREATE INDEX "idx_embedding_queue_record" ON "public"."embedding_queue" USING "btree" ("record_id", "table_name");



CREATE INDEX "idx_embedding_queue_status" ON "public"."embedding_queue" USING "btree" ("status", "priority", "created_at");



CREATE INDEX "idx_embedding_queue_table_record" ON "public"."embedding_queue" USING "btree" ("table_name", "record_id");



CREATE INDEX "idx_enrollments_restore" ON "public"."course_enrollments" USING "btree" ("student_id", "course_id", "last_accessed" DESC);



CREATE INDEX "idx_event_registrations_attended" ON "public"."college_event_registrations" USING "btree" ("attended");



CREATE INDEX "idx_event_registrations_created_at" ON "public"."event_registrations" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_event_registrations_email" ON "public"."event_registrations" USING "btree" ("email");



CREATE INDEX "idx_event_registrations_email_status" ON "public"."event_registrations" USING "btree" ("email", "payment_status");



CREATE INDEX "idx_event_registrations_event" ON "public"."college_event_registrations" USING "btree" ("event_id");



CREATE INDEX "idx_event_registrations_payment_status" ON "public"."event_registrations" USING "btree" ("payment_status");



CREATE INDEX "idx_event_registrations_student" ON "public"."college_event_registrations" USING "btree" ("student_id");



CREATE INDEX "idx_exam_registrations_assessment" ON "public"."exam_registrations" USING "btree" ("assessment_id");



CREATE INDEX "idx_exam_registrations_hall_ticket" ON "public"."exam_registrations" USING "btree" ("hall_ticket_number");



CREATE INDEX "idx_exam_registrations_status" ON "public"."exam_registrations" USING "btree" ("status");



CREATE INDEX "idx_exam_registrations_student" ON "public"."exam_registrations" USING "btree" ("student_id");



CREATE INDEX "idx_exam_registrations_student_record" ON "public"."exam_registrations" USING "btree" ("student_record_id");



CREATE INDEX "idx_exam_registrations_window" ON "public"."exam_registrations" USING "btree" ("exam_window_id");



CREATE INDEX "idx_exam_rooms_building" ON "public"."exam_rooms" USING "btree" ("building");



CREATE INDEX "idx_exam_rooms_code" ON "public"."exam_rooms" USING "btree" ("room_code");



CREATE INDEX "idx_exam_rooms_college" ON "public"."exam_rooms" USING "btree" ("college_id");



CREATE INDEX "idx_exam_rooms_school" ON "public"."exam_rooms" USING "btree" ("school_id");



CREATE INDEX "idx_exam_rooms_status" ON "public"."exam_rooms" USING "btree" ("status");



CREATE INDEX "idx_exam_seating_attendance" ON "public"."exam_seating_arrangements" USING "btree" ("attendance_status");



CREATE INDEX "idx_exam_seating_room" ON "public"."exam_seating_arrangements" USING "btree" ("exam_room_id");



CREATE INDEX "idx_exam_seating_student" ON "public"."exam_seating_arrangements" USING "btree" ("student_id");



CREATE INDEX "idx_exam_seating_student_record" ON "public"."exam_seating_arrangements" USING "btree" ("student_record_id");



CREATE INDEX "idx_exam_seating_timetable" ON "public"."exam_seating_arrangements" USING "btree" ("exam_timetable_id");



CREATE INDEX "idx_exam_timetable_assessment" ON "public"."exam_timetable" USING "btree" ("assessment_id");



CREATE INDEX "idx_exam_timetable_date" ON "public"."exam_timetable" USING "btree" ("exam_date");



CREATE INDEX "idx_exam_timetable_room" ON "public"."exam_timetable" USING "btree" ("room");



CREATE INDEX "idx_exam_timetable_status" ON "public"."exam_timetable" USING "btree" ("status");



CREATE INDEX "idx_exam_windows_academic_year" ON "public"."exam_windows" USING "btree" ("academic_year");



CREATE INDEX "idx_exam_windows_college" ON "public"."exam_windows" USING "btree" ("college_id");



CREATE INDEX "idx_exam_windows_dates" ON "public"."exam_windows" USING "btree" ("start_date", "end_date");



CREATE INDEX "idx_exam_windows_school" ON "public"."exam_windows" USING "btree" ("school_id");



CREATE INDEX "idx_exam_windows_semester" ON "public"."exam_windows" USING "btree" ("semester");



CREATE INDEX "idx_exam_windows_status" ON "public"."exam_windows" USING "btree" ("status");



CREATE INDEX "idx_expenditures_budget" ON "public"."expenditures" USING "btree" ("budget_id");



CREATE INDEX "idx_expenditures_category" ON "public"."expenditures" USING "btree" ("category");



CREATE INDEX "idx_expenditures_date" ON "public"."expenditures" USING "btree" ("expenditure_date");



CREATE INDEX "idx_expenditures_department" ON "public"."expenditures" USING "btree" ("department_id");



CREATE INDEX "idx_expenditures_number" ON "public"."expenditures" USING "btree" ("expenditure_number");



CREATE INDEX "idx_expenditures_override" ON "public"."expenditures" USING "btree" ("is_override");



CREATE INDEX "idx_expenditures_payment_status" ON "public"."expenditures" USING "btree" ("payment_status");



CREATE INDEX "idx_expenditures_status" ON "public"."expenditures" USING "btree" ("status");



CREATE INDEX "idx_expenditures_vendor" ON "public"."expenditures" USING "btree" ("vendor_name");



CREATE INDEX "idx_experience_approval_authority" ON "public"."experience" USING "btree" ("approval_authority");



CREATE INDEX "idx_experience_approval_status" ON "public"."experience" USING "btree" ("approval_status");



CREATE INDEX "idx_experience_student" ON "public"."experience" USING "btree" ("student_id");



CREATE INDEX "idx_experience_student_id" ON "public"."experience" USING "btree" ("student_id");



CREATE INDEX "idx_export_activities_shortlist_id" ON "public"."export_activities" USING "btree" ("shortlist_id");



CREATE INDEX "idx_external_assessment_attempts_completed_at" ON "public"."external_assessment_attempts" USING "btree" ("completed_at" DESC);



CREATE INDEX "idx_external_assessment_attempts_course_name" ON "public"."external_assessment_attempts" USING "btree" ("course_name");



CREATE INDEX "idx_external_assessment_attempts_score" ON "public"."external_assessment_attempts" USING "btree" ("score");



CREATE INDEX "idx_external_assessment_attempts_status" ON "public"."external_assessment_attempts" USING "btree" ("status");



CREATE INDEX "idx_external_assessment_attempts_student_id" ON "public"."external_assessment_attempts" USING "btree" ("student_id");



CREATE UNIQUE INDEX "idx_external_assessment_one_per_course" ON "public"."external_assessment_attempts" USING "btree" ("student_id", "course_name");



CREATE INDEX "idx_external_courses_organization" ON "public"."external_courses" USING "btree" ("organization");



CREATE INDEX "idx_external_courses_student" ON "public"."external_courses" USING "btree" ("student_id");



CREATE INDEX "idx_external_courses_training" ON "public"."external_courses" USING "btree" ("training_id");



CREATE INDEX "idx_faculty_class_assignments_class" ON "public"."college_faculty_class_assignments" USING "btree" ("class_id");



CREATE INDEX "idx_faculty_class_assignments_college" ON "public"."college_faculty_class_assignments" USING "btree" ("college_id");



CREATE INDEX "idx_faculty_class_assignments_faculty" ON "public"."college_faculty_class_assignments" USING "btree" ("faculty_id");



CREATE INDEX "idx_faculty_leaves_college" ON "public"."college_faculty_leaves" USING "btree" ("college_id");



CREATE INDEX "idx_faculty_leaves_dates" ON "public"."college_faculty_leaves" USING "btree" ("start_date", "end_date");



CREATE INDEX "idx_faculty_leaves_faculty" ON "public"."college_faculty_leaves" USING "btree" ("faculty_id");



CREATE INDEX "idx_faculty_leaves_status" ON "public"."college_faculty_leaves" USING "btree" ("status");



CREATE INDEX "idx_fee_payments_date" ON "public"."fee_payments" USING "btree" ("payment_date");



CREATE INDEX "idx_fee_payments_ledger" ON "public"."fee_payments" USING "btree" ("ledger_id");



CREATE INDEX "idx_fee_payments_mode" ON "public"."fee_payments" USING "btree" ("mode");



CREATE INDEX "idx_fee_payments_receipt" ON "public"."fee_payments" USING "btree" ("receipt_number");



CREATE INDEX "idx_fee_payments_status" ON "public"."fee_payments" USING "btree" ("status");



CREATE INDEX "idx_fee_payments_student" ON "public"."fee_payments" USING "btree" ("student_id");



CREATE INDEX "idx_fee_payments_verified" ON "public"."fee_payments" USING "btree" ("is_verified");



CREATE INDEX "idx_fee_structures_academic_year" ON "public"."fee_structures" USING "btree" ("academic_year");



CREATE INDEX "idx_fee_structures_active" ON "public"."fee_structures" USING "btree" ("is_active");



CREATE INDEX "idx_fee_structures_category" ON "public"."fee_structures" USING "btree" ("category");



CREATE INDEX "idx_fee_structures_college_id" ON "public"."fee_structures" USING "btree" ("college_id");



CREATE INDEX "idx_fee_structures_program" ON "public"."fee_structures" USING "btree" ("program_id");



CREATE INDEX "idx_fee_structures_semester" ON "public"."fee_structures" USING "btree" ("semester");



CREATE INDEX "idx_generated_external_assessment_course_id" ON "public"."generated_external_assessment" USING "btree" ("course_id");



CREATE INDEX "idx_generated_external_assessment_name" ON "public"."generated_external_assessment" USING "btree" ("certificate_name");



CREATE INDEX "idx_grading_systems_active" ON "public"."grading_systems" USING "btree" ("is_active");



CREATE INDEX "idx_grading_systems_code" ON "public"."grading_systems" USING "btree" ("system_code");



CREATE INDEX "idx_grading_systems_default" ON "public"."grading_systems" USING "btree" ("is_default");



CREATE INDEX "idx_institution_pricing_active" ON "public"."institution_pricing_tiers" USING "btree" ("is_active");



CREATE INDEX "idx_institution_pricing_role_type" ON "public"."institution_pricing_tiers" USING "btree" ("role_type");



CREATE INDEX "idx_interactions_opportunity" ON "public"."opportunity_interactions" USING "btree" ("opportunity_id");



CREATE INDEX "idx_interactions_student" ON "public"."opportunity_interactions" USING "btree" ("student_id", "action");



CREATE INDEX "idx_internships_approval_status" ON "public"."internships" USING "btree" ("approval_status");



CREATE INDEX "idx_internships_created_at" ON "public"."internships" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_internships_enabled" ON "public"."internships" USING "btree" ("enabled");



CREATE INDEX "idx_internships_student_email" ON "public"."internships" USING "btree" ("student_email");



CREATE INDEX "idx_internships_student_enabled" ON "public"."internships" USING "btree" ("student_email", "enabled");



CREATE INDEX "idx_internships_student_id" ON "public"."internships" USING "btree" ("student_id");



CREATE INDEX "idx_interview_reminders_interview_id" ON "public"."interview_reminders" USING "btree" ("interview_id");



CREATE INDEX "idx_interview_reminders_sent_at" ON "public"."interview_reminders" USING "btree" ("sent_at");



CREATE INDEX "idx_interviews_created_by" ON "public"."interviews" USING "btree" ("created_by");



CREATE INDEX "idx_interviews_date" ON "public"."interviews" USING "btree" ("date");



CREATE INDEX "idx_interviews_status" ON "public"."interviews" USING "btree" ("status");



CREATE INDEX "idx_interviews_student_id" ON "public"."interviews" USING "btree" ("student_id");



CREATE INDEX "idx_invigilator_assignments_date" ON "public"."invigilator_assignments" USING "btree" ("duty_date");



CREATE INDEX "idx_invigilator_assignments_invigilator" ON "public"."invigilator_assignments" USING "btree" ("invigilator_id");



CREATE INDEX "idx_invigilator_assignments_room" ON "public"."invigilator_assignments" USING "btree" ("exam_room_id");



CREATE INDEX "idx_invigilator_assignments_status" ON "public"."invigilator_assignments" USING "btree" ("attendance_status");



CREATE INDEX "idx_invigilator_assignments_timetable" ON "public"."invigilator_assignments" USING "btree" ("exam_timetable_id");



CREATE INDEX "idx_invigilator_lecturer" ON "public"."invigilator_assignments" USING "btree" ("lecturer_record_id");



CREATE INDEX "idx_lesson_plans_chapter_id" ON "public"."lesson_plans" USING "btree" ("chapter_id");



CREATE INDEX "idx_lesson_plans_class" ON "public"."lesson_plans" USING "btree" ("class_id");



CREATE INDEX "idx_lesson_plans_date" ON "public"."lesson_plans" USING "btree" ("date");



CREATE INDEX "idx_lesson_plans_educator" ON "public"."lesson_plans" USING "btree" ("educator_id");



CREATE INDEX "idx_lesson_plans_status" ON "public"."lesson_plans" USING "btree" ("status");



CREATE INDEX "idx_lessons_module" ON "public"."lessons" USING "btree" ("module_id");



CREATE INDEX "idx_lessons_order" ON "public"."lessons" USING "btree" ("module_id", "order_index");



CREATE INDEX "idx_library_book_issues_book_id" ON "public"."library_book_issues" USING "btree" ("book_id");



CREATE INDEX "idx_library_book_issues_college_book_id" ON "public"."library_book_issues_college" USING "btree" ("book_id");



CREATE INDEX "idx_library_book_issues_college_college_id" ON "public"."library_book_issues_college" USING "btree" ("college_id");



CREATE INDEX "idx_library_book_issues_college_due_date" ON "public"."library_book_issues_college" USING "btree" ("college_id", "due_date");



CREATE INDEX "idx_library_book_issues_college_issue_date" ON "public"."library_book_issues_college" USING "btree" ("college_id", "issue_date");



CREATE INDEX "idx_library_book_issues_college_return_date" ON "public"."library_book_issues_college" USING "btree" ("college_id", "return_date");



CREATE INDEX "idx_library_book_issues_college_status" ON "public"."library_book_issues_college" USING "btree" ("college_id", "status");



CREATE INDEX "idx_library_book_issues_college_student_id" ON "public"."library_book_issues_college" USING "btree" ("college_id", "student_id");



CREATE INDEX "idx_library_book_issues_due_date" ON "public"."library_book_issues" USING "btree" ("due_date");



CREATE INDEX "idx_library_book_issues_issue_date" ON "public"."library_book_issues" USING "btree" ("issue_date");



CREATE INDEX "idx_library_book_issues_return_date" ON "public"."library_book_issues" USING "btree" ("return_date");



CREATE INDEX "idx_library_book_issues_school_book_id" ON "public"."library_book_issues_school" USING "btree" ("book_id");



CREATE INDEX "idx_library_book_issues_school_due_date" ON "public"."library_book_issues_school" USING "btree" ("school_id", "due_date");



CREATE INDEX "idx_library_book_issues_school_issue_date" ON "public"."library_book_issues_school" USING "btree" ("school_id", "issue_date");



CREATE INDEX "idx_library_book_issues_school_return_date" ON "public"."library_book_issues_school" USING "btree" ("school_id", "return_date");



CREATE INDEX "idx_library_book_issues_school_school_id" ON "public"."library_book_issues_school" USING "btree" ("school_id");



CREATE INDEX "idx_library_book_issues_school_status" ON "public"."library_book_issues_school" USING "btree" ("school_id", "status");



CREATE INDEX "idx_library_book_issues_school_student_id" ON "public"."library_book_issues_school" USING "btree" ("student_id");



CREATE INDEX "idx_library_book_issues_status" ON "public"."library_book_issues" USING "btree" ("status");



CREATE INDEX "idx_library_book_issues_student_id" ON "public"."library_book_issues" USING "btree" ("student_id");



CREATE INDEX "idx_library_books_author" ON "public"."library_books" USING "gin" ("to_tsvector"('"english"'::"regconfig", "author"));



CREATE INDEX "idx_library_books_available" ON "public"."library_books" USING "btree" ("available_copies") WHERE ("available_copies" > 0);



CREATE INDEX "idx_library_books_book_id" ON "public"."library_books" USING "btree" ("book_id");



CREATE INDEX "idx_library_books_category" ON "public"."library_books" USING "btree" ("category");



CREATE INDEX "idx_library_books_college" ON "public"."library_books" USING "btree" ("college_id");



CREATE INDEX "idx_library_books_college_author" ON "public"."library_books_college" USING "btree" ("college_id", "author");



CREATE INDEX "idx_library_books_college_category" ON "public"."library_books_college" USING "btree" ("college_id", "category");



CREATE INDEX "idx_library_books_college_college_id" ON "public"."library_books_college" USING "btree" ("college_id");



CREATE INDEX "idx_library_books_college_isbn" ON "public"."library_books_college" USING "btree" ("college_id", "isbn");



CREATE INDEX "idx_library_books_college_status" ON "public"."library_books_college" USING "btree" ("college_id", "status");



CREATE INDEX "idx_library_books_college_title" ON "public"."library_books_college" USING "btree" ("college_id", "title");



CREATE INDEX "idx_library_books_department" ON "public"."library_books" USING "btree" ("department_id");



CREATE INDEX "idx_library_books_isbn" ON "public"."library_books" USING "btree" ("isbn");



CREATE INDEX "idx_library_books_location" ON "public"."library_books" USING "btree" ("location");



CREATE INDEX "idx_library_books_school_author" ON "public"."library_books_school" USING "btree" ("school_id", "author");



CREATE INDEX "idx_library_books_school_category" ON "public"."library_books_school" USING "btree" ("school_id", "category");



CREATE INDEX "idx_library_books_school_isbn" ON "public"."library_books_school" USING "btree" ("school_id", "isbn");



CREATE INDEX "idx_library_books_school_school_id" ON "public"."library_books_school" USING "btree" ("school_id");



CREATE INDEX "idx_library_books_school_status" ON "public"."library_books_school" USING "btree" ("school_id", "status");



CREATE INDEX "idx_library_books_school_title" ON "public"."library_books_school" USING "btree" ("school_id", "title");



CREATE INDEX "idx_library_books_status" ON "public"."library_books" USING "btree" ("status");



CREATE INDEX "idx_library_books_title" ON "public"."library_books" USING "gin" ("to_tsvector"('"english"'::"regconfig", "title"));



CREATE INDEX "idx_library_categories_school_school_id" ON "public"."library_categories_school" USING "btree" ("school_id");



CREATE INDEX "idx_library_history_academic_year" ON "public"."library_history" USING "btree" ("academic_year");



CREATE INDEX "idx_library_history_book" ON "public"."library_history" USING "btree" ("book_id");



CREATE INDEX "idx_library_history_department" ON "public"."library_history" USING "btree" ("department_id");



CREATE INDEX "idx_library_history_issue_date" ON "public"."library_history" USING "btree" ("issue_date");



CREATE INDEX "idx_library_history_return_date" ON "public"."library_history" USING "btree" ("return_date");



CREATE INDEX "idx_library_history_status" ON "public"."library_history" USING "btree" ("status");



CREATE INDEX "idx_library_history_student" ON "public"."library_history" USING "btree" ("student_id");



CREATE INDEX "idx_library_history_student_record" ON "public"."library_history" USING "btree" ("student_record_id");



CREATE INDEX "idx_library_issued_books_academic_year" ON "public"."library_issued_books" USING "btree" ("academic_year");



CREATE INDEX "idx_library_issued_books_book" ON "public"."library_issued_books" USING "btree" ("book_id");



CREATE INDEX "idx_library_issued_books_department" ON "public"."library_issued_books" USING "btree" ("department_id");



CREATE INDEX "idx_library_issued_books_due_date" ON "public"."library_issued_books" USING "btree" ("due_date");



CREATE INDEX "idx_library_issued_books_overdue" ON "public"."library_issued_books" USING "btree" ("days_overdue") WHERE ("days_overdue" > 0);



CREATE INDEX "idx_library_issued_books_status" ON "public"."library_issued_books" USING "btree" ("status");



CREATE INDEX "idx_library_issued_books_student" ON "public"."library_issued_books" USING "btree" ("student_id");



CREATE INDEX "idx_library_issued_books_student_record" ON "public"."library_issued_books" USING "btree" ("student_record_id");



CREATE INDEX "idx_library_reservations_book" ON "public"."library_reservations" USING "btree" ("book_id");



CREATE INDEX "idx_library_reservations_priority" ON "public"."library_reservations" USING "btree" ("priority");



CREATE INDEX "idx_library_reservations_status" ON "public"."library_reservations" USING "btree" ("status");



CREATE INDEX "idx_library_reservations_student" ON "public"."library_reservations" USING "btree" ("student_id");



CREATE UNIQUE INDEX "idx_library_reservations_unique_active" ON "public"."library_reservations" USING "btree" ("book_id", "student_id") WHERE ("status" = 'active'::"text");



CREATE INDEX "idx_library_reviews_approved" ON "public"."library_reviews" USING "btree" ("is_approved");



CREATE INDEX "idx_library_reviews_book" ON "public"."library_reviews" USING "btree" ("book_id");



CREATE INDEX "idx_library_reviews_rating" ON "public"."library_reviews" USING "btree" ("rating");



CREATE INDEX "idx_library_reviews_student" ON "public"."library_reviews" USING "btree" ("student_id");



CREATE INDEX "idx_library_settings_school_key" ON "public"."library_settings_school" USING "btree" ("school_id", "setting_key");



CREATE INDEX "idx_library_settings_school_school_id" ON "public"."library_settings_school" USING "btree" ("school_id");



CREATE INDEX "idx_license_assign_assigned_by" ON "public"."license_assignments" USING "btree" ("assigned_by");



CREATE INDEX "idx_license_assign_expires_at" ON "public"."license_assignments" USING "btree" ("expires_at") WHERE ("expires_at" IS NOT NULL);



CREATE INDEX "idx_license_assign_org_sub" ON "public"."license_assignments" USING "btree" ("organization_subscription_id");



CREATE INDEX "idx_license_assign_pool" ON "public"."license_assignments" USING "btree" ("license_pool_id");



CREATE INDEX "idx_license_assign_pool_status" ON "public"."license_assignments" USING "btree" ("license_pool_id", "status");



CREATE INDEX "idx_license_assign_status" ON "public"."license_assignments" USING "btree" ("status");



CREATE INDEX "idx_license_assign_user" ON "public"."license_assignments" USING "btree" ("user_id");



CREATE INDEX "idx_license_assign_user_status" ON "public"."license_assignments" USING "btree" ("user_id", "status");



CREATE INDEX "idx_license_pools_is_active" ON "public"."license_pools" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_license_pools_member_type" ON "public"."license_pools" USING "btree" ("member_type");



CREATE INDEX "idx_license_pools_org_id" ON "public"."license_pools" USING "btree" ("organization_id");



CREATE INDEX "idx_license_pools_org_member" ON "public"."license_pools" USING "btree" ("organization_id", "member_type", "is_active");



CREATE INDEX "idx_license_pools_org_sub" ON "public"."license_pools" USING "btree" ("organization_subscription_id");



CREATE INDEX "idx_license_pools_org_type" ON "public"."license_pools" USING "btree" ("organization_type");



CREATE INDEX "idx_mappings_assessment" ON "public"."outcome_assessment_mappings" USING "btree" ("assessment_type_id");



CREATE INDEX "idx_mappings_outcome" ON "public"."outcome_assessment_mappings" USING "btree" ("learning_outcome_id");



CREATE INDEX "idx_mark_entries_absent" ON "public"."mark_entries" USING "btree" ("is_absent");



CREATE INDEX "idx_mark_entries_assessment" ON "public"."mark_entries" USING "btree" ("assessment_id");



CREATE INDEX "idx_mark_entries_assessment_subject" ON "public"."mark_entries" USING "btree" ("assessment_id", "subject_id");



CREATE INDEX "idx_mark_entries_grade" ON "public"."mark_entries" USING "btree" ("grade");



CREATE INDEX "idx_mark_entries_locked" ON "public"."mark_entries" USING "btree" ("is_locked");



CREATE INDEX "idx_mark_entries_student" ON "public"."mark_entries" USING "btree" ("student_id");



CREATE INDEX "idx_mark_entries_student_record" ON "public"."mark_entries" USING "btree" ("student_record_id");



CREATE INDEX "idx_mark_entries_subject_id" ON "public"."mark_entries" USING "btree" ("subject_id");



CREATE INDEX "idx_mark_entry_batches_assessment" ON "public"."mark_entry_batches" USING "btree" ("assessment_id");



CREATE INDEX "idx_mark_entry_batches_entered_by" ON "public"."mark_entry_batches" USING "btree" ("entered_by");



CREATE INDEX "idx_mark_entry_batches_status" ON "public"."mark_entry_batches" USING "btree" ("status");



CREATE INDEX "idx_mark_moderation_log_assessment" ON "public"."mark_moderation_log" USING "btree" ("assessment_id");



CREATE INDEX "idx_mark_moderation_log_entry" ON "public"."mark_moderation_log" USING "btree" ("mark_entry_id");



CREATE INDEX "idx_mark_moderation_log_moderator" ON "public"."mark_moderation_log" USING "btree" ("moderated_by");



CREATE INDEX "idx_mark_moderation_log_student" ON "public"."mark_moderation_log" USING "btree" ("student_id");



CREATE INDEX "idx_mark_moderation_log_type" ON "public"."mark_moderation_log" USING "btree" ("moderation_type");



CREATE INDEX "idx_mentor_notes_created_by" ON "public"."college_mentor_notes" USING "btree" ("created_by_id");



CREATE INDEX "idx_mentor_notes_follow_up" ON "public"."college_mentor_notes" USING "btree" ("follow_up_date") WHERE ("follow_up_required" = true);



CREATE INDEX "idx_mentor_notes_priority" ON "public"."college_mentor_notes" USING "btree" ("priority");



CREATE INDEX "idx_messages_application_id" ON "public"."messages" USING "btree" ("application_id");



CREATE INDEX "idx_messages_class_id" ON "public"."messages" USING "btree" ("class_id");



CREATE INDEX "idx_messages_conversation_created" ON "public"."messages" USING "btree" ("conversation_id", "created_at" DESC);



CREATE INDEX "idx_messages_conversation_id" ON "public"."messages" USING "btree" ("conversation_id");



CREATE INDEX "idx_messages_created_at" ON "public"."messages" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_messages_is_read" ON "public"."messages" USING "btree" ("is_read");



CREATE INDEX "idx_messages_opportunity_id" ON "public"."messages" USING "btree" ("opportunity_id");



CREATE INDEX "idx_messages_program_section_id" ON "public"."messages" USING "btree" ("program_section_id");



CREATE INDEX "idx_messages_receiver_id" ON "public"."messages" USING "btree" ("receiver_id");



CREATE INDEX "idx_messages_receiver_type" ON "public"."messages" USING "btree" ("receiver_type");



CREATE INDEX "idx_messages_receiver_unread" ON "public"."messages" USING "btree" ("receiver_id", "is_read") WHERE ("is_read" = false);



CREATE INDEX "idx_messages_sender_id" ON "public"."messages" USING "btree" ("sender_id");



CREATE INDEX "idx_messages_sender_type" ON "public"."messages" USING "btree" ("sender_type");



CREATE INDEX "idx_messages_subject" ON "public"."messages" USING "btree" ("subject");



CREATE INDEX "idx_metrics_date" ON "public"."metrics_snapshots" USING "btree" ("snapshotDate" DESC);



CREATE INDEX "idx_metrics_snapshotdate" ON "public"."metrics_snapshots" USING "btree" ("snapshotDate" DESC);



CREATE INDEX "idx_modules_course" ON "public"."course_modules" USING "btree" ("course_id");



CREATE INDEX "idx_modules_order" ON "public"."course_modules" USING "btree" ("course_id", "order_index");



CREATE INDEX "idx_notification_log_sent_at" ON "public"."streak_notification_log" USING "btree" ("sent_at" DESC);



CREATE INDEX "idx_notification_log_status" ON "public"."streak_notification_log" USING "btree" ("status");



CREATE INDEX "idx_notification_log_student_date" ON "public"."streak_notification_log" USING "btree" ("student_id", "notification_date");



CREATE INDEX "idx_notification_log_student_id" ON "public"."streak_notification_log" USING "btree" ("student_id");



CREATE INDEX "idx_notifications_created" ON "public"."notifications" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_notifications_read" ON "public"."notifications" USING "btree" ("read");



CREATE INDEX "idx_notifications_recipient_created" ON "public"."notifications" USING "btree" ("recipient_id", "created_at" DESC);



CREATE INDEX "idx_notifications_recruiter" ON "public"."notifications" USING "btree" ("recipient_id");



CREATE INDEX "idx_notifications_scheduled" ON "public"."notifications" USING "btree" ("status", "scheduled_for") WHERE (("status")::"text" = 'scheduled'::"text");



CREATE INDEX "idx_notifications_type_created" ON "public"."notifications" USING "btree" ("type", "created_at" DESC);



CREATE INDEX "idx_offers_candidate_name_lower" ON "public"."offers" USING "btree" ("lower"("candidate_name"));



CREATE INDEX "idx_offers_expiry_date" ON "public"."offers" USING "btree" ("expiry_date");



CREATE INDEX "idx_offers_inserted_at" ON "public"."offers" USING "btree" ("inserted_at" DESC);



CREATE INDEX "idx_offers_job_title_lower" ON "public"."offers" USING "btree" ("lower"("job_title"));



CREATE INDEX "idx_offers_offer_date" ON "public"."offers" USING "btree" ("offer_date");



CREATE INDEX "idx_offers_sent_via" ON "public"."offers" USING "btree" ("sent_via");



CREATE INDEX "idx_offers_status" ON "public"."offers" USING "btree" ("status");



CREATE INDEX "idx_offers_status_expiry" ON "public"."offers" USING "btree" ("status", "expiry_date");



CREATE INDEX "idx_offers_status_inserted" ON "public"."offers" USING "btree" ("status", "inserted_at" DESC);



CREATE INDEX "idx_offers_template" ON "public"."offers" USING "btree" ("template");



CREATE INDEX "idx_opportunities_active_posted" ON "public"."opportunities" USING "btree" ("is_active", "posted_date" DESC) WHERE ("is_active" = true);



CREATE INDEX "idx_opportunities_active_status_deadline" ON "public"."opportunities" USING "btree" ("is_active", "status", "deadline") WHERE (("is_active" = true) AND ("status" = 'open'::"text"));



COMMENT ON INDEX "public"."idx_opportunities_active_status_deadline" IS 'Main filter for active opportunities. Critical for performance.';



CREATE INDEX "idx_opportunities_company_name" ON "public"."opportunities" USING "btree" ("lower"("company_name"));



CREATE INDEX "idx_opportunities_cost" ON "public"."opportunities" USING "btree" ("cost_inr");



CREATE INDEX "idx_opportunities_created_at" ON "public"."opportunities" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_opportunities_deadline" ON "public"."opportunities" USING "btree" ("deadline", "closing_date");



CREATE INDEX "idx_opportunities_description_lower" ON "public"."opportunities" USING "btree" ("lower"("description")) WHERE ("description" IS NOT NULL);



COMMENT ON INDEX "public"."idx_opportunities_description_lower" IS 'Speeds up LIKE queries on description for course alignment.';



CREATE INDEX "idx_opportunities_embedding" ON "public"."opportunities" USING "ivfflat" ("embedding" "extensions"."vector_cosine_ops") WITH ("lists"='100');



CREATE INDEX "idx_opportunities_embedding_hnsw" ON "public"."opportunities" USING "hnsw" ("embedding" "extensions"."vector_cosine_ops") WITH ("m"='16', "ef_construction"='64');



CREATE INDEX "idx_opportunities_employment_type" ON "public"."opportunities" USING "btree" ("employment_type") WHERE ("employment_type" IS NOT NULL);



COMMENT ON INDEX "public"."idx_opportunities_employment_type" IS 'Speeds up full-time filtering for UG students.';



CREATE INDEX "idx_opportunities_experience_level" ON "public"."opportunities" USING "btree" ("experience_level") WHERE ("experience_level" IS NOT NULL);



COMMENT ON INDEX "public"."idx_opportunities_experience_level" IS 'Speeds up experience level matching.';



CREATE INDEX "idx_opportunities_exposure_type" ON "public"."opportunities" USING "btree" ("exposure_type");



CREATE INDEX "idx_opportunities_job_title" ON "public"."opportunities" USING "btree" ("lower"("job_title"));



CREATE INDEX "idx_opportunities_posted_date" ON "public"."opportunities" USING "btree" ("posted_date" DESC NULLS LAST);



CREATE INDEX "idx_opportunities_requisition_id" ON "public"."opportunities" USING "btree" ("requisition_id");



CREATE INDEX "idx_opportunities_salary" ON "public"."opportunities" USING "btree" ("salary_range_max" DESC, "salary_range_min" DESC);



CREATE INDEX "idx_opportunities_search" ON "public"."opportunities" USING "gin" ("to_tsvector"('"english"'::"regconfig", ((((((((((COALESCE("job_title", ''::"text") || ' '::"text") || COALESCE("title", ''::"text")) || ' '::"text") || COALESCE("company_name", ''::"text")) || ' '::"text") || COALESCE("description", ''::"text")) || ' '::"text") || COALESCE("sector", ''::"text")) || ' '::"text") || COALESCE("exposure_type", ''::"text"))));



CREATE INDEX "idx_opportunities_sector" ON "public"."opportunities" USING "btree" ("sector");



CREATE INDEX "idx_opportunities_skills_gin" ON "public"."opportunities" USING "gin" ("skills_required");



CREATE INDEX "idx_opportunities_title_lower" ON "public"."opportunities" USING "btree" ("lower"("title"));



COMMENT ON INDEX "public"."idx_opportunities_title_lower" IS 'Speeds up LIKE queries for course alignment (blockchain, python, etc).';



CREATE INDEX "idx_opportunity_interactions_action" ON "public"."opportunity_interactions" USING "btree" ("action");



CREATE INDEX "idx_opportunity_interactions_opportunity" ON "public"."opportunity_interactions" USING "btree" ("opportunity_id", "action");



COMMENT ON INDEX "public"."idx_opportunity_interactions_opportunity" IS 'Speeds up opportunity popularity calculations.';



CREATE INDEX "idx_opportunity_interactions_student" ON "public"."opportunity_interactions" USING "btree" ("student_id");



CREATE INDEX "idx_opportunity_interactions_student_action" ON "public"."opportunity_interactions" USING "btree" ("student_id", "action");



COMMENT ON INDEX "public"."idx_opportunity_interactions_student_action" IS 'Speeds up dismissed opportunities lookup.';



CREATE INDEX "idx_org_invitations_email" ON "public"."organization_invitations" USING "btree" ("invitee_email") WHERE ("status" = 'pending'::"text");



CREATE INDEX "idx_org_invitations_expired" ON "public"."organization_invitations" USING "btree" ("expires_at") WHERE ("status" = 'pending'::"text");



CREATE INDEX "idx_org_invitations_invited_by" ON "public"."organization_invitations" USING "btree" ("invited_by", "created_at" DESC);



CREATE INDEX "idx_org_invitations_license_pool" ON "public"."organization_invitations" USING "btree" ("license_pool_id") WHERE (("license_pool_id" IS NOT NULL) AND ("status" = 'pending'::"text"));



CREATE INDEX "idx_org_invitations_organization" ON "public"."organization_invitations" USING "btree" ("organization_id", "organization_type");



CREATE INDEX "idx_org_invitations_pending_active" ON "public"."organization_invitations" USING "btree" ("organization_id", "status", "expires_at") WHERE ("status" = 'pending'::"text");



CREATE INDEX "idx_org_invitations_status" ON "public"."organization_invitations" USING "btree" ("status", "expires_at");



CREATE INDEX "idx_org_invitations_token" ON "public"."organization_invitations" USING "btree" ("invitation_token") WHERE ("status" = 'pending'::"text");



CREATE INDEX "idx_org_subs_end_date" ON "public"."organization_subscriptions" USING "btree" ("end_date");



CREATE INDEX "idx_org_subs_org_id" ON "public"."organization_subscriptions" USING "btree" ("organization_id");



CREATE INDEX "idx_org_subs_org_status" ON "public"."organization_subscriptions" USING "btree" ("organization_id", "status");



CREATE INDEX "idx_org_subs_org_type" ON "public"."organization_subscriptions" USING "btree" ("organization_type");



CREATE INDEX "idx_org_subs_plan_id" ON "public"."organization_subscriptions" USING "btree" ("subscription_plan_id");



CREATE INDEX "idx_org_subs_purchased_by" ON "public"."organization_subscriptions" USING "btree" ("purchased_by");



CREATE INDEX "idx_org_subs_status" ON "public"."organization_subscriptions" USING "btree" ("status");



CREATE INDEX "idx_org_subscriptions_razorpay_payment_id" ON "public"."organization_subscriptions" USING "btree" ("razorpay_payment_id");



CREATE INDEX "idx_organizations_admin_id" ON "public"."organizations" USING "btree" ("admin_id");



CREATE INDEX "idx_organizations_code" ON "public"."organizations" USING "btree" ("code");



CREATE INDEX "idx_organizations_name" ON "public"."organizations" USING "btree" ("name");



CREATE INDEX "idx_organizations_type" ON "public"."organizations" USING "btree" ("organization_type");



CREATE INDEX "idx_otp_requests_log_phone_created" ON "public"."otp_requests_log" USING "btree" ("phone", "created_at");



CREATE INDEX "idx_outcomes_bloom" ON "public"."curriculum_learning_outcomes" USING "btree" ("bloom_level");



CREATE INDEX "idx_outcomes_chapter" ON "public"."curriculum_learning_outcomes" USING "btree" ("chapter_id");



CREATE INDEX "idx_passports_assessments_gin" ON "public"."skill_passports" USING "gin" ("assessments");



CREATE INDEX "idx_passports_certificates_gin" ON "public"."skill_passports" USING "gin" ("certificates");



CREATE INDEX "idx_passports_createdat" ON "public"."skill_passports" USING "btree" ("createdAt" DESC);



CREATE INDEX "idx_passports_nsqflevel" ON "public"."skill_passports" USING "btree" ("nsqfLevel");



CREATE INDEX "idx_passports_projects_gin" ON "public"."skill_passports" USING "gin" ("projects");



CREATE INDEX "idx_passports_status" ON "public"."skill_passports" USING "btree" ("status");



CREATE INDEX "idx_passports_status_nsqf" ON "public"."skill_passports" USING "btree" ("status", "nsqfLevel");



CREATE INDEX "idx_passports_student" ON "public"."skill_passports" USING "btree" ("studentId");



CREATE INDEX "idx_passports_student_status" ON "public"."skill_passports" USING "btree" ("studentId", "status");



CREATE INDEX "idx_passports_studentid" ON "public"."skill_passports" USING "btree" ("studentId");



CREATE INDEX "idx_passports_updatedat" ON "public"."skill_passports" USING "btree" ("updatedAt" DESC);



CREATE INDEX "idx_payment_transactions_bulk" ON "public"."payment_transactions" USING "btree" ("is_bulk_purchase", "created_at" DESC) WHERE ("is_bulk_purchase" = true);



CREATE INDEX "idx_payment_transactions_org_history" ON "public"."payment_transactions" USING "btree" ("organization_id", "status", "created_at" DESC) WHERE ("organization_id" IS NOT NULL);



CREATE INDEX "idx_payment_transactions_organization" ON "public"."payment_transactions" USING "btree" ("organization_id", "organization_type") WHERE ("is_bulk_purchase" = true);



CREATE INDEX "idx_payment_transactions_razorpay_payment_id" ON "public"."payment_transactions" USING "btree" ("razorpay_payment_id");



CREATE INDEX "idx_payment_transactions_subscription_id" ON "public"."payment_transactions" USING "btree" ("subscription_id");



CREATE INDEX "idx_payment_transactions_type" ON "public"."payment_transactions" USING "btree" ("transaction_type");



CREATE INDEX "idx_payment_transactions_user_id" ON "public"."payment_transactions" USING "btree" ("user_id");



CREATE INDEX "idx_permissions_action" ON "public"."permissions" USING "btree" ("action");



CREATE INDEX "idx_permissions_resource" ON "public"."permissions" USING "btree" ("resource");



CREATE INDEX "idx_phone_otps_expires_at" ON "public"."phone_otps" USING "btree" ("expires_at");



CREATE INDEX "idx_phone_otps_phone" ON "public"."phone_otps" USING "btree" ("phone");



CREATE INDEX "idx_pipeline_activities_created_at" ON "public"."pipeline_activities" USING "btree" ("created_at");



CREATE INDEX "idx_pipeline_activities_pipeline_candidate_id" ON "public"."pipeline_activities" USING "btree" ("pipeline_candidate_id");



CREATE INDEX "idx_pipeline_activities_student_id" ON "public"."pipeline_activities" USING "btree" ("student_id");



CREATE INDEX "idx_pipeline_candidates_next_action_date" ON "public"."pipeline_candidates" USING "btree" ("next_action_date");



CREATE INDEX "idx_pipeline_candidates_stage" ON "public"."pipeline_candidates" USING "btree" ("stage");



CREATE INDEX "idx_pipeline_candidates_status" ON "public"."pipeline_candidates" USING "btree" ("status");



CREATE INDEX "idx_pipeline_candidates_student_id" ON "public"."pipeline_candidates" USING "btree" ("student_id");



CREATE INDEX "idx_pipeline_opportunity_id" ON "public"."pipeline_candidates" USING "btree" ("opportunity_id_old");



CREATE INDEX "idx_placements_hired_date" ON "public"."placements" USING "btree" ("hiredDate" DESC);



CREATE INDEX "idx_placements_recruiter" ON "public"."placements" USING "btree" ("recruiterId");



CREATE INDEX "idx_placements_status" ON "public"."placements" USING "btree" ("placementStatus");



CREATE INDEX "idx_placements_student" ON "public"."placements" USING "btree" ("studentId");



CREATE INDEX "idx_plan_features_category" ON "public"."subscription_plan_features" USING "btree" ("category");



CREATE INDEX "idx_plan_features_plan_id" ON "public"."subscription_plan_features" USING "btree" ("plan_id");



CREATE INDEX "idx_pre_registrations_email_status" ON "public"."pre_registrations" USING "btree" ("email", "payment_status");



CREATE UNIQUE INDEX "idx_pre_registrations_email_unique" ON "public"."pre_registrations" USING "btree" ("lower"("email"));



CREATE INDEX "idx_pre_registrations_payment_history" ON "public"."pre_registrations" USING "gin" ("payment_history");



CREATE INDEX "idx_pre_registrations_payment_status" ON "public"."pre_registrations" USING "btree" ("payment_status");



CREATE INDEX "idx_profile_views_date" ON "public"."profile_views" USING "btree" ("viewed_at");



CREATE INDEX "idx_profile_views_student" ON "public"."profile_views" USING "btree" ("student_id");



CREATE INDEX "idx_program_sections_department" ON "public"."program_sections" USING "btree" ("department_id");



CREATE INDEX "idx_program_sections_faculty" ON "public"."program_sections" USING "btree" ("faculty_id");



CREATE INDEX "idx_program_sections_program" ON "public"."program_sections" USING "btree" ("program_id");



CREATE INDEX "idx_program_sections_status" ON "public"."program_sections" USING "btree" ("status");



CREATE INDEX "idx_programs_department" ON "public"."programs" USING "btree" ("department_id");



CREATE INDEX "idx_progress_active" ON "public"."student_course_progress" USING "btree" ("student_id", "course_id") WHERE (("status")::"text" = 'in_progress'::"text");



CREATE INDEX "idx_progress_lesson_lookup" ON "public"."student_course_progress" USING "btree" ("student_id", "course_id", "lesson_id");



CREATE INDEX "idx_projects_created_at" ON "public"."projects" USING "btree" ("student_id", "created_at" DESC) WHERE ("enabled" = true);



CREATE INDEX "idx_projects_student" ON "public"."projects" USING "btree" ("student_id");



COMMENT ON INDEX "public"."idx_projects_student" IS 'Speeds up EXISTS check for profile completeness calculation.';



CREATE INDEX "idx_projects_student_id" ON "public"."projects" USING "btree" ("student_id");



CREATE INDEX "idx_projects_student_lookup" ON "public"."projects" USING "btree" ("student_id", "enabled", "approval_status") WHERE (("enabled" = true) AND (("approval_status")::"text" = ANY (ARRAY[('approved'::character varying)::"text", ('verified'::character varying)::"text"])));



CREATE INDEX "idx_promotional_events_active" ON "public"."promotional_events" USING "btree" ("is_active", "start_date", "end_date");



CREATE INDEX "idx_promotional_events_code" ON "public"."promotional_events" USING "btree" ("event_code");



CREATE INDEX "idx_questions_cache_active" ON "public"."adaptive_aptitude_questions_cache" USING "btree" ("is_active");



CREATE INDEX "idx_questions_cache_difficulty" ON "public"."adaptive_aptitude_questions_cache" USING "btree" ("difficulty");



CREATE INDEX "idx_questions_cache_grade_level" ON "public"."adaptive_aptitude_questions_cache" USING "btree" ("grade_level");



CREATE INDEX "idx_questions_cache_lookup" ON "public"."adaptive_aptitude_questions_cache" USING "btree" ("grade_level", "phase", "difficulty", "subtag") WHERE ("is_active" = true);



CREATE INDEX "idx_questions_cache_options_gin" ON "public"."adaptive_aptitude_questions_cache" USING "gin" ("options");



CREATE INDEX "idx_questions_cache_phase" ON "public"."adaptive_aptitude_questions_cache" USING "btree" ("phase");



CREATE INDEX "idx_questions_cache_question_id" ON "public"."adaptive_aptitude_questions_cache" USING "btree" ("question_id");



CREATE INDEX "idx_questions_cache_subtag" ON "public"."adaptive_aptitude_questions_cache" USING "btree" ("subtag");



CREATE INDEX "idx_questions_stream_id" ON "public"."personal_assessment_questions" USING "btree" ("stream_id");



CREATE INDEX "idx_quiz_progress_lookup" ON "public"."student_quiz_progress" USING "btree" ("student_id", "quiz_id", "attempt_number");



CREATE INDEX "idx_quiz_progress_status" ON "public"."student_quiz_progress" USING "btree" ("status") WHERE (("status")::"text" = 'in_progress'::"text");



CREATE INDEX "idx_quiz_progress_student_course" ON "public"."student_quiz_progress" USING "btree" ("student_id", "course_id");



CREATE INDEX "idx_quizzes_lesson_id" ON "public"."quizzes" USING "btree" ("lesson_id");



CREATE INDEX "idx_razorpay_orders_order_id" ON "public"."razorpay_orders" USING "btree" ("order_id");



CREATE INDEX "idx_razorpay_orders_payment_id" ON "public"."razorpay_orders" USING "btree" ("razorpay_payment_id");



CREATE INDEX "idx_razorpay_orders_status" ON "public"."razorpay_orders" USING "btree" ("status");



CREATE INDEX "idx_razorpay_orders_subscription_id" ON "public"."razorpay_orders" USING "btree" ("subscription_id");



CREATE INDEX "idx_razorpay_orders_user_id" ON "public"."razorpay_orders" USING "btree" ("user_id");



CREATE INDEX "idx_razorpay_orders_user_status" ON "public"."razorpay_orders" USING "btree" ("user_id", "status");



CREATE INDEX "idx_recent_updates_student" ON "public"."recent_updates" USING "btree" ("student_id");



CREATE INDEX "idx_recent_updates_updated_at" ON "public"."recent_updates" USING "btree" ("updated_at");



CREATE INDEX "idx_recommendations_assessment" ON "public"."student_course_recommendations" USING "btree" ("assessment_result_id");



CREATE INDEX "idx_recommendations_course" ON "public"."student_course_recommendations" USING "btree" ("course_id");



CREATE INDEX "idx_recommendations_status" ON "public"."student_course_recommendations" USING "btree" ("status");



CREATE INDEX "idx_recommendations_student" ON "public"."student_course_recommendations" USING "btree" ("student_id");



CREATE INDEX "idx_recommendations_student_status" ON "public"."student_course_recommendations" USING "btree" ("student_id", "status");



CREATE INDEX "idx_recruiter_activities_created" ON "public"."recruiter_activities" USING "btree" ("createdAt" DESC);



CREATE INDEX "idx_recruiter_activities_recruiter" ON "public"."recruiter_activities" USING "btree" ("recruiterId");



CREATE INDEX "idx_recruiter_activities_student" ON "public"."recruiter_activities" USING "btree" ("targetStudentId");



CREATE INDEX "idx_recruiter_activities_type" ON "public"."recruiter_activities" USING "btree" ("activityType");



CREATE INDEX "idx_recruiters_approval" ON "public"."recruiters" USING "btree" ("approval_status");



CREATE INDEX "idx_recruiters_createdat" ON "public"."recruiters" USING "btree" ("createdat" DESC);



CREATE INDEX "idx_recruiters_email" ON "public"."recruiters" USING "btree" ("email");



CREATE INDEX "idx_recruiters_isactive" ON "public"."recruiters" USING "btree" ("isactive");



CREATE INDEX "idx_recruiters_name_trgm" ON "public"."recruiters" USING "gin" ("name" "extensions"."gin_trgm_ops");



CREATE INDEX "idx_recruiters_state" ON "public"."recruiters" USING "btree" ("state");



CREATE INDEX "idx_recruiters_state_status" ON "public"."recruiters" USING "btree" ("state", "verificationstatus");



CREATE INDEX "idx_recruiters_status" ON "public"."recruiters" USING "btree" ("account_status");



CREATE INDEX "idx_recruiters_status_active" ON "public"."recruiters" USING "btree" ("verificationstatus", "isactive");



CREATE INDEX "idx_recruiters_user_id" ON "public"."recruiters" USING "btree" ("user_id");



CREATE INDEX "idx_recruiters_verificationstatus" ON "public"."recruiters" USING "btree" ("verificationstatus");



CREATE INDEX "idx_requisitions_created_by" ON "public"."requisitions" USING "btree" ("created_by");



CREATE INDEX "idx_requisitions_created_date" ON "public"."requisitions" USING "btree" ("created_date");



CREATE INDEX "idx_requisitions_status" ON "public"."requisitions" USING "btree" ("status");



CREATE INDEX "idx_resources_lesson" ON "public"."lesson_resources" USING "btree" ("lesson_id");



CREATE INDEX "idx_response_scales_section" ON "public"."personal_assessment_response_scales" USING "btree" ("section_id");



CREATE INDEX "idx_restrictions_student_grade" ON "public"."personal_assessment_restrictions" USING "btree" ("student_id", "grade_level");



CREATE INDEX "idx_results_grade_level" ON "public"."personal_assessment_results" USING "btree" ("grade_level");



CREATE INDEX "idx_results_metadata_duplicates" ON "public"."adaptive_aptitude_results" USING "gin" ((("metadata" -> 'duplicateValidation'::"text")));



CREATE INDEX "idx_saved_jobs_opportunity_id" ON "public"."saved_jobs" USING "btree" ("opportunity_id_old");



CREATE INDEX "idx_saved_jobs_saved_at" ON "public"."saved_jobs" USING "btree" ("saved_at" DESC);



CREATE INDEX "idx_saved_jobs_student_date" ON "public"."saved_jobs" USING "btree" ("student_id_old", "saved_at" DESC);



CREATE INDEX "idx_saved_jobs_student_id" ON "public"."saved_jobs" USING "btree" ("student_id_old");



CREATE INDEX "idx_saved_searches_created" ON "public"."recruiter_saved_searches" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_saved_searches_last_used" ON "public"."recruiter_saved_searches" USING "btree" ("last_used" DESC NULLS LAST);



CREATE INDEX "idx_saved_searches_recruiter" ON "public"."recruiter_saved_searches" USING "btree" ("recruiter_id");



CREATE INDEX "idx_school_classes_academic_year" ON "public"."school_classes" USING "btree" ("academic_year");



CREATE INDEX "idx_school_classes_school" ON "public"."school_classes" USING "btree" ("school_id");



CREATE INDEX "idx_school_educators_role" ON "public"."school_educators" USING "btree" ("role");



CREATE INDEX "idx_school_educators_school" ON "public"."school_educators" USING "btree" ("school_id");



CREATE INDEX "idx_school_educators_status" ON "public"."school_educators" USING "btree" ("onboarding_status");



CREATE INDEX "idx_school_educators_user" ON "public"."school_educators" USING "btree" ("user_id");



CREATE INDEX "idx_search_history_last_searched" ON "public"."search_history" USING "btree" ("last_searched_at" DESC);



CREATE INDEX "idx_search_history_search_count" ON "public"."search_history" USING "btree" ("search_count" DESC);



CREATE INDEX "idx_search_history_student_id" ON "public"."search_history" USING "btree" ("student_id");



CREATE INDEX "idx_sections_grade_active" ON "public"."personal_assessment_sections" USING "btree" ("grade_level", "is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_sections_grade_level" ON "public"."personal_assessment_sections" USING "btree" ("grade_level");



CREATE INDEX "idx_shortlist_candidates_shortlist_id" ON "public"."shortlist_candidates" USING "btree" ("shortlist_id");



CREATE INDEX "idx_shortlist_candidates_student_id" ON "public"."shortlist_candidates" USING "btree" ("student_id");



CREATE INDEX "idx_shortlists_created_by" ON "public"."shortlists" USING "btree" ("created_by");



CREATE INDEX "idx_shortlists_created_date" ON "public"."shortlists" USING "btree" ("created_date");



CREATE INDEX "idx_skill_assessments_date" ON "public"."skill_assessments" USING "btree" ("assessment_date");



CREATE INDEX "idx_skill_assessments_school" ON "public"."skill_assessments" USING "btree" ("school_id");



CREATE INDEX "idx_skill_assessments_student" ON "public"."skill_assessments" USING "btree" ("student_id");



CREATE INDEX "idx_skill_assessments_type" ON "public"."skill_assessments" USING "btree" ("assessment_type");



CREATE INDEX "idx_skill_badges_category" ON "public"."skill_badges" USING "btree" ("category");



CREATE INDEX "idx_skill_badges_is_active" ON "public"."skill_badges" USING "btree" ("is_active");



CREATE INDEX "idx_skill_badges_level" ON "public"."skill_badges" USING "btree" ("level");



CREATE INDEX "idx_skill_badges_school" ON "public"."skill_badges" USING "btree" ("school_id");



CREATE INDEX "idx_skill_trends_category" ON "public"."skill_trends" USING "btree" ("category");



CREATE INDEX "idx_skill_trends_snapshot" ON "public"."skill_trends" USING "btree" ("snapshotDate" DESC);



CREATE INDEX "idx_skill_verifications_institution_status" ON "public"."skill_verification_requests" USING "btree" ("institution_admin_status");



CREATE INDEX "idx_skill_verifications_overall_status" ON "public"."skill_verification_requests" USING "btree" ("overall_status");



CREATE INDEX "idx_skill_verifications_rareminds_status" ON "public"."skill_verification_requests" USING "btree" ("rareminds_admin_status");



CREATE INDEX "idx_skill_verifications_student_id" ON "public"."skill_verification_requests" USING "btree" ("student_id");



CREATE INDEX "idx_skills_student_enabled" ON "public"."skills" USING "btree" ("student_id", "enabled") WHERE ("enabled" = true);



COMMENT ON INDEX "public"."idx_skills_student_enabled" IS 'Speeds up EXISTS check for profile completeness calculation.';



CREATE INDEX "idx_skills_student_id" ON "public"."skills" USING "btree" ("student_id");



CREATE INDEX "idx_skills_student_lookup" ON "public"."skills" USING "btree" ("student_id", "enabled") WHERE ("enabled" = true);



CREATE INDEX "idx_skills_training_id" ON "public"."skills" USING "btree" ("training_id");



CREATE INDEX "idx_skills_type" ON "public"."skills" USING "btree" ("type");



CREATE INDEX "idx_stream_reports_academic_year" ON "public"."stream_recommendation_reports" USING "btree" ("academic_year");



CREATE INDEX "idx_stream_reports_grade" ON "public"."stream_recommendation_reports" USING "btree" ("current_grade");



CREATE INDEX "idx_stream_reports_is_latest" ON "public"."stream_recommendation_reports" USING "btree" ("is_latest");



CREATE INDEX "idx_stream_reports_recommended" ON "public"."stream_recommendation_reports" USING "btree" ("recommended_stream");



CREATE INDEX "idx_stream_reports_student" ON "public"."stream_recommendation_reports" USING "btree" ("student_id");



CREATE INDEX "idx_student_assignments_assignment" ON "public"."student_assignments" USING "btree" ("assignment_id");



CREATE INDEX "idx_student_assignments_lookup" ON "public"."student_assignments" USING "btree" ("student_id", "is_deleted") WHERE ("is_deleted" = false);



CREATE INDEX "idx_student_assignments_status" ON "public"."student_assignments" USING "btree" ("status");



CREATE INDEX "idx_student_assignments_student" ON "public"."student_assignments" USING "btree" ("student_id");



CREATE INDEX "idx_student_assignments_student_status" ON "public"."student_assignments" USING "btree" ("student_id", "status");



CREATE INDEX "idx_student_assignments_submission_date" ON "public"."student_assignments" USING "btree" ("submission_date");



CREATE INDEX "idx_student_badges_badge" ON "public"."student_skill_badges" USING "btree" ("badge_id");



CREATE INDEX "idx_student_badges_status" ON "public"."student_skill_badges" USING "btree" ("status");



CREATE INDEX "idx_student_badges_student" ON "public"."student_skill_badges" USING "btree" ("student_email");



CREATE INDEX "idx_student_course_progress_course_id" ON "public"."student_course_progress" USING "btree" ("course_id");



CREATE INDEX "idx_student_course_progress_student_course" ON "public"."student_course_progress" USING "btree" ("student_id", "course_id");



CREATE INDEX "idx_student_course_progress_student_id" ON "public"."student_course_progress" USING "btree" ("student_id");



CREATE INDEX "idx_student_enrollments_academic_year" ON "public"."student_enrollments" USING "btree" ("academic_year");



CREATE INDEX "idx_student_enrollments_program" ON "public"."student_enrollments" USING "btree" ("program_id");



CREATE INDEX "idx_student_enrollments_section" ON "public"."student_enrollments" USING "btree" ("section_id");



CREATE INDEX "idx_student_enrollments_status" ON "public"."student_enrollments" USING "btree" ("enrollment_status");



CREATE INDEX "idx_student_enrollments_student" ON "public"."student_enrollments" USING "btree" ("student_id");



CREATE INDEX "idx_student_job_matches_expires" ON "public"."student_job_matches" USING "btree" ("expires_at");



CREATE INDEX "idx_student_job_matches_student_id" ON "public"."student_job_matches" USING "btree" ("student_id");



CREATE INDEX "idx_student_job_matches_valid" ON "public"."student_job_matches" USING "btree" ("is_valid") WHERE ("is_valid" = true);



CREATE INDEX "idx_student_ledgers_college" ON "public"."student_ledgers" USING "btree" ("college_id");



CREATE INDEX "idx_student_ledgers_due_date" ON "public"."student_ledgers" USING "btree" ("due_date");



CREATE INDEX "idx_student_ledgers_fee_structure" ON "public"."student_ledgers" USING "btree" ("fee_structure_id");



CREATE INDEX "idx_student_ledgers_overdue" ON "public"."student_ledgers" USING "btree" ("is_overdue");



CREATE INDEX "idx_student_ledgers_status" ON "public"."student_ledgers" USING "btree" ("payment_status");



CREATE INDEX "idx_student_ledgers_student" ON "public"."student_ledgers" USING "btree" ("student_id");



CREATE INDEX "idx_student_ledgers_student_record" ON "public"."student_ledgers" USING "btree" ("student_record_id");



CREATE INDEX "idx_student_management_records_enrollment" ON "public"."student_management_records" USING "btree" ("enrollment_number");



CREATE INDEX "idx_student_management_records_school" ON "public"."student_management_records" USING "btree" ("school_id");



CREATE INDEX "idx_student_management_records_student" ON "public"."student_management_records" USING "btree" ("student_id");



CREATE INDEX "idx_student_promotions_academic_year" ON "public"."student_promotions" USING "btree" ("academic_year");



CREATE INDEX "idx_student_promotions_college" ON "public"."student_promotions" USING "btree" ("college_id");



CREATE INDEX "idx_student_promotions_from_grade" ON "public"."student_promotions" USING "btree" ("from_grade");



CREATE INDEX "idx_student_promotions_is_passed" ON "public"."student_promotions" USING "btree" ("is_passed");



CREATE INDEX "idx_student_promotions_is_promoted" ON "public"."student_promotions" USING "btree" ("is_promoted");



CREATE INDEX "idx_student_promotions_school" ON "public"."student_promotions" USING "btree" ("school_id");



CREATE INDEX "idx_student_promotions_student" ON "public"."student_promotions" USING "btree" ("student_id");



CREATE INDEX "idx_student_reports_date" ON "public"."student_reports" USING "btree" ("generated_date");



CREATE INDEX "idx_student_reports_school" ON "public"."student_reports" USING "btree" ("school_id");



CREATE INDEX "idx_student_reports_student" ON "public"."student_reports" USING "btree" ("student_id");



CREATE INDEX "idx_student_reports_type" ON "public"."student_reports" USING "btree" ("report_type");



CREATE INDEX "idx_student_streaks_incomplete_today" ON "public"."student_streaks" USING "btree" ("streak_completed_today") WHERE ("streak_completed_today" = false);



CREATE INDEX "idx_student_streaks_last_activity" ON "public"."student_streaks" USING "btree" ("last_activity_date");



CREATE INDEX "idx_student_streaks_student_id" ON "public"."student_streaks" USING "btree" ("student_id");



CREATE INDEX "idx_students_aadhar_number" ON "public"."students" USING "btree" ("aadhar_number") WHERE ("aadhar_number" IS NOT NULL);



CREATE INDEX "idx_students_admission_number" ON "public"."students" USING "btree" ("admission_number");



CREATE INDEX "idx_students_branch_course" ON "public"."students" USING "btree" ("branch_field", "course_name") WHERE (("branch_field" IS NOT NULL) OR ("course_name" IS NOT NULL));



COMMENT ON INDEX "public"."idx_students_branch_course" IS 'Speeds up profile completeness and course alignment checks.';



CREATE INDEX "idx_students_college_class_id" ON "public"."students" USING "btree" ("college_class_id");



CREATE INDEX "idx_students_createdat" ON "public"."students" USING "btree" ("createdAt" DESC);



CREATE INDEX "idx_students_current_backlogs" ON "public"."students" USING "btree" ("current_backlogs");



CREATE INDEX "idx_students_documents" ON "public"."students" USING "gin" ("documents");



CREATE INDEX "idx_students_embedding" ON "public"."students" USING "ivfflat" ("embedding" "extensions"."vector_cosine_ops") WITH ("lists"='100');



CREATE INDEX "idx_students_gap_in_studies" ON "public"."students" USING "btree" ("gap_in_studies");



CREATE INDEX "idx_students_grade" ON "public"."students" USING "btree" ("grade");



CREATE INDEX "idx_students_grade_semester_type" ON "public"."students" USING "btree" ("grade", "semester", "student_type") WHERE ("grade" IS NOT NULL);



COMMENT ON INDEX "public"."idx_students_grade_semester_type" IS 'Speeds up student info lookup in matching function.';



CREATE INDEX "idx_students_hobbies_gin" ON "public"."students" USING "gin" ("hobbies");



CREATE INDEX "idx_students_interests_gin" ON "public"."students" USING "gin" ("interests");



CREATE INDEX "idx_students_is_deleted" ON "public"."students" USING "btree" ("is_deleted");



CREATE INDEX "idx_students_languages_gin" ON "public"."students" USING "gin" ("languages");



CREATE INDEX "idx_students_notification_settings" ON "public"."students" USING "gin" ("notification_settings");



CREATE INDEX "idx_students_program_id" ON "public"."students" USING "btree" ("program_id");



CREATE INDEX "idx_students_roll_number" ON "public"."students" USING "btree" ("roll_number");



CREATE INDEX "idx_students_school" ON "public"."students" USING "btree" ("school_id");



CREATE INDEX "idx_students_school_class" ON "public"."students" USING "btree" ("school_class_id");



CREATE INDEX "idx_students_section" ON "public"."students" USING "btree" ("section");



CREATE INDEX "idx_students_student_id" ON "public"."students" USING "btree" ("student_id");



CREATE INDEX "idx_students_tour_progress" ON "public"."students" USING "gin" ("tour_progress");



CREATE INDEX "idx_students_univ_college" ON "public"."students" USING "btree" ("university_college_id");



CREATE INDEX "idx_students_university" ON "public"."students" USING "btree" ("universityId");



CREATE INDEX "idx_students_user_id" ON "public"."students" USING "btree" ("user_id") WHERE ("user_id" IS NOT NULL);



CREATE INDEX "idx_subscription_cancellations_cancelled_at" ON "public"."subscription_cancellations" USING "btree" ("cancelled_at");



CREATE INDEX "idx_subscription_cancellations_reason" ON "public"."subscription_cancellations" USING "btree" ("cancellation_reason");



CREATE INDEX "idx_subscription_cancellations_subscription_id" ON "public"."subscription_cancellations" USING "btree" ("subscription_id");



CREATE INDEX "idx_subscription_cancellations_user_id" ON "public"."subscription_cancellations" USING "btree" ("user_id");



CREATE INDEX "idx_subscription_migrations_status" ON "public"."subscription_migrations" USING "btree" ("migration_status");



CREATE INDEX "idx_subscription_migrations_user_id" ON "public"."subscription_migrations" USING "btree" ("user_id");



CREATE INDEX "idx_subscription_plan_features_is_addon" ON "public"."subscription_plan_features" USING "btree" ("is_addon") WHERE ("is_addon" = true);



CREATE INDEX "idx_subscription_plans_active" ON "public"."subscription_plans" USING "btree" ("is_active") WHERE ("is_active" = true);



CREATE INDEX "idx_subscription_plans_business_type" ON "public"."subscription_plans" USING "btree" ("business_type");



CREATE INDEX "idx_subscription_plans_entity_role" ON "public"."subscription_plans" USING "btree" ("entity_type", "role_type");



CREATE INDEX "idx_subscription_plans_lookup" ON "public"."subscription_plans" USING "btree" ("business_type", "entity_type", "role_type", "is_active");



CREATE INDEX "idx_subscriptions_cancellation_reason" ON "public"."subscriptions" USING "btree" ("cancellation_reason");



CREATE INDEX "idx_subscriptions_cancelled_at" ON "public"."subscriptions" USING "btree" ("cancelled_at");



CREATE INDEX "idx_subscriptions_organization" ON "public"."subscriptions" USING "btree" ("organization_id", "organization_type") WHERE ("is_organization_subscription" = true);



CREATE INDEX "idx_subscriptions_plan_id" ON "public"."subscriptions" USING "btree" ("plan_id");



CREATE INDEX "idx_subscriptions_plan_type" ON "public"."subscriptions" USING "btree" ("plan_type");



CREATE INDEX "idx_subscriptions_purchased_by" ON "public"."subscriptions" USING "btree" ("purchased_by", "created_at" DESC) WHERE ("is_organization_subscription" = true);



CREATE INDEX "idx_subscriptions_razorpay_sub_id" ON "public"."subscriptions" USING "btree" ("razorpay_subscription_id");



CREATE INDEX "idx_subscriptions_seat_count" ON "public"."subscriptions" USING "btree" ("organization_id", "seat_count") WHERE ("is_organization_subscription" = true);



CREATE INDEX "idx_subscriptions_status" ON "public"."subscriptions" USING "btree" ("status");



COMMENT ON INDEX "public"."idx_subscriptions_status" IS 'Fast lookups by subscription status';



CREATE INDEX "idx_subscriptions_user_id" ON "public"."subscriptions" USING "btree" ("user_id");



CREATE INDEX "idx_subscriptions_user_plan_status" ON "public"."subscriptions" USING "btree" ("user_id", "plan_type", "status");



CREATE INDEX "idx_subscriptions_user_status" ON "public"."subscriptions" USING "btree" ("user_id", "status");



COMMENT ON INDEX "public"."idx_subscriptions_user_status" IS 'Fast lookups by user and status combination';



CREATE INDEX "idx_subscriptions_user_status_enddate" ON "public"."subscriptions" USING "btree" ("user_id", "status", "subscription_end_date" DESC);



CREATE INDEX "idx_substitutions_date" ON "public"."college_faculty_substitutions" USING "btree" ("substitution_date");



CREATE INDEX "idx_substitutions_status" ON "public"."college_faculty_substitutions" USING "btree" ("status");



CREATE INDEX "idx_swap_history_created_at" ON "public"."class_swap_history" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_swap_history_request" ON "public"."class_swap_history" USING "btree" ("swap_request_id");



CREATE INDEX "idx_swap_requests_created_at" ON "public"."class_swap_requests" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_swap_requests_date" ON "public"."class_swap_requests" USING "btree" ("swap_date") WHERE ("swap_date" IS NOT NULL);



CREATE INDEX "idx_swap_requests_requester" ON "public"."class_swap_requests" USING "btree" ("requester_faculty_id", "status");



CREATE INDEX "idx_swap_requests_status" ON "public"."class_swap_requests" USING "btree" ("status");



CREATE INDEX "idx_swap_requests_target" ON "public"."class_swap_requests" USING "btree" ("target_faculty_id", "status");



CREATE INDEX "idx_teacher_journal_educator" ON "public"."teacher_journal" USING "btree" ("educator_id");



CREATE INDEX "idx_teacher_workload_educator" ON "public"."teacher_workload" USING "btree" ("educator_id");



CREATE INDEX "idx_timetable_class_date" ON "public"."exam_timetable" USING "btree" ("class_id", "exam_date");



CREATE INDEX "idx_timetable_school_date" ON "public"."exam_timetable" USING "btree" ("school_id", "exam_date");



CREATE INDEX "idx_timetable_slots_class" ON "public"."timetable_slots" USING "btree" ("class_id");



CREATE INDEX "idx_timetable_slots_educator" ON "public"."timetable_slots" USING "btree" ("educator_id");



CREATE INDEX "idx_timetable_slots_schedule" ON "public"."timetable_slots" USING "btree" ("timetable_id", "day_of_week", "period_number");



CREATE INDEX "idx_timetable_subject_school" ON "public"."exam_timetable" USING "btree" ("subject_id", "school_id");



CREATE INDEX "idx_training_notifications_created" ON "public"."training_notifications" USING "btree" ("created_at" DESC);



CREATE INDEX "idx_training_notifications_experience" ON "public"."training_notifications" USING "btree" ("experience_id");



CREATE INDEX "idx_training_notifications_project" ON "public"."training_notifications" USING "btree" ("project_id");



CREATE INDEX "idx_training_notifications_read" ON "public"."training_notifications" USING "btree" ("is_read");



CREATE INDEX "idx_training_notifications_recipient" ON "public"."training_notifications" USING "btree" ("recipient_type", "school_id", "college_id");



CREATE INDEX "idx_trainings_approval_authority" ON "public"."trainings" USING "btree" ("approval_authority");



CREATE INDEX "idx_trainings_approval_status" ON "public"."trainings" USING "btree" ("approval_status");



CREATE INDEX "idx_trainings_course_id" ON "public"."trainings" USING "btree" ("course_id");



CREATE INDEX "idx_trainings_status" ON "public"."trainings" USING "btree" ("status");



CREATE INDEX "idx_trainings_student" ON "public"."trainings" USING "btree" ("student_id");



COMMENT ON INDEX "public"."idx_trainings_student" IS 'Speeds up EXISTS check for profile completeness calculation.';



CREATE INDEX "idx_trainings_student_id" ON "public"."trainings" USING "btree" ("student_id");



CREATE INDEX "idx_transcript_requests_date" ON "public"."transcript_requests" USING "btree" ("request_date");



CREATE INDEX "idx_transcript_requests_number" ON "public"."transcript_requests" USING "btree" ("request_number");



CREATE INDEX "idx_transcript_requests_status" ON "public"."transcript_requests" USING "btree" ("status");



CREATE INDEX "idx_transcript_requests_student" ON "public"."transcript_requests" USING "btree" ("student_id");



CREATE INDEX "idx_transcript_requests_type" ON "public"."transcript_requests" USING "btree" ("transcript_type");



CREATE INDEX "idx_transcripts_academic_year" ON "public"."transcripts" USING "btree" ("academic_year");



CREATE INDEX "idx_transcripts_program" ON "public"."transcripts" USING "btree" ("program_id");



CREATE INDEX "idx_transcripts_status" ON "public"."transcripts" USING "btree" ("status");



CREATE INDEX "idx_transcripts_student" ON "public"."transcripts" USING "btree" ("student_id");



CREATE INDEX "idx_transcripts_student_record" ON "public"."transcripts" USING "btree" ("student_record_id");



CREATE INDEX "idx_transcripts_type" ON "public"."transcripts" USING "btree" ("type");



CREATE INDEX "idx_transcripts_verification" ON "public"."transcripts" USING "btree" ("verification_id");



CREATE INDEX "idx_tutor_conversations_course_id" ON "public"."tutor_conversations" USING "btree" ("course_id");



CREATE INDEX "idx_tutor_conversations_student_course" ON "public"."tutor_conversations" USING "btree" ("student_id", "course_id");



CREATE INDEX "idx_tutor_conversations_student_id" ON "public"."tutor_conversations" USING "btree" ("student_id");



CREATE INDEX "idx_tutor_feedback_conversation_id" ON "public"."tutor_feedback" USING "btree" ("conversation_id");



CREATE UNIQUE INDEX "idx_unique_active_user_plan" ON "public"."subscriptions" USING "btree" ("user_id", "plan_type") WHERE ("status" = 'active'::"public"."subscription_status");



COMMENT ON INDEX "public"."idx_unique_active_user_plan" IS 'Ensures one active subscription per user per plan type';



CREATE INDEX "idx_univ_colleges_college" ON "public"."university_colleges" USING "btree" ("college_id");



CREATE INDEX "idx_univ_colleges_university" ON "public"."university_colleges" USING "btree" ("university_id");



CREATE INDEX "idx_university_colleges_college_university" ON "public"."university_colleges" USING "btree" ("college_id", "university_id");



CREATE INDEX "idx_university_performance_rank" ON "public"."university_performance" USING "btree" ("rankPosition");



CREATE INDEX "idx_university_performance_snapshot" ON "public"."university_performance" USING "btree" ("snapshotDate" DESC);



CREATE INDEX "idx_user_entitlements_end_date" ON "public"."user_entitlements" USING "btree" ("end_date");



CREATE INDEX "idx_user_entitlements_feature_key" ON "public"."user_entitlements" USING "btree" ("feature_key");



CREATE INDEX "idx_user_entitlements_granted_by" ON "public"."user_entitlements" USING "btree" ("granted_by", "created_at" DESC) WHERE ("granted_by" IS NOT NULL);



CREATE INDEX "idx_user_entitlements_org_provided" ON "public"."user_entitlements" USING "btree" ("user_id", "granted_by_organization") WHERE ("granted_by_organization" = true);



CREATE INDEX "idx_user_entitlements_org_subscription" ON "public"."user_entitlements" USING "btree" ("organization_subscription_id", "user_id") WHERE ("organization_subscription_id" IS NOT NULL);



CREATE INDEX "idx_user_entitlements_status" ON "public"."user_entitlements" USING "btree" ("status");



CREATE INDEX "idx_user_entitlements_user_id" ON "public"."user_entitlements" USING "btree" ("user_id");



CREATE INDEX "idx_user_login_history_success" ON "public"."user_login_history" USING "btree" ("success");



CREATE INDEX "idx_user_login_history_user" ON "public"."user_login_history" USING "btree" ("user_id");



CREATE INDEX "idx_user_profiles_social_links" ON "public"."user_profiles" USING "gin" ("social_links");



CREATE INDEX "idx_user_profiles_updated" ON "public"."user_profiles" USING "btree" ("updated_at");



CREATE INDEX "idx_user_profiles_user" ON "public"."user_profiles" USING "btree" ("user_id");



CREATE INDEX "idx_user_sessions_token" ON "public"."user_sessions" USING "btree" ("session_token");



CREATE INDEX "idx_user_sessions_user" ON "public"."user_sessions" USING "btree" ("user_id");



CREATE INDEX "idx_user_settings_notifications" ON "public"."user_settings" USING "gin" ("notification_preferences");



CREATE INDEX "idx_user_settings_user" ON "public"."user_settings" USING "btree" ("user_id");



CREATE INDEX "idx_user_state_history_user" ON "public"."user_state_history" USING "btree" ("user_id");



CREATE INDEX "idx_verifications_createdat" ON "public"."verifications" USING "btree" ("createdAt" DESC);



CREATE INDEX "idx_verifications_performedby" ON "public"."verifications" USING "btree" ("performedBy");



CREATE INDEX "idx_verifications_target" ON "public"."verifications" USING "btree" ("targetTable", "targetId");



CREATE INDEX "idx_verifications_target_date" ON "public"."verifications" USING "btree" ("targetId", "createdAt" DESC);



CREATE INDEX "idx_verifications_targetid" ON "public"."verifications" USING "btree" ("targetId");



CREATE INDEX "idx_video_summaries_course_id" ON "public"."video_summaries" USING "btree" ("course_id");



CREATE INDEX "idx_video_summaries_lesson_id" ON "public"."video_summaries" USING "btree" ("lesson_id");



CREATE INDEX "idx_video_summaries_status" ON "public"."video_summaries" USING "btree" ("processing_status");



CREATE INDEX "opportunities_duplicate_cost_inr_idx" ON "public"."opportunities_duplicate" USING "btree" ("cost_inr");



CREATE INDEX "opportunities_duplicate_created_at_idx" ON "public"."opportunities_duplicate" USING "btree" ("created_at" DESC);



CREATE INDEX "opportunities_duplicate_deadline_closing_date_idx" ON "public"."opportunities_duplicate" USING "btree" ("deadline", "closing_date");



CREATE INDEX "opportunities_duplicate_embedding_idx" ON "public"."opportunities_duplicate" USING "hnsw" ("embedding" "extensions"."vector_cosine_ops") WITH ("m"='16', "ef_construction"='64');



CREATE INDEX "opportunities_duplicate_exposure_type_idx" ON "public"."opportunities_duplicate" USING "btree" ("exposure_type");



CREATE INDEX "opportunities_duplicate_is_active_posted_date_idx" ON "public"."opportunities_duplicate" USING "btree" ("is_active", "posted_date" DESC) WHERE ("is_active" = true);



CREATE INDEX "opportunities_duplicate_lower_idx" ON "public"."opportunities_duplicate" USING "btree" ("lower"("company_name"));



CREATE INDEX "opportunities_duplicate_lower_idx1" ON "public"."opportunities_duplicate" USING "btree" ("lower"("job_title"));



CREATE INDEX "opportunities_duplicate_posted_date_idx" ON "public"."opportunities_duplicate" USING "btree" ("posted_date" DESC NULLS LAST);



CREATE INDEX "opportunities_duplicate_requisition_id_idx" ON "public"."opportunities_duplicate" USING "btree" ("requisition_id");



CREATE INDEX "opportunities_duplicate_salary_range_max_salary_range_min_idx" ON "public"."opportunities_duplicate" USING "btree" ("salary_range_max" DESC, "salary_range_min" DESC);



CREATE INDEX "opportunities_duplicate_sector_idx" ON "public"."opportunities_duplicate" USING "btree" ("sector");



CREATE INDEX "opportunities_duplicate_skills_required_idx" ON "public"."opportunities_duplicate" USING "gin" ("skills_required");



CREATE INDEX "opportunities_duplicate_to_tsvector_idx" ON "public"."opportunities_duplicate" USING "gin" ("to_tsvector"('"english"'::"regconfig", ((((((((((COALESCE("job_title", ''::"text") || ' '::"text") || COALESCE("title", ''::"text")) || ' '::"text") || COALESCE("company_name", ''::"text")) || ' '::"text") || COALESCE("description", ''::"text")) || ' '::"text") || COALESCE("sector", ''::"text")) || ' '::"text") || COALESCE("exposure_type", ''::"text"))));



CREATE UNIQUE INDEX "organizations_code_type_unique" ON "public"."organizations" USING "btree" ("code", "organization_type") WHERE ("code" IS NOT NULL);



CREATE INDEX "projects_embedding_idx" ON "public"."projects" USING "hnsw" ("embedding" "extensions"."vector_cosine_ops") WITH ("m"='16', "ef_construction"='64');



CREATE INDEX "reset_tokens_email_idx" ON "public"."reset_tokens" USING "btree" ("email");



CREATE INDEX "reset_tokens_token_idx" ON "public"."reset_tokens" USING "btree" ("token");



CREATE INDEX "skills_embedding_hnsw_idx" ON "public"."skills" USING "hnsw" ("embedding" "extensions"."vector_cosine_ops") WITH ("m"='16', "ef_construction"='64');



CREATE INDEX "students_embedding_idx" ON "public"."students" USING "ivfflat" ("embedding" "extensions"."vector_cosine_ops");



CREATE INDEX "trainings_embedding_idx" ON "public"."trainings" USING "hnsw" ("embedding" "extensions"."vector_cosine_ops") WITH ("m"='16', "ef_construction"='64');



CREATE UNIQUE INDEX "unique_active_assignment" ON "public"."license_assignments" USING "btree" ("user_id", "organization_subscription_id") WHERE (("status")::"text" = 'active'::"text");



CREATE UNIQUE INDEX "unique_active_student_period" ON "public"."college_mentor_student_allocations" USING "btree" ("student_id", "period_id") WHERE (("status")::"text" = 'active'::"text");



COMMENT ON INDEX "public"."unique_active_student_period" IS 'Ensures a student can only have one ACTIVE allocation per period. Allows historical records with transferred/completed status.';



CREATE INDEX "university_courses_university_id_idx" ON "public"."university_courses" USING "btree" ("university_id");



CREATE UNIQUE INDEX "ux_event_registrations_email_lowercase" ON "public"."event_registrations" USING "btree" ("lower"(("email")::"text"));



CREATE OR REPLACE VIEW "public"."chapter_details" AS
 SELECT "cc"."id",
    "cc"."curriculum_id",
    "cc"."name",
    "cc"."code",
    "cc"."description",
    "cc"."order_number",
    "cc"."estimated_duration",
    "cc"."duration_unit",
    "cc"."created_at",
    "count"("clo"."id") AS "outcome_count"
   FROM ("public"."curriculum_chapters" "cc"
     LEFT JOIN "public"."curriculum_learning_outcomes" "clo" ON (("cc"."id" = "clo"."chapter_id")))
  GROUP BY "cc"."id";



CREATE OR REPLACE VIEW "public"."college_assignments_view" AS
 SELECT "ca"."assignment_id",
    "ca"."title",
    "ca"."description",
    "ca"."instructions",
    "ca"."course_name",
    "ca"."course_code",
    "ca"."college_id",
    "ca"."college_educator_id",
    "ca"."program_section_id",
    "ca"."department_id",
    "ca"."program_id",
    "ca"."educator_name",
    "ca"."total_points",
    "ca"."assignment_type",
    "ca"."skill_outcomes",
    "ca"."document_pdf",
    "ca"."due_date",
    "ca"."available_from",
    "ca"."created_date",
    "ca"."updated_date",
    "ca"."allow_late_submission",
    "ca"."is_deleted",
    "ps"."semester",
    "ps"."section",
    "ps"."academic_year",
    "ps"."current_students",
    "p"."name" AS "program_name",
    "p"."code" AS "program_code",
    "d"."name" AS "department_name",
    "d"."code" AS "department_code",
    ((("cl"."first_name")::"text" || ' '::"text") || ("cl"."last_name")::"text") AS "educator_full_name",
    "cl"."email" AS "educator_email",
    "o"."name" AS "college_name",
    "count"(DISTINCT "csa"."student_assignment_id") AS "total_assigned",
    "count"(DISTINCT
        CASE
            WHEN ("csa"."status" = 'submitted'::"text") THEN "csa"."student_assignment_id"
            ELSE NULL::"uuid"
        END) AS "total_submitted",
    "count"(DISTINCT
        CASE
            WHEN ("csa"."status" = 'graded'::"text") THEN "csa"."student_assignment_id"
            ELSE NULL::"uuid"
        END) AS "total_graded"
   FROM (((((("public"."college_assignments" "ca"
     LEFT JOIN "public"."program_sections" "ps" ON (("ca"."program_section_id" = "ps"."id")))
     LEFT JOIN "public"."programs" "p" ON (("ca"."program_id" = "p"."id")))
     LEFT JOIN "public"."departments" "d" ON (("ca"."department_id" = "d"."id")))
     LEFT JOIN "public"."college_lecturers" "cl" ON (("ca"."college_educator_id" = "cl"."user_id")))
     LEFT JOIN "public"."organizations" "o" ON (("ca"."college_id" = "o"."id")))
     LEFT JOIN "public"."college_student_assignments" "csa" ON ((("ca"."assignment_id" = "csa"."assignment_id") AND ("csa"."is_deleted" = false))))
  WHERE ("ca"."is_deleted" = false)
  GROUP BY "ca"."assignment_id", "ps"."semester", "ps"."section", "ps"."academic_year", "ps"."current_students", "p"."name", "p"."code", "d"."name", "d"."code", "cl"."first_name", "cl"."last_name", "cl"."email", "o"."name";



CREATE OR REPLACE VIEW "public"."course_summary" AS
 SELECT "c"."course_id",
    "c"."title",
    "c"."code",
    "c"."description",
    "c"."status",
    "c"."duration",
    "c"."educator_id",
    COALESCE("concat"("u"."firstName", ' ', "u"."lastName"), 'Unknown'::"text") AS "educator_name",
    "c"."enrollment_count",
    "c"."completion_rate",
    "c"."evidence_pending",
    "c"."created_at",
    "c"."updated_at",
    "count"(DISTINCT "cm"."module_id") AS "module_count",
    "count"(DISTINCT "l"."lesson_id") AS "lesson_count",
    "count"(DISTINCT "lr"."resource_id") AS "resource_count",
    COALESCE("json_agg"(DISTINCT "cs"."skill_name") FILTER (WHERE ("cs"."skill_name" IS NOT NULL)), '[]'::json) AS "skills",
    COALESCE("json_agg"(DISTINCT "cc"."class_name") FILTER (WHERE ("cc"."class_name" IS NOT NULL)), '[]'::json) AS "classes"
   FROM ((((((("public"."courses" "c"
     LEFT JOIN "public"."admin_users" "au" ON (("c"."educator_id" = "au"."id")))
     LEFT JOIN "public"."users" "u" ON (("au"."id" = "u"."id")))
     LEFT JOIN "public"."course_modules" "cm" ON (("c"."course_id" = "cm"."course_id")))
     LEFT JOIN "public"."lessons" "l" ON (("cm"."module_id" = "l"."module_id")))
     LEFT JOIN "public"."lesson_resources" "lr" ON (("l"."lesson_id" = "lr"."lesson_id")))
     LEFT JOIN "public"."course_skills" "cs" ON (("c"."course_id" = "cs"."course_id")))
     LEFT JOIN "public"."course_classes" "cc" ON (("c"."course_id" = "cc"."course_id")))
  GROUP BY "c"."course_id", "u"."firstName", "u"."lastName";



CREATE OR REPLACE VIEW "public"."curriculum_summary" AS
 SELECT "c"."id",
    "c"."school_id",
    "c"."subject",
    "c"."class",
    "c"."academic_year",
    "c"."status",
    "c"."created_by",
    "c"."approved_by",
    "c"."approval_date",
    "c"."rejection_reason",
    "c"."last_modified",
    "c"."created_at",
    ((("se"."first_name")::"text" || ' '::"text") || ("se"."last_name")::"text") AS "created_by_name",
    "se"."email" AS "created_by_email",
    "count"(DISTINCT "cc"."id") AS "total_chapters",
    "count"(DISTINCT "clo"."id") AS "total_outcomes",
    "count"(DISTINCT "oam"."id") AS "total_assessment_mappings",
        CASE
            WHEN ("count"(DISTINCT "cc"."id") = 0) THEN (0)::numeric
            ELSE "round"(((("count"(DISTINCT
            CASE
                WHEN ("clo"."id" IS NOT NULL) THEN "cc"."id"
                ELSE NULL::"uuid"
            END))::numeric / ("count"(DISTINCT "cc"."id"))::numeric) * (100)::numeric))
        END AS "completion_percentage"
   FROM (((("public"."curriculums" "c"
     LEFT JOIN "public"."school_educators" "se" ON (("c"."created_by" = "se"."id")))
     LEFT JOIN "public"."curriculum_chapters" "cc" ON (("c"."id" = "cc"."curriculum_id")))
     LEFT JOIN "public"."curriculum_learning_outcomes" "clo" ON (("cc"."id" = "clo"."chapter_id")))
     LEFT JOIN "public"."outcome_assessment_mappings" "oam" ON (("clo"."id" = "oam"."learning_outcome_id")))
  GROUP BY "c"."id", "se"."first_name", "se"."last_name", "se"."email";



CREATE OR REPLACE VIEW "public"."learning_outcome_details" AS
 SELECT "clo"."id",
    "clo"."chapter_id",
    "clo"."outcome",
    "clo"."bloom_level",
    "cc"."name" AS "chapter_name",
    "cc"."curriculum_id",
    "c"."subject",
    "c"."class",
    "c"."academic_year",
    "count"("oam"."id") AS "assessment_count",
    "array_agg"(
        CASE
            WHEN ("at"."name" IS NOT NULL) THEN "jsonb_build_object"('assessment_type', "at"."name", 'weightage', "oam"."weightage")
            ELSE NULL::"jsonb"
        END) FILTER (WHERE ("at"."name" IS NOT NULL)) AS "assessment_mappings"
   FROM (((("public"."curriculum_learning_outcomes" "clo"
     JOIN "public"."curriculum_chapters" "cc" ON (("clo"."chapter_id" = "cc"."id")))
     JOIN "public"."curriculums" "c" ON (("cc"."curriculum_id" = "c"."id")))
     LEFT JOIN "public"."outcome_assessment_mappings" "oam" ON (("clo"."id" = "oam"."learning_outcome_id")))
     LEFT JOIN "public"."assessment_types" "at" ON (("oam"."assessment_type_id" = "at"."id")))
  GROUP BY "clo"."id", "cc"."name", "cc"."curriculum_id", "c"."subject", "c"."class", "c"."academic_year";



CREATE OR REPLACE TRIGGER "attendance_slot_id_check" BEFORE INSERT OR UPDATE ON "public"."attendance_records" FOR EACH ROW EXECUTE FUNCTION "public"."check_attendance_slot_id"();



CREATE OR REPLACE TRIGGER "auto_create_skills_from_external_course" BEFORE INSERT OR UPDATE ON "public"."external_courses" FOR EACH ROW EXECUTE FUNCTION "public"."create_skills_from_external_course"();



CREATE OR REPLACE TRIGGER "auto_create_skills_from_internal_course" BEFORE UPDATE ON "public"."course_enrollments" FOR EACH ROW EXECUTE FUNCTION "public"."create_skills_from_internal_course"();



CREATE OR REPLACE TRIGGER "auto_opportunity_embedding" AFTER INSERT OR UPDATE OF "title", "description", "skills_required", "requirements" ON "public"."opportunities" FOR EACH ROW WHEN (("new"."embedding" IS NULL)) EXECUTE FUNCTION "public"."trigger_opportunity_embedding"();



CREATE OR REPLACE TRIGGER "auto_populate_result_columns" BEFORE INSERT ON "public"."personal_assessment_results" FOR EACH ROW EXECUTE FUNCTION "public"."populate_result_columns_from_gemini"();



CREATE OR REPLACE TRIGGER "auto_populate_result_columns_update" BEFORE UPDATE ON "public"."personal_assessment_results" FOR EACH ROW WHEN (("new"."gemini_results" IS DISTINCT FROM "old"."gemini_results")) EXECUTE FUNCTION "public"."populate_result_columns_from_gemini"();



CREATE OR REPLACE TRIGGER "auto_reset_attempt_on_result_delete" AFTER DELETE ON "public"."personal_assessment_results" FOR EACH ROW EXECUTE FUNCTION "public"."reset_attempt_on_result_delete"();



CREATE OR REPLACE TRIGGER "calculate_assessment_scores_trigger" BEFORE INSERT ON "public"."personal_assessment_results" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_assessment_scores"();



CREATE OR REPLACE TRIGGER "check_break_overlap_trigger" BEFORE INSERT OR UPDATE ON "public"."college_breaks" FOR EACH ROW EXECUTE FUNCTION "public"."check_break_date_overlap"();



CREATE OR REPLACE TRIGGER "check_slot_conflicts_trigger" BEFORE INSERT OR UPDATE ON "public"."college_timetable_slots" FOR EACH ROW EXECUTE FUNCTION "public"."check_timetable_slot_conflicts"();



CREATE OR REPLACE TRIGGER "experience_admin_notify" AFTER INSERT OR UPDATE ON "public"."experience" FOR EACH ROW EXECUTE FUNCTION "public"."notify_admin_experience"();



CREATE OR REPLACE TRIGGER "lesson_plan_approved_trigger" AFTER INSERT OR UPDATE OF "status" ON "public"."lesson_plans" FOR EACH ROW EXECUTE FUNCTION "public"."add_to_teacher_journal"();



CREATE OR REPLACE TRIGGER "notify_student_experience" AFTER UPDATE ON "public"."experience" FOR EACH ROW EXECUTE FUNCTION "public"."notify_student_on_approval"();



CREATE OR REPLACE TRIGGER "on_message_read" AFTER UPDATE OF "is_read" ON "public"."messages" FOR EACH ROW WHEN ((("old"."is_read" = false) AND ("new"."is_read" = true))) EXECUTE FUNCTION "public"."reset_unread_count"();



CREATE OR REPLACE TRIGGER "pipeline_activity_notification_trigger" AFTER INSERT ON "public"."pipeline_activities" FOR EACH ROW EXECUTE FUNCTION "public"."create_notification_from_pipeline_activity"();



CREATE OR REPLACE TRIGGER "populate_chapter_name_trigger" BEFORE INSERT OR UPDATE OF "chapter_id" ON "public"."lesson_plans" FOR EACH ROW EXECUTE FUNCTION "public"."populate_chapter_name"();



CREATE OR REPLACE TRIGGER "prevent_duplicate_active_subscription" BEFORE INSERT OR UPDATE ON "public"."subscriptions" FOR EACH ROW EXECUTE FUNCTION "public"."check_duplicate_active_subscription"();



CREATE OR REPLACE TRIGGER "project_student_notify_trigger" AFTER UPDATE OF "approval_status" ON "public"."projects" FOR EACH ROW EXECUTE FUNCTION "public"."notify_student_on_approval"();



CREATE OR REPLACE TRIGGER "set_approval_authority_projects" BEFORE INSERT OR UPDATE ON "public"."projects" FOR EACH ROW EXECUTE FUNCTION "public"."set_approval_authority"();



CREATE OR REPLACE TRIGGER "set_approval_requests_timestamp" BEFORE UPDATE ON "public"."approval_requests" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at_timestamp"();



CREATE OR REPLACE TRIGGER "set_approval_types_timestamp" BEFORE UPDATE ON "public"."approval_types" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at_timestamp"();



CREATE OR REPLACE TRIGGER "set_approval_workflows_timestamp" BEFORE UPDATE ON "public"."approval_workflows" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at_timestamp"();



CREATE OR REPLACE TRIGGER "set_program_sections_timestamp" BEFORE UPDATE ON "public"."program_sections" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at_timestamp"();



CREATE OR REPLACE TRIGGER "set_programs_timestamp" BEFORE UPDATE ON "public"."programs" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at_timestamp"();



CREATE OR REPLACE TRIGGER "set_role_permissions_timestamp" BEFORE UPDATE ON "public"."role_permissions" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at_timestamp"();



CREATE OR REPLACE TRIGGER "set_roles_timestamp" BEFORE UPDATE ON "public"."roles" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at_timestamp"();



CREATE OR REPLACE TRIGGER "set_students_updated_at" BEFORE UPDATE ON "public"."students" FOR EACH ROW EXECUTE FUNCTION "public"."update_students_updated_at"();



CREATE OR REPLACE TRIGGER "set_teacher_id" BEFORE INSERT ON "public"."school_educators" FOR EACH ROW WHEN ((("new"."teacher_id" IS NULL) OR (("new"."teacher_id")::"text" = ''::"text"))) EXECUTE FUNCTION "public"."generate_teacher_id"();



CREATE OR REPLACE TRIGGER "timetable_slot_workload_trigger" AFTER INSERT OR DELETE OR UPDATE ON "public"."timetable_slots" FOR EACH ROW EXECUTE FUNCTION "public"."on_timetable_slot_change"();



CREATE OR REPLACE TRIGGER "training_admin_notify" AFTER INSERT OR UPDATE ON "public"."projects" FOR EACH ROW EXECUTE FUNCTION "public"."notify_admin_experience"();



CREATE OR REPLACE TRIGGER "training_student_notify_trigger" AFTER UPDATE OF "approval_status" ON "public"."trainings" FOR EACH ROW EXECUTE FUNCTION "public"."notify_student_on_approval"();



CREATE OR REPLACE TRIGGER "trg_activities_timestamp" BEFORE UPDATE ON "public"."club_activities" FOR EACH ROW EXECUTE FUNCTION "public"."update_timestamp"();



CREATE OR REPLACE TRIGGER "trg_assignments_updated" BEFORE UPDATE ON "public"."assignments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_assignments_updated_fn"();



CREATE OR REPLACE TRIGGER "trg_certificates_embedding" AFTER INSERT OR DELETE OR UPDATE ON "public"."certificates" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_related_student_embedding"();



CREATE OR REPLACE TRIGGER "trg_check_club_capacity" BEFORE INSERT OR UPDATE ON "public"."club_memberships" FOR EACH ROW EXECUTE FUNCTION "public"."check_club_capacity"();



CREATE OR REPLACE TRIGGER "trg_check_max_clubs" BEFORE INSERT OR UPDATE ON "public"."club_memberships" FOR EACH ROW EXECUTE FUNCTION "public"."check_max_clubs_per_student"();



CREATE OR REPLACE TRIGGER "trg_clubs_timestamp" BEFORE UPDATE ON "public"."clubs" FOR EACH ROW EXECUTE FUNCTION "public"."update_timestamp"();



CREATE OR REPLACE TRIGGER "trg_college_assignments_updated" BEFORE UPDATE ON "public"."college_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_college_assignments_updated_fn"();



CREATE OR REPLACE TRIGGER "trg_college_student_assignments_grade_pct" BEFORE INSERT OR UPDATE OF "grade_received" ON "public"."college_student_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_college_student_assignments_grade_pct_fn"();



CREATE OR REPLACE TRIGGER "trg_college_student_assignments_late_check" BEFORE INSERT OR UPDATE OF "submission_date" ON "public"."college_student_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_college_student_assignments_late_check_fn"();



CREATE OR REPLACE TRIGGER "trg_college_student_assignments_status" BEFORE INSERT OR UPDATE OF "status" ON "public"."college_student_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_college_student_assignments_status_fn"();



CREATE OR REPLACE TRIGGER "trg_college_student_assignments_updated" BEFORE UPDATE ON "public"."college_student_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_college_student_assignments_updated_fn"();



CREATE OR REPLACE TRIGGER "trg_competitions_timestamp" BEFORE UPDATE ON "public"."competitions" FOR EACH ROW EXECUTE FUNCTION "public"."update_timestamp"();



CREATE OR REPLACE TRIGGER "trg_enrollment_completion_embedding" AFTER UPDATE OF "progress", "status" ON "public"."course_enrollments" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_enrollment_completion_embedding"();



CREATE OR REPLACE TRIGGER "trg_generate_credential_id" BEFORE INSERT ON "public"."club_certificates" FOR EACH ROW EXECUTE FUNCTION "public"."generate_certificate_credential_id"();



CREATE OR REPLACE TRIGGER "trg_generate_student_id" BEFORE INSERT ON "public"."students" FOR EACH ROW EXECUTE FUNCTION "public"."generate_student_id"();



CREATE OR REPLACE TRIGGER "trg_mark_previous_reports_not_latest" AFTER INSERT ON "public"."stream_recommendation_reports" FOR EACH ROW EXECUTE FUNCTION "public"."mark_previous_stream_reports_not_latest"();



CREATE OR REPLACE TRIGGER "trg_projects_embedding" AFTER INSERT OR DELETE OR UPDATE ON "public"."projects" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_related_student_embedding"();



CREATE OR REPLACE TRIGGER "trg_skills_embedding" AFTER INSERT OR DELETE OR UPDATE ON "public"."skills" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_related_student_embedding"();



CREATE OR REPLACE TRIGGER "trg_stream_reports_updated_at" BEFORE UPDATE ON "public"."stream_recommendation_reports" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "trg_student_assignments_grade_pct" BEFORE INSERT OR UPDATE OF "grade_received" ON "public"."student_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_student_assignments_grade_pct_fn"();



CREATE OR REPLACE TRIGGER "trg_student_assignments_late_check" BEFORE INSERT OR UPDATE OF "submission_date" ON "public"."student_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_student_assignments_late_check_fn"();



CREATE OR REPLACE TRIGGER "trg_student_assignments_status" BEFORE INSERT OR UPDATE OF "status" ON "public"."student_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_student_assignments_status_fn"();



CREATE OR REPLACE TRIGGER "trg_student_assignments_updated" BEFORE UPDATE ON "public"."student_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."trg_student_assignments_updated_fn"();



CREATE OR REPLACE TRIGGER "trg_student_embedding_queue" AFTER INSERT OR UPDATE OF "name", "email", "bio", "skill_summary", "branch_field", "course_name", "university" ON "public"."students" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_student_embedding_queue"();



CREATE OR REPLACE TRIGGER "trg_student_promotions_updated_at" BEFORE UPDATE ON "public"."student_promotions" FOR EACH ROW EXECUTE FUNCTION "public"."update_student_promotions_updated_at"();



CREATE OR REPLACE TRIGGER "trg_trainings_embedding" AFTER INSERT OR DELETE OR UPDATE ON "public"."trainings" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_related_student_embedding"();



CREATE OR REPLACE TRIGGER "trg_update_attendance" AFTER INSERT OR UPDATE ON "public"."club_attendance_records" FOR EACH ROW EXECUTE FUNCTION "public"."update_membership_attendance"();



CREATE OR REPLACE TRIGGER "trg_update_grade_on_program" BEFORE INSERT OR UPDATE OF "program_id" ON "public"."students" FOR EACH ROW EXECUTE FUNCTION "public"."update_grade_on_program_mapping"();



CREATE OR REPLACE TRIGGER "trg_update_student_grade_on_promotion" AFTER INSERT OR UPDATE OF "is_promoted", "to_grade" ON "public"."student_promotions" FOR EACH ROW WHEN ((("new"."is_promoted" = true) AND ("new"."to_grade" IS NOT NULL))) EXECUTE FUNCTION "public"."update_student_grade_on_promotion"();



CREATE OR REPLACE TRIGGER "trg_validate_club_membership_school" BEFORE INSERT OR UPDATE ON "public"."club_memberships" FOR EACH ROW EXECUTE FUNCTION "public"."validate_student_school_match"();



CREATE OR REPLACE TRIGGER "trg_validate_competition_registration_school" BEFORE INSERT OR UPDATE ON "public"."competition_registrations" FOR EACH ROW EXECUTE FUNCTION "public"."validate_student_competition_school"();



CREATE OR REPLACE TRIGGER "trigger_auto_add_to_pipeline" AFTER INSERT ON "public"."applied_jobs" FOR EACH ROW EXECUTE FUNCTION "public"."auto_add_applicant_to_pipeline"();



CREATE OR REPLACE TRIGGER "trigger_auto_assign_license_college_lecturers" AFTER INSERT ON "public"."college_lecturers" FOR EACH ROW EXECUTE FUNCTION "public"."auto_assign_license_to_member"();



CREATE OR REPLACE TRIGGER "trigger_auto_assign_license_school_educators" AFTER INSERT ON "public"."school_educators" FOR EACH ROW EXECUTE FUNCTION "public"."auto_assign_license_to_member"();



CREATE OR REPLACE TRIGGER "trigger_auto_assign_license_students" AFTER INSERT ON "public"."students" FOR EACH ROW EXECUTE FUNCTION "public"."auto_assign_license_to_member"();



CREATE OR REPLACE TRIGGER "trigger_auto_create_assessment_result" AFTER UPDATE ON "public"."personal_assessment_attempts" FOR EACH ROW EXECUTE FUNCTION "public"."auto_create_assessment_result"();



CREATE OR REPLACE TRIGGER "trigger_auto_set_cancelled_at" BEFORE UPDATE ON "public"."subscriptions" FOR EACH ROW WHEN (("old"."status" IS DISTINCT FROM "new"."status")) EXECUTE FUNCTION "public"."auto_set_cancelled_at"();



CREATE OR REPLACE TRIGGER "trigger_auto_set_university_id" BEFORE INSERT OR UPDATE ON "public"."college_curriculums" FOR EACH ROW EXECUTE FUNCTION "public"."auto_set_university_id"();



CREATE OR REPLACE TRIGGER "trigger_calculate_batch_statistics" BEFORE INSERT OR UPDATE ON "public"."mark_entry_batches" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_batch_statistics"();



CREATE OR REPLACE TRIGGER "trigger_calculate_days_borrowed" BEFORE INSERT OR UPDATE ON "public"."library_history" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_days_borrowed"();



CREATE OR REPLACE TRIGGER "trigger_calculate_exam_registration_fee" BEFORE INSERT OR UPDATE ON "public"."exam_registrations" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_exam_registration_fee"();



CREATE OR REPLACE TRIGGER "trigger_calculate_library_fine" BEFORE INSERT OR UPDATE ON "public"."library_issued_books" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_library_fine"();



CREATE OR REPLACE TRIGGER "trigger_calculate_moderation_difference" BEFORE INSERT OR UPDATE ON "public"."mark_moderation_log" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_moderation_difference"();



CREATE OR REPLACE TRIGGER "trigger_calculate_transcript_request_fee" BEFORE INSERT OR UPDATE ON "public"."transcript_requests" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_transcript_request_fee"();



CREATE OR REPLACE TRIGGER "trigger_certificate_embedding" AFTER INSERT OR UPDATE OF "title", "issuer", "platform", "level", "category", "description", "enabled" ON "public"."certificates" FOR EACH ROW WHEN (("new"."enabled" = true)) EXECUTE FUNCTION "public"."trigger_entity_embedding_generation"();



CREATE OR REPLACE TRIGGER "trigger_certificates_updated_at" BEFORE UPDATE ON "public"."certificates" FOR EACH ROW EXECUTE FUNCTION "public"."update_certificates_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_college_circulars_updated_at" BEFORE UPDATE ON "public"."college_circulars" FOR EACH ROW EXECUTE FUNCTION "public"."update_college_circulars_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_college_events_updated_at" BEFORE UPDATE ON "public"."college_events" FOR EACH ROW EXECUTE FUNCTION "public"."update_college_events_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_course_enrollment_embedding" AFTER INSERT OR UPDATE OF "course_title", "status", "progress", "grade", "skills_acquired" ON "public"."course_enrollments" FOR EACH ROW WHEN (("new"."status" = ANY (ARRAY['completed'::"text", 'in_progress'::"text", 'active'::"text"]))) EXECUTE FUNCTION "public"."trigger_entity_embedding_generation"();



CREATE OR REPLACE TRIGGER "trigger_create_assessment_restriction" AFTER UPDATE ON "public"."personal_assessment_attempts" FOR EACH ROW EXECUTE FUNCTION "public"."create_assessment_restriction"();



CREATE OR REPLACE TRIGGER "trigger_create_faculty_leave_balances" AFTER INSERT ON "public"."college_lecturers" FOR EACH ROW EXECUTE FUNCTION "public"."create_faculty_leave_balances"();



CREATE OR REPLACE TRIGGER "trigger_create_message_notification" AFTER INSERT ON "public"."messages" FOR EACH ROW EXECUTE FUNCTION "public"."create_message_notification"();



CREATE OR REPLACE TRIGGER "trigger_create_swap_history" AFTER INSERT OR UPDATE ON "public"."class_swap_requests" FOR EACH ROW EXECUTE FUNCTION "public"."create_swap_history_entry"();



CREATE OR REPLACE TRIGGER "trigger_decrement_applications_count" AFTER DELETE ON "public"."applied_jobs" FOR EACH ROW EXECUTE FUNCTION "public"."decrement_applications_count"();



CREATE OR REPLACE TRIGGER "trigger_increment_applications_count" AFTER INSERT ON "public"."applied_jobs" FOR EACH ROW EXECUTE FUNCTION "public"."increment_applications_count"();



CREATE OR REPLACE TRIGGER "trigger_initialize_student_streak" AFTER INSERT ON "public"."students" FOR EACH ROW EXECUTE FUNCTION "public"."initialize_student_streak"();



CREATE OR REPLACE TRIGGER "trigger_invalidate_all_job_matches_on_opportunity" AFTER INSERT OR DELETE OR UPDATE OF "title", "description", "requirements", "skills_required", "status", "embedding" ON "public"."opportunities" FOR EACH ROW EXECUTE FUNCTION "public"."invalidate_all_job_matches_on_opportunity_change"();



CREATE OR REPLACE TRIGGER "trigger_invalidate_job_matches_on_enrollment" AFTER INSERT OR DELETE OR UPDATE ON "public"."course_enrollments" FOR EACH ROW EXECUTE FUNCTION "public"."invalidate_job_matches_cache"();



CREATE OR REPLACE TRIGGER "trigger_invalidate_job_matches_on_student" AFTER UPDATE OF "name", "branch_field", "semester", "currentCgpa", "skill_summary", "interests", "hobbies", "embedding", "metadata" ON "public"."students" FOR EACH ROW EXECUTE FUNCTION "public"."invalidate_job_matches_cache"();



CREATE OR REPLACE TRIGGER "trigger_invalidate_job_matches_on_training" AFTER INSERT OR DELETE OR UPDATE ON "public"."trainings" FOR EACH ROW EXECUTE FUNCTION "public"."invalidate_job_matches_cache"();



CREATE OR REPLACE TRIGGER "trigger_new_opportunity_notification" AFTER INSERT ON "public"."opportunities" FOR EACH ROW WHEN (("new"."is_active" IS TRUE)) EXECUTE FUNCTION "public"."notify_students_new_opportunity"();



CREATE OR REPLACE TRIGGER "trigger_notify_project_approval_unified" AFTER INSERT OR UPDATE OF "approval_status" ON "public"."projects" FOR EACH ROW EXECUTE FUNCTION "public"."notify_project_approval_unified"();



CREATE OR REPLACE TRIGGER "trigger_notify_training_admin" AFTER INSERT OR UPDATE ON "public"."trainings" FOR EACH ROW EXECUTE FUNCTION "public"."notify_training_admin"();



CREATE OR REPLACE TRIGGER "trigger_opportunity_update_notification" AFTER UPDATE ON "public"."opportunities" FOR EACH ROW WHEN (("old"."is_active" IS DISTINCT FROM "new"."is_active")) EXECUTE FUNCTION "public"."notify_students_opportunity_update"();



CREATE OR REPLACE TRIGGER "trigger_project_embedding" AFTER INSERT OR UPDATE OF "title", "role", "organization", "tech_stack", "description", "enabled" ON "public"."projects" FOR EACH ROW WHEN (("new"."enabled" = true)) EXECUTE FUNCTION "public"."trigger_entity_embedding_generation"();



CREATE OR REPLACE TRIGGER "trigger_reset_quiz_on_enrollment_reset" AFTER UPDATE ON "public"."course_enrollments" FOR EACH ROW WHEN (("new"."progress" = 0)) EXECUTE FUNCTION "public"."reset_quiz_progress_on_enrollment_reset"();



CREATE OR REPLACE TRIGGER "trigger_reset_unread_count" AFTER UPDATE ON "public"."messages" FOR EACH ROW EXECUTE FUNCTION "public"."reset_unread_count"();



CREATE OR REPLACE TRIGGER "trigger_set_approval_authority" BEFORE INSERT OR UPDATE ON "public"."trainings" FOR EACH ROW EXECUTE FUNCTION "public"."set_approval_authority"();



CREATE OR REPLACE TRIGGER "trigger_set_experience_approval_authority" BEFORE INSERT OR UPDATE OF "student_id" ON "public"."experience" FOR EACH ROW EXECUTE FUNCTION "public"."set_experience_approval_authority"();



CREATE OR REPLACE TRIGGER "trigger_set_total_students" BEFORE INSERT ON "public"."college_attendance_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."set_session_total_students"();



CREATE OR REPLACE TRIGGER "trigger_set_training_approval_authority" BEFORE INSERT OR UPDATE ON "public"."trainings" FOR EACH ROW EXECUTE FUNCTION "public"."set_training_approval_authority"();



CREATE OR REPLACE TRIGGER "trigger_skill_embedding" AFTER INSERT OR UPDATE OF "name", "type", "level", "proficiency_level", "description", "enabled" ON "public"."skills" FOR EACH ROW WHEN (("new"."enabled" = true)) EXECUTE FUNCTION "public"."trigger_entity_embedding_generation"();



CREATE OR REPLACE TRIGGER "trigger_student_course_progress_updated_at" BEFORE UPDATE ON "public"."student_course_progress" FOR EACH ROW EXECUTE FUNCTION "public"."update_student_course_progress_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_subscription_plans_updated_at" BEFORE UPDATE ON "public"."subscription_plans" FOR EACH ROW EXECUTE FUNCTION "public"."update_subscription_plans_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_sync_lecturer_record_invigilator" BEFORE INSERT OR UPDATE ON "public"."invigilator_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."sync_lecturer_record_id"();



CREATE OR REPLACE TRIGGER "trigger_sync_pool_seats" AFTER INSERT OR DELETE OR UPDATE ON "public"."license_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."sync_pool_assigned_seats"();



CREATE OR REPLACE TRIGGER "trigger_sync_student_record_exam_reg" BEFORE INSERT OR UPDATE ON "public"."exam_registrations" FOR EACH ROW EXECUTE FUNCTION "public"."sync_student_record_id"();



CREATE OR REPLACE TRIGGER "trigger_sync_student_record_ledgers" BEFORE INSERT OR UPDATE ON "public"."student_ledgers" FOR EACH ROW EXECUTE FUNCTION "public"."sync_student_record_id"();



CREATE OR REPLACE TRIGGER "trigger_sync_student_record_library" BEFORE INSERT OR UPDATE ON "public"."library_issued_books" FOR EACH ROW EXECUTE FUNCTION "public"."sync_student_record_id"();



CREATE OR REPLACE TRIGGER "trigger_sync_student_record_mark_entries" BEFORE INSERT OR UPDATE ON "public"."mark_entries" FOR EACH ROW EXECUTE FUNCTION "public"."sync_student_record_id"();



CREATE OR REPLACE TRIGGER "trigger_sync_student_record_seating" BEFORE INSERT OR UPDATE ON "public"."exam_seating_arrangements" FOR EACH ROW EXECUTE FUNCTION "public"."sync_student_record_id"();



CREATE OR REPLACE TRIGGER "trigger_sync_student_record_transcripts" BEFORE INSERT OR UPDATE ON "public"."transcripts" FOR EACH ROW EXECUTE FUNCTION "public"."sync_student_record_id"();



CREATE OR REPLACE TRIGGER "trigger_sync_training_on_enrollment_update" AFTER UPDATE ON "public"."course_enrollments" FOR EACH ROW EXECUTE FUNCTION "public"."sync_training_from_enrollment"();



CREATE OR REPLACE TRIGGER "trigger_training_embedding" AFTER INSERT OR UPDATE OF "title", "organization", "source", "duration", "description" ON "public"."trainings" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_entity_embedding_generation"();



CREATE OR REPLACE TRIGGER "trigger_tutor_conversations_updated_at" BEFORE UPDATE ON "public"."tutor_conversations" FOR EACH ROW EXECUTE FUNCTION "public"."update_tutor_conversations_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_applied_jobs_timestamp" BEFORE UPDATE ON "public"."applied_jobs" FOR EACH ROW EXECUTE FUNCTION "public"."update_applied_jobs_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_book_availability" AFTER INSERT OR DELETE OR UPDATE ON "public"."library_book_issues" FOR EACH ROW EXECUTE FUNCTION "public"."update_book_availability"();



CREATE OR REPLACE TRIGGER "trigger_update_book_availability_college" AFTER INSERT OR DELETE OR UPDATE ON "public"."library_book_issues_college" FOR EACH ROW EXECUTE FUNCTION "public"."update_book_availability_college"();



CREATE OR REPLACE TRIGGER "trigger_update_book_availability_school" AFTER INSERT OR DELETE OR UPDATE ON "public"."library_book_issues_school" FOR EACH ROW EXECUTE FUNCTION "public"."update_book_availability_school"();



CREATE OR REPLACE TRIGGER "trigger_update_book_on_issue" AFTER INSERT ON "public"."library_issued_books" FOR EACH ROW EXECUTE FUNCTION "public"."update_book_availability_on_issue"();



CREATE OR REPLACE TRIGGER "trigger_update_book_on_return" AFTER UPDATE ON "public"."library_issued_books" FOR EACH ROW EXECUTE FUNCTION "public"."update_book_availability_on_return"();



CREATE OR REPLACE TRIGGER "trigger_update_book_rating" AFTER INSERT OR UPDATE ON "public"."library_reviews" FOR EACH ROW WHEN (("new"."is_approved" = true)) EXECUTE FUNCTION "public"."update_book_rating"();



CREATE OR REPLACE TRIGGER "trigger_update_budget_on_expenditure" AFTER INSERT OR UPDATE ON "public"."expenditures" FOR EACH ROW EXECUTE FUNCTION "public"."update_budget_on_expenditure"();



CREATE OR REPLACE TRIGGER "trigger_update_college_lesson_plans_updated_at" BEFORE UPDATE ON "public"."college_lesson_plans" FOR EACH ROW EXECUTE FUNCTION "public"."update_college_lesson_plans_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_conversation_on_message" AFTER INSERT ON "public"."messages" FOR EACH ROW EXECUTE FUNCTION "public"."update_conversation_on_message"();



CREATE OR REPLACE TRIGGER "trigger_update_conversation_unread_count" AFTER INSERT ON "public"."messages" FOR EACH ROW EXECUTE FUNCTION "public"."update_conversation_unread_count"();



CREATE OR REPLACE TRIGGER "trigger_update_email_tracking_updated_at" BEFORE UPDATE ON "public"."pre_registration_email_tracking" FOR EACH ROW EXECUTE FUNCTION "public"."update_email_tracking_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_ledger_overdue" BEFORE INSERT OR UPDATE ON "public"."student_ledgers" FOR EACH ROW EXECUTE FUNCTION "public"."update_ledger_overdue_status"();



CREATE OR REPLACE TRIGGER "trigger_update_license_assignments_updated_at" BEFORE UPDATE ON "public"."license_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."update_license_assignments_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_license_pools_updated_at" BEFORE UPDATE ON "public"."license_pools" FOR EACH ROW EXECUTE FUNCTION "public"."update_license_pools_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_mentor_note_timestamp" BEFORE UPDATE ON "public"."college_mentor_notes" FOR EACH ROW EXECUTE FUNCTION "public"."update_mentor_note_timestamp"();



CREATE OR REPLACE TRIGGER "trigger_update_organization_invitations_timestamp" BEFORE UPDATE ON "public"."organization_invitations" FOR EACH ROW EXECUTE FUNCTION "public"."update_organization_invitations_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_organization_subscriptions_updated_at" BEFORE UPDATE ON "public"."organization_subscriptions" FOR EACH ROW EXECUTE FUNCTION "public"."update_organization_subscriptions_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_saved_jobs_timestamp" BEFORE UPDATE ON "public"."saved_jobs" FOR EACH ROW EXECUTE FUNCTION "public"."update_saved_jobs_updated_at"();



CREATE OR REPLACE TRIGGER "trigger_update_section_enrollment_count" AFTER INSERT OR DELETE OR UPDATE ON "public"."student_enrollments" FOR EACH ROW EXECUTE FUNCTION "public"."update_section_enrollment_count"();



CREATE OR REPLACE TRIGGER "trigger_update_session_stats" AFTER INSERT OR DELETE OR UPDATE ON "public"."college_attendance_records" FOR EACH ROW EXECUTE FUNCTION "public"."update_session_attendance_stats"();



CREATE OR REPLACE TRIGGER "trigger_update_streak_timestamp" BEFORE UPDATE ON "public"."student_streaks" FOR EACH ROW EXECUTE FUNCTION "public"."update_streak_timestamp"();



CREATE OR REPLACE TRIGGER "trigger_update_swap_request_timestamp" BEFORE UPDATE ON "public"."class_swap_requests" FOR EACH ROW EXECUTE FUNCTION "public"."update_swap_request_timestamp"();



CREATE OR REPLACE TRIGGER "trigger_validate_pool_allocation" BEFORE INSERT OR UPDATE ON "public"."license_pools" FOR EACH ROW EXECUTE FUNCTION "public"."validate_pool_allocation"();



CREATE OR REPLACE TRIGGER "trigger_validate_seat_availability" BEFORE INSERT ON "public"."license_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."validate_seat_availability"();



CREATE OR REPLACE TRIGGER "update_adaptive_sessions_updated_at" BEFORE UPDATE ON "public"."adaptive_aptitude_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."update_adaptive_updated_at"();



CREATE OR REPLACE TRIGGER "update_admission_applications_updated_at" BEFORE UPDATE ON "public"."admission_applications" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_applied_jobs_updated_at" BEFORE UPDATE ON "public"."applied_jobs" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_assessment_types_updated_at" BEFORE UPDATE ON "public"."assessment_types" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_assessments_updated_at" BEFORE UPDATE ON "public"."assessments" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_attendance_records_updated_at" BEFORE UPDATE ON "public"."attendance_records" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_certificates_updated_at" BEFORE UPDATE ON "public"."certificates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_college_event_registrations_updated_at" BEFORE UPDATE ON "public"."college_event_registrations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_conversations_backup_20251106_updated_at" BEFORE UPDATE ON "public"."conversations_backup_20251106" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_conversations_updated_at" BEFORE UPDATE ON "public"."conversations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_course_enrollments_updated_at" BEFORE UPDATE ON "public"."course_enrollments" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_courses_updated_at" BEFORE UPDATE ON "public"."courses" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_curriculum_academic_years_updated_at" BEFORE UPDATE ON "public"."curriculum_academic_years" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_curriculum_chapters_updated_at" BEFORE UPDATE ON "public"."curriculum_chapters" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_curriculum_classes_updated_at" BEFORE UPDATE ON "public"."curriculum_classes" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_curriculum_courses_updated_at" BEFORE UPDATE ON "public"."curriculum_courses" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_curriculum_learning_outcomes_updated_at" BEFORE UPDATE ON "public"."curriculum_learning_outcomes" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_curriculum_on_chapter_change" AFTER INSERT OR DELETE OR UPDATE ON "public"."curriculum_chapters" FOR EACH ROW EXECUTE FUNCTION "public"."update_curriculum_last_modified"();



CREATE OR REPLACE TRIGGER "update_curriculum_on_outcome_change" AFTER INSERT OR DELETE OR UPDATE ON "public"."curriculum_learning_outcomes" FOR EACH ROW EXECUTE FUNCTION "public"."update_curriculum_last_modified"();



CREATE OR REPLACE TRIGGER "update_curriculum_subjects_updated_at" BEFORE UPDATE ON "public"."curriculum_subjects" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_curriculums_updated_at" BEFORE UPDATE ON "public"."curriculums" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_department_budgets_updated_at" BEFORE UPDATE ON "public"."department_budgets" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_department_faculty_assignments_updated_at" BEFORE UPDATE ON "public"."department_faculty_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_departments_updated_at" BEFORE UPDATE ON "public"."departments" FOR EACH ROW EXECUTE FUNCTION "public"."update_departments_updated_at"();



CREATE OR REPLACE TRIGGER "update_education_updated_at" BEFORE UPDATE ON "public"."education" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_exam_registrations_updated_at" BEFORE UPDATE ON "public"."exam_registrations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_exam_rooms_updated_at" BEFORE UPDATE ON "public"."exam_rooms" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_exam_seating_updated_at" BEFORE UPDATE ON "public"."exam_seating_arrangements" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_exam_timetable_updated_at" BEFORE UPDATE ON "public"."exam_timetable" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_exam_windows_updated_at" BEFORE UPDATE ON "public"."exam_windows" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_expenditures_updated_at" BEFORE UPDATE ON "public"."expenditures" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_external_assessment_attempts_timestamp" BEFORE UPDATE ON "public"."external_assessment_attempts" FOR EACH ROW EXECUTE FUNCTION "public"."update_external_assessment_attempts_updated_at"();



CREATE OR REPLACE TRIGGER "update_external_courses_updated_at" BEFORE UPDATE ON "public"."external_courses" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_fee_payments_updated_at" BEFORE UPDATE ON "public"."fee_payments" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_fee_structures_updated_at" BEFORE UPDATE ON "public"."fee_structures" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_grading_systems_updated_at" BEFORE UPDATE ON "public"."grading_systems" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_internships_updated_at" BEFORE UPDATE ON "public"."internships" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_interviews_updated_at" BEFORE UPDATE ON "public"."interviews" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_invigilator_assignments_updated_at" BEFORE UPDATE ON "public"."invigilator_assignments" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_lesson_plans_updated_at" BEFORE UPDATE ON "public"."lesson_plans" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_lessons_updated_at" BEFORE UPDATE ON "public"."lessons" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_library_book_issues_college_updated_at" BEFORE UPDATE ON "public"."library_book_issues_college" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_library_books_college_updated_at" BEFORE UPDATE ON "public"."library_books_college" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_library_books_updated_at" BEFORE UPDATE ON "public"."library_books" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_library_categories_college_updated_at" BEFORE UPDATE ON "public"."library_categories_college" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_library_issued_books_updated_at" BEFORE UPDATE ON "public"."library_issued_books" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_library_reservations_updated_at" BEFORE UPDATE ON "public"."library_reservations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_library_reviews_updated_at" BEFORE UPDATE ON "public"."library_reviews" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_library_settings_college_updated_at" BEFORE UPDATE ON "public"."library_settings_college" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_mark_entries_updated_at" BEFORE UPDATE ON "public"."mark_entries" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_mark_entry_batches_updated_at" BEFORE UPDATE ON "public"."mark_entry_batches" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_messages_updated_at" BEFORE UPDATE ON "public"."messages" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_modules_updated_at" BEFORE UPDATE ON "public"."course_modules" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_offers_updated_at" BEFORE UPDATE ON "public"."offers" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_opportunities_updated_at" BEFORE UPDATE ON "public"."opportunities" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_passports_timestamp" BEFORE UPDATE ON "public"."skill_passports" FOR EACH ROW EXECUTE FUNCTION "public"."update_timestamp"();



CREATE OR REPLACE TRIGGER "update_phone_otps_updated_at" BEFORE UPDATE ON "public"."phone_otps" FOR EACH ROW EXECUTE FUNCTION "public"."update_phone_otps_updated_at"();



CREATE OR REPLACE TRIGGER "update_pipeline_candidates_updated_at" BEFORE UPDATE ON "public"."pipeline_candidates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_placements_timestamp" BEFORE UPDATE ON "public"."placements" FOR EACH ROW EXECUTE FUNCTION "public"."update_timestamp"();



CREATE OR REPLACE TRIGGER "update_projects_updated_at" BEFORE UPDATE ON "public"."projects" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_recent_updates_updated_at" BEFORE UPDATE ON "public"."recent_updates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_recruiter_saved_searches_updated_at" BEFORE UPDATE ON "public"."recruiter_saved_searches" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_requisitions_updated_at" BEFORE UPDATE ON "public"."requisitions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_saved_jobs_updated_at" BEFORE UPDATE ON "public"."saved_jobs" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_school_classes_updated_at" BEFORE UPDATE ON "public"."school_classes" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_school_educators_updated_at" BEFORE UPDATE ON "public"."school_educators" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_shortlists_updated_at" BEFORE UPDATE ON "public"."shortlists" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_skill_assessments_updated_at" BEFORE UPDATE ON "public"."skill_assessments" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_skill_verification_requests_updated_at" BEFORE UPDATE ON "public"."skill_verification_requests" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_skills_updated_at" BEFORE UPDATE ON "public"."skills" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_student_ledgers_updated_at" BEFORE UPDATE ON "public"."student_ledgers" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_student_management_records_updated_at" BEFORE UPDATE ON "public"."student_management_records" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_students_updated_at" BEFORE UPDATE ON "public"."students" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_subscriptions_updated_at" BEFORE UPDATE ON "public"."subscriptions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_teacher_journal_updated_at" BEFORE UPDATE ON "public"."teacher_journal" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_timetable_slots_updated_at" BEFORE UPDATE ON "public"."timetable_slots" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_timetables_updated_at" BEFORE UPDATE ON "public"."timetables" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_trainings_updated_at" BEFORE UPDATE ON "public"."trainings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_transcript_requests_updated_at" BEFORE UPDATE ON "public"."transcript_requests" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_transcripts_updated_at" BEFORE UPDATE ON "public"."transcripts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_university_colleges_updated_at" BEFORE UPDATE ON "public"."university_colleges" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_university_courses_updated_at" BEFORE UPDATE ON "public"."university_courses" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_user_categories_updated_at" BEFORE UPDATE ON "public"."user_categories" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_user_profiles_updated_at" BEFORE UPDATE ON "public"."user_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "update_user_settings_updated_at" BEFORE UPDATE ON "public"."user_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();



CREATE OR REPLACE TRIGGER "validate_aadhar_trigger" BEFORE INSERT OR UPDATE ON "public"."students" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_validate_aadhar"();



CREATE OR REPLACE TRIGGER "validate_evaluation_items_trigger" BEFORE INSERT OR UPDATE OF "evaluation_items" ON "public"."lesson_plans" FOR EACH ROW EXECUTE FUNCTION "public"."validate_evaluation_items"();



CREATE OR REPLACE TRIGGER "validate_status_transition" BEFORE UPDATE ON "public"."subscriptions" FOR EACH ROW WHEN (("old"."status" IS DISTINCT FROM "new"."status")) EXECUTE FUNCTION "public"."validate_subscription_status_transition"();



ALTER TABLE ONLY "public"."adaptive_aptitude_responses"
    ADD CONSTRAINT "adaptive_aptitude_responses_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."adaptive_aptitude_sessions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."adaptive_aptitude_results"
    ADD CONSTRAINT "adaptive_aptitude_results_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."adaptive_aptitude_sessions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."adaptive_aptitude_results"
    ADD CONSTRAINT "adaptive_aptitude_results_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."adaptive_aptitude_sessions"
    ADD CONSTRAINT "adaptive_aptitude_sessions_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."addon_events"
    ADD CONSTRAINT "addon_events_bundle_id_fkey" FOREIGN KEY ("bundle_id") REFERENCES "public"."bundles"("id");



ALTER TABLE ONLY "public"."addon_events"
    ADD CONSTRAINT "addon_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."addon_pending_orders"
    ADD CONSTRAINT "addon_pending_orders_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."addon_pending_orders"
    ADD CONSTRAINT "addon_pending_orders_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_granted_by_fkey" FOREIGN KEY ("granted_by") REFERENCES "public"."admin_users"("id");



ALTER TABLE ONLY "public"."admin_users"
    ADD CONSTRAINT "admin_users_id_fkey" FOREIGN KEY ("id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admission_applications"
    ADD CONSTRAINT "admission_applications_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."admission_applications"
    ADD CONSTRAINT "admission_applications_verified_by_fkey" FOREIGN KEY ("verified_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."ai_evaluations"
    ADD CONSTRAINT "ai_evaluations_conversation_id_fkey" FOREIGN KEY ("conversation_id") REFERENCES "public"."career_ai_conversations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."approval_actions"
    ADD CONSTRAINT "approval_actions_approver_id_fkey" FOREIGN KEY ("approver_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."approval_actions"
    ADD CONSTRAINT "approval_actions_request_id_fkey" FOREIGN KEY ("request_id") REFERENCES "public"."approval_requests"("id");



ALTER TABLE ONLY "public"."approval_requests"
    ADD CONSTRAINT "approval_requests_requester_id_fkey" FOREIGN KEY ("requester_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."approval_requests"
    ADD CONSTRAINT "approval_requests_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "public"."approval_workflows"("id");



ALTER TABLE ONLY "public"."approval_workflows"
    ADD CONSTRAINT "approval_workflows_approval_type_fkey" FOREIGN KEY ("approval_type") REFERENCES "public"."approval_types"("name");



ALTER TABLE ONLY "public"."personal_assessment_attempts"
    ADD CONSTRAINT "assessment_attempts_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."personal_assessment_streams"("id");



ALTER TABLE ONLY "public"."personal_assessment_attempts"
    ADD CONSTRAINT "assessment_attempts_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."personal_assessment_questions"
    ADD CONSTRAINT "assessment_questions_section_id_fkey" FOREIGN KEY ("section_id") REFERENCES "public"."personal_assessment_sections"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."personal_assessment_questions"
    ADD CONSTRAINT "assessment_questions_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."personal_assessment_streams"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."personal_assessment_responses"
    ADD CONSTRAINT "assessment_responses_attempt_id_fkey" FOREIGN KEY ("attempt_id") REFERENCES "public"."personal_assessment_attempts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."personal_assessment_results"
    ADD CONSTRAINT "assessment_results_attempt_id_fkey" FOREIGN KEY ("attempt_id") REFERENCES "public"."personal_assessment_attempts"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."personal_assessment_results"
    ADD CONSTRAINT "assessment_results_stream_id_fkey" FOREIGN KEY ("stream_id") REFERENCES "public"."personal_assessment_streams"("id");



ALTER TABLE ONLY "public"."personal_assessment_results"
    ADD CONSTRAINT "assessment_results_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."assessments"
    ADD CONSTRAINT "assessments_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."assessments"
    ADD CONSTRAINT "assessments_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."assessments"
    ADD CONSTRAINT "assessments_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "public"."curriculum_courses"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."assessments"
    ADD CONSTRAINT "assessments_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."assessments"
    ADD CONSTRAINT "assessments_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."assessments"
    ADD CONSTRAINT "assessments_faculty_id_fkey" FOREIGN KEY ("faculty_id") REFERENCES "public"."college_lecturers"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."assessments"
    ADD CONSTRAINT "assessments_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."assessments"
    ADD CONSTRAINT "assessments_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."assessments"
    ADD CONSTRAINT "assessments_teacher_id_fkey" FOREIGN KEY ("teacher_id") REFERENCES "public"."school_educators"("id");



ALTER TABLE ONLY "public"."assignments"
    ADD CONSTRAINT "assignments_educator_fk" FOREIGN KEY ("educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."assignments"
    ADD CONSTRAINT "assignments_school_class_id_fkey" FOREIGN KEY ("school_class_id") REFERENCES "public"."school_classes"("id");



ALTER TABLE ONLY "public"."attendance_alerts"
    ADD CONSTRAINT "attendance_alerts_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."attendance_alerts"
    ADD CONSTRAINT "attendance_alerts_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."attendance_records"
    ADD CONSTRAINT "attendance_records_marked_by_fkey" FOREIGN KEY ("marked_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."attendance_records"
    ADD CONSTRAINT "attendance_records_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."attendance_records"
    ADD CONSTRAINT "attendance_records_slot_id_fkey" FOREIGN KEY ("slot_id") REFERENCES "public"."timetable_slots"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."attendance_records"
    ADD CONSTRAINT "attendance_records_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."audit_logs"
    ADD CONSTRAINT "audit_logs_actorid_fkey" FOREIGN KEY ("actorId") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."budget_alerts"
    ADD CONSTRAINT "budget_alerts_acknowledged_by_fkey" FOREIGN KEY ("acknowledged_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."budget_alerts"
    ADD CONSTRAINT "budget_alerts_budget_id_fkey" FOREIGN KEY ("budget_id") REFERENCES "public"."department_budgets"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."budget_alerts"
    ADD CONSTRAINT "budget_alerts_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id");



ALTER TABLE ONLY "public"."budget_revisions"
    ADD CONSTRAINT "budget_revisions_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."budget_revisions"
    ADD CONSTRAINT "budget_revisions_budget_id_fkey" FOREIGN KEY ("budget_id") REFERENCES "public"."department_budgets"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."budget_revisions"
    ADD CONSTRAINT "budget_revisions_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id");



ALTER TABLE ONLY "public"."budget_revisions"
    ADD CONSTRAINT "budget_revisions_requested_by_fkey" FOREIGN KEY ("requested_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."bundle_features"
    ADD CONSTRAINT "bundle_features_bundle_id_fkey" FOREIGN KEY ("bundle_id") REFERENCES "public"."bundles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."career_ai_conversations"
    ADD CONSTRAINT "career_ai_conversations_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."career_assessment_ai_questions"
    ADD CONSTRAINT "career_assessment_ai_questions_attempt_id_fkey" FOREIGN KEY ("attempt_id") REFERENCES "public"."personal_assessment_attempts"("id");



ALTER TABLE ONLY "public"."career_assessment_ai_questions"
    ADD CONSTRAINT "career_assessment_ai_questions_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id");



ALTER TABLE ONLY "public"."certificates"
    ADD CONSTRAINT "certificates_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."certificates"
    ADD CONSTRAINT "certificates_training_id_fkey" FOREIGN KEY ("training_id") REFERENCES "public"."trainings"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."class_swap_history"
    ADD CONSTRAINT "class_swap_history_swap_request_id_fkey" FOREIGN KEY ("swap_request_id") REFERENCES "public"."class_swap_requests"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."club_activities"
    ADD CONSTRAINT "club_activities_club_id_fkey" FOREIGN KEY ("club_id") REFERENCES "public"."clubs"("club_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."club_activities"
    ADD CONSTRAINT "club_activities_created_by_educator_id_fkey" FOREIGN KEY ("created_by_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."club_attendance"
    ADD CONSTRAINT "club_attendance_club_id_fkey" FOREIGN KEY ("club_id") REFERENCES "public"."clubs"("club_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."club_attendance"
    ADD CONSTRAINT "club_attendance_created_by_educator_id_fkey" FOREIGN KEY ("created_by_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."club_attendance_records"
    ADD CONSTRAINT "club_attendance_records_attendance_id_fkey" FOREIGN KEY ("attendance_id") REFERENCES "public"."club_attendance"("attendance_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."club_attendance_records"
    ADD CONSTRAINT "club_attendance_records_marked_by_educator_id_fkey" FOREIGN KEY ("marked_by_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."club_certificates"
    ADD CONSTRAINT "club_certificates_issued_by_educator_id_fkey" FOREIGN KEY ("issued_by_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."club_certificates"
    ADD CONSTRAINT "club_certificates_related_badge_id_fkey" FOREIGN KEY ("related_badge_id") REFERENCES "public"."skill_badges"("badge_id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."club_certificates"
    ADD CONSTRAINT "club_certificates_related_club_id_fkey" FOREIGN KEY ("related_club_id") REFERENCES "public"."clubs"("club_id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."club_certificates"
    ADD CONSTRAINT "club_certificates_related_comp_id_fkey" FOREIGN KEY ("related_comp_id") REFERENCES "public"."competitions"("comp_id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."club_certificates"
    ADD CONSTRAINT "club_certificates_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."club_memberships"
    ADD CONSTRAINT "club_memberships_club_id_fkey" FOREIGN KEY ("club_id") REFERENCES "public"."clubs"("club_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."club_memberships"
    ADD CONSTRAINT "club_memberships_enrolled_by_educator_id_fkey" FOREIGN KEY ("enrolled_by_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."clubs"
    ADD CONSTRAINT "clubs_created_by_educator_id_fkey" FOREIGN KEY ("created_by_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."clubs"
    ADD CONSTRAINT "clubs_mentor_educator_id_fkey" FOREIGN KEY ("mentor_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."clubs"
    ADD CONSTRAINT "clubs_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_assignment_attachments"
    ADD CONSTRAINT "college_assignment_attachments_assignment_id_fkey" FOREIGN KEY ("assignment_id") REFERENCES "public"."college_assignments"("assignment_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_assignment_attachments"
    ADD CONSTRAINT "college_assignment_attachments_uploaded_by_fkey" FOREIGN KEY ("uploaded_by") REFERENCES "public"."college_lecturers"("user_id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_assignments"
    ADD CONSTRAINT "college_assignments_college_educator_id_fkey" FOREIGN KEY ("college_educator_id") REFERENCES "public"."college_lecturers"("user_id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_assignments"
    ADD CONSTRAINT "college_assignments_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_assignments"
    ADD CONSTRAINT "college_assignments_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_assignments"
    ADD CONSTRAINT "college_assignments_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_assignments"
    ADD CONSTRAINT "college_assignments_program_section_id_fkey" FOREIGN KEY ("program_section_id") REFERENCES "public"."program_sections"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_attendance_records"
    ADD CONSTRAINT "college_attendance_records_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_attendance_records"
    ADD CONSTRAINT "college_attendance_records_faculty_id_fkey" FOREIGN KEY ("faculty_id") REFERENCES "public"."college_lecturers"("id");



ALTER TABLE ONLY "public"."college_attendance_records"
    ADD CONSTRAINT "college_attendance_records_marked_by_fkey" FOREIGN KEY ("marked_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."college_attendance_records"
    ADD CONSTRAINT "college_attendance_records_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."college_attendance_sessions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_attendance_records"
    ADD CONSTRAINT "college_attendance_records_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id");



ALTER TABLE ONLY "public"."college_attendance_sessions"
    ADD CONSTRAINT "college_attendance_sessions_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_attendance_sessions"
    ADD CONSTRAINT "college_attendance_sessions_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."college_attendance_sessions"
    ADD CONSTRAINT "college_attendance_sessions_faculty_id_fkey" FOREIGN KEY ("faculty_id") REFERENCES "public"."college_lecturers"("id");



ALTER TABLE ONLY "public"."college_attendance_settings"
    ADD CONSTRAINT "college_attendance_settings_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_breaks"
    ADD CONSTRAINT "college_breaks_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_breaks"
    ADD CONSTRAINT "college_breaks_timetable_id_fkey" FOREIGN KEY ("timetable_id") REFERENCES "public"."college_timetables"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_circulars"
    ADD CONSTRAINT "college_circulars_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_circulars"
    ADD CONSTRAINT "college_circulars_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."college_classes"
    ADD CONSTRAINT "college_classes_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_classes"
    ADD CONSTRAINT "college_classes_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id");



ALTER TABLE ONLY "public"."college_course_mappings"
    ADD CONSTRAINT "college_course_mappings_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "public"."college_courses"("id");



ALTER TABLE ONLY "public"."college_course_mappings"
    ADD CONSTRAINT "college_course_mappings_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_course_mappings"
    ADD CONSTRAINT "college_course_mappings_faculty_id_fkey" FOREIGN KEY ("faculty_id") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_course_mappings"
    ADD CONSTRAINT "college_course_mappings_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_course_mappings"
    ADD CONSTRAINT "college_course_mappings_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_courses"
    ADD CONSTRAINT "college_courses_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_curriculum_outcomes"
    ADD CONSTRAINT "college_curriculum_outcomes_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."college_curriculum_outcomes"
    ADD CONSTRAINT "college_curriculum_outcomes_curriculum_id_fkey" FOREIGN KEY ("curriculum_id") REFERENCES "public"."college_curriculums"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_curriculum_outcomes"
    ADD CONSTRAINT "college_curriculum_outcomes_unit_id_fkey" FOREIGN KEY ("unit_id") REFERENCES "public"."college_curriculum_units"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_curriculum_outcomes"
    ADD CONSTRAINT "college_curriculum_outcomes_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."college_curriculum_units"
    ADD CONSTRAINT "college_curriculum_units_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."college_curriculum_units"
    ADD CONSTRAINT "college_curriculum_units_curriculum_id_fkey" FOREIGN KEY ("curriculum_id") REFERENCES "public"."college_curriculums"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_curriculum_units"
    ADD CONSTRAINT "college_curriculum_units_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "college_curriculums_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "college_curriculums_cloned_from_id_fkey" FOREIGN KEY ("cloned_from_id") REFERENCES "public"."college_curriculums"("id");



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "college_curriculums_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "college_curriculums_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "public"."college_courses"("id");



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "college_curriculums_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "college_curriculums_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id");



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "college_curriculums_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id");



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "college_curriculums_requested_by_fkey" FOREIGN KEY ("requested_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "college_curriculums_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "college_curriculums_university_id_fkey" FOREIGN KEY ("university_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_event_registrations"
    ADD CONSTRAINT "college_event_registrations_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."college_events"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_event_registrations"
    ADD CONSTRAINT "college_event_registrations_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_events"
    ADD CONSTRAINT "college_events_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_events"
    ADD CONSTRAINT "college_events_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."college_faculty_class_assignments"
    ADD CONSTRAINT "college_faculty_class_assignments_class_id_fkey" FOREIGN KEY ("class_id") REFERENCES "public"."college_classes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_class_assignments"
    ADD CONSTRAINT "college_faculty_class_assignments_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_class_assignments"
    ADD CONSTRAINT "college_faculty_class_assignments_faculty_id_fkey" FOREIGN KEY ("faculty_id") REFERENCES "public"."college_lecturers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_leave_balances"
    ADD CONSTRAINT "college_faculty_leave_balances_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_leave_balances"
    ADD CONSTRAINT "college_faculty_leave_balances_faculty_id_fkey" FOREIGN KEY ("faculty_id") REFERENCES "public"."college_lecturers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_leave_balances"
    ADD CONSTRAINT "college_faculty_leave_balances_leave_type_id_fkey" FOREIGN KEY ("leave_type_id") REFERENCES "public"."college_leave_types"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_leaves"
    ADD CONSTRAINT "college_faculty_leaves_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_leaves"
    ADD CONSTRAINT "college_faculty_leaves_faculty_id_fkey" FOREIGN KEY ("faculty_id") REFERENCES "public"."college_lecturers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_leaves"
    ADD CONSTRAINT "college_faculty_leaves_leave_type_id_fkey" FOREIGN KEY ("leave_type_id") REFERENCES "public"."college_leave_types"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_leaves"
    ADD CONSTRAINT "college_faculty_leaves_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."college_faculty_substitutions"
    ADD CONSTRAINT "college_faculty_substitutions_class_id_fkey" FOREIGN KEY ("class_id") REFERENCES "public"."college_classes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_substitutions"
    ADD CONSTRAINT "college_faculty_substitutions_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_substitutions"
    ADD CONSTRAINT "college_faculty_substitutions_leave_id_fkey" FOREIGN KEY ("leave_id") REFERENCES "public"."college_faculty_leaves"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_substitutions"
    ADD CONSTRAINT "college_faculty_substitutions_original_faculty_id_fkey" FOREIGN KEY ("original_faculty_id") REFERENCES "public"."college_lecturers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_faculty_substitutions"
    ADD CONSTRAINT "college_faculty_substitutions_substitute_faculty_id_fkey" FOREIGN KEY ("substitute_faculty_id") REFERENCES "public"."college_lecturers"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_faculty_substitutions"
    ADD CONSTRAINT "college_faculty_substitutions_timetable_slot_id_fkey" FOREIGN KEY ("timetable_slot_id") REFERENCES "public"."college_timetable_slots"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_leave_types"
    ADD CONSTRAINT "college_leave_types_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_lecturers"
    ADD CONSTRAINT "college_lecturers_collegeid_fkey" FOREIGN KEY ("collegeId") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_lesson_plans"
    ADD CONSTRAINT "college_lesson_plans_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_lesson_plans"
    ADD CONSTRAINT "college_lesson_plans_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "public"."college_courses"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_lesson_plans"
    ADD CONSTRAINT "college_lesson_plans_curriculum_id_fkey" FOREIGN KEY ("curriculum_id") REFERENCES "public"."college_curriculums"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_lesson_plans"
    ADD CONSTRAINT "college_lesson_plans_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_lesson_plans"
    ADD CONSTRAINT "college_lesson_plans_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_lesson_plans"
    ADD CONSTRAINT "college_lesson_plans_unit_id_fkey" FOREIGN KEY ("unit_id") REFERENCES "public"."college_curriculum_units"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_mentor_notes"
    ADD CONSTRAINT "college_mentor_notes_allocation_id_fkey" FOREIGN KEY ("allocation_id") REFERENCES "public"."college_mentor_student_allocations"("id");



ALTER TABLE ONLY "public"."college_mentor_notes"
    ADD CONSTRAINT "college_mentor_notes_created_by_id_fkey" FOREIGN KEY ("created_by_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."college_mentor_notes"
    ADD CONSTRAINT "college_mentor_notes_last_updated_by_fkey" FOREIGN KEY ("last_updated_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."college_mentor_notes"
    ADD CONSTRAINT "college_mentor_notes_mentor_id_fkey" FOREIGN KEY ("mentor_id") REFERENCES "public"."college_lecturers"("id");



ALTER TABLE ONLY "public"."college_mentor_notes"
    ADD CONSTRAINT "college_mentor_notes_resolved_by_fkey" FOREIGN KEY ("resolved_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."college_mentor_notes"
    ADD CONSTRAINT "college_mentor_notes_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id");



ALTER TABLE ONLY "public"."college_mentor_periods"
    ADD CONSTRAINT "college_mentor_periods_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."university_colleges"("id");



ALTER TABLE ONLY "public"."college_mentor_periods"
    ADD CONSTRAINT "college_mentor_periods_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."college_lecturers"("id");



ALTER TABLE ONLY "public"."college_mentor_student_allocations"
    ADD CONSTRAINT "college_mentor_student_allocations_assigned_by_fkey" FOREIGN KEY ("assigned_by") REFERENCES "public"."college_lecturers"("id");



ALTER TABLE ONLY "public"."college_mentor_student_allocations"
    ADD CONSTRAINT "college_mentor_student_allocations_mentor_id_fkey" FOREIGN KEY ("mentor_id") REFERENCES "public"."college_lecturers"("id");



ALTER TABLE ONLY "public"."college_mentor_student_allocations"
    ADD CONSTRAINT "college_mentor_student_allocations_period_id_fkey" FOREIGN KEY ("period_id") REFERENCES "public"."college_mentor_periods"("id");



ALTER TABLE ONLY "public"."college_mentor_student_allocations"
    ADD CONSTRAINT "college_mentor_student_allocations_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id");



ALTER TABLE ONLY "public"."college_role_module_permissions"
    ADD CONSTRAINT "college_role_module_permissions_module_id_fkey" FOREIGN KEY ("module_id") REFERENCES "public"."college_setting_modules"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_role_module_permissions"
    ADD CONSTRAINT "college_role_module_permissions_permission_id_fkey" FOREIGN KEY ("permission_id") REFERENCES "public"."college_setting_permissions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_student_assignments"
    ADD CONSTRAINT "college_student_assignments_assignment_id_fkey" FOREIGN KEY ("assignment_id") REFERENCES "public"."college_assignments"("assignment_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_student_assignments"
    ADD CONSTRAINT "college_student_assignments_graded_by_fkey" FOREIGN KEY ("graded_by") REFERENCES "public"."college_lecturers"("user_id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_student_assignments"
    ADD CONSTRAINT "college_student_assignments_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("user_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_time_periods"
    ADD CONSTRAINT "college_time_periods_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_time_periods"
    ADD CONSTRAINT "college_time_periods_timetable_id_fkey" FOREIGN KEY ("timetable_id") REFERENCES "public"."college_timetables"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_timetable_slots"
    ADD CONSTRAINT "college_timetable_slots_class_id_fkey" FOREIGN KEY ("class_id") REFERENCES "public"."college_classes"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_timetable_slots"
    ADD CONSTRAINT "college_timetable_slots_educator_id_fkey" FOREIGN KEY ("educator_id") REFERENCES "public"."college_lecturers"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."college_timetable_slots"
    ADD CONSTRAINT "college_timetable_slots_timetable_id_fkey" FOREIGN KEY ("timetable_id") REFERENCES "public"."college_timetables"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_timetables"
    ADD CONSTRAINT "college_timetables_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."competition_clubs"
    ADD CONSTRAINT "competition_clubs_club_id_fkey" FOREIGN KEY ("club_id") REFERENCES "public"."clubs"("club_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."competition_clubs"
    ADD CONSTRAINT "competition_clubs_comp_id_fkey" FOREIGN KEY ("comp_id") REFERENCES "public"."competitions"("comp_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."competition_clubs"
    ADD CONSTRAINT "competition_clubs_registered_by_educator_id_fkey" FOREIGN KEY ("registered_by_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."competition_registrations"
    ADD CONSTRAINT "competition_registrations_comp_id_fkey" FOREIGN KEY ("comp_id") REFERENCES "public"."competitions"("comp_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."competition_registrations"
    ADD CONSTRAINT "competition_registrations_registered_by_educator_id_fkey" FOREIGN KEY ("registered_by_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."competition_results"
    ADD CONSTRAINT "competition_results_comp_id_fkey" FOREIGN KEY ("comp_id") REFERENCES "public"."competitions"("comp_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."competition_results"
    ADD CONSTRAINT "competition_results_recorded_by_educator_id_fkey" FOREIGN KEY ("recorded_by_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."competition_results"
    ADD CONSTRAINT "competition_results_registration_id_fkey" FOREIGN KEY ("registration_id") REFERENCES "public"."competition_registrations"("registration_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."competitions"
    ADD CONSTRAINT "competitions_created_by_educator_id_fkey" FOREIGN KEY ("created_by_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."competitions"
    ADD CONSTRAINT "competitions_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_application_id_fkey" FOREIGN KEY ("application_id") REFERENCES "public"."applied_jobs"("id_old");



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_class_id_fkey" FOREIGN KEY ("class_id") REFERENCES "public"."school_classes"("id");



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_opportunity_id_fkey" FOREIGN KEY ("opportunity_id") REFERENCES "public"."opportunities"("id_old");



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_program_section_id_fkey" FOREIGN KEY ("program_section_id") REFERENCES "public"."program_sections"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_recruiter_id_fkey" FOREIGN KEY ("recruiter_id") REFERENCES "public"."recruiters"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("user_id");



ALTER TABLE ONLY "public"."course_enrollments"
    ADD CONSTRAINT "course_enrollments_training_id_fkey" FOREIGN KEY ("training_id") REFERENCES "public"."trainings"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."courses"
    ADD CONSTRAINT "courses_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."courses"
    ADD CONSTRAINT "courses_educator_id_fkey" FOREIGN KEY ("educator_id") REFERENCES "public"."admin_users"("id") ON UPDATE CASCADE ON DELETE SET NULL;



ALTER TABLE ONLY "public"."courses"
    ADD CONSTRAINT "courses_rejected_by_fkey" FOREIGN KEY ("rejected_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."courses"
    ADD CONSTRAINT "courses_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."curriculum_academic_years"
    ADD CONSTRAINT "curriculum_academic_years_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."curriculum_chapters"
    ADD CONSTRAINT "curriculum_chapters_curriculum_id_fkey" FOREIGN KEY ("curriculum_id") REFERENCES "public"."curriculums"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."curriculum_classes"
    ADD CONSTRAINT "curriculum_classes_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."curriculum_courses"
    ADD CONSTRAINT "curriculum_courses_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."curriculum_courses"
    ADD CONSTRAINT "curriculum_courses_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."curriculum_courses"
    ADD CONSTRAINT "curriculum_courses_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."curriculum_courses"
    ADD CONSTRAINT "curriculum_courses_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."curriculum_learning_outcomes"
    ADD CONSTRAINT "curriculum_learning_outcomes_chapter_id_fkey" FOREIGN KEY ("chapter_id") REFERENCES "public"."curriculum_chapters"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."curriculum_subjects"
    ADD CONSTRAINT "curriculum_subjects_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."curriculums"
    ADD CONSTRAINT "curriculums_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."curriculums"
    ADD CONSTRAINT "curriculums_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."curriculums"
    ADD CONSTRAINT "curriculums_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."department_budgets"
    ADD CONSTRAINT "department_budgets_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."department_budgets"
    ADD CONSTRAINT "department_budgets_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."department_budgets"
    ADD CONSTRAINT "department_budgets_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."department_budgets"
    ADD CONSTRAINT "department_budgets_previous_budget_id_fkey" FOREIGN KEY ("previous_budget_id") REFERENCES "public"."department_budgets"("id");



ALTER TABLE ONLY "public"."department_budgets"
    ADD CONSTRAINT "department_budgets_submitted_by_fkey" FOREIGN KEY ("submitted_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."department_faculty_assignments"
    ADD CONSTRAINT "department_faculty_assignments_assigned_by_fkey" FOREIGN KEY ("assigned_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."department_faculty_assignments"
    ADD CONSTRAINT "department_faculty_assignments_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."department_faculty_assignments"
    ADD CONSTRAINT "department_faculty_assignments_lecturer_id_fkey" FOREIGN KEY ("lecturer_id") REFERENCES "public"."college_lecturers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."departments"
    ADD CONSTRAINT "departments_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."departments"
    ADD CONSTRAINT "departments_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."departments"
    ADD CONSTRAINT "departments_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."departments"
    ADD CONSTRAINT "departments_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."document_access_history"
    ADD CONSTRAINT "document_access_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."education"
    ADD CONSTRAINT "education_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."event_registrations"
    ADD CONSTRAINT "event_registrations_student_tier_id_fkey" FOREIGN KEY ("student_tier_id") REFERENCES "public"."institution_pricing_tiers"("id");



ALTER TABLE ONLY "public"."event_registrations"
    ADD CONSTRAINT "event_registrations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."exam_registrations"
    ADD CONSTRAINT "exam_registrations_assessment_id_fkey" FOREIGN KEY ("assessment_id") REFERENCES "public"."assessments"("id");



ALTER TABLE ONLY "public"."exam_registrations"
    ADD CONSTRAINT "exam_registrations_exam_window_id_fkey" FOREIGN KEY ("exam_window_id") REFERENCES "public"."exam_windows"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exam_registrations"
    ADD CONSTRAINT "exam_registrations_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id");



ALTER TABLE ONLY "public"."exam_registrations"
    ADD CONSTRAINT "exam_registrations_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exam_registrations"
    ADD CONSTRAINT "exam_registrations_student_record_id_fkey" FOREIGN KEY ("student_record_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exam_rooms"
    ADD CONSTRAINT "exam_rooms_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exam_rooms"
    ADD CONSTRAINT "exam_rooms_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exam_seating_arrangements"
    ADD CONSTRAINT "exam_seating_arrangements_exam_room_id_fkey" FOREIGN KEY ("exam_room_id") REFERENCES "public"."exam_rooms"("id");



ALTER TABLE ONLY "public"."exam_seating_arrangements"
    ADD CONSTRAINT "exam_seating_arrangements_exam_timetable_id_fkey" FOREIGN KEY ("exam_timetable_id") REFERENCES "public"."exam_timetable"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exam_seating_arrangements"
    ADD CONSTRAINT "exam_seating_arrangements_marked_by_fkey" FOREIGN KEY ("marked_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."exam_seating_arrangements"
    ADD CONSTRAINT "exam_seating_arrangements_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."exam_seating_arrangements"
    ADD CONSTRAINT "exam_seating_arrangements_student_record_id_fkey" FOREIGN KEY ("student_record_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exam_timetable"
    ADD CONSTRAINT "exam_timetable_assessment_id_fkey" FOREIGN KEY ("assessment_id") REFERENCES "public"."assessments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exam_timetable"
    ADD CONSTRAINT "exam_timetable_chief_invigilator_fkey" FOREIGN KEY ("chief_invigilator") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."exam_timetable"
    ADD CONSTRAINT "exam_timetable_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exam_windows"
    ADD CONSTRAINT "exam_windows_assessment_type_id_fkey" FOREIGN KEY ("assessment_type_id") REFERENCES "public"."assessment_types"("id");



ALTER TABLE ONLY "public"."exam_windows"
    ADD CONSTRAINT "exam_windows_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exam_windows"
    ADD CONSTRAINT "exam_windows_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."exam_windows"
    ADD CONSTRAINT "exam_windows_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id");



ALTER TABLE ONLY "public"."exam_windows"
    ADD CONSTRAINT "exam_windows_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id");



ALTER TABLE ONLY "public"."exam_windows"
    ADD CONSTRAINT "exam_windows_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."expenditures"
    ADD CONSTRAINT "expenditures_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."expenditures"
    ADD CONSTRAINT "expenditures_budget_id_fkey" FOREIGN KEY ("budget_id") REFERENCES "public"."department_budgets"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."expenditures"
    ADD CONSTRAINT "expenditures_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."expenditures"
    ADD CONSTRAINT "expenditures_override_approved_by_fkey" FOREIGN KEY ("override_approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."expenditures"
    ADD CONSTRAINT "expenditures_recorded_by_fkey" FOREIGN KEY ("recorded_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."expenditures"
    ADD CONSTRAINT "expenditures_reimbursement_to_fkey" FOREIGN KEY ("reimbursement_to") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."expenditures"
    ADD CONSTRAINT "expenditures_submitted_by_fkey" FOREIGN KEY ("submitted_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."experience"
    ADD CONSTRAINT "experience_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."experience"
    ADD CONSTRAINT "experience_rejected_by_fkey" FOREIGN KEY ("rejected_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."experience"
    ADD CONSTRAINT "experience_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."export_activities"
    ADD CONSTRAINT "export_activities_shortlist_id_fkey" FOREIGN KEY ("shortlist_id") REFERENCES "public"."shortlists"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."external_assessment_attempts"
    ADD CONSTRAINT "external_assessment_attempts_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."external_courses"
    ADD CONSTRAINT "external_courses_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("user_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."external_courses"
    ADD CONSTRAINT "external_courses_training_id_fkey" FOREIGN KEY ("training_id") REFERENCES "public"."trainings"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."fee_payments"
    ADD CONSTRAINT "fee_payments_ledger_id_fkey" FOREIGN KEY ("ledger_id") REFERENCES "public"."student_ledgers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."fee_payments"
    ADD CONSTRAINT "fee_payments_reconciled_by_fkey" FOREIGN KEY ("reconciled_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."fee_payments"
    ADD CONSTRAINT "fee_payments_recorded_by_fkey" FOREIGN KEY ("recorded_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."fee_payments"
    ADD CONSTRAINT "fee_payments_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."fee_payments"
    ADD CONSTRAINT "fee_payments_verified_by_fkey" FOREIGN KEY ("verified_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."fee_structures"
    ADD CONSTRAINT "fee_structures_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."fee_structures"
    ADD CONSTRAINT "fee_structures_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."fee_structures"
    ADD CONSTRAINT "fee_structures_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."fee_structures"
    ADD CONSTRAINT "fee_structures_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."applied_jobs"
    ADD CONSTRAINT "fk_applied_jobs_opportunity" FOREIGN KEY ("opportunity_id") REFERENCES "public"."opportunities"("id");



ALTER TABLE ONLY "public"."applied_jobs"
    ADD CONSTRAINT "fk_applied_jobs_student" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id");



ALTER TABLE ONLY "public"."assignment_attachments"
    ADD CONSTRAINT "fk_attachment_assignment" FOREIGN KEY ("assignment_id") REFERENCES "public"."assignments"("assignment_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_lecturers"
    ADD CONSTRAINT "fk_college_lecturers_user" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."course_modules"
    ADD CONSTRAINT "fk_course" FOREIGN KEY ("course_id") REFERENCES "public"."courses"("course_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."course_classes"
    ADD CONSTRAINT "fk_course_class" FOREIGN KEY ("course_id") REFERENCES "public"."courses"("course_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."course_co_educators"
    ADD CONSTRAINT "fk_course_co_edu" FOREIGN KEY ("course_id") REFERENCES "public"."courses"("course_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."course_skills"
    ADD CONSTRAINT "fk_course_skill" FOREIGN KEY ("course_id") REFERENCES "public"."courses"("course_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."college_curriculums"
    ADD CONSTRAINT "fk_curriculum_course_id" FOREIGN KEY ("course_id") REFERENCES "public"."college_courses"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."course_co_educators"
    ADD CONSTRAINT "fk_educator_co_edu" FOREIGN KEY ("educator_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."lesson_resources"
    ADD CONSTRAINT "fk_lesson" FOREIGN KEY ("lesson_id") REFERENCES "public"."lessons"("lesson_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."lessons"
    ADD CONSTRAINT "fk_module" FOREIGN KEY ("module_id") REFERENCES "public"."course_modules"("module_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profile_views"
    ADD CONSTRAINT "fk_profile_views_student" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profile_views"
    ADD CONSTRAINT "fk_profile_views_viewer" FOREIGN KEY ("viewer_id") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."saved_jobs"
    ADD CONSTRAINT "fk_saved_jobs_opportunity" FOREIGN KEY ("opportunity_id") REFERENCES "public"."opportunities"("id");



ALTER TABLE ONLY "public"."saved_jobs"
    ADD CONSTRAINT "fk_saved_jobs_student" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id");



ALTER TABLE ONLY "public"."student_assignments"
    ADD CONSTRAINT "fk_student_assignment_assignment" FOREIGN KEY ("assignment_id") REFERENCES "public"."assignments"("assignment_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."club_memberships"
    ADD CONSTRAINT "fk_student_email" FOREIGN KEY ("student_email") REFERENCES "public"."students"("email") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."club_attendance_records"
    ADD CONSTRAINT "fk_student_email" FOREIGN KEY ("student_email") REFERENCES "public"."students"("email") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."competition_registrations"
    ADD CONSTRAINT "fk_student_email" FOREIGN KEY ("student_email") REFERENCES "public"."students"("email") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."competition_results"
    ADD CONSTRAINT "fk_student_email" FOREIGN KEY ("student_email") REFERENCES "public"."students"("email") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_skill_badges"
    ADD CONSTRAINT "fk_student_email" FOREIGN KEY ("student_email") REFERENCES "public"."students"("email") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."club_certificates"
    ADD CONSTRAINT "fk_student_email" FOREIGN KEY ("student_email") REFERENCES "public"."students"("email") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "fk_students_user" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "fk_subscriptions_plan_id" FOREIGN KEY ("plan_id") REFERENCES "public"."subscription_plans"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "fk_subscriptions_public_users" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "fk_subscriptions_user_id" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."exam_timetable"
    ADD CONSTRAINT "fk_timetable_class" FOREIGN KEY ("class_id") REFERENCES "public"."school_classes"("id");



ALTER TABLE ONLY "public"."exam_timetable"
    ADD CONSTRAINT "fk_timetable_subject" FOREIGN KEY ("subject_id") REFERENCES "public"."curriculum_subjects"("id");



ALTER TABLE ONLY "public"."user_entitlements"
    ADD CONSTRAINT "fk_user_entitlements_bundle" FOREIGN KEY ("bundle_id") REFERENCES "public"."bundles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."internships"
    ADD CONSTRAINT "internships_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."internships"
    ADD CONSTRAINT "internships_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."interview_reminders"
    ADD CONSTRAINT "interview_reminders_interview_id_fkey" FOREIGN KEY ("interview_id") REFERENCES "public"."interviews"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."interviews"
    ADD CONSTRAINT "interviews_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("user_id");



ALTER TABLE ONLY "public"."invigilator_assignments"
    ADD CONSTRAINT "invigilator_assignments_assigned_by_fkey" FOREIGN KEY ("assigned_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."invigilator_assignments"
    ADD CONSTRAINT "invigilator_assignments_exam_room_id_fkey" FOREIGN KEY ("exam_room_id") REFERENCES "public"."exam_rooms"("id");



ALTER TABLE ONLY "public"."invigilator_assignments"
    ADD CONSTRAINT "invigilator_assignments_exam_timetable_id_fkey" FOREIGN KEY ("exam_timetable_id") REFERENCES "public"."exam_timetable"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."invigilator_assignments"
    ADD CONSTRAINT "invigilator_assignments_invigilator_id_fkey" FOREIGN KEY ("invigilator_id") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."invigilator_assignments"
    ADD CONSTRAINT "invigilator_assignments_lecturer_record_id_fkey" FOREIGN KEY ("lecturer_record_id") REFERENCES "public"."college_lecturers"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."lesson_plans"
    ADD CONSTRAINT "lesson_plans_chapter_id_fkey" FOREIGN KEY ("chapter_id") REFERENCES "public"."curriculum_chapters"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."lesson_plans"
    ADD CONSTRAINT "lesson_plans_class_id_fkey" FOREIGN KEY ("class_id") REFERENCES "public"."school_classes"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."lesson_plans"
    ADD CONSTRAINT "lesson_plans_educator_id_fkey" FOREIGN KEY ("educator_id") REFERENCES "public"."school_educators"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."lesson_plans"
    ADD CONSTRAINT "lesson_plans_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."library_book_issues"
    ADD CONSTRAINT "library_book_issues_book_id_fkey" FOREIGN KEY ("book_id") REFERENCES "public"."library_books"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."library_book_issues_college"
    ADD CONSTRAINT "library_book_issues_college_book_id_fkey" FOREIGN KEY ("book_id") REFERENCES "public"."library_books_college"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."library_book_issues_school"
    ADD CONSTRAINT "library_book_issues_school_book_id_fkey" FOREIGN KEY ("book_id") REFERENCES "public"."library_books_school"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."library_book_issues"
    ADD CONSTRAINT "library_book_issues_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."library_books"
    ADD CONSTRAINT "library_books_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."library_books"
    ADD CONSTRAINT "library_books_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."library_books"
    ADD CONSTRAINT "library_books_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id");



ALTER TABLE ONLY "public"."library_history"
    ADD CONSTRAINT "library_history_book_id_fkey" FOREIGN KEY ("book_id") REFERENCES "public"."library_books"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."library_history"
    ADD CONSTRAINT "library_history_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id");



ALTER TABLE ONLY "public"."library_history"
    ADD CONSTRAINT "library_history_issued_by_fkey" FOREIGN KEY ("issued_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."library_history"
    ADD CONSTRAINT "library_history_returned_to_fkey" FOREIGN KEY ("returned_to") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."library_history"
    ADD CONSTRAINT "library_history_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."library_history"
    ADD CONSTRAINT "library_history_student_record_id_fkey" FOREIGN KEY ("student_record_id") REFERENCES "public"."students"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."library_issued_books"
    ADD CONSTRAINT "library_issued_books_book_id_fkey" FOREIGN KEY ("book_id") REFERENCES "public"."library_books"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."library_issued_books"
    ADD CONSTRAINT "library_issued_books_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id");



ALTER TABLE ONLY "public"."library_issued_books"
    ADD CONSTRAINT "library_issued_books_issued_by_fkey" FOREIGN KEY ("issued_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."library_issued_books"
    ADD CONSTRAINT "library_issued_books_returned_to_fkey" FOREIGN KEY ("returned_to") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."library_issued_books"
    ADD CONSTRAINT "library_issued_books_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."library_issued_books"
    ADD CONSTRAINT "library_issued_books_student_record_id_fkey" FOREIGN KEY ("student_record_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."library_reservations"
    ADD CONSTRAINT "library_reservations_book_id_fkey" FOREIGN KEY ("book_id") REFERENCES "public"."library_books"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."library_reservations"
    ADD CONSTRAINT "library_reservations_issued_book_id_fkey" FOREIGN KEY ("issued_book_id") REFERENCES "public"."library_issued_books"("id");



ALTER TABLE ONLY "public"."library_reservations"
    ADD CONSTRAINT "library_reservations_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."library_reviews"
    ADD CONSTRAINT "library_reviews_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."library_reviews"
    ADD CONSTRAINT "library_reviews_book_id_fkey" FOREIGN KEY ("book_id") REFERENCES "public"."library_books"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."library_reviews"
    ADD CONSTRAINT "library_reviews_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."license_assignments"
    ADD CONSTRAINT "license_assignments_assigned_by_fkey" FOREIGN KEY ("assigned_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."license_assignments"
    ADD CONSTRAINT "license_assignments_license_pool_id_fkey" FOREIGN KEY ("license_pool_id") REFERENCES "public"."license_pools"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."license_assignments"
    ADD CONSTRAINT "license_assignments_organization_subscription_id_fkey" FOREIGN KEY ("organization_subscription_id") REFERENCES "public"."organization_subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."license_assignments"
    ADD CONSTRAINT "license_assignments_revoked_by_fkey" FOREIGN KEY ("revoked_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."license_assignments"
    ADD CONSTRAINT "license_assignments_transferred_from_fkey" FOREIGN KEY ("transferred_from") REFERENCES "public"."license_assignments"("id");



ALTER TABLE ONLY "public"."license_assignments"
    ADD CONSTRAINT "license_assignments_transferred_to_fkey" FOREIGN KEY ("transferred_to") REFERENCES "public"."license_assignments"("id");



ALTER TABLE ONLY "public"."license_assignments"
    ADD CONSTRAINT "license_assignments_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."license_pools"
    ADD CONSTRAINT "license_pools_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."license_pools"
    ADD CONSTRAINT "license_pools_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."license_pools"
    ADD CONSTRAINT "license_pools_organization_subscription_id_fkey" FOREIGN KEY ("organization_subscription_id") REFERENCES "public"."organization_subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mark_entries"
    ADD CONSTRAINT "mark_entries_assessment_id_fkey" FOREIGN KEY ("assessment_id") REFERENCES "public"."assessments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mark_entries"
    ADD CONSTRAINT "mark_entries_entered_by_fkey" FOREIGN KEY ("entered_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."mark_entries"
    ADD CONSTRAINT "mark_entries_locked_by_fkey" FOREIGN KEY ("locked_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."mark_entries"
    ADD CONSTRAINT "mark_entries_moderated_by_fkey" FOREIGN KEY ("moderated_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."mark_entries"
    ADD CONSTRAINT "mark_entries_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mark_entries"
    ADD CONSTRAINT "mark_entries_student_record_id_fkey" FOREIGN KEY ("student_record_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mark_entry_batches"
    ADD CONSTRAINT "mark_entry_batches_assessment_id_fkey" FOREIGN KEY ("assessment_id") REFERENCES "public"."assessments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mark_entry_batches"
    ADD CONSTRAINT "mark_entry_batches_entered_by_fkey" FOREIGN KEY ("entered_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."mark_entry_batches"
    ADD CONSTRAINT "mark_entry_batches_locked_by_fkey" FOREIGN KEY ("locked_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."mark_moderation_log"
    ADD CONSTRAINT "mark_moderation_log_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."mark_moderation_log"
    ADD CONSTRAINT "mark_moderation_log_assessment_id_fkey" FOREIGN KEY ("assessment_id") REFERENCES "public"."assessments"("id");



ALTER TABLE ONLY "public"."mark_moderation_log"
    ADD CONSTRAINT "mark_moderation_log_mark_entry_id_fkey" FOREIGN KEY ("mark_entry_id") REFERENCES "public"."mark_entries"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mark_moderation_log"
    ADD CONSTRAINT "mark_moderation_log_moderated_by_fkey" FOREIGN KEY ("moderated_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."mark_moderation_log"
    ADD CONSTRAINT "mark_moderation_log_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."mentor_notes"
    ADD CONSTRAINT "mentor_notes_college_lecturer_id_fkey" FOREIGN KEY ("college_lecturer_id") REFERENCES "public"."college_lecturers"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mentor_notes"
    ADD CONSTRAINT "mentor_notes_school_educator_id_fkey" FOREIGN KEY ("school_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."mentor_notes"
    ADD CONSTRAINT "mentor_notes_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_class_id_fkey" FOREIGN KEY ("class_id") REFERENCES "public"."school_classes"("id");



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_conversation_id_fkey" FOREIGN KEY ("conversation_id") REFERENCES "public"."conversations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_program_section_id_fkey" FOREIGN KEY ("program_section_id") REFERENCES "public"."program_sections"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_assessment_id_fkey" FOREIGN KEY ("assessment_id") REFERENCES "public"."personal_assessment_results"("id");



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_recipient_id_fkey" FOREIGN KEY ("recipient_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."opportunities_duplicate"
    ADD CONSTRAINT "opportunities_duplicate_recruiter_id_fkey" FOREIGN KEY ("recruiter_id") REFERENCES "public"."recruiters"("id");



ALTER TABLE ONLY "public"."opportunities_duplicate"
    ADD CONSTRAINT "opportunities_duplicate_requisition_id_fkey" FOREIGN KEY ("requisition_id") REFERENCES "public"."requisitions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."opportunities"
    ADD CONSTRAINT "opportunities_recruiter_id_fkey" FOREIGN KEY ("recruiter_id") REFERENCES "public"."recruiters"("id");



ALTER TABLE ONLY "public"."opportunities"
    ADD CONSTRAINT "opportunities_requisition_id_fkey" FOREIGN KEY ("requisition_id") REFERENCES "public"."requisitions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."opportunity_interactions"
    ADD CONSTRAINT "opportunity_interactions_opportunity_id_fkey" FOREIGN KEY ("opportunity_id") REFERENCES "public"."opportunities"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."opportunity_interactions"
    ADD CONSTRAINT "opportunity_interactions_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("user_id");



ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "organization_invitations_accepted_by_user_id_fkey" FOREIGN KEY ("accepted_by_user_id") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "organization_invitations_cancelled_by_fkey" FOREIGN KEY ("cancelled_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "organization_invitations_invited_by_fkey" FOREIGN KEY ("invited_by") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "organization_invitations_license_pool_id_fkey" FOREIGN KEY ("license_pool_id") REFERENCES "public"."license_pools"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "organization_invitations_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "organization_invitations_subscription_plan_id_fkey" FOREIGN KEY ("subscription_plan_id") REFERENCES "public"."subscription_plans"("id");



ALTER TABLE ONLY "public"."organization_subscriptions"
    ADD CONSTRAINT "organization_subscriptions_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."organization_subscriptions"
    ADD CONSTRAINT "organization_subscriptions_purchased_by_fkey" FOREIGN KEY ("purchased_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."organization_subscriptions"
    ADD CONSTRAINT "organization_subscriptions_subscription_plan_id_fkey" FOREIGN KEY ("subscription_plan_id") REFERENCES "public"."subscription_plans"("id");



ALTER TABLE ONLY "public"."organizations"
    ADD CONSTRAINT "organizations_admin_id_fkey" FOREIGN KEY ("admin_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."organizations"
    ADD CONSTRAINT "organizations_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."outcome_assessment_mappings"
    ADD CONSTRAINT "outcome_assessment_mappings_assessment_type_id_fkey" FOREIGN KEY ("assessment_type_id") REFERENCES "public"."assessment_types"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."outcome_assessment_mappings"
    ADD CONSTRAINT "outcome_assessment_mappings_learning_outcome_id_fkey" FOREIGN KEY ("learning_outcome_id") REFERENCES "public"."curriculum_learning_outcomes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."subscriptions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."payment_transactions"
    ADD CONSTRAINT "payment_transactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."personal_assessment_attempts"
    ADD CONSTRAINT "personal_assessment_attempts_adaptive_aptitude_session_id_fkey" FOREIGN KEY ("adaptive_aptitude_session_id") REFERENCES "public"."adaptive_aptitude_sessions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."personal_assessment_response_scales"
    ADD CONSTRAINT "personal_assessment_response_scales_section_id_fkey" FOREIGN KEY ("section_id") REFERENCES "public"."personal_assessment_sections"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pipeline_activities"
    ADD CONSTRAINT "pipeline_activities_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id");



ALTER TABLE ONLY "public"."pipeline_candidates"
    ADD CONSTRAINT "pipeline_candidates_opportunity_id_fkey" FOREIGN KEY ("opportunity_id") REFERENCES "public"."opportunities"("id");



ALTER TABLE ONLY "public"."pipeline_candidates"
    ADD CONSTRAINT "pipeline_candidates_requisition_id_fkey" FOREIGN KEY ("requisition_id") REFERENCES "public"."recruiters"("id");



ALTER TABLE ONLY "public"."pipeline_candidates"
    ADD CONSTRAINT "pipeline_candidates_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id");



ALTER TABLE ONLY "public"."placements"
    ADD CONSTRAINT "placements_recruiterId_fkey" FOREIGN KEY ("recruiterId") REFERENCES "public"."recruiters"("id") ON UPDATE CASCADE ON DELETE SET NULL;



ALTER TABLE ONLY "public"."placements"
    ADD CONSTRAINT "placements_studentId_fkey" FOREIGN KEY ("studentId") REFERENCES "public"."students"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."placements"
    ADD CONSTRAINT "placements_studentid_fkey" FOREIGN KEY ("studentId") REFERENCES "public"."students"("user_id");



ALTER TABLE ONLY "public"."pre_registration_email_tracking"
    ADD CONSTRAINT "pre_registration_email_tracking_pre_registration_id_fkey" FOREIGN KEY ("pre_registration_id") REFERENCES "public"."pre_registrations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profile_views"
    ADD CONSTRAINT "profile_views_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("user_id");



ALTER TABLE ONLY "public"."program_sections"
    ADD CONSTRAINT "program_sections_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."program_sections"
    ADD CONSTRAINT "program_sections_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."program_sections"
    ADD CONSTRAINT "program_sections_faculty_id_fkey" FOREIGN KEY ("faculty_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."program_sections"
    ADD CONSTRAINT "program_sections_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."program_sections"
    ADD CONSTRAINT "program_sections_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."programs"
    ADD CONSTRAINT "programs_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."programs"
    ADD CONSTRAINT "programs_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."programs"
    ADD CONSTRAINT "programs_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."quizzes"
    ADD CONSTRAINT "quizzes_lesson_id_fkey" FOREIGN KEY ("lesson_id") REFERENCES "public"."lessons"("lesson_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."razorpay_orders"
    ADD CONSTRAINT "razorpay_orders_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."subscriptions"("id");



ALTER TABLE ONLY "public"."razorpay_orders"
    ADD CONSTRAINT "razorpay_orders_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."recent_updates"
    ADD CONSTRAINT "recent_updates_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("user_id");



ALTER TABLE ONLY "public"."recruiter_activities"
    ADD CONSTRAINT "recruiter_activities_targetStudentId_fkey" FOREIGN KEY ("targetStudentId") REFERENCES "public"."students"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."recruiter_activities"
    ADD CONSTRAINT "recruiter_activities_targetstudentid_fkey" FOREIGN KEY ("targetStudentId") REFERENCES "public"."students"("user_id");



ALTER TABLE ONLY "public"."recruiters"
    ADD CONSTRAINT "recruiters_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."recruiters"
    ADD CONSTRAINT "recruiters_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."recruiters"
    ADD CONSTRAINT "recruiters_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."role_permissions"
    ADD CONSTRAINT "role_permissions_permission_name_fkey" FOREIGN KEY ("permission_name") REFERENCES "public"."permissions"("name") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."role_permissions"
    ADD CONSTRAINT "role_permissions_role_fkey" FOREIGN KEY ("role") REFERENCES "public"."roles"("name") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."school_classes"
    ADD CONSTRAINT "school_classes_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."school_educator_class_assignments"
    ADD CONSTRAINT "school_educator_class_assignments_assigned_by_fkey" FOREIGN KEY ("assigned_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."school_educator_class_assignments"
    ADD CONSTRAINT "school_educator_class_assignments_class_id_fkey" FOREIGN KEY ("class_id") REFERENCES "public"."school_classes"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."school_educator_class_assignments"
    ADD CONSTRAINT "school_educator_class_assignments_educator_id_fkey" FOREIGN KEY ("educator_id") REFERENCES "public"."school_educators"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."school_educators"
    ADD CONSTRAINT "school_educators_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."school_educators"
    ADD CONSTRAINT "school_educators_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."search_history"
    ADD CONSTRAINT "search_history_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("user_id");



ALTER TABLE ONLY "public"."shortlist_candidates"
    ADD CONSTRAINT "shortlist_candidates_shortlist_id_fkey" FOREIGN KEY ("shortlist_id") REFERENCES "public"."shortlists"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."shortlist_candidates"
    ADD CONSTRAINT "shortlist_candidates_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."skill_assessments"
    ADD CONSTRAINT "skill_assessments_assessed_by_fkey" FOREIGN KEY ("assessed_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."skill_assessments"
    ADD CONSTRAINT "skill_assessments_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."skill_assessments"
    ADD CONSTRAINT "skill_assessments_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."skill_badges"
    ADD CONSTRAINT "skill_badges_created_by_educator_id_fkey" FOREIGN KEY ("created_by_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."skill_badges"
    ADD CONSTRAINT "skill_badges_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."skill_passports"
    ADD CONSTRAINT "skill_passports_studentid_fkey1" FOREIGN KEY ("studentId") REFERENCES "public"."students"("user_id");



ALTER TABLE ONLY "public"."skill_verification_requests"
    ADD CONSTRAINT "skill_verification_requests_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."skills"
    ADD CONSTRAINT "skills_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."skills"
    ADD CONSTRAINT "skills_training_id_fkey" FOREIGN KEY ("training_id") REFERENCES "public"."trainings"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."streak_notification_log"
    ADD CONSTRAINT "streak_notification_log_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."stream_recommendation_reports"
    ADD CONSTRAINT "stream_recommendation_reports_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "public"."school_educators"("id");



ALTER TABLE ONLY "public"."stream_recommendation_reports"
    ADD CONSTRAINT "stream_recommendation_reports_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_assignments"
    ADD CONSTRAINT "student_assignments_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("user_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_course_progress"
    ADD CONSTRAINT "student_course_progress_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "public"."courses"("course_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_course_progress"
    ADD CONSTRAINT "student_course_progress_lesson_id_fkey" FOREIGN KEY ("lesson_id") REFERENCES "public"."lessons"("lesson_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_course_progress"
    ADD CONSTRAINT "student_course_progress_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_course_recommendations"
    ADD CONSTRAINT "student_course_recommendations_assessment_result_id_fkey" FOREIGN KEY ("assessment_result_id") REFERENCES "public"."personal_assessment_results"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."student_course_recommendations"
    ADD CONSTRAINT "student_course_recommendations_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "public"."courses"("course_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_course_recommendations"
    ADD CONSTRAINT "student_course_recommendations_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("user_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_enrollments"
    ADD CONSTRAINT "student_enrollments_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."student_enrollments"
    ADD CONSTRAINT "student_enrollments_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id");



ALTER TABLE ONLY "public"."student_enrollments"
    ADD CONSTRAINT "student_enrollments_section_id_fkey" FOREIGN KEY ("section_id") REFERENCES "public"."program_sections"("id");



ALTER TABLE ONLY "public"."student_enrollments"
    ADD CONSTRAINT "student_enrollments_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_enrollments"
    ADD CONSTRAINT "student_enrollments_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."student_job_matches"
    ADD CONSTRAINT "student_job_matches_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_ledgers"
    ADD CONSTRAINT "student_ledgers_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_ledgers"
    ADD CONSTRAINT "student_ledgers_fee_structure_id_fkey" FOREIGN KEY ("fee_structure_id") REFERENCES "public"."fee_structures"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_ledgers"
    ADD CONSTRAINT "student_ledgers_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_ledgers"
    ADD CONSTRAINT "student_ledgers_student_record_id_fkey" FOREIGN KEY ("student_record_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_ledgers"
    ADD CONSTRAINT "student_ledgers_waived_by_fkey" FOREIGN KEY ("waived_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."student_management_records"
    ADD CONSTRAINT "student_management_records_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_management_records"
    ADD CONSTRAINT "student_management_records_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_promotions"
    ADD CONSTRAINT "student_promotions_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."student_promotions"
    ADD CONSTRAINT "student_promotions_promoted_by_fkey" FOREIGN KEY ("promoted_by") REFERENCES "public"."school_educators"("id");



ALTER TABLE ONLY "public"."student_promotions"
    ADD CONSTRAINT "student_promotions_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."student_promotions"
    ADD CONSTRAINT "student_promotions_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_reports"
    ADD CONSTRAINT "student_reports_generated_by_fkey" FOREIGN KEY ("generated_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."student_reports"
    ADD CONSTRAINT "student_reports_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_reports"
    ADD CONSTRAINT "student_reports_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_skill_badges"
    ADD CONSTRAINT "student_skill_badges_awarded_by_educator_id_fkey" FOREIGN KEY ("awarded_by_educator_id") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."student_skill_badges"
    ADD CONSTRAINT "student_skill_badges_badge_id_fkey" FOREIGN KEY ("badge_id") REFERENCES "public"."skill_badges"("badge_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."student_streaks"
    ADD CONSTRAINT "student_streaks_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_college_class_id_fkey" FOREIGN KEY ("college_class_id") REFERENCES "public"."college_classes"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_deleted_by_fkey" FOREIGN KEY ("deleted_by") REFERENCES "public"."school_educators"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id");



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_program_section_id_fkey" FOREIGN KEY ("program_section_id") REFERENCES "public"."program_sections"("id");



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_school_class_id_fkey" FOREIGN KEY ("school_class_id") REFERENCES "public"."school_classes"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_university_college_id_fkey" FOREIGN KEY ("university_college_id") REFERENCES "public"."university_colleges"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_universityid_fkey" FOREIGN KEY ("universityId") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."subscription_cancellations"
    ADD CONSTRAINT "subscription_cancellations_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscription_cancellations"
    ADD CONSTRAINT "subscription_cancellations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscription_migrations"
    ADD CONSTRAINT "subscription_migrations_old_subscription_id_fkey" FOREIGN KEY ("old_subscription_id") REFERENCES "public"."subscriptions"("id");



ALTER TABLE ONLY "public"."subscription_migrations"
    ADD CONSTRAINT "subscription_migrations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscription_plan_features"
    ADD CONSTRAINT "subscription_plan_features_plan_id_fkey" FOREIGN KEY ("plan_id") REFERENCES "public"."subscription_plans"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_purchased_by_fkey" FOREIGN KEY ("purchased_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."teacher_journal"
    ADD CONSTRAINT "teacher_journal_educator_id_fkey" FOREIGN KEY ("educator_id") REFERENCES "public"."school_educators"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."teacher_journal"
    ADD CONSTRAINT "teacher_journal_lesson_plan_id_fkey" FOREIGN KEY ("lesson_plan_id") REFERENCES "public"."lesson_plans"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."teacher_workload"
    ADD CONSTRAINT "teacher_workload_educator_id_fkey" FOREIGN KEY ("educator_id") REFERENCES "public"."school_educators"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."teacher_workload"
    ADD CONSTRAINT "teacher_workload_timetable_id_fkey" FOREIGN KEY ("timetable_id") REFERENCES "public"."timetables"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."timetable_conflicts"
    ADD CONSTRAINT "timetable_conflicts_educator_id_fkey" FOREIGN KEY ("educator_id") REFERENCES "public"."school_educators"("id");



ALTER TABLE ONLY "public"."timetable_conflicts"
    ADD CONSTRAINT "timetable_conflicts_slot_id_fkey" FOREIGN KEY ("slot_id") REFERENCES "public"."timetable_slots"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."timetable_conflicts"
    ADD CONSTRAINT "timetable_conflicts_timetable_id_fkey" FOREIGN KEY ("timetable_id") REFERENCES "public"."timetables"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."timetable_slots"
    ADD CONSTRAINT "timetable_slots_class_id_fkey" FOREIGN KEY ("class_id") REFERENCES "public"."school_classes"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."timetable_slots"
    ADD CONSTRAINT "timetable_slots_educator_id_fkey" FOREIGN KEY ("educator_id") REFERENCES "public"."school_educators"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."timetable_slots"
    ADD CONSTRAINT "timetable_slots_timetable_id_fkey" FOREIGN KEY ("timetable_id") REFERENCES "public"."timetables"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."timetables"
    ADD CONSTRAINT "timetables_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."timetables"
    ADD CONSTRAINT "timetables_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."training_notifications"
    ADD CONSTRAINT "training_notifications_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."training_notifications"
    ADD CONSTRAINT "training_notifications_experience_id_fkey" FOREIGN KEY ("experience_id") REFERENCES "public"."experience"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."training_notifications"
    ADD CONSTRAINT "training_notifications_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."training_notifications"
    ADD CONSTRAINT "training_notifications_school_id_fkey" FOREIGN KEY ("school_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."training_notifications"
    ADD CONSTRAINT "training_notifications_training_id_fkey" FOREIGN KEY ("training_id") REFERENCES "public"."trainings"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."trainings"
    ADD CONSTRAINT "trainings_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."trainings"
    ADD CONSTRAINT "trainings_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "public"."courses"("course_id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."trainings"
    ADD CONSTRAINT "trainings_rejected_by_fkey" FOREIGN KEY ("rejected_by") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."trainings"
    ADD CONSTRAINT "trainings_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."transcript_requests"
    ADD CONSTRAINT "transcript_requests_processed_by_fkey" FOREIGN KEY ("processed_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."transcript_requests"
    ADD CONSTRAINT "transcript_requests_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."transcript_requests"
    ADD CONSTRAINT "transcript_requests_transcript_id_fkey" FOREIGN KEY ("transcript_id") REFERENCES "public"."transcripts"("id");



ALTER TABLE ONLY "public"."transcripts"
    ADD CONSTRAINT "transcripts_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."transcripts"
    ADD CONSTRAINT "transcripts_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."transcripts"
    ADD CONSTRAINT "transcripts_department_id_fkey" FOREIGN KEY ("department_id") REFERENCES "public"."departments"("id");



ALTER TABLE ONLY "public"."transcripts"
    ADD CONSTRAINT "transcripts_program_id_fkey" FOREIGN KEY ("program_id") REFERENCES "public"."programs"("id");



ALTER TABLE ONLY "public"."transcripts"
    ADD CONSTRAINT "transcripts_student_id_fkey" FOREIGN KEY ("student_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."transcripts"
    ADD CONSTRAINT "transcripts_student_record_id_fkey" FOREIGN KEY ("student_record_id") REFERENCES "public"."students"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tutor_conversations"
    ADD CONSTRAINT "tutor_conversations_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "public"."courses"("course_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tutor_conversations"
    ADD CONSTRAINT "tutor_conversations_lesson_id_fkey" FOREIGN KEY ("lesson_id") REFERENCES "public"."lessons"("lesson_id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."tutor_conversations"
    ADD CONSTRAINT "tutor_conversations_student_id_fkey1" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id");



ALTER TABLE ONLY "public"."tutor_feedback"
    ADD CONSTRAINT "tutor_feedback_conversation_id_fkey" FOREIGN KEY ("conversation_id") REFERENCES "public"."tutor_conversations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."university_colleges"
    ADD CONSTRAINT "university_colleges_college_id_fkey" FOREIGN KEY ("college_id") REFERENCES "public"."organizations"("id");



ALTER TABLE ONLY "public"."university_colleges"
    ADD CONSTRAINT "university_colleges_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id");



ALTER TABLE ONLY "public"."university_colleges"
    ADD CONSTRAINT "university_colleges_university_id_fkey" FOREIGN KEY ("university_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."university_courses"
    ADD CONSTRAINT "university_courses_approved_by_fkey" FOREIGN KEY ("approved_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."university_courses"
    ADD CONSTRAINT "university_courses_university_id_fkey" FOREIGN KEY ("university_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."university_performance"
    ADD CONSTRAINT "university_performance_universityid_fkey" FOREIGN KEY ("universityId") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_categories"
    ADD CONSTRAINT "user_categories_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."user_categories"
    ADD CONSTRAINT "user_categories_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."user_entitlements"
    ADD CONSTRAINT "user_entitlements_granted_by_fkey" FOREIGN KEY ("granted_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."user_entitlements"
    ADD CONSTRAINT "user_entitlements_organization_subscription_id_fkey" FOREIGN KEY ("organization_subscription_id") REFERENCES "public"."organization_subscriptions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_entitlements"
    ADD CONSTRAINT "user_entitlements_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_login_history"
    ADD CONSTRAINT "user_login_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_sessions"
    ADD CONSTRAINT "user_sessions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_settings"
    ADD CONSTRAINT "user_settings_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."user_settings"
    ADD CONSTRAINT "user_settings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_state_history"
    ADD CONSTRAINT "user_state_history_changed_by_fkey" FOREIGN KEY ("changed_by") REFERENCES "public"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."user_state_history"
    ADD CONSTRAINT "user_state_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_email_fkey" FOREIGN KEY ("email") REFERENCES "public"."users"("email") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_organizationid_fkey" FOREIGN KEY ("organizationId") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."verifications"
    ADD CONSTRAINT "verifications_performedby_fkey" FOREIGN KEY ("performedBy") REFERENCES "public"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."video_summaries"
    ADD CONSTRAINT "video_summaries_course_id_fkey" FOREIGN KEY ("course_id") REFERENCES "public"."courses"("course_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."video_summaries"
    ADD CONSTRAINT "video_summaries_lesson_id_fkey" FOREIGN KEY ("lesson_id") REFERENCES "public"."lessons"("lesson_id") ON DELETE CASCADE;



CREATE POLICY "Admins can create license assignments" ON "public"."license_assignments" FOR INSERT WITH CHECK ((("auth"."uid"() = "assigned_by") AND ("auth"."uid"() IN ( SELECT "u"."id"
   FROM "public"."users" "u"
  WHERE ("u"."role" = ANY (ARRAY['school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role", 'super_admin'::"public"."user_role"]))))));



CREATE POLICY "Admins can create license pools" ON "public"."license_pools" FOR INSERT WITH CHECK ((("auth"."uid"() = "created_by") AND ("auth"."uid"() IN ( SELECT "u"."id"
   FROM "public"."users" "u"
  WHERE ("u"."role" = ANY (ARRAY['school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role", 'super_admin'::"public"."user_role"]))))));



CREATE POLICY "Admins can create organization subscriptions" ON "public"."organization_subscriptions" FOR INSERT WITH CHECK ((("auth"."uid"() = "purchased_by") AND ("auth"."uid"() IN ( SELECT "u"."id"
   FROM "public"."users" "u"
  WHERE ("u"."role" = ANY (ARRAY['school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role", 'super_admin'::"public"."user_role"]))))));



CREATE POLICY "Admins can delete license pools" ON "public"."license_pools" FOR DELETE USING ((("auth"."uid"() = "created_by") OR ("auth"."uid"() IN ( SELECT "u"."id"
   FROM "public"."users" "u"
  WHERE ("u"."role" = ANY (ARRAY['school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role", 'super_admin'::"public"."user_role"]))))));



CREATE POLICY "Admins can manage all swap requests" ON "public"."class_swap_requests" USING ((EXISTS ( SELECT 1
   FROM "public"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ("users"."role" = ANY (ARRAY['super_admin'::"public"."user_role", 'rm_admin'::"public"."user_role", 'school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role"]))))));



CREATE POLICY "Admins can manage categories" ON "public"."user_categories" USING ((("auth"."jwt"() ->> 'role'::"text") = 'admin'::"text"));



CREATE POLICY "Admins can update license assignments" ON "public"."license_assignments" FOR UPDATE USING ((("auth"."uid"() = "assigned_by") OR ("auth"."uid"() IN ( SELECT "os"."purchased_by"
   FROM "public"."organization_subscriptions" "os"
  WHERE ("os"."id" = "license_assignments"."organization_subscription_id"))) OR ("auth"."uid"() IN ( SELECT "u"."id"
   FROM "public"."users" "u"
  WHERE ("u"."role" = ANY (ARRAY['school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role", 'super_admin'::"public"."user_role"]))))));



CREATE POLICY "Admins can update license pools" ON "public"."license_pools" FOR UPDATE USING ((("auth"."uid"() = "created_by") OR ("auth"."uid"() IN ( SELECT "u"."id"
   FROM "public"."users" "u"
  WHERE ("u"."role" = ANY (ARRAY['school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role", 'super_admin'::"public"."user_role"]))))));



CREATE POLICY "Admins can update organization subscriptions" ON "public"."organization_subscriptions" FOR UPDATE USING ((("auth"."uid"() = "purchased_by") OR ("auth"."uid"() IN ( SELECT "u"."id"
   FROM "public"."users" "u"
  WHERE ("u"."role" = ANY (ARRAY['school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role", 'super_admin'::"public"."user_role"]))))));



CREATE POLICY "Admins can update verification requests" ON "public"."skill_verification_requests" FOR UPDATE USING (true);



CREATE POLICY "Admins can view all book issues" ON "public"."library_book_issues" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "auth"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND (("users"."raw_user_meta_data" ->> 'role'::"text") = ANY (ARRAY['admin'::"text", 'college_admin'::"text", 'librarian'::"text"]))))));



CREATE POLICY "Admins can view all book issues" ON "public"."library_book_issues_college" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "auth"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ((("users"."raw_user_meta_data" ->> 'role'::"text") = ANY (ARRAY['admin'::"text", 'college_admin'::"text", 'librarian'::"text"])) OR (("users"."email")::"text" ~~ '%@admin.%'::"text"))))));



CREATE POLICY "Admins can view all document access" ON "public"."document_access_history" FOR SELECT USING ((("auth"."jwt"() ->> 'role'::"text") = 'admin'::"text"));



CREATE POLICY "Admins can view all external assessment attempts" ON "public"."external_assessment_attempts" USING ((EXISTS ( SELECT 1
   FROM "public"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ("users"."role" = ANY (ARRAY['school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role", 'super_admin'::"public"."user_role"]))))));



CREATE POLICY "Admins can view all profiles" ON "public"."user_profiles" FOR SELECT USING ((("auth"."jwt"() ->> 'role'::"text") = 'admin'::"text"));



CREATE POLICY "Admins can view all state history" ON "public"."user_state_history" FOR SELECT USING ((("auth"."jwt"() ->> 'role'::"text") = 'admin'::"text"));



CREATE POLICY "Admins can view all swap history" ON "public"."class_swap_history" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ("users"."role" = ANY (ARRAY['super_admin'::"public"."user_role", 'rm_admin'::"public"."user_role", 'school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role"]))))));



CREATE POLICY "Admins can view all verification requests" ON "public"."skill_verification_requests" FOR SELECT USING (true);



CREATE POLICY "Admins can view library settings" ON "public"."library_settings" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "auth"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND (("users"."raw_user_meta_data" ->> 'role'::"text") = ANY (ARRAY['admin'::"text", 'college_admin'::"text", 'librarian'::"text"]))))));



CREATE POLICY "Admins can view library settings" ON "public"."library_settings_college" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "auth"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ((("users"."raw_user_meta_data" ->> 'role'::"text") = ANY (ARRAY['admin'::"text", 'college_admin'::"text", 'librarian'::"text"])) OR (("users"."email")::"text" ~~ '%@admin.%'::"text"))))));



CREATE POLICY "Admins can view organization license assignments" ON "public"."license_assignments" FOR SELECT USING ((("auth"."uid"() = "user_id") OR ("auth"."uid"() = "assigned_by") OR ("auth"."uid"() IN ( SELECT "os"."purchased_by"
   FROM "public"."organization_subscriptions" "os"
  WHERE ("os"."id" = "license_assignments"."organization_subscription_id"))) OR ("auth"."uid"() IN ( SELECT "u"."id"
   FROM "public"."users" "u"
  WHERE ("u"."role" = ANY (ARRAY['school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role", 'super_admin'::"public"."user_role"]))))));



CREATE POLICY "Admins can view own organization license pools" ON "public"."license_pools" FOR SELECT USING ((("auth"."uid"() = "created_by") OR ("auth"."uid"() IN ( SELECT "u"."id"
   FROM "public"."users" "u"
  WHERE (("u"."role" = ANY (ARRAY['school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role", 'super_admin'::"public"."user_role"])) AND (((("license_pools"."organization_type")::"text" = 'school'::"text") AND (EXISTS ( SELECT 1
           FROM "public"."school_educators" "se"
          WHERE (("se"."user_id" = "u"."id") AND ("se"."school_id" = "license_pools"."organization_id"))))) OR ((("license_pools"."organization_type")::"text" = 'college'::"text") AND (EXISTS ( SELECT 1
           FROM "public"."college_lecturers" "cl"
          WHERE (("cl"."user_id" = "u"."id") AND ("cl"."collegeId" = "license_pools"."organization_id"))))) OR ((("license_pools"."organization_type")::"text" = 'university'::"text") AND ("u"."role" = 'university_admin'::"public"."user_role"))))))));



CREATE POLICY "Admins can view own organization subscriptions" ON "public"."organization_subscriptions" FOR SELECT USING ((("auth"."uid"() = "purchased_by") OR ("auth"."uid"() IN ( SELECT "u"."id"
   FROM "public"."users" "u"
  WHERE (("u"."role" = ANY (ARRAY['school_admin'::"public"."user_role", 'college_admin'::"public"."user_role", 'university_admin'::"public"."user_role", 'super_admin'::"public"."user_role"])) AND (((("organization_subscriptions"."organization_type")::"text" = 'school'::"text") AND (EXISTS ( SELECT 1
           FROM "public"."school_educators" "se"
          WHERE (("se"."user_id" = "u"."id") AND ("se"."school_id" = "organization_subscriptions"."organization_id"))))) OR ((("organization_subscriptions"."organization_type")::"text" = 'college'::"text") AND (EXISTS ( SELECT 1
           FROM "public"."college_lecturers" "cl"
          WHERE (("cl"."user_id" = "u"."id") AND ("cl"."collegeId" = "organization_subscriptions"."organization_id"))))) OR ((("organization_subscriptions"."organization_type")::"text" = 'university'::"text") AND ("u"."role" = 'university_admin'::"public"."user_role"))))))));



CREATE POLICY "Allow admin write access to features" ON "public"."subscription_plan_features" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Allow admin write access to plans" ON "public"."subscription_plans" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Allow all for college_faculty_leave_balances" ON "public"."college_faculty_leave_balances" USING (true);



CREATE POLICY "Allow all for college_faculty_leaves" ON "public"."college_faculty_leaves" USING (true);



CREATE POLICY "Allow all for college_faculty_substitutions" ON "public"."college_faculty_substitutions" USING (true);



CREATE POLICY "Allow all for college_leave_types" ON "public"."college_leave_types" USING (true);



CREATE POLICY "Allow all operations on college_event_registrations" ON "public"."college_event_registrations" USING (true) WITH CHECK (true);



CREATE POLICY "Allow all users to view opportunities" ON "public"."opportunities" FOR SELECT USING (true);



CREATE POLICY "Allow anon insert" ON "public"."pre_registrations" FOR INSERT TO "anon" WITH CHECK (true);



CREATE POLICY "Allow anon select" ON "public"."pre_registrations" FOR SELECT TO "anon" USING (true);



CREATE POLICY "Allow anon update" ON "public"."pre_registrations" FOR UPDATE TO "anon" USING (true) WITH CHECK (true);



CREATE POLICY "Allow authenticated delete attempts" ON "public"."personal_assessment_attempts" FOR DELETE TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated delete responses" ON "public"."personal_assessment_responses" FOR DELETE TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated delete restrictions" ON "public"."personal_assessment_restrictions" FOR DELETE TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated delete results" ON "public"."personal_assessment_results" FOR DELETE TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated insert attempts" ON "public"."personal_assessment_attempts" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Allow authenticated insert responses" ON "public"."personal_assessment_responses" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Allow authenticated insert restrictions" ON "public"."personal_assessment_restrictions" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Allow authenticated insert results" ON "public"."personal_assessment_results" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Allow authenticated inserts" ON "public"."notifications" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow authenticated select attempts" ON "public"."personal_assessment_attempts" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated select responses" ON "public"."personal_assessment_responses" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated select restrictions" ON "public"."personal_assessment_restrictions" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated select results" ON "public"."personal_assessment_results" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated update attempts" ON "public"."personal_assessment_attempts" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Allow authenticated update responses" ON "public"."personal_assessment_responses" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Allow authenticated update restrictions" ON "public"."personal_assessment_restrictions" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Allow authenticated update results" ON "public"."personal_assessment_results" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Allow authenticated users to delete cache" ON "public"."embedding_cache" FOR DELETE TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated users to insert cache" ON "public"."embedding_cache" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Allow authenticated users to read cache" ON "public"."embedding_cache" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated users to read organizations" ON "public"."organizations" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Allow authenticated users to update cache" ON "public"."embedding_cache" FOR UPDATE TO "authenticated" USING (true);



CREATE POLICY "Allow delete for authenticated on faculty_class_assignments" ON "public"."college_faculty_class_assignments" FOR DELETE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow delete for authenticated users" ON "public"."college_classes" FOR DELETE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow delete for authenticated users" ON "public"."college_timetable_slots" FOR DELETE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow delete for authenticated users" ON "public"."college_timetables" FOR DELETE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow delete for authenticated users on college_breaks" ON "public"."college_breaks" FOR DELETE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow delete for authenticated users on college_time_periods" ON "public"."college_time_periods" FOR DELETE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow full access to authenticated users" ON "public"."students" TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Allow insert for authenticated on faculty_class_assignments" ON "public"."college_faculty_class_assignments" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow insert for authenticated users" ON "public"."college_classes" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow insert for authenticated users" ON "public"."college_timetable_slots" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow insert for authenticated users" ON "public"."college_timetables" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow insert for authenticated users on college_breaks" ON "public"."college_breaks" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow insert for authenticated users on college_time_periods" ON "public"."college_time_periods" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow public delete" ON "public"."users" FOR DELETE USING (true);



CREATE POLICY "Allow public insert" ON "public"."audit_logs" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow public insert" ON "public"."generated_external_assessment" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow public insert" ON "public"."metrics_snapshots" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow public insert" ON "public"."placements" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow public insert" ON "public"."recruiter_activities" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow public insert" ON "public"."skill_passports" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow public insert" ON "public"."skill_trends" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow public insert" ON "public"."students" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow public insert" ON "public"."university_performance" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow public insert" ON "public"."users" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow public insert" ON "public"."verifications" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow public read" ON "public"."audit_logs" FOR SELECT USING (true);



CREATE POLICY "Allow public read" ON "public"."generated_external_assessment" FOR SELECT USING (true);



CREATE POLICY "Allow public read" ON "public"."metrics_snapshots" FOR SELECT USING (true);



CREATE POLICY "Allow public read" ON "public"."placements" FOR SELECT USING (true);



CREATE POLICY "Allow public read" ON "public"."recruiter_activities" FOR SELECT USING (true);



CREATE POLICY "Allow public read" ON "public"."skill_passports" FOR SELECT USING (true);



CREATE POLICY "Allow public read" ON "public"."skill_trends" FOR SELECT USING (true);



CREATE POLICY "Allow public read" ON "public"."students" FOR SELECT USING (true);



CREATE POLICY "Allow public read" ON "public"."university_performance" FOR SELECT USING (true);



CREATE POLICY "Allow public read" ON "public"."users" FOR SELECT USING (true);



CREATE POLICY "Allow public read" ON "public"."verifications" FOR SELECT USING (true);



CREATE POLICY "Allow public read access to active plans" ON "public"."subscription_plans" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Allow public read access to plan features" ON "public"."subscription_plan_features" FOR SELECT USING (true);



CREATE POLICY "Allow public read access to recent_updates" ON "public"."recent_updates" FOR SELECT USING (true);



CREATE POLICY "Allow public update" ON "public"."metrics_snapshots" FOR UPDATE USING (true);



CREATE POLICY "Allow public update" ON "public"."placements" FOR UPDATE USING (true);



CREATE POLICY "Allow public update" ON "public"."skill_passports" FOR UPDATE USING (true);



CREATE POLICY "Allow public update" ON "public"."skill_trends" FOR UPDATE USING (true);



CREATE POLICY "Allow public update" ON "public"."students" FOR UPDATE USING (true);



CREATE POLICY "Allow public update" ON "public"."university_performance" FOR UPDATE USING (true);



CREATE POLICY "Allow public update" ON "public"."users" FOR UPDATE USING (true);



CREATE POLICY "Allow read access to college_breaks" ON "public"."college_breaks" FOR SELECT USING (true);



CREATE POLICY "Allow read access to college_classes" ON "public"."college_classes" FOR SELECT USING (true);



CREATE POLICY "Allow read access to college_time_periods" ON "public"."college_time_periods" FOR SELECT USING (true);



CREATE POLICY "Allow read access to college_timetable_slots" ON "public"."college_timetable_slots" FOR SELECT USING (true);



CREATE POLICY "Allow read access to college_timetables" ON "public"."college_timetables" FOR SELECT USING (true);



CREATE POLICY "Allow read access to faculty_class_assignments" ON "public"."college_faculty_class_assignments" FOR SELECT USING (true);



CREATE POLICY "Allow system to insert history entries" ON "public"."class_swap_history" FOR INSERT WITH CHECK (true);



CREATE POLICY "Allow update for authenticated on faculty_class_assignments" ON "public"."college_faculty_class_assignments" FOR UPDATE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow update for authenticated users" ON "public"."college_classes" FOR UPDATE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow update for authenticated users" ON "public"."college_timetable_slots" FOR UPDATE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow update for authenticated users" ON "public"."college_timetables" FOR UPDATE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow update for authenticated users on college_breaks" ON "public"."college_breaks" FOR UPDATE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow update for authenticated users on college_time_periods" ON "public"."college_time_periods" FOR UPDATE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow users to delete their own organization" ON "public"."organizations" FOR DELETE TO "authenticated" USING (("admin_id" = "auth"."uid"()));



CREATE POLICY "Allow users to insert own recent_updates" ON "public"."recent_updates" FOR INSERT WITH CHECK (("auth"."uid"() = "student_id"));



CREATE POLICY "Allow users to insert their own organization" ON "public"."organizations" FOR INSERT TO "authenticated" WITH CHECK (("admin_id" = "auth"."uid"()));



CREATE POLICY "Allow users to update own recent_updates" ON "public"."recent_updates" FOR UPDATE USING (("auth"."uid"() = "student_id"));



CREATE POLICY "Allow users to update their own organization" ON "public"."organizations" FOR UPDATE TO "authenticated" USING (("admin_id" = "auth"."uid"())) WITH CHECK (("admin_id" = "auth"."uid"()));



CREATE POLICY "Anyone can read assessment questions" ON "public"."personal_assessment_questions" FOR SELECT USING (true);



CREATE POLICY "Anyone can read assessment sections" ON "public"."personal_assessment_sections" FOR SELECT USING (true);



CREATE POLICY "Anyone can read assessment streams" ON "public"."personal_assessment_streams" FOR SELECT USING (true);



CREATE POLICY "Anyone can read generated assessments" ON "public"."generated_external_assessment" FOR SELECT USING (true);



CREATE POLICY "Anyone can read video summaries" ON "public"."video_summaries" FOR SELECT USING (true);



CREATE POLICY "Anyone can track profile views" ON "public"."profile_views" FOR INSERT WITH CHECK (true);



CREATE POLICY "Anyone can view active streams" ON "public"."personal_assessment_streams" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Anyone can view assessment questions" ON "public"."personal_assessment_questions" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Anyone can view assessment sections" ON "public"."personal_assessment_sections" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Anyone can view assessment streams" ON "public"."personal_assessment_streams" FOR SELECT USING (("is_active" = true));



CREATE POLICY "Anyone can view assessment types" ON "public"."assessment_types" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Anyone can view categories" ON "public"."user_categories" FOR SELECT USING (true);



CREATE POLICY "Anyone can view invitation by token" ON "public"."organization_invitations" FOR SELECT USING (("invitation_token" IS NOT NULL));



CREATE POLICY "Anyone can view library books" ON "public"."library_books_college" FOR SELECT USING (true);



CREATE POLICY "Anyone can view library categories" ON "public"."library_categories" FOR SELECT USING (true);



CREATE POLICY "Anyone can view library categories" ON "public"."library_categories_college" FOR SELECT USING (true);



CREATE POLICY "Anyone can view response scales" ON "public"."personal_assessment_response_scales" FOR SELECT USING (true);



CREATE POLICY "Authenticated users can create interviews" ON "public"."interviews" FOR INSERT WITH CHECK (true);



CREATE POLICY "Authenticated users can create shortlists" ON "public"."shortlists" FOR INSERT WITH CHECK (true);



CREATE POLICY "Authenticated users can delete interviews" ON "public"."interviews" FOR DELETE USING (true);



CREATE POLICY "Authenticated users can delete opportunities" ON "public"."opportunities" FOR DELETE TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can delete shortlists" ON "public"."shortlists" FOR DELETE USING (true);



CREATE POLICY "Authenticated users can insert generated assessments" ON "public"."generated_external_assessment" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can insert opportunities" ON "public"."opportunities" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Authenticated users can insert questions" ON "public"."adaptive_aptitude_questions_cache" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can log activities" ON "public"."pipeline_activities" FOR INSERT WITH CHECK (true);



CREATE POLICY "Authenticated users can log export activities" ON "public"."export_activities" FOR INSERT WITH CHECK (true);



CREATE POLICY "Authenticated users can log reminders" ON "public"."interview_reminders" FOR INSERT WITH CHECK (true);



CREATE POLICY "Authenticated users can manage pipeline candidates" ON "public"."pipeline_candidates" USING (true);



CREATE POLICY "Authenticated users can manage requisitions" ON "public"."requisitions" USING (true);



CREATE POLICY "Authenticated users can manage shortlist candidates" ON "public"."shortlist_candidates" USING (true);



CREATE POLICY "Authenticated users can read lessons" ON "public"."lessons" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can read modules" ON "public"."course_modules" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can read questions" ON "public"."adaptive_aptitude_questions_cache" FOR SELECT USING ((("auth"."role"() = 'authenticated'::"text") AND ("is_active" = true)));



CREATE POLICY "Authenticated users can read resources" ON "public"."lesson_resources" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can update interviews" ON "public"."interviews" FOR UPDATE USING (true);



CREATE POLICY "Authenticated users can update opportunities" ON "public"."opportunities" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Authenticated users can update questions" ON "public"."adaptive_aptitude_questions_cache" FOR UPDATE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Authenticated users can update shortlists" ON "public"."shortlists" FOR UPDATE USING (true);



CREATE POLICY "Authenticated users can view activities" ON "public"."pipeline_activities" FOR SELECT USING (true);



CREATE POLICY "Authenticated users can view export activities" ON "public"."export_activities" FOR SELECT USING (true);



CREATE POLICY "Authenticated users can view interviews" ON "public"."interviews" FOR SELECT USING (true);



CREATE POLICY "Authenticated users can view pipeline candidates" ON "public"."pipeline_candidates" FOR SELECT USING (true);



CREATE POLICY "Authenticated users can view reminders" ON "public"."interview_reminders" FOR SELECT USING (true);



CREATE POLICY "Authenticated users can view requisitions" ON "public"."requisitions" FOR SELECT USING (true);



CREATE POLICY "Authenticated users can view shortlist candidates" ON "public"."shortlist_candidates" FOR SELECT USING (true);



CREATE POLICY "Authenticated users can view shortlists" ON "public"."shortlists" FOR SELECT USING (true);



CREATE POLICY "Bundle features are publicly readable" ON "public"."bundle_features" FOR SELECT USING (true);



CREATE POLICY "Bundles are publicly readable" ON "public"."bundles" FOR SELECT USING (("is_active" = true));



CREATE POLICY "College admins can delete their college circulars" ON "public"."college_circulars" FOR DELETE USING (true);



CREATE POLICY "College admins can delete their college events" ON "public"."college_events" FOR DELETE USING (true);



CREATE POLICY "College admins can delete their enrollments" ON "public"."student_enrollments" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM ("public"."college_lecturers" "cl"
     JOIN "public"."students" "s" ON (("s"."college_id" = "cl"."collegeId")))
  WHERE (("cl"."user_id" = "auth"."uid"()) AND ("s"."id" = "student_enrollments"."student_id")))));



CREATE POLICY "College admins can insert circulars for their college" ON "public"."college_circulars" FOR INSERT WITH CHECK (true);



CREATE POLICY "College admins can insert enrollments" ON "public"."student_enrollments" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."college_lecturers" "cl"
     JOIN "public"."students" "s" ON (("s"."college_id" = "cl"."collegeId")))
  WHERE (("cl"."user_id" = "auth"."uid"()) AND ("s"."id" = "student_enrollments"."student_id")))));



CREATE POLICY "College admins can insert events for their college" ON "public"."college_events" FOR INSERT WITH CHECK (true);



CREATE POLICY "College admins can send messages to students" ON "public"."messages" FOR INSERT WITH CHECK ((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'college_admin'::"text") AND ("receiver_type" = 'student'::"text")));



CREATE POLICY "College admins can update their college circulars" ON "public"."college_circulars" FOR UPDATE USING (true);



CREATE POLICY "College admins can update their college events" ON "public"."college_events" FOR UPDATE USING (true);



CREATE POLICY "College admins can update their curriculum" ON "public"."college_curriculums" FOR UPDATE USING (("college_id" IN ( SELECT "users"."organizationId"
   FROM "public"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ("users"."role" = 'college_admin'::"public"."user_role")))));



CREATE POLICY "College admins can update their enrollments" ON "public"."student_enrollments" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM ("public"."college_lecturers" "cl"
     JOIN "public"."students" "s" ON (("s"."college_id" = "cl"."collegeId")))
  WHERE (("cl"."user_id" = "auth"."uid"()) AND ("s"."id" = "student_enrollments"."student_id")))));



CREATE POLICY "College admins can view student conversation messages" ON "public"."messages" FOR SELECT USING (((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'college_admin'::"text")) OR (("receiver_id" = "auth"."uid"()) AND ("receiver_type" = 'college_admin'::"text"))));



CREATE POLICY "College admins can view their college circulars" ON "public"."college_circulars" FOR SELECT USING (true);



CREATE POLICY "College admins can view their college events" ON "public"."college_events" FOR SELECT USING (true);



CREATE POLICY "College admins can view their curriculum" ON "public"."college_curriculums" FOR SELECT USING (("college_id" IN ( SELECT "users"."organizationId"
   FROM "public"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ("users"."role" = 'college_admin'::"public"."user_role")))));



CREATE POLICY "College admins can view their enrollments" ON "public"."student_enrollments" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM ("public"."college_lecturers" "cl"
     JOIN "public"."students" "s" ON (("s"."college_id" = "cl"."collegeId")))
  WHERE (("cl"."user_id" = "auth"."uid"()) AND ("s"."id" = "student_enrollments"."student_id")))));



CREATE POLICY "College users can create lesson plans" ON "public"."college_lesson_plans" FOR INSERT WITH CHECK ((("college_id" IN ( SELECT "college_lecturers"."collegeId"
   FROM "public"."college_lecturers"
  WHERE ("college_lecturers"."user_id" = "auth"."uid"())
UNION
 SELECT "departments"."college_id"
   FROM "public"."departments"
  WHERE ("departments"."created_by" = "auth"."uid"()))) AND ("created_by" = "auth"."uid"())));



CREATE POLICY "College users can delete their lesson plans" ON "public"."college_lesson_plans" FOR DELETE USING ((("created_by" = "auth"."uid"()) AND ("college_id" IN ( SELECT "college_lecturers"."collegeId"
   FROM "public"."college_lecturers"
  WHERE ("college_lecturers"."user_id" = "auth"."uid"())
UNION
 SELECT "departments"."college_id"
   FROM "public"."departments"
  WHERE ("departments"."created_by" = "auth"."uid"())))));



CREATE POLICY "College users can update their lesson plans" ON "public"."college_lesson_plans" FOR UPDATE USING ((("created_by" = "auth"."uid"()) AND ("college_id" IN ( SELECT "college_lecturers"."collegeId"
   FROM "public"."college_lecturers"
  WHERE ("college_lecturers"."user_id" = "auth"."uid"())
UNION
 SELECT "departments"."college_id"
   FROM "public"."departments"
  WHERE ("departments"."created_by" = "auth"."uid"())))));



CREATE POLICY "College users can view lesson plans in their college" ON "public"."college_lesson_plans" FOR SELECT USING (("college_id" IN ( SELECT "college_lecturers"."collegeId"
   FROM "public"."college_lecturers"
  WHERE ("college_lecturers"."user_id" = "auth"."uid"())
UNION
 SELECT "departments"."college_id"
   FROM "public"."departments"
  WHERE ("departments"."created_by" = "auth"."uid"()))));



CREATE POLICY "Create organization invitations" ON "public"."organization_invitations" FOR INSERT WITH CHECK ((("auth"."uid"() = "invited_by") AND "public"."is_organization_admin"("auth"."uid"())));



CREATE POLICY "Delete organization invitations" ON "public"."organization_invitations" FOR DELETE USING ("public"."is_organization_admin"("auth"."uid"()));



CREATE POLICY "Development access for lesson plans" ON "public"."college_lesson_plans" USING (("auth"."uid"() IS NOT NULL)) WITH CHECK (("auth"."uid"() IS NOT NULL));



CREATE POLICY "Discount codes readable by authenticated" ON "public"."addon_discount_codes" FOR SELECT USING ((("auth"."role"() = 'authenticated'::"text") AND ("is_active" = true) AND ("valid_from" <= "now"()) AND ("valid_until" >= "now"())));



CREATE POLICY "Educators can create admin conversations" ON "public"."conversations" FOR INSERT WITH CHECK ((("educator_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))) AND (("conversation_type")::"text" = 'educator_admin'::"text")));



CREATE POLICY "Educators can create curriculums" ON "public"."curriculums" FOR INSERT TO "authenticated" WITH CHECK (("created_by" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "Educators can create lesson plans" ON "public"."lesson_plans" FOR INSERT WITH CHECK (("educator_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "Educators can create student conversations" ON "public"."conversations" FOR INSERT WITH CHECK ((("educator_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))) AND (("conversation_type")::"text" = 'student_educator'::"text")));



CREATE POLICY "Educators can delete classes of their courses" ON "public"."course_classes" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."courses"
  WHERE (("courses"."course_id" = "course_classes"."course_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



COMMENT ON POLICY "Educators can delete classes of their courses" ON "public"."course_classes" IS 'Allows educators to delete classes of courses they own or co-educate';



CREATE POLICY "Educators can delete lessons" ON "public"."lessons" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."course_modules"
     JOIN "public"."courses" ON (("courses"."course_id" = "course_modules"."course_id")))
  WHERE (("course_modules"."module_id" = "lessons"."module_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



CREATE POLICY "Educators can delete modules" ON "public"."course_modules" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."courses"
  WHERE (("courses"."course_id" = "course_modules"."course_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



CREATE POLICY "Educators can delete resources" ON "public"."lesson_resources" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM (("public"."lessons"
     JOIN "public"."course_modules" ON (("course_modules"."module_id" = "lessons"."module_id")))
     JOIN "public"."courses" ON (("courses"."course_id" = "course_modules"."course_id")))
  WHERE (("lessons"."lesson_id" = "lesson_resources"."lesson_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



CREATE POLICY "Educators can delete skills of their courses" ON "public"."course_skills" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."courses"
  WHERE (("courses"."course_id" = "course_skills"."course_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



COMMENT ON POLICY "Educators can delete skills of their courses" ON "public"."course_skills" IS 'Allows educators to delete skills of courses they own or co-educate';



CREATE POLICY "Educators can delete their own courses" ON "public"."courses" FOR DELETE USING (("educator_id" = "auth"."uid"()));



CREATE POLICY "Educators can delete their own draft curriculums" ON "public"."curriculums" FOR DELETE TO "authenticated" USING ((("created_by" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))) AND (("status")::"text" = 'draft'::"text")));



CREATE POLICY "Educators can insert classes for their courses" ON "public"."course_classes" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."courses"
  WHERE (("courses"."course_id" = "course_classes"."course_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



COMMENT ON POLICY "Educators can insert classes for their courses" ON "public"."course_classes" IS 'Allows educators to insert classes for courses they own or co-educate';



CREATE POLICY "Educators can insert lessons" ON "public"."lessons" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM ("public"."course_modules"
     JOIN "public"."courses" ON (("courses"."course_id" = "course_modules"."course_id")))
  WHERE (("course_modules"."module_id" = "lessons"."module_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



CREATE POLICY "Educators can insert modules" ON "public"."course_modules" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."courses"
  WHERE (("courses"."course_id" = "course_modules"."course_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



CREATE POLICY "Educators can insert resources" ON "public"."lesson_resources" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM (("public"."lessons"
     JOIN "public"."course_modules" ON (("course_modules"."module_id" = "lessons"."module_id")))
     JOIN "public"."courses" ON (("courses"."course_id" = "course_modules"."course_id")))
  WHERE (("lessons"."lesson_id" = "lesson_resources"."lesson_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



CREATE POLICY "Educators can insert skills for their courses" ON "public"."course_skills" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."courses"
  WHERE (("courses"."course_id" = "course_skills"."course_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



COMMENT ON POLICY "Educators can insert skills for their courses" ON "public"."course_skills" IS 'Allows educators to insert skills for courses they own or co-educate';



CREATE POLICY "Educators can insert their own courses" ON "public"."courses" FOR INSERT WITH CHECK (("educator_id" = "auth"."uid"()));



CREATE POLICY "Educators can manage chapters in their draft/rejected curriculu" ON "public"."curriculum_chapters" TO "authenticated" USING (("curriculum_id" IN ( SELECT "curriculums"."id"
   FROM "public"."curriculums"
  WHERE (("curriculums"."created_by" IN ( SELECT "school_educators"."id"
           FROM "public"."school_educators"
          WHERE ("school_educators"."user_id" = "auth"."uid"()))) AND (("curriculums"."status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('rejected'::character varying)::"text"]))))));



CREATE POLICY "Educators can manage co-educators of their courses" ON "public"."course_co_educators" USING ((EXISTS ( SELECT 1
   FROM "public"."courses"
  WHERE (("courses"."course_id" = "course_co_educators"."course_id") AND ("courses"."educator_id" = "auth"."uid"())))));



CREATE POLICY "Educators can manage mappings in their draft/rejected curriculu" ON "public"."outcome_assessment_mappings" TO "authenticated" USING (("learning_outcome_id" IN ( SELECT "clo"."id"
   FROM (("public"."curriculum_learning_outcomes" "clo"
     JOIN "public"."curriculum_chapters" "cc" ON (("clo"."chapter_id" = "cc"."id")))
     JOIN "public"."curriculums" "c" ON (("cc"."curriculum_id" = "c"."id")))
  WHERE (("c"."created_by" IN ( SELECT "school_educators"."id"
           FROM "public"."school_educators"
          WHERE ("school_educators"."user_id" = "auth"."uid"()))) AND (("c"."status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('rejected'::character varying)::"text"]))))));



CREATE POLICY "Educators can manage outcomes in their draft/rejected curriculu" ON "public"."curriculum_learning_outcomes" TO "authenticated" USING (("chapter_id" IN ( SELECT "cc"."id"
   FROM ("public"."curriculum_chapters" "cc"
     JOIN "public"."curriculums" "c" ON (("cc"."curriculum_id" = "c"."id")))
  WHERE (("c"."created_by" IN ( SELECT "school_educators"."id"
           FROM "public"."school_educators"
          WHERE ("school_educators"."user_id" = "auth"."uid"()))) AND (("c"."status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('rejected'::character varying)::"text"]))))));



CREATE POLICY "Educators can send messages to school admins" ON "public"."messages" FOR INSERT WITH CHECK ((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'educator'::"text") AND ("receiver_type" = 'school_admin'::"text")));



CREATE POLICY "Educators can send messages to students" ON "public"."messages" FOR INSERT WITH CHECK ((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'educator'::"text") AND ("receiver_type" = 'student'::"text")));



CREATE POLICY "Educators can update classes of their courses" ON "public"."course_classes" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."courses"
  WHERE (("courses"."course_id" = "course_classes"."course_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



COMMENT ON POLICY "Educators can update classes of their courses" ON "public"."course_classes" IS 'Allows educators to update classes of courses they own or co-educate';



CREATE POLICY "Educators can update lessons" ON "public"."lessons" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM ("public"."course_modules"
     JOIN "public"."courses" ON (("courses"."course_id" = "course_modules"."course_id")))
  WHERE (("course_modules"."module_id" = "lessons"."module_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



CREATE POLICY "Educators can update modules" ON "public"."course_modules" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."courses"
  WHERE (("courses"."course_id" = "course_modules"."course_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



CREATE POLICY "Educators can update own draft lesson plans" ON "public"."lesson_plans" FOR UPDATE USING ((("educator_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))) AND (("status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('revision_required'::character varying)::"text"]))));



CREATE POLICY "Educators can update resources" ON "public"."lesson_resources" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM (("public"."lessons"
     JOIN "public"."course_modules" ON (("course_modules"."module_id" = "lessons"."module_id")))
     JOIN "public"."courses" ON (("courses"."course_id" = "course_modules"."course_id")))
  WHERE (("lessons"."lesson_id" = "lesson_resources"."lesson_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



CREATE POLICY "Educators can update skills of their courses" ON "public"."course_skills" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."courses"
  WHERE (("courses"."course_id" = "course_skills"."course_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



COMMENT ON POLICY "Educators can update skills of their courses" ON "public"."course_skills" IS 'Allows educators to update skills of courses they own or co-educate';



CREATE POLICY "Educators can update their admin conversations" ON "public"."conversations" FOR UPDATE USING ((("educator_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))) AND (("conversation_type")::"text" = 'educator_admin'::"text")));



CREATE POLICY "Educators can update their own courses" ON "public"."courses" FOR UPDATE USING ((("educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."course_co_educators"
  WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"()))))));



CREATE POLICY "Educators can update their own draft/rejected curriculums" ON "public"."curriculums" FOR UPDATE TO "authenticated" USING ((("created_by" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))) AND (("status")::"text" = ANY (ARRAY[('draft'::character varying)::"text", ('rejected'::character varying)::"text"]))));



CREATE POLICY "Educators can update their student conversations" ON "public"."conversations" FOR UPDATE USING ((("educator_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))) AND (("conversation_type")::"text" = 'student_educator'::"text")));



CREATE POLICY "Educators can view admin conversation messages" ON "public"."messages" FOR SELECT USING (((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'educator'::"text")) OR (("receiver_id" = "auth"."uid"()) AND ("receiver_type" = 'educator'::"text"))));



CREATE POLICY "Educators can view chapters from their school curriculums" ON "public"."curriculum_chapters" FOR SELECT TO "authenticated" USING (("curriculum_id" IN ( SELECT "curriculums"."id"
   FROM "public"."curriculums"
  WHERE ("curriculums"."school_id" IN ( SELECT "school_educators"."school_id"
           FROM "public"."school_educators"
          WHERE ("school_educators"."user_id" = "auth"."uid"()))))));



CREATE POLICY "Educators can view classes of their courses" ON "public"."course_classes" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."courses"
  WHERE (("courses"."course_id" = "course_classes"."course_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



COMMENT ON POLICY "Educators can view classes of their courses" ON "public"."course_classes" IS 'Allows educators to view classes of courses they own or co-educate';



CREATE POLICY "Educators can view course enrollments" ON "public"."course_enrollments" FOR SELECT USING ((("educator_id")::"text" = ("auth"."jwt"() ->> 'sub'::"text")));



CREATE POLICY "Educators can view curriculums from their school" ON "public"."curriculums" FOR SELECT TO "authenticated" USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "Educators can view mappings from their school curriculums" ON "public"."outcome_assessment_mappings" FOR SELECT TO "authenticated" USING (("learning_outcome_id" IN ( SELECT "clo"."id"
   FROM (("public"."curriculum_learning_outcomes" "clo"
     JOIN "public"."curriculum_chapters" "cc" ON (("clo"."chapter_id" = "cc"."id")))
     JOIN "public"."curriculums" "c" ON (("cc"."curriculum_id" = "c"."id")))
  WHERE ("c"."school_id" IN ( SELECT "school_educators"."school_id"
           FROM "public"."school_educators"
          WHERE ("school_educators"."user_id" = "auth"."uid"()))))));



CREATE POLICY "Educators can view outcomes from their school curriculums" ON "public"."curriculum_learning_outcomes" FOR SELECT TO "authenticated" USING (("chapter_id" IN ( SELECT "cc"."id"
   FROM ("public"."curriculum_chapters" "cc"
     JOIN "public"."curriculums" "c" ON (("cc"."curriculum_id" = "c"."id")))
  WHERE ("c"."school_id" IN ( SELECT "school_educators"."school_id"
           FROM "public"."school_educators"
          WHERE ("school_educators"."user_id" = "auth"."uid"()))))));



CREATE POLICY "Educators can view own lesson plans" ON "public"."lesson_plans" FOR SELECT USING (("educator_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "Educators can view skills of their courses" ON "public"."course_skills" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."courses"
  WHERE (("courses"."course_id" = "course_skills"."course_id") AND (("courses"."educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."course_co_educators"
          WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"())))))))));



COMMENT ON POLICY "Educators can view skills of their courses" ON "public"."course_skills" IS 'Allows educators to view skills of courses they own or co-educate';



CREATE POLICY "Educators can view student conversation messages" ON "public"."messages" FOR SELECT USING (((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'educator'::"text")) OR (("receiver_id" = "auth"."uid"()) AND ("receiver_type" = 'educator'::"text"))));



CREATE POLICY "Educators can view student external assessment attempts" ON "public"."external_assessment_attempts" FOR SELECT USING (("student_id" IN ( SELECT "s"."id"
   FROM ("public"."students" "s"
     JOIN "public"."school_educators" "se" ON (("se"."school_id" = "s"."school_id")))
  WHERE ("se"."user_id" = "auth"."uid"()))));



CREATE POLICY "Educators can view their admin conversations" ON "public"."conversations" FOR SELECT USING ((("educator_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))) AND (("conversation_type")::"text" = 'educator_admin'::"text") AND (("deleted_by_educator" IS NULL) OR ("deleted_by_educator" = false))));



CREATE POLICY "Educators can view their own courses" ON "public"."courses" FOR SELECT USING ((("educator_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
   FROM "public"."course_co_educators"
  WHERE (("course_co_educators"."course_id" = "courses"."course_id") AND ("course_co_educators"."educator_id" = "auth"."uid"()))))));



CREATE POLICY "Educators can view their student conversations" ON "public"."conversations" FOR SELECT USING ((("educator_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))) AND (("conversation_type")::"text" = 'student_educator'::"text") AND (("deleted_by_educator" IS NULL) OR ("deleted_by_educator" = false))));



CREATE POLICY "Enable delete for authenticated users only" ON "public"."assignment_attachments" FOR DELETE TO "authenticated" USING (true);



CREATE POLICY "Enable delete for users based on user_id" ON "public"."certificates" FOR DELETE USING (true);



CREATE POLICY "Enable delete for users based on user_id" ON "public"."offers" FOR DELETE USING (true);



CREATE POLICY "Enable delete for users based on user_id" ON "public"."school_classes" FOR DELETE USING (true);



CREATE POLICY "Enable insert for authenticated users only" ON "public"."assignment_attachments" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Enable insert for authenticated users only" ON "public"."assignments" FOR INSERT WITH CHECK (true);



CREATE POLICY "Enable insert for authenticated users only" ON "public"."certificates" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Enable insert for authenticated users only" ON "public"."experience" FOR INSERT WITH CHECK (true);



CREATE POLICY "Enable insert for authenticated users only" ON "public"."offers" FOR INSERT WITH CHECK (true);



CREATE POLICY "Enable insert for authenticated users only" ON "public"."projects" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Enable insert for authenticated users only" ON "public"."recruiters" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Enable insert for authenticated users only" ON "public"."school_classes" FOR INSERT WITH CHECK (true);



CREATE POLICY "Enable insert for authenticated users only" ON "public"."student_assignments" FOR INSERT WITH CHECK (true);



CREATE POLICY "Enable read access for all users" ON "public"."assignment_attachments" FOR SELECT USING (true);



CREATE POLICY "Enable read access for all users" ON "public"."assignments" FOR SELECT USING (true);



CREATE POLICY "Enable read access for all users" ON "public"."certificates" FOR SELECT USING (true);



CREATE POLICY "Enable read access for all users" ON "public"."experience" FOR SELECT USING (true);



CREATE POLICY "Enable read access for all users" ON "public"."offers" FOR SELECT USING (true);



CREATE POLICY "Enable read access for all users" ON "public"."recruiters" FOR SELECT USING (true);



CREATE POLICY "Enable read access for all users" ON "public"."school_classes" FOR SELECT USING (true);



CREATE POLICY "Enable read access for all users" ON "public"."student_assignments" FOR SELECT USING (true);



CREATE POLICY "Enable read access for all users" ON "public"."students" FOR SELECT USING (true);



CREATE POLICY "Enable update for authenticated users only" ON "public"."assignment_attachments" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Faculty can create swap requests" ON "public"."class_swap_requests" FOR INSERT WITH CHECK (("requester_faculty_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"())
UNION
 SELECT "college_lecturers"."id"
   FROM "public"."college_lecturers"
  WHERE ("college_lecturers"."user_id" = "auth"."uid"()))));



CREATE POLICY "Faculty can update swap requests" ON "public"."class_swap_requests" FOR UPDATE USING ((("requester_faculty_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"())
UNION
 SELECT "college_lecturers"."id"
   FROM "public"."college_lecturers"
  WHERE ("college_lecturers"."user_id" = "auth"."uid"()))) OR ("target_faculty_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"())
UNION
 SELECT "college_lecturers"."id"
   FROM "public"."college_lecturers"
  WHERE ("college_lecturers"."user_id" = "auth"."uid"())))));



CREATE POLICY "Faculty can view own swap history" ON "public"."class_swap_history" FOR SELECT USING (("swap_request_id" IN ( SELECT "class_swap_requests"."id"
   FROM "public"."class_swap_requests"
  WHERE (("class_swap_requests"."requester_faculty_id" IN ( SELECT "school_educators"."id"
           FROM "public"."school_educators"
          WHERE ("school_educators"."user_id" = "auth"."uid"())
        UNION
         SELECT "college_lecturers"."id"
           FROM "public"."college_lecturers"
          WHERE ("college_lecturers"."user_id" = "auth"."uid"()))) OR ("class_swap_requests"."target_faculty_id" IN ( SELECT "school_educators"."id"
           FROM "public"."school_educators"
          WHERE ("school_educators"."user_id" = "auth"."uid"())
        UNION
         SELECT "college_lecturers"."id"
           FROM "public"."college_lecturers"
          WHERE ("college_lecturers"."user_id" = "auth"."uid"())))))));



CREATE POLICY "Faculty can view own swap requests" ON "public"."class_swap_requests" FOR SELECT USING ((("requester_faculty_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"())
UNION
 SELECT "college_lecturers"."id"
   FROM "public"."college_lecturers"
  WHERE ("college_lecturers"."user_id" = "auth"."uid"()))) OR ("target_faculty_id" IN ( SELECT "school_educators"."id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"())
UNION
 SELECT "college_lecturers"."id"
   FROM "public"."college_lecturers"
  WHERE ("college_lecturers"."user_id" = "auth"."uid"())))));



CREATE POLICY "License holders can view their organization subscription" ON "public"."organization_subscriptions" FOR SELECT USING ("public"."user_has_license_for_org_subscription"("id"));



CREATE POLICY "Only admins can manage book issues" ON "public"."library_book_issues" USING ((EXISTS ( SELECT 1
   FROM "auth"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND (("users"."raw_user_meta_data" ->> 'role'::"text") = ANY (ARRAY['admin'::"text", 'college_admin'::"text", 'librarian'::"text"]))))));



CREATE POLICY "Only admins can manage book issues" ON "public"."library_book_issues_college" USING ((EXISTS ( SELECT 1
   FROM "auth"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ((("users"."raw_user_meta_data" ->> 'role'::"text") = ANY (ARRAY['admin'::"text", 'college_admin'::"text", 'librarian'::"text"])) OR (("users"."email")::"text" ~~ '%@admin.%'::"text"))))));



CREATE POLICY "Only admins can manage library books" ON "public"."library_books_college" USING ((EXISTS ( SELECT 1
   FROM "auth"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ((("users"."raw_user_meta_data" ->> 'role'::"text") = ANY (ARRAY['admin'::"text", 'college_admin'::"text", 'librarian'::"text"])) OR (("users"."email")::"text" ~~ '%@admin.%'::"text"))))));



CREATE POLICY "Only admins can manage library categories" ON "public"."library_categories" USING ((EXISTS ( SELECT 1
   FROM "auth"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND (("users"."raw_user_meta_data" ->> 'role'::"text") = ANY (ARRAY['admin'::"text", 'college_admin'::"text", 'librarian'::"text"]))))));



CREATE POLICY "Only admins can manage library categories" ON "public"."library_categories_college" USING ((EXISTS ( SELECT 1
   FROM "auth"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ((("users"."raw_user_meta_data" ->> 'role'::"text") = ANY (ARRAY['admin'::"text", 'college_admin'::"text", 'librarian'::"text"])) OR (("users"."email")::"text" ~~ '%@admin.%'::"text"))))));



CREATE POLICY "Only admins can manage library settings" ON "public"."library_settings" USING ((EXISTS ( SELECT 1
   FROM "auth"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND (("users"."raw_user_meta_data" ->> 'role'::"text") = ANY (ARRAY['admin'::"text", 'college_admin'::"text", 'librarian'::"text"]))))));



CREATE POLICY "Only admins can manage library settings" ON "public"."library_settings_college" USING ((EXISTS ( SELECT 1
   FROM "auth"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ((("users"."raw_user_meta_data" ->> 'role'::"text") = ANY (ARRAY['admin'::"text", 'college_admin'::"text", 'librarian'::"text"])) OR (("users"."email")::"text" ~~ '%@admin.%'::"text"))))));



CREATE POLICY "Policy with table joins" ON "public"."certificates" FOR UPDATE USING (true);



CREATE POLICY "Policy with table joins" ON "public"."experience" FOR UPDATE USING (true);



CREATE POLICY "Policy with table joins" ON "public"."offers" FOR UPDATE USING (true);



CREATE POLICY "Policy with table joins" ON "public"."recruiters" FOR UPDATE USING (true);



CREATE POLICY "Policy with table joins" ON "public"."school_classes" FOR UPDATE USING (true);



CREATE POLICY "Policy with table joins" ON "public"."student_assignments" FOR UPDATE USING (true);



CREATE POLICY "Recruiters can create student conversations" ON "public"."conversations" FOR INSERT WITH CHECK ((("recruiter_id" = "auth"."uid"()) AND ("student_id" IS NOT NULL) AND (("conversation_type" IS NULL) OR (("conversation_type")::"text" = 'student_recruiter'::"text"))));



CREATE POLICY "Recruiters can send messages to students" ON "public"."messages" FOR INSERT WITH CHECK ((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'recruiter'::"text") AND ("receiver_type" = 'student'::"text")));



CREATE POLICY "Recruiters can update application status" ON "public"."applied_jobs" FOR UPDATE USING (("opportunity_id_old" IN ( SELECT "opportunities"."id_old" AS "id"
   FROM "public"."opportunities"
  WHERE ("opportunities"."created_by" = ("auth"."uid"())::"text"))));



CREATE POLICY "Recruiters can update their student conversations" ON "public"."conversations" FOR UPDATE USING ((("recruiter_id" = "auth"."uid"()) AND ("student_id" IS NOT NULL) AND (("conversation_type" IS NULL) OR (("conversation_type")::"text" = 'student_recruiter'::"text"))));



CREATE POLICY "Recruiters can view applications for their opportunities" ON "public"."applied_jobs" FOR SELECT USING (("opportunity_id_old" IN ( SELECT "opportunities"."id_old" AS "id"
   FROM "public"."opportunities"
  WHERE ("opportunities"."created_by" = ("auth"."uid"())::"text"))));



CREATE POLICY "Recruiters can view approved internships" ON "public"."internships" FOR SELECT USING ((("enabled" = true) AND ("approval_status" = 'approved'::"text")));



CREATE POLICY "Recruiters can view student conversation messages" ON "public"."messages" FOR SELECT USING (((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'recruiter'::"text") AND ("receiver_type" = 'student'::"text")) OR (("receiver_id" = "auth"."uid"()) AND ("receiver_type" = 'recruiter'::"text") AND ("sender_type" = 'student'::"text"))));



CREATE POLICY "Recruiters can view their student conversations" ON "public"."conversations" FOR SELECT USING ((("recruiter_id" = "auth"."uid"()) AND ("student_id" IS NOT NULL) AND (("conversation_type" IS NULL) OR (("conversation_type")::"text" = 'student_recruiter'::"text")) AND (("deleted_by_recruiter" IS NULL) OR ("deleted_by_recruiter" = false))));



CREATE POLICY "School admins can create educator conversations" ON "public"."conversations" FOR INSERT WITH CHECK ((("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE (("school_educators"."user_id" = "auth"."uid"()) AND (("school_educators"."role")::"text" = 'school_admin'::"text")))) AND (("conversation_type")::"text" = 'educator_admin'::"text")));



CREATE POLICY "School admins can create student conversations" ON "public"."conversations" FOR INSERT WITH CHECK ((("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE (("school_educators"."user_id" = "auth"."uid"()) AND (("school_educators"."role")::"text" = 'school_admin'::"text")))) AND (("conversation_type")::"text" = 'student_admin'::"text")));



CREATE POLICY "School admins can insert applications" ON "public"."admission_applications" FOR INSERT WITH CHECK (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "School admins can review lesson plans" ON "public"."lesson_plans" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."school_educators" "se"
  WHERE (("se"."id" = "lesson_plans"."educator_id") AND ("se"."school_id" IN ( SELECT "school_educators"."school_id"
           FROM "public"."school_educators"
          WHERE (("school_educators"."user_id" = "auth"."uid"()) AND (("school_educators"."role")::"text" = 'school_admin'::"text"))))))));



CREATE POLICY "School admins can send messages to educators" ON "public"."messages" FOR INSERT WITH CHECK ((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'school_admin'::"text") AND ("receiver_type" = 'educator'::"text")));



CREATE POLICY "School admins can send messages to students" ON "public"."messages" FOR INSERT WITH CHECK ((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'school_admin'::"text") AND ("receiver_type" = 'student'::"text")));



CREATE POLICY "School admins can update their educator conversations" ON "public"."conversations" FOR UPDATE USING ((("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE (("school_educators"."user_id" = "auth"."uid"()) AND (("school_educators"."role")::"text" = 'school_admin'::"text")))) AND (("conversation_type")::"text" = 'educator_admin'::"text")));



CREATE POLICY "School admins can update their school's applications" ON "public"."admission_applications" FOR UPDATE USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "School admins can update their student conversations" ON "public"."conversations" FOR UPDATE USING ((("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE (("school_educators"."user_id" = "auth"."uid"()) AND (("school_educators"."role")::"text" = 'school_admin'::"text")))) AND (("conversation_type")::"text" = 'student_admin'::"text")));



CREATE POLICY "School admins can view all lesson plans" ON "public"."lesson_plans" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."school_educators" "se"
  WHERE (("se"."id" = "lesson_plans"."educator_id") AND ("se"."school_id" IN ( SELECT "school_educators"."school_id"
           FROM "public"."school_educators"
          WHERE (("school_educators"."user_id" = "auth"."uid"()) AND (("school_educators"."role")::"text" = 'school_admin'::"text"))))))));



CREATE POLICY "School admins can view educator conversation messages" ON "public"."messages" FOR SELECT USING (((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'school_admin'::"text")) OR (("receiver_id" = "auth"."uid"()) AND ("receiver_type" = 'school_admin'::"text"))));



CREATE POLICY "School admins can view student conversation messages" ON "public"."messages" FOR SELECT USING (((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'school_admin'::"text")) OR (("receiver_id" = "auth"."uid"()) AND ("receiver_type" = 'school_admin'::"text"))));



CREATE POLICY "School admins can view their educator conversations" ON "public"."conversations" FOR SELECT USING ((("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE (("school_educators"."user_id" = "auth"."uid"()) AND (("school_educators"."role")::"text" = 'school_admin'::"text")))) AND (("conversation_type")::"text" = 'educator_admin'::"text") AND (("deleted_by_admin" IS NULL) OR ("deleted_by_admin" = false))));



CREATE POLICY "School admins can view their school's applications" ON "public"."admission_applications" FOR SELECT USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "School admins can view their student conversations" ON "public"."conversations" FOR SELECT USING ((("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE (("school_educators"."user_id" = "auth"."uid"()) AND (("school_educators"."role")::"text" = 'school_admin'::"text")))) AND (("conversation_type")::"text" = 'student_admin'::"text") AND (("deleted_by_admin" IS NULL) OR ("deleted_by_admin" = false))));



CREATE POLICY "School staff can manage alerts" ON "public"."attendance_alerts" USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "School staff can manage assessments" ON "public"."skill_assessments" USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "School staff can manage attendance" ON "public"."attendance_records" USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "School staff can manage reports" ON "public"."student_reports" USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "School staff can manage student records" ON "public"."student_management_records" USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "School staff can view alerts" ON "public"."attendance_alerts" FOR SELECT USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "School staff can view assessments" ON "public"."skill_assessments" FOR SELECT USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "School staff can view attendance" ON "public"."attendance_records" FOR SELECT USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "School staff can view reports" ON "public"."student_reports" FOR SELECT USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "School staff can view their school's student records" ON "public"."student_management_records" FOR SELECT USING (("school_id" IN ( SELECT "school_educators"."school_id"
   FROM "public"."school_educators"
  WHERE ("school_educators"."user_id" = "auth"."uid"()))));



CREATE POLICY "Service role access otp_requests_log" ON "public"."otp_requests_log" USING (true);



CREATE POLICY "Service role access phone_otps" ON "public"."phone_otps" USING (true);



CREATE POLICY "Service role can do everything" ON "public"."reset_tokens" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "Service role can manage addon orders" ON "public"."addon_pending_orders" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can manage questions" ON "public"."adaptive_aptitude_questions_cache" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role can manage video summaries" ON "public"."video_summaries" USING (true) WITH CHECK (true);



CREATE POLICY "Service role can read all events" ON "public"."addon_events" FOR SELECT USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role has full access to job matches cache" ON "public"."student_job_matches" USING (("auth"."role"() = 'service_role'::"text")) WITH CHECK (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role has full access to student_course_progress" ON "public"."student_course_progress" USING ((("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text"));



CREATE POLICY "Service role has full access to tutor_feedback" ON "public"."tutor_feedback" USING ((("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text"));



CREATE POLICY "Students can add evaluations" ON "public"."ai_evaluations" FOR INSERT WITH CHECK ((("auth"."uid"() = "student_id") AND (EXISTS ( SELECT 1
   FROM "public"."career_ai_conversations"
  WHERE (("career_ai_conversations"."id" = "ai_evaluations"."conversation_id") AND ("career_ai_conversations"."student_id" = "auth"."uid"()))))));



CREATE POLICY "Students can create admin conversations" ON "public"."conversations" FOR INSERT WITH CHECK ((("student_id" = "auth"."uid"()) AND (("conversation_type")::"text" = 'student_admin'::"text")));



CREATE POLICY "Students can create college admin conversations" ON "public"."conversations" FOR INSERT WITH CHECK ((("student_id" = "auth"."uid"()) AND (("conversation_type")::"text" = 'student_college_admin'::"text")));



CREATE POLICY "Students can create educator conversations" ON "public"."conversations" FOR INSERT WITH CHECK ((("student_id" = "auth"."uid"()) AND (("conversation_type")::"text" = 'student_educator'::"text")));



CREATE POLICY "Students can create feedback on their conversations" ON "public"."tutor_feedback" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."tutor_conversations" "tc"
  WHERE (("tc"."id" = "tutor_feedback"."conversation_id") AND ("tc"."student_id" = "auth"."uid"())))));



CREATE POLICY "Students can create own applications" ON "public"."applied_jobs" FOR INSERT WITH CHECK ((("student_id" = "auth"."uid"()) OR ("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."id" = "auth"."uid"())))));



CREATE POLICY "Students can create own enrollments" ON "public"."course_enrollments" FOR INSERT WITH CHECK ((("student_email" = ("auth"."jwt"() ->> 'email'::"text")) OR (("student_id")::"text" = ("auth"."jwt"() ->> 'sub'::"text"))));



CREATE POLICY "Students can create own results" ON "public"."adaptive_aptitude_results" FOR INSERT WITH CHECK (("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."user_id" = "auth"."uid"()))));



CREATE POLICY "Students can create own sessions" ON "public"."adaptive_aptitude_sessions" FOR INSERT WITH CHECK (("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."user_id" = "auth"."uid"()))));



CREATE POLICY "Students can create recruiter conversations" ON "public"."conversations" FOR INSERT WITH CHECK ((("student_id" = "auth"."uid"()) AND ("recruiter_id" IS NOT NULL) AND (("conversation_type" IS NULL) OR (("conversation_type")::"text" = 'student_recruiter'::"text"))));



CREATE POLICY "Students can create responses for own sessions" ON "public"."adaptive_aptitude_responses" FOR INSERT WITH CHECK (("session_id" IN ( SELECT "adaptive_aptitude_sessions"."id"
   FROM "public"."adaptive_aptitude_sessions"
  WHERE ("adaptive_aptitude_sessions"."student_id" IN ( SELECT "students"."id"
           FROM "public"."students"
          WHERE ("students"."user_id" = "auth"."uid"()))))));



CREATE POLICY "Students can create their own progress" ON "public"."student_course_progress" FOR INSERT WITH CHECK (("auth"."uid"() = "student_id"));



CREATE POLICY "Students can delete own applications" ON "public"."applied_jobs" FOR DELETE USING ((("student_id" = "auth"."uid"()) OR ("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."id" = "auth"."uid"())))));



CREATE POLICY "Students can delete own internships" ON "public"."internships" FOR DELETE USING ((("auth"."uid"() = "student_id") OR ("student_email" = ("auth"."jwt"() ->> 'email'::"text"))));



CREATE POLICY "Students can insert own external assessment attempts" ON "public"."external_assessment_attempts" FOR INSERT WITH CHECK (("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."user_id" = "auth"."uid"()))));



CREATE POLICY "Students can insert own internships" ON "public"."internships" FOR INSERT WITH CHECK ((("auth"."uid"() = "student_id") OR ("student_email" = ("auth"."jwt"() ->> 'email'::"text"))));



CREATE POLICY "Students can insert own profile" ON "public"."students" FOR INSERT WITH CHECK (("auth"."uid"() = "id"));



CREATE POLICY "Students can insert own quiz progress" ON "public"."student_quiz_progress" FOR INSERT WITH CHECK (("student_id" = "auth"."uid"()));



CREATE POLICY "Students can insert verification requests" ON "public"."skill_verification_requests" FOR INSERT WITH CHECK (("auth"."uid"() = "student_id"));



CREATE POLICY "Students can send messages to college admins" ON "public"."messages" FOR INSERT WITH CHECK ((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'student'::"text") AND ("receiver_type" = 'college_admin'::"text")));



CREATE POLICY "Students can send messages to educators" ON "public"."messages" FOR INSERT WITH CHECK ((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'student'::"text") AND ("receiver_type" = 'educator'::"text")));



CREATE POLICY "Students can send messages to recruiters" ON "public"."messages" FOR INSERT WITH CHECK ((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'student'::"text") AND ("receiver_type" = 'recruiter'::"text")));



CREATE POLICY "Students can send messages to school admins" ON "public"."messages" FOR INSERT WITH CHECK ((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'student'::"text") AND ("receiver_type" = 'school_admin'::"text")));



CREATE POLICY "Students can update own applications" ON "public"."applied_jobs" FOR UPDATE USING ((("student_id" = "auth"."uid"()) OR ("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."id" = "auth"."uid"())))));



CREATE POLICY "Students can update own enrollments" ON "public"."course_enrollments" FOR UPDATE USING ((("student_email" = ("auth"."jwt"() ->> 'email'::"text")) OR (("student_id")::"text" = ("auth"."jwt"() ->> 'sub'::"text"))));



CREATE POLICY "Students can update own evaluations" ON "public"."ai_evaluations" FOR UPDATE USING (("auth"."uid"() = "student_id"));



CREATE POLICY "Students can update own external assessment attempts" ON "public"."external_assessment_attempts" FOR UPDATE USING (("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."user_id" = "auth"."uid"())))) WITH CHECK (("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."user_id" = "auth"."uid"()))));



CREATE POLICY "Students can update own internships" ON "public"."internships" FOR UPDATE USING ((("auth"."uid"() = "student_id") OR ("student_email" = ("auth"."jwt"() ->> 'email'::"text")))) WITH CHECK ((("auth"."uid"() = "student_id") OR ("student_email" = ("auth"."jwt"() ->> 'email'::"text"))));



CREATE POLICY "Students can update own quiz progress" ON "public"."student_quiz_progress" FOR UPDATE USING (("student_id" = "auth"."uid"()));



CREATE POLICY "Students can update own sessions" ON "public"."adaptive_aptitude_sessions" FOR UPDATE USING (("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."user_id" = "auth"."uid"()))));



CREATE POLICY "Students can update their admin conversations" ON "public"."conversations" FOR UPDATE USING ((("student_id" = "auth"."uid"()) AND (("conversation_type")::"text" = 'student_admin'::"text")));



CREATE POLICY "Students can update their college admin conversations" ON "public"."conversations" FOR UPDATE USING ((("student_id" = "auth"."uid"()) AND (("conversation_type")::"text" = 'student_college_admin'::"text")));



CREATE POLICY "Students can update their educator conversations" ON "public"."conversations" FOR UPDATE USING ((("student_id" = "auth"."uid"()) AND (("conversation_type")::"text" = 'student_educator'::"text")));



CREATE POLICY "Students can update their own progress" ON "public"."student_course_progress" FOR UPDATE USING (("auth"."uid"() = "student_id")) WITH CHECK (("auth"."uid"() = "student_id"));



CREATE POLICY "Students can update their recruiter conversations" ON "public"."conversations" FOR UPDATE USING ((("student_id" = "auth"."uid"()) AND ("recruiter_id" IS NOT NULL) AND (("conversation_type" IS NULL) OR (("conversation_type")::"text" = 'student_recruiter'::"text"))));



CREATE POLICY "Students can view admin conversation messages" ON "public"."messages" FOR SELECT USING (((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'student'::"text")) OR (("receiver_id" = "auth"."uid"()) AND ("receiver_type" = 'student'::"text"))));



CREATE POLICY "Students can view college admin conversation messages" ON "public"."messages" FOR SELECT USING (((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'student'::"text")) OR (("receiver_id" = "auth"."uid"()) AND ("receiver_type" = 'student'::"text"))));



CREATE POLICY "Students can view educator conversation messages" ON "public"."messages" FOR SELECT USING (((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'student'::"text")) OR (("receiver_id" = "auth"."uid"()) AND ("receiver_type" = 'student'::"text"))));



CREATE POLICY "Students can view feedback on their conversations" ON "public"."tutor_feedback" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."tutor_conversations" "tc"
  WHERE (("tc"."id" = "tutor_feedback"."conversation_id") AND ("tc"."student_id" = "auth"."uid"())))));



CREATE POLICY "Students can view own applications" ON "public"."applied_jobs" FOR SELECT USING ((("student_id" = "auth"."uid"()) OR ("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."id" = "auth"."uid"())))));



CREATE POLICY "Students can view own enrollments" ON "public"."course_enrollments" FOR SELECT USING ((("student_email" = ("auth"."jwt"() ->> 'email'::"text")) OR (("student_id")::"text" = ("auth"."jwt"() ->> 'sub'::"text"))));



CREATE POLICY "Students can view own external assessment attempts" ON "public"."external_assessment_attempts" FOR SELECT USING (("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."user_id" = "auth"."uid"()))));



CREATE POLICY "Students can view own internships" ON "public"."internships" FOR SELECT USING ((("auth"."uid"() = "student_id") OR ("student_email" = ("auth"."jwt"() ->> 'email'::"text"))));



CREATE POLICY "Students can view own profile views" ON "public"."profile_views" FOR SELECT USING (true);



CREATE POLICY "Students can view own quiz progress" ON "public"."student_quiz_progress" FOR SELECT USING (("student_id" = "auth"."uid"()));



CREATE POLICY "Students can view own responses" ON "public"."adaptive_aptitude_responses" FOR SELECT USING (("session_id" IN ( SELECT "adaptive_aptitude_sessions"."id"
   FROM "public"."adaptive_aptitude_sessions"
  WHERE ("adaptive_aptitude_sessions"."student_id" IN ( SELECT "students"."id"
           FROM "public"."students"
          WHERE ("students"."user_id" = "auth"."uid"()))))));



CREATE POLICY "Students can view own results" ON "public"."adaptive_aptitude_results" FOR SELECT USING (("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."user_id" = "auth"."uid"()))));



CREATE POLICY "Students can view own sessions" ON "public"."adaptive_aptitude_sessions" FOR SELECT USING (("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."user_id" = "auth"."uid"()))));



CREATE POLICY "Students can view recruiter conversation messages" ON "public"."messages" FOR SELECT USING (((("sender_id" = "auth"."uid"()) AND ("sender_type" = 'student'::"text") AND ("receiver_type" = 'recruiter'::"text")) OR (("receiver_id" = "auth"."uid"()) AND ("receiver_type" = 'student'::"text") AND ("sender_type" = 'recruiter'::"text"))));



CREATE POLICY "Students can view their admin conversations" ON "public"."conversations" FOR SELECT USING ((("student_id" = "auth"."uid"()) AND (("conversation_type")::"text" = 'student_admin'::"text") AND (("deleted_by_student" IS NULL) OR ("deleted_by_student" = false))));



CREATE POLICY "Students can view their college admin conversations" ON "public"."conversations" FOR SELECT USING ((("student_id" = "auth"."uid"()) AND (("conversation_type")::"text" = 'student_college_admin'::"text") AND (("deleted_by_student" IS NULL) OR ("deleted_by_student" = false))));



CREATE POLICY "Students can view their educator conversations" ON "public"."conversations" FOR SELECT USING ((("student_id" = "auth"."uid"()) AND (("conversation_type")::"text" = 'student_educator'::"text") AND (("deleted_by_student" IS NULL) OR ("deleted_by_student" = false))));



CREATE POLICY "Students can view their own book issues" ON "public"."library_book_issues" FOR SELECT USING (("auth"."uid"() = "student_id"));



CREATE POLICY "Students can view their own book issues" ON "public"."library_book_issues_college" FOR SELECT USING ((("auth"."uid"())::"text" = "student_id"));



CREATE POLICY "Students can view their own job matches cache" ON "public"."student_job_matches" FOR SELECT USING (("student_id" IN ( SELECT "students"."id"
   FROM "public"."students"
  WHERE ("students"."user_id" = "auth"."uid"()))));



CREATE POLICY "Students can view their own progress" ON "public"."student_course_progress" FOR SELECT USING (("auth"."uid"() = "student_id"));



CREATE POLICY "Students can view their own verification requests" ON "public"."skill_verification_requests" FOR SELECT USING (("auth"."uid"() = "student_id"));



CREATE POLICY "Students can view their recruiter conversations" ON "public"."conversations" FOR SELECT USING ((("student_id" = "auth"."uid"()) AND ("recruiter_id" IS NOT NULL) AND (("conversation_type" IS NULL) OR (("conversation_type")::"text" = 'student_recruiter'::"text")) AND (("deleted_by_student" IS NULL) OR ("deleted_by_student" = false))));



CREATE POLICY "Students view own evaluations" ON "public"."ai_evaluations" FOR SELECT USING (("auth"."uid"() = "student_id"));



CREATE POLICY "System can insert document access" ON "public"."document_access_history" FOR INSERT WITH CHECK (true);



CREATE POLICY "System can insert login history" ON "public"."user_login_history" FOR INSERT WITH CHECK (true);



CREATE POLICY "System can insert state history" ON "public"."user_state_history" FOR INSERT WITH CHECK (true);



CREATE POLICY "University admins can update curriculum for approval" ON "public"."college_curriculums" FOR UPDATE USING ((("university_id" IN ( SELECT "users"."organizationId"
   FROM "public"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ("users"."role" = 'university_admin'::"public"."user_role")))) AND (("status")::"text" = ANY (ARRAY[('pending_approval'::character varying)::"text", ('rejected'::character varying)::"text"]))));



CREATE POLICY "University admins can view affiliated college curriculum" ON "public"."college_curriculums" FOR SELECT USING (("university_id" IN ( SELECT "users"."organizationId"
   FROM "public"."users"
  WHERE (("users"."id" = "auth"."uid"()) AND ("users"."role" = 'university_admin'::"public"."user_role")))));



CREATE POLICY "Update organization invitations" ON "public"."organization_invitations" FOR UPDATE USING (("public"."is_organization_admin"("auth"."uid"()) OR (("invitee_email" = "public"."get_user_email"("auth"."uid"())) AND ("status" = 'pending'::"text")))) WITH CHECK (("public"."is_organization_admin"("auth"."uid"()) OR (("invitee_email" = "public"."get_user_email"("auth"."uid"())) AND ("status" = ANY (ARRAY['accepted'::"text", 'pending'::"text"])))));



CREATE POLICY "Users can create own payment transactions" ON "public"."payment_transactions" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can create own subscriptions" ON "public"."subscriptions" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can delete own career conversations" ON "public"."career_ai_conversations" FOR DELETE USING (("auth"."uid"() = "student_id"));



CREATE POLICY "Users can delete own saved searches" ON "public"."recruiter_saved_searches" FOR DELETE USING (true);



CREATE POLICY "Users can insert own career conversations" ON "public"."career_ai_conversations" FOR INSERT WITH CHECK (("auth"."uid"() = "student_id"));



CREATE POLICY "Users can insert own events" ON "public"."addon_events" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert own profile" ON "public"."user_profiles" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert own saved searches" ON "public"."recruiter_saved_searches" FOR INSERT WITH CHECK (true);



CREATE POLICY "Users can insert own sessions" ON "public"."user_sessions" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can insert own settings" ON "public"."user_settings" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can read their own notifications" ON "public"."notifications" FOR SELECT USING (("recipient_id" = "auth"."uid"()));



CREATE POLICY "Users can update own career conversations" ON "public"."career_ai_conversations" FOR UPDATE USING (("auth"."uid"() = "student_id"));



CREATE POLICY "Users can update own profile" ON "public"."user_profiles" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update own saved searches" ON "public"."recruiter_saved_searches" FOR UPDATE USING (true);



CREATE POLICY "Users can update own sessions" ON "public"."user_sessions" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update own settings" ON "public"."user_settings" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update own subscriptions" ON "public"."subscriptions" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can update their received messages" ON "public"."messages" FOR UPDATE USING (("receiver_id" = "auth"."uid"()));



CREATE POLICY "Users can view own addon orders" ON "public"."addon_pending_orders" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own career conversations" ON "public"."career_ai_conversations" FOR SELECT USING (("auth"."uid"() = "student_id"));



CREATE POLICY "Users can view own document access" ON "public"."document_access_history" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own login history" ON "public"."user_login_history" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own migrations" ON "public"."subscription_migrations" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own payment transactions" ON "public"."payment_transactions" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own profile" ON "public"."user_profiles" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own saved searches" ON "public"."recruiter_saved_searches" FOR SELECT USING (true);



CREATE POLICY "Users can view own sessions" ON "public"."user_sessions" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own settings" ON "public"."user_settings" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own state history" ON "public"."user_state_history" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can view own subscription" ON "public"."subscriptions" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Users can view own subscriptions" ON "public"."subscriptions" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "View organization invitations" ON "public"."organization_invitations" FOR SELECT USING (("public"."is_organization_admin"("auth"."uid"()) OR ("invitee_email" = "public"."get_user_email"("auth"."uid"()))));



ALTER TABLE "public"."adaptive_aptitude_responses" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."adaptive_aptitude_results" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."adaptive_aptitude_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."addon_discount_codes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."addon_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."addon_pending_orders" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "admin_delete" ON "public"."admin_users" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE (("au"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("au"."admin_role" = 'super_admin'::"text")))));



CREATE POLICY "admin_insert" ON "public"."admin_users" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE (("au"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("au"."admin_role" = 'super_admin'::"text")))));



CREATE POLICY "admin_read" ON "public"."admin_users" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE (("au"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("au"."admin_role" = 'super_admin'::"text")))));



CREATE POLICY "admin_update" ON "public"."admin_users" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE (("au"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("au"."admin_role" = 'super_admin'::"text"))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."admin_users" "au"
  WHERE (("au"."id" = ( SELECT "auth"."uid"() AS "uid")) AND ("au"."admin_role" = 'super_admin'::"text")))));



ALTER TABLE "public"."admission_applications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_evaluations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."app_config" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."assessment_types" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."assignment_attachments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."attendance_alerts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."audit_logs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bundle_features" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."bundles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."career_ai_conversations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."class_swap_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."class_swap_requests" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."club_attendance" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."club_attendance_records" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."club_memberships" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."clubs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "college_admins_all_assignments" ON "public"."college_assignments" USING ((EXISTS ( SELECT 1
   FROM "public"."organizations" "o"
  WHERE (("o"."id" = "college_assignments"."college_id") AND (("o"."organization_type")::"text" = 'college'::"text") AND ("o"."admin_id" = "auth"."uid"())))));



ALTER TABLE "public"."college_breaks" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_circulars" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_classes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_event_registrations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_events" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_faculty_class_assignments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_faculty_leave_balances" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_faculty_leaves" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_faculty_substitutions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_leave_types" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_lecturer_course_assignments" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "college_lecturers_own_assignments" ON "public"."college_assignments" USING ((EXISTS ( SELECT 1
   FROM "public"."college_lecturers" "cl"
  WHERE (("cl"."user_id" = "auth"."uid"()) AND ("cl"."user_id" = "college_assignments"."college_educator_id")))));



ALTER TABLE "public"."college_lesson_plans" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_student_assignments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_time_periods" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_timetable_slots" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."college_timetables" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."competition_clubs" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."competition_registrations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."competitions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."course_co_educators" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."curriculum_academic_years" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."curriculum_classes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."curriculum_subjects" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."document_access_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "educators_created_assignments" ON "public"."college_student_assignments" USING ((EXISTS ( SELECT 1
   FROM "public"."college_assignments" "ca"
  WHERE (("ca"."assignment_id" = "college_student_assignments"."assignment_id") AND ("ca"."college_educator_id" = "auth"."uid"())))));



ALTER TABLE "public"."embedding_cache" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."experience" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."export_activities" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."external_assessment_attempts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."internships" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."interview_reminders" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."interviews" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."library_categories_school" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."library_settings_school" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."license_assignments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."license_pools" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."metrics_snapshots" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."offers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."opportunity_interactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."organization_invitations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."organization_subscriptions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."organizations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."otp_requests_log" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payment_transactions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."permissions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."personal_assessment_attempts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."personal_assessment_questions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."personal_assessment_response_scales" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."personal_assessment_responses" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."personal_assessment_restrictions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."personal_assessment_results" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."personal_assessment_sections" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."personal_assessment_streams" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."phone_otps" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pipeline_activities" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pipeline_candidates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."placements" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pre_registrations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."profile_views" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."recent_updates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."recruiter_activities" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."recruiter_saved_searches" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."requisitions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."reset_tokens" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."school_classes" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."search_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."shortlist_candidates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."shortlists" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."skill_assessments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."skill_passports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."skill_trends" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."skill_verification_requests" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."student_enrollments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."student_job_matches" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."student_management_records" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."student_quiz_progress" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."student_reports" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."students" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "students_assigned_assignments" ON "public"."college_assignments" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."college_student_assignments" "csa"
  WHERE (("csa"."assignment_id" = "college_assignments"."assignment_id") AND ("csa"."student_id" = "auth"."uid"()) AND ("csa"."is_deleted" = false)))));



CREATE POLICY "students_own_assignments" ON "public"."college_student_assignments" USING (("auth"."uid"() = "student_id"));



ALTER TABLE "public"."subscription_migrations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscription_plan_features" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscription_plans" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscriptions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "tutor_conversations_delete" ON "public"."tutor_conversations" FOR DELETE TO "authenticated" USING (("auth"."uid"() = "student_id"));



CREATE POLICY "tutor_conversations_insert" ON "public"."tutor_conversations" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "student_id"));



CREATE POLICY "tutor_conversations_select" ON "public"."tutor_conversations" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "student_id"));



CREATE POLICY "tutor_conversations_update" ON "public"."tutor_conversations" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "student_id")) WITH CHECK (("auth"."uid"() = "student_id"));



ALTER TABLE "public"."tutor_feedback" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."university_courses" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."university_performance" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_categories" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_entitlements" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "user_entitlements_insert_own" ON "public"."user_entitlements" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "user_entitlements_select_own" ON "public"."user_entitlements" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "user_entitlements_service_role" ON "public"."user_entitlements" TO "service_role" USING (true) WITH CHECK (true);



CREATE POLICY "user_entitlements_update_own" ON "public"."user_entitlements" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."user_login_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_settings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_state_history" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."verifications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."video_summaries" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";






ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."conversations";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."messages";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."notifications";









GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";
GRANT USAGE ON SCHEMA "public" TO "supabase_auth_admin";







































































































































































































































































































































































































































































































































































































































GRANT ALL ON FUNCTION "public"."add_achievement_update"("p_student_id" "uuid", "p_achievement" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_achievement_update"("p_student_id" "uuid", "p_achievement" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_achievement_update"("p_student_id" "uuid", "p_achievement" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."add_column_if_not_exists"("p_table_name" "text", "p_column_name" "text", "p_column_definition" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_column_if_not_exists"("p_table_name" "text", "p_column_name" "text", "p_column_definition" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_column_if_not_exists"("p_table_name" "text", "p_column_name" "text", "p_column_definition" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."add_constraint_if_not_exists"("p_table_name" "text", "p_constraint_name" "text", "p_constraint_definition" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_constraint_if_not_exists"("p_table_name" "text", "p_constraint_name" "text", "p_constraint_definition" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_constraint_if_not_exists"("p_table_name" "text", "p_constraint_name" "text", "p_constraint_definition" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."add_jsonb_recent_update"("student_email" "text", "update_title" "text", "update_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_jsonb_recent_update"("student_email" "text", "update_title" "text", "update_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_jsonb_recent_update"("student_email" "text", "update_title" "text", "update_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."add_jsonb_recent_update"("student_uuid" "uuid", "update_title" "text", "update_description" "text", "update_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_jsonb_recent_update"("student_uuid" "uuid", "update_title" "text", "update_description" "text", "update_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_jsonb_recent_update"("student_uuid" "uuid", "update_title" "text", "update_description" "text", "update_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."add_opportunity_match_update"("p_student_id" "uuid", "p_opportunity_title" "text", "p_company_name" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_opportunity_match_update"("p_student_id" "uuid", "p_opportunity_title" "text", "p_company_name" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_opportunity_match_update"("p_student_id" "uuid", "p_opportunity_title" "text", "p_company_name" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."add_recent_update"("p_student_id" "uuid", "p_message" "text", "p_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_recent_update"("p_student_id" "uuid", "p_message" "text", "p_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_recent_update"("p_student_id" "uuid", "p_message" "text", "p_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."add_recent_update"("student_email" "text", "update_title" "text", "update_description" "text", "update_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_recent_update"("student_email" "text", "update_title" "text", "update_description" "text", "update_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_recent_update"("student_email" "text", "update_title" "text", "update_description" "text", "update_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."add_recent_update_by_email"("student_email" "text", "update_title" "text", "update_description" "text", "update_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."add_recent_update_by_email"("student_email" "text", "update_title" "text", "update_description" "text", "update_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_recent_update_by_email"("student_email" "text", "update_title" "text", "update_description" "text", "update_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."add_to_profile_array"("p_student_id" "uuid", "p_array_name" "text", "p_new_item" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."add_to_profile_array"("p_student_id" "uuid", "p_array_name" "text", "p_new_item" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_to_profile_array"("p_student_id" "uuid", "p_array_name" "text", "p_new_item" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."add_to_teacher_journal"() TO "anon";
GRANT ALL ON FUNCTION "public"."add_to_teacher_journal"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."add_to_teacher_journal"() TO "service_role";



GRANT ALL ON FUNCTION "public"."analyze_skills_demand"() TO "anon";
GRANT ALL ON FUNCTION "public"."analyze_skills_demand"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."analyze_skills_demand"() TO "service_role";



GRANT ALL ON FUNCTION "public"."apply_change_to_tables"("p_curriculum_id" "uuid", "p_change_type" character varying, "p_entity_id" "uuid", "p_change_data" "jsonb", "p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."apply_change_to_tables"("p_curriculum_id" "uuid", "p_change_type" character varying, "p_entity_id" "uuid", "p_change_data" "jsonb", "p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."apply_change_to_tables"("p_curriculum_id" "uuid", "p_change_type" character varying, "p_entity_id" "uuid", "p_change_data" "jsonb", "p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."apply_to_job"("p_student_id" "uuid", "p_opportunity_id" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."apply_to_job"("p_student_id" "uuid", "p_opportunity_id" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."apply_to_job"("p_student_id" "uuid", "p_opportunity_id" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_add_applicant_to_pipeline"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_add_applicant_to_pipeline"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_add_applicant_to_pipeline"() TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_assign_license_to_member"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_assign_license_to_member"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_assign_license_to_member"() TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_create_assessment_result"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_create_assessment_result"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_create_assessment_result"() TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_set_cancelled_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_set_cancelled_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_set_cancelled_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."auto_set_university_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."auto_set_university_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."auto_set_university_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."backfill_assessment_reminders"() TO "anon";
GRANT ALL ON FUNCTION "public"."backfill_assessment_reminders"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."backfill_assessment_reminders"() TO "service_role";



GRANT ALL ON TABLE "public"."certificates" TO "anon";
GRANT ALL ON TABLE "public"."certificates" TO "authenticated";
GRANT ALL ON TABLE "public"."certificates" TO "service_role";



GRANT ALL ON FUNCTION "public"."build_certificate_text"("cert_record" "public"."certificates") TO "anon";
GRANT ALL ON FUNCTION "public"."build_certificate_text"("cert_record" "public"."certificates") TO "authenticated";
GRANT ALL ON FUNCTION "public"."build_certificate_text"("cert_record" "public"."certificates") TO "service_role";



GRANT ALL ON TABLE "public"."course_enrollments" TO "anon";
GRANT ALL ON TABLE "public"."course_enrollments" TO "authenticated";
GRANT ALL ON TABLE "public"."course_enrollments" TO "service_role";



GRANT ALL ON FUNCTION "public"."build_course_enrollment_text"("p_enrollment" "public"."course_enrollments") TO "anon";
GRANT ALL ON FUNCTION "public"."build_course_enrollment_text"("p_enrollment" "public"."course_enrollments") TO "authenticated";
GRANT ALL ON FUNCTION "public"."build_course_enrollment_text"("p_enrollment" "public"."course_enrollments") TO "service_role";



GRANT ALL ON TABLE "public"."projects" TO "anon";
GRANT ALL ON TABLE "public"."projects" TO "authenticated";
GRANT ALL ON TABLE "public"."projects" TO "service_role";



GRANT ALL ON FUNCTION "public"."build_project_text"("proj_record" "public"."projects") TO "anon";
GRANT ALL ON FUNCTION "public"."build_project_text"("proj_record" "public"."projects") TO "authenticated";
GRANT ALL ON FUNCTION "public"."build_project_text"("proj_record" "public"."projects") TO "service_role";



GRANT ALL ON TABLE "public"."skills" TO "anon";
GRANT ALL ON TABLE "public"."skills" TO "authenticated";
GRANT ALL ON TABLE "public"."skills" TO "service_role";



GRANT ALL ON FUNCTION "public"."build_skill_text"("p_skill" "public"."skills") TO "anon";
GRANT ALL ON FUNCTION "public"."build_skill_text"("p_skill" "public"."skills") TO "authenticated";
GRANT ALL ON FUNCTION "public"."build_skill_text"("p_skill" "public"."skills") TO "service_role";



GRANT ALL ON TABLE "public"."trainings" TO "anon";
GRANT ALL ON TABLE "public"."trainings" TO "authenticated";
GRANT ALL ON TABLE "public"."trainings" TO "service_role";



GRANT ALL ON FUNCTION "public"."build_training_text"("training_record" "public"."trainings") TO "anon";
GRANT ALL ON FUNCTION "public"."build_training_text"("training_record" "public"."trainings") TO "authenticated";
GRANT ALL ON FUNCTION "public"."build_training_text"("training_record" "public"."trainings") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_assessment_scores"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_assessment_scores"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_assessment_scores"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_batch_statistics"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_batch_statistics"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_batch_statistics"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_days_borrowed"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_days_borrowed"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_days_borrowed"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_exam_registration_fee"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_exam_registration_fee"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_exam_registration_fee"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_fine"("issue_date" "date", "return_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_fine"("issue_date" "date", "return_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_fine"("issue_date" "date", "return_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_fine_college"("p_college_id" "uuid", "issue_date" "date", "return_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_fine_college"("p_college_id" "uuid", "issue_date" "date", "return_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_fine_college"("p_college_id" "uuid", "issue_date" "date", "return_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_fine_school"("p_school_id" "uuid", "issue_date" "date", "return_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_fine_school"("p_school_id" "uuid", "issue_date" "date", "return_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_fine_school"("p_school_id" "uuid", "issue_date" "date", "return_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_internship_duration"("start_date" "date", "end_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_internship_duration"("start_date" "date", "end_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_internship_duration"("start_date" "date", "end_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_library_fine"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_library_fine"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_library_fine"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_moderation_difference"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_moderation_difference"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_moderation_difference"() TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_session_stats"("p_session_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_session_stats"("p_session_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_session_stats"("p_session_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_teacher_workload"("p_educator_id" "uuid", "p_timetable_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_teacher_workload"("p_educator_id" "uuid", "p_timetable_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_teacher_workload"("p_educator_id" "uuid", "p_timetable_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."calculate_transcript_request_fee"() TO "anon";
GRANT ALL ON FUNCTION "public"."calculate_transcript_request_fee"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."calculate_transcript_request_fee"() TO "service_role";



GRANT ALL ON FUNCTION "public"."can_student_join_club"("p_student_email" character varying, "p_club_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."can_student_join_club"("p_student_email" character varying, "p_club_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."can_student_join_club"("p_student_email" character varying, "p_club_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."can_take_assessment"("p_student_id" "text", "p_grade_level" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."can_take_assessment"("p_student_id" "text", "p_grade_level" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."can_take_assessment"("p_student_id" "text", "p_grade_level" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_attendance_alerts"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_attendance_alerts"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_attendance_alerts"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_attendance_slot_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_attendance_slot_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_attendance_slot_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_break_date_overlap"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_break_date_overlap"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_break_date_overlap"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_budget_alerts"("p_budget_id" "uuid", "p_budget_head_name" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."check_budget_alerts"("p_budget_id" "uuid", "p_budget_head_name" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_budget_alerts"("p_budget_id" "uuid", "p_budget_head_name" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_club_capacity"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_club_capacity"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_club_capacity"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_college_affiliation"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_college_affiliation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_college_affiliation"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_college_affiliation_status"("p_college_id" "uuid", "p_university_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."check_college_affiliation_status"("p_college_id" "uuid", "p_university_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_college_affiliation_status"("p_college_id" "uuid", "p_university_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_duplicate_active_subscription"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_duplicate_active_subscription"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_duplicate_active_subscription"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_max_clubs_per_student"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_max_clubs_per_student"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_max_clubs_per_student"() TO "service_role";



GRANT ALL ON FUNCTION "public"."check_swap_conflicts"("p_requester_slot_id" "uuid", "p_target_slot_id" "uuid", "p_swap_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."check_swap_conflicts"("p_requester_slot_id" "uuid", "p_target_slot_id" "uuid", "p_swap_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_swap_conflicts"("p_requester_slot_id" "uuid", "p_target_slot_id" "uuid", "p_swap_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."check_timetable_slot_conflicts"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_timetable_slot_conflicts"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_timetable_slot_conflicts"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_embedding_queue"("days_old" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_embedding_queue"("days_old" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_embedding_queue"("days_old" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_expired_job_matches_cache"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_expired_job_matches_cache"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_expired_job_matches_cache"() TO "service_role";



GRANT ALL ON FUNCTION "public"."cleanup_expired_otps"() TO "anon";
GRANT ALL ON FUNCTION "public"."cleanup_expired_otps"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."cleanup_expired_otps"() TO "service_role";



GRANT ALL ON FUNCTION "public"."complete_embedding_queue_item"("queue_id" "uuid", "success" boolean, "error_msg" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."complete_embedding_queue_item"("queue_id" "uuid", "success" boolean, "error_msg" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."complete_embedding_queue_item"("queue_id" "uuid", "success" boolean, "error_msg" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."compute_student_profile_hash"("p_student_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."compute_student_profile_hash"("p_student_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."compute_student_profile_hash"("p_student_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."copy_curriculum_template"("p_source_curriculum_id" "uuid", "p_target_school_id" "uuid", "p_target_subject" character varying, "p_target_class" character varying, "p_target_academic_year" character varying, "p_created_by" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."copy_curriculum_template"("p_source_curriculum_id" "uuid", "p_target_school_id" "uuid", "p_target_subject" character varying, "p_target_class" character varying, "p_target_academic_year" character varying, "p_created_by" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."copy_curriculum_template"("p_source_curriculum_id" "uuid", "p_target_school_id" "uuid", "p_target_subject" character varying, "p_target_class" character varying, "p_target_academic_year" character varying, "p_created_by" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_assessment_restriction"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_assessment_restriction"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_assessment_restriction"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_faculty_leave_balances"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_faculty_leave_balances"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_faculty_leave_balances"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_index_if_not_exists"("p_index_name" "text", "p_table_name" "text", "p_definition" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."create_index_if_not_exists"("p_index_name" "text", "p_table_name" "text", "p_definition" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_index_if_not_exists"("p_index_name" "text", "p_table_name" "text", "p_definition" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_message_notification"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_message_notification"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_message_notification"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_notification_from_pipeline_activity"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_notification_from_pipeline_activity"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_notification_from_pipeline_activity"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_skills_from_external_course"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_skills_from_external_course"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_skills_from_external_course"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_skills_from_internal_course"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_skills_from_internal_course"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_skills_from_internal_course"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_student_with_user"("p_email" "text", "p_name" "text", "p_student_id" "text", "p_grade" "text", "p_school_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."create_student_with_user"("p_email" "text", "p_name" "text", "p_student_id" "text", "p_grade" "text", "p_school_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_student_with_user"("p_email" "text", "p_name" "text", "p_student_id" "text", "p_grade" "text", "p_school_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_swap_history_entry"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_swap_history_entry"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_swap_history_entry"() TO "service_role";



GRANT ALL ON FUNCTION "public"."curriculum_add_pending_change"("p_curriculum_id" "uuid", "p_change_type" "text", "p_entity_id" "uuid", "p_change_data" "jsonb", "p_message" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."curriculum_add_pending_change"("p_curriculum_id" "uuid", "p_change_type" "text", "p_entity_id" "uuid", "p_change_data" "jsonb", "p_message" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."curriculum_add_pending_change"("p_curriculum_id" "uuid", "p_change_type" "text", "p_entity_id" "uuid", "p_change_data" "jsonb", "p_message" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."curriculum_approve_pending_change"("p_curriculum_id" "uuid", "p_change_id" "uuid", "p_review_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."curriculum_approve_pending_change"("p_curriculum_id" "uuid", "p_change_id" "uuid", "p_review_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."curriculum_approve_pending_change"("p_curriculum_id" "uuid", "p_change_id" "uuid", "p_review_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."curriculum_reject_pending_change"("p_curriculum_id" "uuid", "p_change_id" "uuid", "p_review_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."curriculum_reject_pending_change"("p_curriculum_id" "uuid", "p_change_id" "uuid", "p_review_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."curriculum_reject_pending_change"("p_curriculum_id" "uuid", "p_change_id" "uuid", "p_review_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."decrement_applications_count"() TO "anon";
GRANT ALL ON FUNCTION "public"."decrement_applications_count"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."decrement_applications_count"() TO "service_role";



GRANT ALL ON FUNCTION "public"."delete_from_profile_array"("p_student_id" "uuid", "p_array_name" "text", "p_item_id" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."delete_from_profile_array"("p_student_id" "uuid", "p_array_name" "text", "p_item_id" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_from_profile_array"("p_student_id" "uuid", "p_array_name" "text", "p_item_id" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."detect_timetable_conflicts"("p_timetable_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."detect_timetable_conflicts"("p_timetable_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."detect_timetable_conflicts"("p_timetable_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."expire_old_subscriptions"() TO "anon";
GRANT ALL ON FUNCTION "public"."expire_old_subscriptions"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."expire_old_subscriptions"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_certificate_credential_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_certificate_credential_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_certificate_credential_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_enrollment_number"("p_school_id" "uuid", "p_academic_year" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."generate_enrollment_number"("p_school_id" "uuid", "p_academic_year" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_enrollment_number"("p_school_id" "uuid", "p_academic_year" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_student_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_student_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_student_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."generate_teacher_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."generate_teacher_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."generate_teacher_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."getActiveEnrollment"("p_studentId" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."getActiveEnrollment"("p_studentId" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."getActiveEnrollment"("p_studentId" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_active_subscription"("uid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_active_subscription"("uid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_active_subscription"("uid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_all_pending_changes_for_university"("p_university_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_all_pending_changes_for_university"("p_university_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_all_pending_changes_for_university"("p_university_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_approved_trainings_for_student"("student_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_approved_trainings_for_student"("student_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_approved_trainings_for_student"("student_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_available_questions"("p_grade_level" "public"."grade_level", "p_phase" "public"."test_phase", "p_difficulty" smallint, "p_subtag" "public"."question_subtag", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_available_questions"("p_grade_level" "public"."grade_level", "p_phase" "public"."test_phase", "p_difficulty" smallint, "p_subtag" "public"."question_subtag", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_available_questions"("p_grade_level" "public"."grade_level", "p_phase" "public"."test_phase", "p_difficulty" smallint, "p_subtag" "public"."question_subtag", "p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_cached_job_matches"("p_student_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_cached_job_matches"("p_student_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_cached_job_matches"("p_student_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_club_details"("p_club_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_club_details"("p_club_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_club_details"("p_club_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_college_admin_notifications"("admin_college_id" "uuid", "unread_only" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."get_college_admin_notifications"("admin_college_id" "uuid", "unread_only" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_college_admin_notifications"("admin_college_id" "uuid", "unread_only" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_college_admin_project_notifications"("admin_college_id" "uuid", "unread_only" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."get_college_admin_project_notifications"("admin_college_id" "uuid", "unread_only" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_college_admin_project_notifications"("admin_college_id" "uuid", "unread_only" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_college_educator_assignments"("educator_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_college_educator_assignments"("educator_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_college_educator_assignments"("educator_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_course_full_details"("course_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_course_full_details"("course_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_course_full_details"("course_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_current_academic_year"("p_school_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_current_academic_year"("p_school_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_current_academic_year"("p_school_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_embedding_queue_batch"("batch_size" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_embedding_queue_batch"("batch_size" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_embedding_queue_batch"("batch_size" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_embedding_queue_stats"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_embedding_queue_stats"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_embedding_queue_stats"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_embedding_stats"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_embedding_stats"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_embedding_stats"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_lecturer_details"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_lecturer_details"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_lecturer_details"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_or_create_college_educator_admin_conversation"("p_educator_id" "uuid", "p_college_id" "uuid", "p_subject" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_or_create_college_educator_admin_conversation"("p_educator_id" "uuid", "p_college_id" "uuid", "p_subject" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_or_create_college_educator_admin_conversation"("p_educator_id" "uuid", "p_college_id" "uuid", "p_subject" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_or_create_educator_admin_conversation"("p_educator_id" "uuid", "p_school_id" "uuid", "p_subject" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_or_create_educator_admin_conversation"("p_educator_id" "uuid", "p_school_id" "uuid", "p_subject" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_or_create_educator_admin_conversation"("p_educator_id" "uuid", "p_school_id" "uuid", "p_subject" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_or_create_student_admin_conversation"("p_student_id" "uuid", "p_school_id" "uuid", "p_subject" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_or_create_student_admin_conversation"("p_student_id" "uuid", "p_school_id" "uuid", "p_subject" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_or_create_student_admin_conversation"("p_student_id" "uuid", "p_school_id" "uuid", "p_subject" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_or_create_student_college_admin_conversation"("p_student_id" "uuid", "p_college_id" "uuid", "p_subject" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_or_create_student_college_admin_conversation"("p_student_id" "uuid", "p_college_id" "uuid", "p_subject" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_or_create_student_college_admin_conversation"("p_student_id" "uuid", "p_college_id" "uuid", "p_subject" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_or_create_student_educator_conversation"("p_student_id" "uuid", "p_educator_id" "uuid", "p_class_id" "uuid", "p_subject" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_or_create_student_educator_conversation"("p_student_id" "uuid", "p_educator_id" "uuid", "p_class_id" "uuid", "p_subject" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_or_create_student_educator_conversation"("p_student_id" "uuid", "p_educator_id" "uuid", "p_class_id" "uuid", "p_subject" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_changes"("p_curriculum_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_changes"("p_curriculum_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_changes"("p_curriculum_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_college_experiences"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_college_experiences"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_college_experiences"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_college_experiences"("p_admin_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_college_experiences"("p_admin_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_college_experiences"("p_admin_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_college_projects"("input_college_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_college_projects"("input_college_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_college_projects"("input_college_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_college_trainings"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_college_trainings"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_college_trainings"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_college_trainings"("p_admin_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_college_trainings"("p_admin_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_college_trainings"("p_admin_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_rareminds_trainings"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_rareminds_trainings"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_rareminds_trainings"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_school_experiences"("input_school_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_school_experiences"("input_school_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_school_experiences"("input_school_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_school_projects"("input_school_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_school_projects"("input_school_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_school_projects"("input_school_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_school_trainings"("input_school_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_school_trainings"("input_school_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_school_trainings"("input_school_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_pending_swap_count"("p_faculty_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_pending_swap_count"("p_faculty_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_pending_swap_count"("p_faculty_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_plan_features"("p_plan_code" "text", "p_limit" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_plan_features"("p_plan_code" "text", "p_limit" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_plan_features"("p_plan_code" "text", "p_limit" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_popular_opportunities"("student_id_param" "uuid", "limit_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_popular_opportunities"("student_id_param" "uuid", "limit_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_popular_opportunities"("student_id_param" "uuid", "limit_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_popular_opportunities_with_eligibility"("student_id_param" "uuid", "student_grade_param" "text", "student_course_param" "text", "student_type_param" "text", "limit_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_popular_opportunities_with_eligibility"("student_id_param" "uuid", "student_grade_param" "text", "student_course_param" "text", "student_type_param" "text", "limit_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_popular_opportunities_with_eligibility"("student_id_param" "uuid", "student_grade_param" "text", "student_course_param" "text", "student_type_param" "text", "limit_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_program_section_students"("section_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_program_section_students"("section_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_program_section_students"("section_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_scheduled_assessment_reminders"("days_ahead" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."get_scheduled_assessment_reminders"("days_ahead" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_scheduled_assessment_reminders"("days_ahead" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_school_admin_notifications"("admin_school_id" "uuid", "unread_only" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."get_school_admin_notifications"("admin_school_id" "uuid", "unread_only" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_school_admin_notifications"("admin_school_id" "uuid", "unread_only" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_school_admin_project_notifications"("admin_school_id" "uuid", "unread_only" boolean) TO "anon";
GRANT ALL ON FUNCTION "public"."get_school_admin_project_notifications"("admin_school_id" "uuid", "unread_only" boolean) TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_school_admin_project_notifications"("admin_school_id" "uuid", "unread_only" boolean) TO "service_role";



GRANT ALL ON FUNCTION "public"."get_student_academic_summary"("p_student_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_student_academic_summary"("p_student_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_student_academic_summary"("p_student_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_student_details"("p_user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_student_details"("p_user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_student_details"("p_user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_student_eligibility"("student_grade" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_student_eligibility"("student_grade" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_student_eligibility"("student_grade" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_student_stream_recommendation_data"("p_student_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_student_stream_recommendation_data"("p_student_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_student_stream_recommendation_data"("p_student_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_student_trainings_with_approvers"("student_email" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_student_trainings_with_approvers"("student_email" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_student_trainings_with_approvers"("student_email" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_students_needing_reminder"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_students_needing_reminder"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_students_needing_reminder"() TO "service_role";



GRANT ALL ON FUNCTION "public"."get_training_with_approver_details"("training_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_training_with_approver_details"("training_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_training_with_approver_details"("training_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_university_admins"("p_university_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_university_admins"("p_university_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_university_admins"("p_university_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_unread_notification_count"("admin_school_id" "uuid", "admin_college_id" "uuid", "admin_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_unread_notification_count"("admin_school_id" "uuid", "admin_college_id" "uuid", "admin_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_unread_notification_count"("admin_school_id" "uuid", "admin_college_id" "uuid", "admin_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_email"("user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_email"("user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_email"("user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."get_user_unread_count"("user_id" "text", "user_type" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."get_user_unread_count"("user_id" "text", "user_type" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_user_unread_count"("user_id" "text", "user_type" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_auth_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_auth_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_auth_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."has_advanced_skills"("skills_json" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."has_advanced_skills"("skills_json" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."has_advanced_skills"("skills_json" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."increment_applications_count"() TO "anon";
GRANT ALL ON FUNCTION "public"."increment_applications_count"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."increment_applications_count"() TO "service_role";



GRANT ALL ON FUNCTION "public"."increment_course_enrollment"("course_id_param" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."increment_course_enrollment"("course_id_param" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."increment_course_enrollment"("course_id_param" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."increment_search_usage"("search_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."increment_search_usage"("search_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."increment_search_usage"("search_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."initialize_student_streak"() TO "anon";
GRANT ALL ON FUNCTION "public"."initialize_student_streak"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."initialize_student_streak"() TO "service_role";



GRANT ALL ON FUNCTION "public"."invalidate_all_job_matches_on_opportunity_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."invalidate_all_job_matches_on_opportunity_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."invalidate_all_job_matches_on_opportunity_change"() TO "service_role";



GRANT ALL ON FUNCTION "public"."invalidate_job_matches_cache"() TO "anon";
GRANT ALL ON FUNCTION "public"."invalidate_job_matches_cache"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."invalidate_job_matches_cache"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_job_matches_cache_valid"("p_student_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_job_matches_cache_valid"("p_student_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_job_matches_cache_valid"("p_student_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_organization_admin"("user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_organization_admin"("user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_organization_admin"("user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_senior_level_job"("p_title" "text", "p_experience_level" "text", "p_experience_required" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."is_senior_level_job"("p_title" "text", "p_experience_level" "text", "p_experience_required" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_senior_level_job"("p_title" "text", "p_experience_level" "text", "p_experience_required" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_student_fresher"("p_student_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_student_fresher"("p_student_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_student_fresher"("p_student_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."is_subscription_active"("sub_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_subscription_active"("sub_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_subscription_active"("sub_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."log_notification_sent"("p_student_id" "uuid", "p_template_number" integer, "p_notification_type" character varying, "p_status" character varying, "p_error_message" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."log_notification_sent"("p_student_id" "uuid", "p_template_number" integer, "p_notification_type" character varying, "p_status" character varying, "p_error_message" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_notification_sent"("p_student_id" "uuid", "p_template_number" integer, "p_notification_type" character varying, "p_status" character varying, "p_error_message" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_conversation_as_read"("p_conversation_id" "text", "p_user_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_conversation_as_read"("p_conversation_id" "text", "p_user_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_conversation_as_read"("p_conversation_id" "text", "p_user_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_notification_read"("notification_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."mark_notification_read"("notification_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_notification_read"("notification_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."mark_previous_stream_reports_not_latest"() TO "anon";
GRANT ALL ON FUNCTION "public"."mark_previous_stream_reports_not_latest"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."mark_previous_stream_reports_not_latest"() TO "service_role";















GRANT ALL ON FUNCTION "public"."notify_admin_assessment_completion"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_admin_assessment_completion"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_admin_assessment_completion"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_admin_experience"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_admin_experience"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_admin_experience"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_admin_experience_submission"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_admin_experience_submission"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_admin_experience_submission"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_admin_on_experience_submission"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_admin_on_experience_submission"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_admin_on_experience_submission"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_admin_on_experience_submission_final"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_admin_on_experience_submission_final"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_admin_on_experience_submission_final"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_admin_on_submission"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_admin_on_submission"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_admin_on_submission"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_admin_training_submission"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_admin_training_submission"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_admin_training_submission"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_experience_approval"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_experience_approval"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_experience_approval"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_experience_student"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_experience_student"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_experience_student"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_experience_submission"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_experience_submission"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_experience_submission"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_project_approval"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_project_approval"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_project_approval"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_project_approval_unified"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_project_approval_unified"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_project_approval_unified"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_student_on_approval"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_student_on_approval"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_student_on_approval"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_student_on_approval_status_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_student_on_approval_status_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_student_on_approval_status_change"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_students_new_opportunity"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_students_new_opportunity"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_students_new_opportunity"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_students_opportunity_update"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_students_opportunity_update"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_students_opportunity_update"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_training_admin"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_training_admin"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_training_admin"() TO "service_role";



GRANT ALL ON FUNCTION "public"."notify_training_submission"() TO "anon";
GRANT ALL ON FUNCTION "public"."notify_training_submission"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."notify_training_submission"() TO "service_role";



GRANT ALL ON FUNCTION "public"."on_timetable_slot_change"() TO "anon";
GRANT ALL ON FUNCTION "public"."on_timetable_slot_change"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."on_timetable_slot_change"() TO "service_role";



GRANT ALL ON FUNCTION "public"."parse_experience_years"("experience_text" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."parse_experience_years"("experience_text" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."parse_experience_years"("experience_text" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."populate_chapter_name"() TO "anon";
GRANT ALL ON FUNCTION "public"."populate_chapter_name"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."populate_chapter_name"() TO "service_role";



GRANT ALL ON FUNCTION "public"."populate_result_columns_from_gemini"() TO "anon";
GRANT ALL ON FUNCTION "public"."populate_result_columns_from_gemini"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."populate_result_columns_from_gemini"() TO "service_role";



GRANT ALL ON FUNCTION "public"."process_assessment_reminders"() TO "anon";
GRANT ALL ON FUNCTION "public"."process_assessment_reminders"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_assessment_reminders"() TO "service_role";



GRANT ALL ON FUNCTION "public"."queue_embedding_generation"("p_record_id" "uuid", "p_table_name" "text", "p_operation" "text", "p_priority" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."queue_embedding_generation"("p_record_id" "uuid", "p_table_name" "text", "p_operation" "text", "p_priority" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."queue_embedding_generation"("p_record_id" "uuid", "p_table_name" "text", "p_operation" "text", "p_priority" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."reset_attempt_on_result_delete"() TO "anon";
GRANT ALL ON FUNCTION "public"."reset_attempt_on_result_delete"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."reset_attempt_on_result_delete"() TO "service_role";



GRANT ALL ON FUNCTION "public"."reset_daily_streak_flags"() TO "anon";
GRANT ALL ON FUNCTION "public"."reset_daily_streak_flags"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."reset_daily_streak_flags"() TO "service_role";



GRANT ALL ON FUNCTION "public"."reset_enrollment_progress"("p_student_email" "text", "p_course_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."reset_enrollment_progress"("p_student_email" "text", "p_course_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."reset_enrollment_progress"("p_student_email" "text", "p_course_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."reset_quiz_progress_on_enrollment_reset"() TO "anon";
GRANT ALL ON FUNCTION "public"."reset_quiz_progress_on_enrollment_reset"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."reset_quiz_progress_on_enrollment_reset"() TO "service_role";



GRANT ALL ON FUNCTION "public"."reset_unread_count"() TO "anon";
GRANT ALL ON FUNCTION "public"."reset_unread_count"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."reset_unread_count"() TO "service_role";



GRANT ALL ON FUNCTION "public"."review_curriculum"("p_curriculum_id" "uuid", "p_decision" "text", "p_notes" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."review_curriculum"("p_curriculum_id" "uuid", "p_decision" "text", "p_notes" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."review_curriculum"("p_curriculum_id" "uuid", "p_decision" "text", "p_notes" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."save_job_matches_cache"("p_student_id" "uuid", "p_matches" "jsonb", "p_algorithm_version" character varying) TO "anon";
GRANT ALL ON FUNCTION "public"."save_job_matches_cache"("p_student_id" "uuid", "p_matches" "jsonb", "p_algorithm_version" character varying) TO "authenticated";
GRANT ALL ON FUNCTION "public"."save_job_matches_cache"("p_student_id" "uuid", "p_matches" "jsonb", "p_algorithm_version" character varying) TO "service_role";



GRANT ALL ON FUNCTION "public"."schedule_assessment_reminder"() TO "anon";
GRANT ALL ON FUNCTION "public"."schedule_assessment_reminder"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."schedule_assessment_reminder"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_approval_authority"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_approval_authority"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_approval_authority"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_experience_approval_authority"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_experience_approval_authority"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_experience_approval_authority"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_experience_approval_authority_final"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_experience_approval_authority_final"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_experience_approval_authority_final"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_project_approval_authority"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_project_approval_authority"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_project_approval_authority"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_session_total_students"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_session_total_students"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_session_total_students"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_training_approval_authority"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_training_approval_authority"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_training_approval_authority"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_updated_at_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_updated_at_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_updated_at_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."submit_curriculum_for_approval"("p_curriculum_id" "uuid", "p_message" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."submit_curriculum_for_approval"("p_curriculum_id" "uuid", "p_message" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."submit_curriculum_for_approval"("p_curriculum_id" "uuid", "p_message" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_lecturer_record_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_lecturer_record_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_lecturer_record_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_pool_assigned_seats"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_pool_assigned_seats"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_pool_assigned_seats"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_student_record_id"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_student_record_id"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_student_record_id"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_training_from_enrollment"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_training_from_enrollment"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_training_from_enrollment"() TO "service_role";



GRANT ALL ON FUNCTION "public"."test_assessment_reminders"("student_uuid" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."test_assessment_reminders"("student_uuid" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."test_assessment_reminders"("student_uuid" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."test_outcome_approval_debug"("p_curriculum_id" "uuid", "p_change_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."test_outcome_approval_debug"("p_curriculum_id" "uuid", "p_change_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."test_outcome_approval_debug"("p_curriculum_id" "uuid", "p_change_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."toggle_save_job"("p_student_id" "uuid", "p_opportunity_id" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."toggle_save_job"("p_student_id" "uuid", "p_opportunity_id" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."toggle_save_job"("p_student_id" "uuid", "p_opportunity_id" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."track_profile_view"("p_student_id" "uuid", "p_viewer_type" "text", "p_viewer_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."track_profile_view"("p_student_id" "uuid", "p_viewer_type" "text", "p_viewer_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."track_profile_view"("p_student_id" "uuid", "p_viewer_type" "text", "p_viewer_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."transferStudent"("p_studentId" "uuid", "p_newEntityType" "text", "p_newEntityId" "uuid", "p_newClassId" "uuid", "p_transferReason" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."transferStudent"("p_studentId" "uuid", "p_newEntityType" "text", "p_newEntityId" "uuid", "p_newClassId" "uuid", "p_transferReason" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."transferStudent"("p_studentId" "uuid", "p_newEntityType" "text", "p_newEntityId" "uuid", "p_newClassId" "uuid", "p_transferReason" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_assignments_completion_fn"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_assignments_completion_fn"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_assignments_completion_fn"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_assignments_grade_pct_fn"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_assignments_grade_pct_fn"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_assignments_grade_pct_fn"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_assignments_updated_fn"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_assignments_updated_fn"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_assignments_updated_fn"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_college_assignments_updated_fn"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_college_assignments_updated_fn"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_college_assignments_updated_fn"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_college_student_assignments_grade_pct_fn"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_college_student_assignments_grade_pct_fn"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_college_student_assignments_grade_pct_fn"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_college_student_assignments_late_check_fn"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_college_student_assignments_late_check_fn"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_college_student_assignments_late_check_fn"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_college_student_assignments_status_fn"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_college_student_assignments_status_fn"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_college_student_assignments_status_fn"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_college_student_assignments_updated_fn"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_college_student_assignments_updated_fn"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_college_student_assignments_updated_fn"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_insert_recent_update"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_insert_recent_update"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_insert_recent_update"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_student_assignments_grade_pct_fn"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_student_assignments_grade_pct_fn"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_student_assignments_grade_pct_fn"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_student_assignments_late_check_fn"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_student_assignments_late_check_fn"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_student_assignments_late_check_fn"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_student_assignments_status_fn"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_student_assignments_status_fn"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_student_assignments_status_fn"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trg_student_assignments_updated_fn"() TO "anon";
GRANT ALL ON FUNCTION "public"."trg_student_assignments_updated_fn"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trg_student_assignments_updated_fn"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_course_embedding_queue"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_course_embedding_queue"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_course_embedding_queue"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_enrollment_completion_embedding"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_enrollment_completion_embedding"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_enrollment_completion_embedding"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_entity_embedding_generation"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_entity_embedding_generation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_entity_embedding_generation"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_opportunity_embedding"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_opportunity_embedding"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_opportunity_embedding"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_opportunity_embedding_queue"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_opportunity_embedding_queue"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_opportunity_embedding_queue"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_profile_update"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_profile_update"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_profile_update"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_related_student_embedding"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_related_student_embedding"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_related_student_embedding"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_skills_improvement"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_skills_improvement"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_skills_improvement"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_student_embedding_queue"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_student_embedding_queue"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_student_embedding_queue"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_training_completion"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_training_completion"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_training_completion"() TO "service_role";



GRANT ALL ON FUNCTION "public"."trigger_validate_aadhar"() TO "anon";
GRANT ALL ON FUNCTION "public"."trigger_validate_aadhar"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."trigger_validate_aadhar"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_adaptive_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_adaptive_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_adaptive_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_applied_jobs_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_applied_jobs_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_applied_jobs_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_book_availability"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_book_availability"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_book_availability"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_book_availability_college"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_book_availability_college"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_book_availability_college"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_book_availability_on_issue"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_book_availability_on_issue"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_book_availability_on_issue"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_book_availability_on_return"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_book_availability_on_return"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_book_availability_on_return"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_book_availability_school"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_book_availability_school"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_book_availability_school"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_book_rating"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_book_rating"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_book_rating"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_budget_on_expenditure"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_budget_on_expenditure"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_budget_on_expenditure"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_certificates_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_certificates_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_certificates_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_college_circulars_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_college_circulars_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_college_circulars_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_college_events_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_college_events_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_college_events_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_college_lesson_plans_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_college_lesson_plans_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_college_lesson_plans_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_conversation_on_message"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_conversation_on_message"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_conversation_on_message"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_conversation_unread_count"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_conversation_unread_count"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_conversation_unread_count"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_curriculum_last_modified"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_curriculum_last_modified"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_curriculum_last_modified"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_departments_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_departments_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_departments_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_email_tracking_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_email_tracking_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_email_tracking_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_external_assessment_attempts_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_external_assessment_attempts_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_external_assessment_attempts_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_grade_on_program_mapping"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_grade_on_program_mapping"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_grade_on_program_mapping"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_ledger_overdue_status"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_ledger_overdue_status"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_ledger_overdue_status"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_license_assignments_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_license_assignments_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_license_assignments_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_license_pools_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_license_pools_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_license_pools_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_membership_attendance"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_membership_attendance"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_membership_attendance"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_mentor_note_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_mentor_note_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_mentor_note_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_organization_invitations_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_organization_invitations_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_organization_invitations_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_organization_subscriptions_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_organization_subscriptions_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_organization_subscriptions_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_phone_otps_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_phone_otps_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_phone_otps_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_profile_array_item"("p_student_id" "uuid", "p_array_name" "text", "p_item_id" integer, "p_updates" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."update_profile_array_item"("p_student_id" "uuid", "p_array_name" "text", "p_item_id" integer, "p_updates" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_profile_array_item"("p_student_id" "uuid", "p_array_name" "text", "p_item_id" integer, "p_updates" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_question_usage"("p_question_id" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."update_question_usage"("p_question_id" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_question_usage"("p_question_id" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_saved_jobs_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_saved_jobs_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_saved_jobs_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_section_enrollment_count"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_section_enrollment_count"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_section_enrollment_count"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_session_attendance_stats"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_session_attendance_stats"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_session_attendance_stats"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_streak_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_streak_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_streak_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_student_course_progress_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_student_course_progress_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_student_course_progress_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_student_grade_on_promotion"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_student_grade_on_promotion"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_student_grade_on_promotion"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_student_promotions_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_student_promotions_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_student_promotions_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_student_streak"("p_student_id" "uuid", "p_activity_date" "date") TO "anon";
GRANT ALL ON FUNCTION "public"."update_student_streak"("p_student_id" "uuid", "p_activity_date" "date") TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_student_streak"("p_student_id" "uuid", "p_activity_date" "date") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_students_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_students_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_students_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_subscription_plans_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_subscription_plans_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_subscription_plans_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_swap_request_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_swap_request_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_swap_request_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_timestamp"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_timestamp"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_timestamp"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_tutor_conversations_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_tutor_conversations_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_tutor_conversations_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";



GRANT ALL ON FUNCTION "public"."user_has_license_for_org_subscription"("org_sub_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."user_has_license_for_org_subscription"("org_sub_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."user_has_license_for_org_subscription"("org_sub_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."validateOneActiveEnrollment"() TO "anon";
GRANT ALL ON FUNCTION "public"."validateOneActiveEnrollment"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."validateOneActiveEnrollment"() TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_aadhar_number"("aadhar_num" "text") TO "anon";
GRANT ALL ON FUNCTION "public"."validate_aadhar_number"("aadhar_num" "text") TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_aadhar_number"("aadhar_num" "text") TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_curriculum"("p_curriculum_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."validate_curriculum"("p_curriculum_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_curriculum"("p_curriculum_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_evaluation_items"() TO "anon";
GRANT ALL ON FUNCTION "public"."validate_evaluation_items"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_evaluation_items"() TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_pool_allocation"() TO "anon";
GRANT ALL ON FUNCTION "public"."validate_pool_allocation"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_pool_allocation"() TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_seat_availability"() TO "anon";
GRANT ALL ON FUNCTION "public"."validate_seat_availability"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_seat_availability"() TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_student_competition_school"() TO "anon";
GRANT ALL ON FUNCTION "public"."validate_student_competition_school"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_student_competition_school"() TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_student_school_match"() TO "anon";
GRANT ALL ON FUNCTION "public"."validate_student_school_match"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_student_school_match"() TO "service_role";



GRANT ALL ON FUNCTION "public"."validate_subscription_status_transition"() TO "anon";
GRANT ALL ON FUNCTION "public"."validate_subscription_status_transition"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."validate_subscription_status_transition"() TO "service_role";




































GRANT ALL ON TABLE "public"."adaptive_aptitude_questions_cache" TO "anon";
GRANT ALL ON TABLE "public"."adaptive_aptitude_questions_cache" TO "authenticated";
GRANT ALL ON TABLE "public"."adaptive_aptitude_questions_cache" TO "service_role";



GRANT ALL ON TABLE "public"."adaptive_aptitude_responses" TO "anon";
GRANT ALL ON TABLE "public"."adaptive_aptitude_responses" TO "authenticated";
GRANT ALL ON TABLE "public"."adaptive_aptitude_responses" TO "service_role";



GRANT ALL ON TABLE "public"."adaptive_aptitude_results" TO "anon";
GRANT ALL ON TABLE "public"."adaptive_aptitude_results" TO "authenticated";
GRANT ALL ON TABLE "public"."adaptive_aptitude_results" TO "service_role";



GRANT ALL ON TABLE "public"."adaptive_aptitude_sessions" TO "anon";
GRANT ALL ON TABLE "public"."adaptive_aptitude_sessions" TO "authenticated";
GRANT ALL ON TABLE "public"."adaptive_aptitude_sessions" TO "service_role";



GRANT ALL ON TABLE "public"."addon_discount_codes" TO "anon";
GRANT ALL ON TABLE "public"."addon_discount_codes" TO "authenticated";
GRANT ALL ON TABLE "public"."addon_discount_codes" TO "service_role";



GRANT ALL ON TABLE "public"."addon_events" TO "anon";
GRANT ALL ON TABLE "public"."addon_events" TO "authenticated";
GRANT ALL ON TABLE "public"."addon_events" TO "service_role";



GRANT ALL ON TABLE "public"."addon_pending_orders" TO "anon";
GRANT ALL ON TABLE "public"."addon_pending_orders" TO "authenticated";
GRANT ALL ON TABLE "public"."addon_pending_orders" TO "service_role";



GRANT ALL ON TABLE "public"."admin_users" TO "anon";
GRANT ALL ON TABLE "public"."admin_users" TO "authenticated";
GRANT ALL ON TABLE "public"."admin_users" TO "service_role";



GRANT ALL ON TABLE "public"."admission_applications" TO "anon";
GRANT ALL ON TABLE "public"."admission_applications" TO "authenticated";
GRANT ALL ON TABLE "public"."admission_applications" TO "service_role";



GRANT ALL ON TABLE "public"."ai_evaluations" TO "anon";
GRANT ALL ON TABLE "public"."ai_evaluations" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_evaluations" TO "service_role";



GRANT ALL ON TABLE "public"."app_config" TO "anon";
GRANT ALL ON TABLE "public"."app_config" TO "authenticated";
GRANT ALL ON TABLE "public"."app_config" TO "service_role";



GRANT ALL ON TABLE "public"."applied_jobs" TO "anon";
GRANT ALL ON TABLE "public"."applied_jobs" TO "authenticated";
GRANT ALL ON TABLE "public"."applied_jobs" TO "service_role";



GRANT ALL ON TABLE "public"."applied_jobs_backup_migration" TO "anon";
GRANT ALL ON TABLE "public"."applied_jobs_backup_migration" TO "authenticated";
GRANT ALL ON TABLE "public"."applied_jobs_backup_migration" TO "service_role";



GRANT ALL ON TABLE "public"."approval_actions" TO "anon";
GRANT ALL ON TABLE "public"."approval_actions" TO "authenticated";
GRANT ALL ON TABLE "public"."approval_actions" TO "service_role";



GRANT ALL ON TABLE "public"."approval_requests" TO "anon";
GRANT ALL ON TABLE "public"."approval_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."approval_requests" TO "service_role";



GRANT ALL ON TABLE "public"."approval_types" TO "anon";
GRANT ALL ON TABLE "public"."approval_types" TO "authenticated";
GRANT ALL ON TABLE "public"."approval_types" TO "service_role";



GRANT ALL ON TABLE "public"."approval_workflows" TO "anon";
GRANT ALL ON TABLE "public"."approval_workflows" TO "authenticated";
GRANT ALL ON TABLE "public"."approval_workflows" TO "service_role";



GRANT ALL ON TABLE "public"."assessment_types" TO "anon";
GRANT ALL ON TABLE "public"."assessment_types" TO "authenticated";
GRANT ALL ON TABLE "public"."assessment_types" TO "service_role";



GRANT ALL ON TABLE "public"."assessments" TO "anon";
GRANT ALL ON TABLE "public"."assessments" TO "authenticated";
GRANT ALL ON TABLE "public"."assessments" TO "service_role";



GRANT ALL ON TABLE "public"."assignment_attachments" TO "anon";
GRANT ALL ON TABLE "public"."assignment_attachments" TO "authenticated";
GRANT ALL ON TABLE "public"."assignment_attachments" TO "service_role";



GRANT ALL ON TABLE "public"."assignments" TO "anon";
GRANT ALL ON TABLE "public"."assignments" TO "authenticated";
GRANT ALL ON TABLE "public"."assignments" TO "service_role";



GRANT ALL ON TABLE "public"."attendance_alerts" TO "anon";
GRANT ALL ON TABLE "public"."attendance_alerts" TO "authenticated";
GRANT ALL ON TABLE "public"."attendance_alerts" TO "service_role";



GRANT ALL ON TABLE "public"."attendance_records" TO "anon";
GRANT ALL ON TABLE "public"."attendance_records" TO "authenticated";
GRANT ALL ON TABLE "public"."attendance_records" TO "service_role";



GRANT ALL ON TABLE "public"."audit_logs" TO "anon";
GRANT ALL ON TABLE "public"."audit_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."audit_logs" TO "service_role";



GRANT ALL ON TABLE "public"."budget_alerts" TO "anon";
GRANT ALL ON TABLE "public"."budget_alerts" TO "authenticated";
GRANT ALL ON TABLE "public"."budget_alerts" TO "service_role";



GRANT ALL ON TABLE "public"."budget_revisions" TO "anon";
GRANT ALL ON TABLE "public"."budget_revisions" TO "authenticated";
GRANT ALL ON TABLE "public"."budget_revisions" TO "service_role";



GRANT ALL ON TABLE "public"."bundle_features" TO "anon";
GRANT ALL ON TABLE "public"."bundle_features" TO "authenticated";
GRANT ALL ON TABLE "public"."bundle_features" TO "service_role";



GRANT ALL ON TABLE "public"."bundles" TO "anon";
GRANT ALL ON TABLE "public"."bundles" TO "authenticated";
GRANT ALL ON TABLE "public"."bundles" TO "service_role";



GRANT ALL ON TABLE "public"."career_ai_conversations" TO "anon";
GRANT ALL ON TABLE "public"."career_ai_conversations" TO "authenticated";
GRANT ALL ON TABLE "public"."career_ai_conversations" TO "service_role";



GRANT ALL ON TABLE "public"."career_assessment_ai_questions" TO "anon";
GRANT ALL ON TABLE "public"."career_assessment_ai_questions" TO "authenticated";
GRANT ALL ON TABLE "public"."career_assessment_ai_questions" TO "service_role";



GRANT ALL ON TABLE "public"."chapter_details" TO "anon";
GRANT ALL ON TABLE "public"."chapter_details" TO "authenticated";
GRANT ALL ON TABLE "public"."chapter_details" TO "service_role";



GRANT ALL ON TABLE "public"."class_swap_history" TO "anon";
GRANT ALL ON TABLE "public"."class_swap_history" TO "authenticated";
GRANT ALL ON TABLE "public"."class_swap_history" TO "service_role";



GRANT ALL ON TABLE "public"."class_swap_requests" TO "anon";
GRANT ALL ON TABLE "public"."class_swap_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."class_swap_requests" TO "service_role";



GRANT ALL ON TABLE "public"."club_activities" TO "anon";
GRANT ALL ON TABLE "public"."club_activities" TO "authenticated";
GRANT ALL ON TABLE "public"."club_activities" TO "service_role";



GRANT ALL ON TABLE "public"."club_attendance" TO "anon";
GRANT ALL ON TABLE "public"."club_attendance" TO "authenticated";
GRANT ALL ON TABLE "public"."club_attendance" TO "service_role";



GRANT ALL ON TABLE "public"."club_attendance_records" TO "anon";
GRANT ALL ON TABLE "public"."club_attendance_records" TO "authenticated";
GRANT ALL ON TABLE "public"."club_attendance_records" TO "service_role";



GRANT ALL ON TABLE "public"."club_certificates" TO "anon";
GRANT ALL ON TABLE "public"."club_certificates" TO "authenticated";
GRANT ALL ON TABLE "public"."club_certificates" TO "service_role";



GRANT ALL ON TABLE "public"."club_memberships" TO "anon";
GRANT ALL ON TABLE "public"."club_memberships" TO "authenticated";
GRANT ALL ON TABLE "public"."club_memberships" TO "service_role";



GRANT ALL ON TABLE "public"."clubs" TO "anon";
GRANT ALL ON TABLE "public"."clubs" TO "authenticated";
GRANT ALL ON TABLE "public"."clubs" TO "service_role";



GRANT ALL ON TABLE "public"."students" TO "anon";
GRANT ALL ON TABLE "public"."students" TO "authenticated";
GRANT ALL ON TABLE "public"."students" TO "service_role";



GRANT ALL ON TABLE "public"."club_participation_report" TO "anon";
GRANT ALL ON TABLE "public"."club_participation_report" TO "authenticated";
GRANT ALL ON TABLE "public"."club_participation_report" TO "service_role";



GRANT ALL ON TABLE "public"."college_assignment_attachments" TO "anon";
GRANT ALL ON TABLE "public"."college_assignment_attachments" TO "authenticated";
GRANT ALL ON TABLE "public"."college_assignment_attachments" TO "service_role";



GRANT ALL ON TABLE "public"."college_assignments" TO "anon";
GRANT ALL ON TABLE "public"."college_assignments" TO "authenticated";
GRANT ALL ON TABLE "public"."college_assignments" TO "service_role";



GRANT ALL ON TABLE "public"."college_assignments_view" TO "anon";
GRANT ALL ON TABLE "public"."college_assignments_view" TO "authenticated";
GRANT ALL ON TABLE "public"."college_assignments_view" TO "service_role";



GRANT ALL ON TABLE "public"."college_attendance_records" TO "anon";
GRANT ALL ON TABLE "public"."college_attendance_records" TO "authenticated";
GRANT ALL ON TABLE "public"."college_attendance_records" TO "service_role";



GRANT ALL ON TABLE "public"."college_attendance_sessions" TO "anon";
GRANT ALL ON TABLE "public"."college_attendance_sessions" TO "authenticated";
GRANT ALL ON TABLE "public"."college_attendance_sessions" TO "service_role";



GRANT ALL ON TABLE "public"."college_attendance_settings" TO "anon";
GRANT ALL ON TABLE "public"."college_attendance_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."college_attendance_settings" TO "service_role";



GRANT ALL ON TABLE "public"."college_breaks" TO "anon";
GRANT ALL ON TABLE "public"."college_breaks" TO "authenticated";
GRANT ALL ON TABLE "public"."college_breaks" TO "service_role";



GRANT ALL ON TABLE "public"."college_circulars" TO "anon";
GRANT ALL ON TABLE "public"."college_circulars" TO "authenticated";
GRANT ALL ON TABLE "public"."college_circulars" TO "service_role";



GRANT ALL ON TABLE "public"."college_classes" TO "anon";
GRANT ALL ON TABLE "public"."college_classes" TO "authenticated";
GRANT ALL ON TABLE "public"."college_classes" TO "service_role";



GRANT ALL ON TABLE "public"."college_course_mappings" TO "anon";
GRANT ALL ON TABLE "public"."college_course_mappings" TO "authenticated";
GRANT ALL ON TABLE "public"."college_course_mappings" TO "service_role";



GRANT ALL ON TABLE "public"."college_courses" TO "anon";
GRANT ALL ON TABLE "public"."college_courses" TO "authenticated";
GRANT ALL ON TABLE "public"."college_courses" TO "service_role";



GRANT ALL ON TABLE "public"."college_curriculum_outcomes" TO "anon";
GRANT ALL ON TABLE "public"."college_curriculum_outcomes" TO "authenticated";
GRANT ALL ON TABLE "public"."college_curriculum_outcomes" TO "service_role";



GRANT ALL ON TABLE "public"."college_curriculums" TO "anon";
GRANT ALL ON TABLE "public"."college_curriculums" TO "authenticated";
GRANT ALL ON TABLE "public"."college_curriculums" TO "service_role";



GRANT ALL ON TABLE "public"."departments" TO "anon";
GRANT ALL ON TABLE "public"."departments" TO "authenticated";
GRANT ALL ON TABLE "public"."departments" TO "service_role";



GRANT ALL ON TABLE "public"."organizations" TO "anon";
GRANT ALL ON TABLE "public"."organizations" TO "authenticated";
GRANT ALL ON TABLE "public"."organizations" TO "service_role";



GRANT ALL ON TABLE "public"."programs" TO "anon";
GRANT ALL ON TABLE "public"."programs" TO "authenticated";
GRANT ALL ON TABLE "public"."programs" TO "service_role";



GRANT ALL ON TABLE "public"."university_colleges" TO "anon";
GRANT ALL ON TABLE "public"."university_colleges" TO "authenticated";
GRANT ALL ON TABLE "public"."university_colleges" TO "service_role";



GRANT ALL ON TABLE "public"."college_curriculum_status" TO "anon";
GRANT ALL ON TABLE "public"."college_curriculum_status" TO "authenticated";
GRANT ALL ON TABLE "public"."college_curriculum_status" TO "service_role";



GRANT ALL ON TABLE "public"."college_curriculum_units" TO "anon";
GRANT ALL ON TABLE "public"."college_curriculum_units" TO "authenticated";
GRANT ALL ON TABLE "public"."college_curriculum_units" TO "service_role";



GRANT ALL ON TABLE "public"."college_daily_attendance_summary" TO "anon";
GRANT ALL ON TABLE "public"."college_daily_attendance_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."college_daily_attendance_summary" TO "service_role";



GRANT ALL ON TABLE "public"."college_event_registrations" TO "anon";
GRANT ALL ON TABLE "public"."college_event_registrations" TO "authenticated";
GRANT ALL ON TABLE "public"."college_event_registrations" TO "service_role";



GRANT ALL ON TABLE "public"."college_events" TO "anon";
GRANT ALL ON TABLE "public"."college_events" TO "authenticated";
GRANT ALL ON TABLE "public"."college_events" TO "service_role";



GRANT ALL ON TABLE "public"."college_faculty_class_assignments" TO "anon";
GRANT ALL ON TABLE "public"."college_faculty_class_assignments" TO "authenticated";
GRANT ALL ON TABLE "public"."college_faculty_class_assignments" TO "service_role";



GRANT ALL ON TABLE "public"."college_faculty_leave_balances" TO "anon";
GRANT ALL ON TABLE "public"."college_faculty_leave_balances" TO "authenticated";
GRANT ALL ON TABLE "public"."college_faculty_leave_balances" TO "service_role";



GRANT ALL ON TABLE "public"."college_faculty_leaves" TO "anon";
GRANT ALL ON TABLE "public"."college_faculty_leaves" TO "authenticated";
GRANT ALL ON TABLE "public"."college_faculty_leaves" TO "service_role";



GRANT ALL ON TABLE "public"."college_faculty_substitutions" TO "anon";
GRANT ALL ON TABLE "public"."college_faculty_substitutions" TO "authenticated";
GRANT ALL ON TABLE "public"."college_faculty_substitutions" TO "service_role";



GRANT ALL ON TABLE "public"."college_leave_types" TO "anon";
GRANT ALL ON TABLE "public"."college_leave_types" TO "authenticated";
GRANT ALL ON TABLE "public"."college_leave_types" TO "service_role";



GRANT ALL ON TABLE "public"."college_lecturer_course_assignments" TO "anon";
GRANT ALL ON TABLE "public"."college_lecturer_course_assignments" TO "authenticated";
GRANT ALL ON TABLE "public"."college_lecturer_course_assignments" TO "service_role";



GRANT ALL ON TABLE "public"."college_lecturers" TO "anon";
GRANT ALL ON TABLE "public"."college_lecturers" TO "authenticated";
GRANT ALL ON TABLE "public"."college_lecturers" TO "service_role";



GRANT ALL ON TABLE "public"."college_lecturers_backup" TO "anon";
GRANT ALL ON TABLE "public"."college_lecturers_backup" TO "authenticated";
GRANT ALL ON TABLE "public"."college_lecturers_backup" TO "service_role";



GRANT ALL ON TABLE "public"."college_lesson_plans" TO "anon";
GRANT ALL ON TABLE "public"."college_lesson_plans" TO "authenticated";
GRANT ALL ON TABLE "public"."college_lesson_plans" TO "service_role";



GRANT ALL ON TABLE "public"."college_mentor_notes" TO "anon";
GRANT ALL ON TABLE "public"."college_mentor_notes" TO "authenticated";
GRANT ALL ON TABLE "public"."college_mentor_notes" TO "service_role";



GRANT ALL ON TABLE "public"."college_mentor_periods" TO "anon";
GRANT ALL ON TABLE "public"."college_mentor_periods" TO "authenticated";
GRANT ALL ON TABLE "public"."college_mentor_periods" TO "service_role";



GRANT ALL ON TABLE "public"."college_mentor_student_allocations" TO "anon";
GRANT ALL ON TABLE "public"."college_mentor_student_allocations" TO "authenticated";
GRANT ALL ON TABLE "public"."college_mentor_student_allocations" TO "service_role";



GRANT ALL ON TABLE "public"."college_role_module_permissions" TO "anon";
GRANT ALL ON TABLE "public"."college_role_module_permissions" TO "authenticated";
GRANT ALL ON TABLE "public"."college_role_module_permissions" TO "service_role";



GRANT ALL ON TABLE "public"."college_role_scope_rules" TO "anon";
GRANT ALL ON TABLE "public"."college_role_scope_rules" TO "authenticated";
GRANT ALL ON TABLE "public"."college_role_scope_rules" TO "service_role";



GRANT ALL ON TABLE "public"."college_setting_modules" TO "anon";
GRANT ALL ON TABLE "public"."college_setting_modules" TO "authenticated";
GRANT ALL ON TABLE "public"."college_setting_modules" TO "service_role";



GRANT ALL ON TABLE "public"."college_setting_permissions" TO "anon";
GRANT ALL ON TABLE "public"."college_setting_permissions" TO "authenticated";
GRANT ALL ON TABLE "public"."college_setting_permissions" TO "service_role";



GRANT ALL ON TABLE "public"."college_student_assignments" TO "anon";
GRANT ALL ON TABLE "public"."college_student_assignments" TO "authenticated";
GRANT ALL ON TABLE "public"."college_student_assignments" TO "service_role";



GRANT ALL ON TABLE "public"."college_student_attendance_stats" TO "anon";
GRANT ALL ON TABLE "public"."college_student_attendance_stats" TO "authenticated";
GRANT ALL ON TABLE "public"."college_student_attendance_stats" TO "service_role";



GRANT ALL ON TABLE "public"."college_subject_attendance_summary" TO "anon";
GRANT ALL ON TABLE "public"."college_subject_attendance_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."college_subject_attendance_summary" TO "service_role";



GRANT ALL ON TABLE "public"."college_time_periods" TO "anon";
GRANT ALL ON TABLE "public"."college_time_periods" TO "authenticated";
GRANT ALL ON TABLE "public"."college_time_periods" TO "service_role";



GRANT ALL ON TABLE "public"."college_timetable_slots" TO "anon";
GRANT ALL ON TABLE "public"."college_timetable_slots" TO "authenticated";
GRANT ALL ON TABLE "public"."college_timetable_slots" TO "service_role";



GRANT ALL ON TABLE "public"."college_timetables" TO "anon";
GRANT ALL ON TABLE "public"."college_timetables" TO "authenticated";
GRANT ALL ON TABLE "public"."college_timetables" TO "service_role";



GRANT ALL ON TABLE "public"."companies" TO "anon";
GRANT ALL ON TABLE "public"."companies" TO "authenticated";
GRANT ALL ON TABLE "public"."companies" TO "service_role";



GRANT ALL ON TABLE "public"."company_branches" TO "anon";
GRANT ALL ON TABLE "public"."company_branches" TO "authenticated";
GRANT ALL ON TABLE "public"."company_branches" TO "service_role";



GRANT ALL ON TABLE "public"."competition_clubs" TO "anon";
GRANT ALL ON TABLE "public"."competition_clubs" TO "authenticated";
GRANT ALL ON TABLE "public"."competition_clubs" TO "service_role";



GRANT ALL ON TABLE "public"."competition_results" TO "anon";
GRANT ALL ON TABLE "public"."competition_results" TO "authenticated";
GRANT ALL ON TABLE "public"."competition_results" TO "service_role";



GRANT ALL ON TABLE "public"."competitions" TO "anon";
GRANT ALL ON TABLE "public"."competitions" TO "authenticated";
GRANT ALL ON TABLE "public"."competitions" TO "service_role";



GRANT ALL ON TABLE "public"."competition_performance_report" TO "anon";
GRANT ALL ON TABLE "public"."competition_performance_report" TO "authenticated";
GRANT ALL ON TABLE "public"."competition_performance_report" TO "service_role";



GRANT ALL ON TABLE "public"."competition_registrations" TO "anon";
GRANT ALL ON TABLE "public"."competition_registrations" TO "authenticated";
GRANT ALL ON TABLE "public"."competition_registrations" TO "service_role";



GRANT ALL ON TABLE "public"."competition_results_with_students" TO "anon";
GRANT ALL ON TABLE "public"."competition_results_with_students" TO "authenticated";
GRANT ALL ON TABLE "public"."competition_results_with_students" TO "service_role";



GRANT ALL ON TABLE "public"."conversations" TO "anon";
GRANT ALL ON TABLE "public"."conversations" TO "authenticated";
GRANT ALL ON TABLE "public"."conversations" TO "service_role";



GRANT ALL ON TABLE "public"."conversations_backup_20251106" TO "anon";
GRANT ALL ON TABLE "public"."conversations_backup_20251106" TO "authenticated";
GRANT ALL ON TABLE "public"."conversations_backup_20251106" TO "service_role";



GRANT ALL ON TABLE "public"."opportunities" TO "anon";
GRANT ALL ON TABLE "public"."opportunities" TO "authenticated";
GRANT ALL ON TABLE "public"."opportunities" TO "service_role";



GRANT ALL ON TABLE "public"."recruiters" TO "anon";
GRANT ALL ON TABLE "public"."recruiters" TO "authenticated";
GRANT ALL ON TABLE "public"."recruiters" TO "service_role";



GRANT ALL ON TABLE "public"."conversations_detailed" TO "anon";
GRANT ALL ON TABLE "public"."conversations_detailed" TO "authenticated";
GRANT ALL ON TABLE "public"."conversations_detailed" TO "service_role";



GRANT ALL ON TABLE "public"."course_classes" TO "anon";
GRANT ALL ON TABLE "public"."course_classes" TO "authenticated";
GRANT ALL ON TABLE "public"."course_classes" TO "service_role";



GRANT ALL ON TABLE "public"."course_co_educators" TO "anon";
GRANT ALL ON TABLE "public"."course_co_educators" TO "authenticated";
GRANT ALL ON TABLE "public"."course_co_educators" TO "service_role";



GRANT ALL ON TABLE "public"."course_modules" TO "anon";
GRANT ALL ON TABLE "public"."course_modules" TO "authenticated";
GRANT ALL ON TABLE "public"."course_modules" TO "service_role";



GRANT ALL ON TABLE "public"."course_skills" TO "anon";
GRANT ALL ON TABLE "public"."course_skills" TO "authenticated";
GRANT ALL ON TABLE "public"."course_skills" TO "service_role";



GRANT ALL ON TABLE "public"."course_summary" TO "anon";
GRANT ALL ON TABLE "public"."course_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."course_summary" TO "service_role";



GRANT ALL ON TABLE "public"."courses" TO "anon";
GRANT ALL ON TABLE "public"."courses" TO "authenticated";
GRANT ALL ON TABLE "public"."courses" TO "service_role";



GRANT ALL ON TABLE "public"."curriculum_academic_years" TO "anon";
GRANT ALL ON TABLE "public"."curriculum_academic_years" TO "authenticated";
GRANT ALL ON TABLE "public"."curriculum_academic_years" TO "service_role";



GRANT ALL ON TABLE "public"."users" TO "anon";
GRANT ALL ON TABLE "public"."users" TO "authenticated";
GRANT ALL ON TABLE "public"."users" TO "service_role";
GRANT SELECT,INSERT ON TABLE "public"."users" TO "supabase_auth_admin";



GRANT ALL ON TABLE "public"."curriculum_approval_dashboard" TO "anon";
GRANT ALL ON TABLE "public"."curriculum_approval_dashboard" TO "authenticated";
GRANT ALL ON TABLE "public"."curriculum_approval_dashboard" TO "service_role";



GRANT ALL ON TABLE "public"."curriculum_chapters" TO "anon";
GRANT ALL ON TABLE "public"."curriculum_chapters" TO "authenticated";
GRANT ALL ON TABLE "public"."curriculum_chapters" TO "service_role";



GRANT ALL ON TABLE "public"."curriculum_classes" TO "anon";
GRANT ALL ON TABLE "public"."curriculum_classes" TO "authenticated";
GRANT ALL ON TABLE "public"."curriculum_classes" TO "service_role";



GRANT ALL ON TABLE "public"."curriculum_courses" TO "anon";
GRANT ALL ON TABLE "public"."curriculum_courses" TO "authenticated";
GRANT ALL ON TABLE "public"."curriculum_courses" TO "service_role";



GRANT ALL ON TABLE "public"."curriculum_learning_outcomes" TO "anon";
GRANT ALL ON TABLE "public"."curriculum_learning_outcomes" TO "authenticated";
GRANT ALL ON TABLE "public"."curriculum_learning_outcomes" TO "service_role";



GRANT ALL ON TABLE "public"."curriculum_subjects" TO "anon";
GRANT ALL ON TABLE "public"."curriculum_subjects" TO "authenticated";
GRANT ALL ON TABLE "public"."curriculum_subjects" TO "service_role";



GRANT ALL ON TABLE "public"."curriculum_summary" TO "anon";
GRANT ALL ON TABLE "public"."curriculum_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."curriculum_summary" TO "service_role";



GRANT ALL ON TABLE "public"."curriculums" TO "anon";
GRANT ALL ON TABLE "public"."curriculums" TO "authenticated";
GRANT ALL ON TABLE "public"."curriculums" TO "service_role";



GRANT ALL ON TABLE "public"."department_budgets" TO "anon";
GRANT ALL ON TABLE "public"."department_budgets" TO "authenticated";
GRANT ALL ON TABLE "public"."department_budgets" TO "service_role";



GRANT ALL ON TABLE "public"."department_faculty_assignments" TO "anon";
GRANT ALL ON TABLE "public"."department_faculty_assignments" TO "authenticated";
GRANT ALL ON TABLE "public"."department_faculty_assignments" TO "service_role";



GRANT ALL ON TABLE "public"."document_access_history" TO "anon";
GRANT ALL ON TABLE "public"."document_access_history" TO "authenticated";
GRANT ALL ON TABLE "public"."document_access_history" TO "service_role";



GRANT ALL ON TABLE "public"."education" TO "anon";
GRANT ALL ON TABLE "public"."education" TO "authenticated";
GRANT ALL ON TABLE "public"."education" TO "service_role";



GRANT ALL ON TABLE "public"."embedding_cache" TO "anon";
GRANT ALL ON TABLE "public"."embedding_cache" TO "authenticated";
GRANT ALL ON TABLE "public"."embedding_cache" TO "service_role";



GRANT ALL ON TABLE "public"."embedding_queue" TO "anon";
GRANT ALL ON TABLE "public"."embedding_queue" TO "authenticated";
GRANT ALL ON TABLE "public"."embedding_queue" TO "service_role";



GRANT ALL ON TABLE "public"."program_sections" TO "anon";
GRANT ALL ON TABLE "public"."program_sections" TO "authenticated";
GRANT ALL ON TABLE "public"."program_sections" TO "service_role";



GRANT ALL ON TABLE "public"."student_enrollments" TO "anon";
GRANT ALL ON TABLE "public"."student_enrollments" TO "authenticated";
GRANT ALL ON TABLE "public"."student_enrollments" TO "service_role";



GRANT ALL ON TABLE "public"."enrolled_students_view" TO "anon";
GRANT ALL ON TABLE "public"."enrolled_students_view" TO "authenticated";
GRANT ALL ON TABLE "public"."enrolled_students_view" TO "service_role";



GRANT ALL ON TABLE "public"."event_registrations" TO "anon";
GRANT ALL ON TABLE "public"."event_registrations" TO "authenticated";
GRANT ALL ON TABLE "public"."event_registrations" TO "service_role";



GRANT ALL ON TABLE "public"."exam_registrations" TO "anon";
GRANT ALL ON TABLE "public"."exam_registrations" TO "authenticated";
GRANT ALL ON TABLE "public"."exam_registrations" TO "service_role";



GRANT ALL ON TABLE "public"."exam_rooms" TO "anon";
GRANT ALL ON TABLE "public"."exam_rooms" TO "authenticated";
GRANT ALL ON TABLE "public"."exam_rooms" TO "service_role";



GRANT ALL ON TABLE "public"."exam_seating_arrangements" TO "anon";
GRANT ALL ON TABLE "public"."exam_seating_arrangements" TO "authenticated";
GRANT ALL ON TABLE "public"."exam_seating_arrangements" TO "service_role";



GRANT ALL ON TABLE "public"."exam_timetable" TO "anon";
GRANT ALL ON TABLE "public"."exam_timetable" TO "authenticated";
GRANT ALL ON TABLE "public"."exam_timetable" TO "service_role";



GRANT ALL ON TABLE "public"."exam_windows" TO "anon";
GRANT ALL ON TABLE "public"."exam_windows" TO "authenticated";
GRANT ALL ON TABLE "public"."exam_windows" TO "service_role";



GRANT ALL ON TABLE "public"."expenditures" TO "anon";
GRANT ALL ON TABLE "public"."expenditures" TO "authenticated";
GRANT ALL ON TABLE "public"."expenditures" TO "service_role";



GRANT ALL ON TABLE "public"."experience" TO "anon";
GRANT ALL ON TABLE "public"."experience" TO "authenticated";
GRANT ALL ON TABLE "public"."experience" TO "service_role";



GRANT ALL ON TABLE "public"."export_activities" TO "anon";
GRANT ALL ON TABLE "public"."export_activities" TO "authenticated";
GRANT ALL ON TABLE "public"."export_activities" TO "service_role";



GRANT ALL ON SEQUENCE "public"."export_activities_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."export_activities_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."export_activities_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."external_assessment_attempts" TO "anon";
GRANT ALL ON TABLE "public"."external_assessment_attempts" TO "authenticated";
GRANT ALL ON TABLE "public"."external_assessment_attempts" TO "service_role";



GRANT ALL ON TABLE "public"."external_courses" TO "anon";
GRANT ALL ON TABLE "public"."external_courses" TO "authenticated";
GRANT ALL ON TABLE "public"."external_courses" TO "service_role";



GRANT ALL ON TABLE "public"."faculty_with_user_data" TO "anon";
GRANT ALL ON TABLE "public"."faculty_with_user_data" TO "authenticated";
GRANT ALL ON TABLE "public"."faculty_with_user_data" TO "service_role";



GRANT ALL ON TABLE "public"."fee_payments" TO "anon";
GRANT ALL ON TABLE "public"."fee_payments" TO "authenticated";
GRANT ALL ON TABLE "public"."fee_payments" TO "service_role";



GRANT ALL ON TABLE "public"."fee_structures" TO "anon";
GRANT ALL ON TABLE "public"."fee_structures" TO "authenticated";
GRANT ALL ON TABLE "public"."fee_structures" TO "service_role";



GRANT ALL ON TABLE "public"."generated_external_assessment" TO "anon";
GRANT ALL ON TABLE "public"."generated_external_assessment" TO "authenticated";
GRANT ALL ON TABLE "public"."generated_external_assessment" TO "service_role";



GRANT ALL ON TABLE "public"."grading_systems" TO "anon";
GRANT ALL ON TABLE "public"."grading_systems" TO "authenticated";
GRANT ALL ON TABLE "public"."grading_systems" TO "service_role";



GRANT ALL ON TABLE "public"."institution_pricing_tiers" TO "anon";
GRANT ALL ON TABLE "public"."institution_pricing_tiers" TO "authenticated";
GRANT ALL ON TABLE "public"."institution_pricing_tiers" TO "service_role";



GRANT ALL ON TABLE "public"."internships" TO "anon";
GRANT ALL ON TABLE "public"."internships" TO "authenticated";
GRANT ALL ON TABLE "public"."internships" TO "service_role";



GRANT ALL ON TABLE "public"."interview_reminders" TO "anon";
GRANT ALL ON TABLE "public"."interview_reminders" TO "authenticated";
GRANT ALL ON TABLE "public"."interview_reminders" TO "service_role";



GRANT ALL ON SEQUENCE "public"."interview_reminders_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."interview_reminders_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."interview_reminders_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."interviews" TO "anon";
GRANT ALL ON TABLE "public"."interviews" TO "authenticated";
GRANT ALL ON TABLE "public"."interviews" TO "service_role";



GRANT ALL ON TABLE "public"."invigilator_assignments" TO "anon";
GRANT ALL ON TABLE "public"."invigilator_assignments" TO "authenticated";
GRANT ALL ON TABLE "public"."invigilator_assignments" TO "service_role";



GRANT ALL ON TABLE "public"."learning_outcome_details" TO "anon";
GRANT ALL ON TABLE "public"."learning_outcome_details" TO "authenticated";
GRANT ALL ON TABLE "public"."learning_outcome_details" TO "service_role";



GRANT ALL ON TABLE "public"."lesson_plans" TO "anon";
GRANT ALL ON TABLE "public"."lesson_plans" TO "authenticated";
GRANT ALL ON TABLE "public"."lesson_plans" TO "service_role";



GRANT ALL ON TABLE "public"."lesson_resources" TO "anon";
GRANT ALL ON TABLE "public"."lesson_resources" TO "authenticated";
GRANT ALL ON TABLE "public"."lesson_resources" TO "service_role";



GRANT ALL ON TABLE "public"."lessons" TO "anon";
GRANT ALL ON TABLE "public"."lessons" TO "authenticated";
GRANT ALL ON TABLE "public"."lessons" TO "service_role";



GRANT ALL ON TABLE "public"."library_book_issues" TO "anon";
GRANT ALL ON TABLE "public"."library_book_issues" TO "authenticated";
GRANT ALL ON TABLE "public"."library_book_issues" TO "service_role";



GRANT ALL ON TABLE "public"."library_book_issues_college" TO "anon";
GRANT ALL ON TABLE "public"."library_book_issues_college" TO "authenticated";
GRANT ALL ON TABLE "public"."library_book_issues_college" TO "service_role";



GRANT ALL ON TABLE "public"."library_book_issues_school" TO "anon";
GRANT ALL ON TABLE "public"."library_book_issues_school" TO "authenticated";
GRANT ALL ON TABLE "public"."library_book_issues_school" TO "service_role";



GRANT ALL ON TABLE "public"."library_books" TO "anon";
GRANT ALL ON TABLE "public"."library_books" TO "authenticated";
GRANT ALL ON TABLE "public"."library_books" TO "service_role";



GRANT ALL ON TABLE "public"."library_books_college" TO "anon";
GRANT ALL ON TABLE "public"."library_books_college" TO "authenticated";
GRANT ALL ON TABLE "public"."library_books_college" TO "service_role";



GRANT ALL ON TABLE "public"."library_books_school" TO "anon";
GRANT ALL ON TABLE "public"."library_books_school" TO "authenticated";
GRANT ALL ON TABLE "public"."library_books_school" TO "service_role";



GRANT ALL ON TABLE "public"."library_categories" TO "anon";
GRANT ALL ON TABLE "public"."library_categories" TO "authenticated";
GRANT ALL ON TABLE "public"."library_categories" TO "service_role";



GRANT ALL ON TABLE "public"."library_categories_college" TO "anon";
GRANT ALL ON TABLE "public"."library_categories_college" TO "authenticated";
GRANT ALL ON TABLE "public"."library_categories_college" TO "service_role";



GRANT ALL ON TABLE "public"."library_categories_school" TO "anon";
GRANT ALL ON TABLE "public"."library_categories_school" TO "authenticated";
GRANT ALL ON TABLE "public"."library_categories_school" TO "service_role";



GRANT ALL ON TABLE "public"."library_history" TO "anon";
GRANT ALL ON TABLE "public"."library_history" TO "authenticated";
GRANT ALL ON TABLE "public"."library_history" TO "service_role";



GRANT ALL ON TABLE "public"."library_issued_books" TO "anon";
GRANT ALL ON TABLE "public"."library_issued_books" TO "authenticated";
GRANT ALL ON TABLE "public"."library_issued_books" TO "service_role";



GRANT ALL ON TABLE "public"."library_reservations" TO "anon";
GRANT ALL ON TABLE "public"."library_reservations" TO "authenticated";
GRANT ALL ON TABLE "public"."library_reservations" TO "service_role";



GRANT ALL ON TABLE "public"."library_reviews" TO "anon";
GRANT ALL ON TABLE "public"."library_reviews" TO "authenticated";
GRANT ALL ON TABLE "public"."library_reviews" TO "service_role";



GRANT ALL ON TABLE "public"."library_settings" TO "anon";
GRANT ALL ON TABLE "public"."library_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."library_settings" TO "service_role";



GRANT ALL ON TABLE "public"."library_settings_college" TO "anon";
GRANT ALL ON TABLE "public"."library_settings_college" TO "authenticated";
GRANT ALL ON TABLE "public"."library_settings_college" TO "service_role";



GRANT ALL ON TABLE "public"."library_settings_school" TO "anon";
GRANT ALL ON TABLE "public"."library_settings_school" TO "authenticated";
GRANT ALL ON TABLE "public"."library_settings_school" TO "service_role";



GRANT ALL ON TABLE "public"."overdue_books" TO "anon";
GRANT ALL ON TABLE "public"."overdue_books" TO "authenticated";
GRANT ALL ON TABLE "public"."overdue_books" TO "service_role";



GRANT ALL ON TABLE "public"."library_stats" TO "anon";
GRANT ALL ON TABLE "public"."library_stats" TO "authenticated";
GRANT ALL ON TABLE "public"."library_stats" TO "service_role";



GRANT ALL ON TABLE "public"."overdue_books_college" TO "anon";
GRANT ALL ON TABLE "public"."overdue_books_college" TO "authenticated";
GRANT ALL ON TABLE "public"."overdue_books_college" TO "service_role";



GRANT ALL ON TABLE "public"."library_stats_college" TO "anon";
GRANT ALL ON TABLE "public"."library_stats_college" TO "authenticated";
GRANT ALL ON TABLE "public"."library_stats_college" TO "service_role";



GRANT ALL ON TABLE "public"."overdue_books_school" TO "anon";
GRANT ALL ON TABLE "public"."overdue_books_school" TO "authenticated";
GRANT ALL ON TABLE "public"."overdue_books_school" TO "service_role";



GRANT ALL ON TABLE "public"."library_stats_school" TO "anon";
GRANT ALL ON TABLE "public"."library_stats_school" TO "authenticated";
GRANT ALL ON TABLE "public"."library_stats_school" TO "service_role";



GRANT ALL ON TABLE "public"."license_assignments" TO "anon";
GRANT ALL ON TABLE "public"."license_assignments" TO "authenticated";
GRANT ALL ON TABLE "public"."license_assignments" TO "service_role";



GRANT ALL ON TABLE "public"."license_pools" TO "anon";
GRANT ALL ON TABLE "public"."license_pools" TO "authenticated";
GRANT ALL ON TABLE "public"."license_pools" TO "service_role";



GRANT ALL ON TABLE "public"."mark_entries" TO "anon";
GRANT ALL ON TABLE "public"."mark_entries" TO "authenticated";
GRANT ALL ON TABLE "public"."mark_entries" TO "service_role";



GRANT ALL ON TABLE "public"."mark_entry_batches" TO "anon";
GRANT ALL ON TABLE "public"."mark_entry_batches" TO "authenticated";
GRANT ALL ON TABLE "public"."mark_entry_batches" TO "service_role";



GRANT ALL ON TABLE "public"."mark_moderation_log" TO "anon";
GRANT ALL ON TABLE "public"."mark_moderation_log" TO "authenticated";
GRANT ALL ON TABLE "public"."mark_moderation_log" TO "service_role";



GRANT ALL ON TABLE "public"."mentor_notes" TO "anon";
GRANT ALL ON TABLE "public"."mentor_notes" TO "authenticated";
GRANT ALL ON TABLE "public"."mentor_notes" TO "service_role";



GRANT ALL ON TABLE "public"."messages" TO "anon";
GRANT ALL ON TABLE "public"."messages" TO "authenticated";
GRANT ALL ON TABLE "public"."messages" TO "service_role";



GRANT ALL ON TABLE "public"."messages_backup" TO "anon";
GRANT ALL ON TABLE "public"."messages_backup" TO "authenticated";
GRANT ALL ON TABLE "public"."messages_backup" TO "service_role";



GRANT ALL ON SEQUENCE "public"."messages_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."messages_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."messages_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."metrics_snapshots" TO "anon";
GRANT ALL ON TABLE "public"."metrics_snapshots" TO "authenticated";
GRANT ALL ON TABLE "public"."metrics_snapshots" TO "service_role";



GRANT ALL ON TABLE "public"."notifications" TO "anon";
GRANT ALL ON TABLE "public"."notifications" TO "authenticated";
GRANT ALL ON TABLE "public"."notifications" TO "service_role";



GRANT ALL ON TABLE "public"."notifications_backup_20251106" TO "anon";
GRANT ALL ON TABLE "public"."notifications_backup_20251106" TO "authenticated";
GRANT ALL ON TABLE "public"."notifications_backup_20251106" TO "service_role";



GRANT ALL ON TABLE "public"."offers" TO "anon";
GRANT ALL ON TABLE "public"."offers" TO "authenticated";
GRANT ALL ON TABLE "public"."offers" TO "service_role";



GRANT ALL ON TABLE "public"."opportunities_backup_migration" TO "anon";
GRANT ALL ON TABLE "public"."opportunities_backup_migration" TO "authenticated";
GRANT ALL ON TABLE "public"."opportunities_backup_migration" TO "service_role";



GRANT ALL ON TABLE "public"."opportunities_duplicate" TO "anon";
GRANT ALL ON TABLE "public"."opportunities_duplicate" TO "authenticated";
GRANT ALL ON TABLE "public"."opportunities_duplicate" TO "service_role";



GRANT ALL ON TABLE "public"."opportunity_interactions" TO "anon";
GRANT ALL ON TABLE "public"."opportunity_interactions" TO "authenticated";
GRANT ALL ON TABLE "public"."opportunity_interactions" TO "service_role";



GRANT ALL ON TABLE "public"."opportunity_interactions_backup_uuid_migration" TO "anon";
GRANT ALL ON TABLE "public"."opportunity_interactions_backup_uuid_migration" TO "authenticated";
GRANT ALL ON TABLE "public"."opportunity_interactions_backup_uuid_migration" TO "service_role";



GRANT ALL ON TABLE "public"."organization_invitations" TO "anon";
GRANT ALL ON TABLE "public"."organization_invitations" TO "authenticated";
GRANT ALL ON TABLE "public"."organization_invitations" TO "service_role";



GRANT ALL ON TABLE "public"."organization_subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."organization_subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."organization_subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."otp_requests_log" TO "anon";
GRANT ALL ON TABLE "public"."otp_requests_log" TO "authenticated";
GRANT ALL ON TABLE "public"."otp_requests_log" TO "service_role";



GRANT ALL ON TABLE "public"."outcome_assessment_mappings" TO "anon";
GRANT ALL ON TABLE "public"."outcome_assessment_mappings" TO "authenticated";
GRANT ALL ON TABLE "public"."outcome_assessment_mappings" TO "service_role";



GRANT ALL ON TABLE "public"."payment_transactions" TO "anon";
GRANT ALL ON TABLE "public"."payment_transactions" TO "authenticated";
GRANT ALL ON TABLE "public"."payment_transactions" TO "service_role";



GRANT ALL ON TABLE "public"."pending_scorecards" TO "anon";
GRANT ALL ON TABLE "public"."pending_scorecards" TO "authenticated";
GRANT ALL ON TABLE "public"."pending_scorecards" TO "service_role";



GRANT ALL ON TABLE "public"."permissions" TO "anon";
GRANT ALL ON TABLE "public"."permissions" TO "authenticated";
GRANT ALL ON TABLE "public"."permissions" TO "service_role";



GRANT ALL ON TABLE "public"."personal_assessment_attempts" TO "anon";
GRANT ALL ON TABLE "public"."personal_assessment_attempts" TO "authenticated";
GRANT ALL ON TABLE "public"."personal_assessment_attempts" TO "service_role";



GRANT ALL ON TABLE "public"."personal_assessment_questions" TO "anon";
GRANT ALL ON TABLE "public"."personal_assessment_questions" TO "authenticated";
GRANT ALL ON TABLE "public"."personal_assessment_questions" TO "service_role";



GRANT ALL ON TABLE "public"."personal_assessment_response_scales" TO "anon";
GRANT ALL ON TABLE "public"."personal_assessment_response_scales" TO "authenticated";
GRANT ALL ON TABLE "public"."personal_assessment_response_scales" TO "service_role";



GRANT ALL ON TABLE "public"."personal_assessment_responses" TO "anon";
GRANT ALL ON TABLE "public"."personal_assessment_responses" TO "authenticated";
GRANT ALL ON TABLE "public"."personal_assessment_responses" TO "service_role";



GRANT ALL ON TABLE "public"."personal_assessment_restrictions" TO "anon";
GRANT ALL ON TABLE "public"."personal_assessment_restrictions" TO "authenticated";
GRANT ALL ON TABLE "public"."personal_assessment_restrictions" TO "service_role";



GRANT ALL ON TABLE "public"."personal_assessment_results" TO "anon";
GRANT ALL ON TABLE "public"."personal_assessment_results" TO "authenticated";
GRANT ALL ON TABLE "public"."personal_assessment_results" TO "service_role";



GRANT ALL ON TABLE "public"."personal_assessment_sections" TO "anon";
GRANT ALL ON TABLE "public"."personal_assessment_sections" TO "authenticated";
GRANT ALL ON TABLE "public"."personal_assessment_sections" TO "service_role";



GRANT ALL ON TABLE "public"."personal_assessment_streams" TO "anon";
GRANT ALL ON TABLE "public"."personal_assessment_streams" TO "authenticated";
GRANT ALL ON TABLE "public"."personal_assessment_streams" TO "service_role";



GRANT ALL ON TABLE "public"."phone_otps" TO "anon";
GRANT ALL ON TABLE "public"."phone_otps" TO "authenticated";
GRANT ALL ON TABLE "public"."phone_otps" TO "service_role";



GRANT ALL ON TABLE "public"."pipeline_activities" TO "anon";
GRANT ALL ON TABLE "public"."pipeline_activities" TO "authenticated";
GRANT ALL ON TABLE "public"."pipeline_activities" TO "service_role";



GRANT ALL ON SEQUENCE "public"."pipeline_activities_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."pipeline_activities_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."pipeline_activities_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."pipeline_candidates" TO "anon";
GRANT ALL ON TABLE "public"."pipeline_candidates" TO "authenticated";
GRANT ALL ON TABLE "public"."pipeline_candidates" TO "service_role";



GRANT ALL ON TABLE "public"."pipeline_candidates_backup_migration" TO "anon";
GRANT ALL ON TABLE "public"."pipeline_candidates_backup_migration" TO "authenticated";
GRANT ALL ON TABLE "public"."pipeline_candidates_backup_migration" TO "service_role";



GRANT ALL ON TABLE "public"."pipeline_candidates_detailed" TO "anon";
GRANT ALL ON TABLE "public"."pipeline_candidates_detailed" TO "authenticated";
GRANT ALL ON TABLE "public"."pipeline_candidates_detailed" TO "service_role";



GRANT ALL ON TABLE "public"."placements" TO "anon";
GRANT ALL ON TABLE "public"."placements" TO "authenticated";
GRANT ALL ON TABLE "public"."placements" TO "service_role";



GRANT ALL ON TABLE "public"."pre_registration_email_tracking" TO "anon";
GRANT ALL ON TABLE "public"."pre_registration_email_tracking" TO "authenticated";
GRANT ALL ON TABLE "public"."pre_registration_email_tracking" TO "service_role";



GRANT ALL ON TABLE "public"."pre_registrations" TO "anon";
GRANT ALL ON TABLE "public"."pre_registrations" TO "authenticated";
GRANT ALL ON TABLE "public"."pre_registrations" TO "service_role";



GRANT ALL ON TABLE "public"."profile_views" TO "anon";
GRANT ALL ON TABLE "public"."profile_views" TO "authenticated";
GRANT ALL ON TABLE "public"."profile_views" TO "service_role";



GRANT ALL ON TABLE "public"."profile_views_backup_20251106" TO "anon";
GRANT ALL ON TABLE "public"."profile_views_backup_20251106" TO "authenticated";
GRANT ALL ON TABLE "public"."profile_views_backup_20251106" TO "service_role";



GRANT ALL ON TABLE "public"."program_sections_view" TO "anon";
GRANT ALL ON TABLE "public"."program_sections_view" TO "authenticated";
GRANT ALL ON TABLE "public"."program_sections_view" TO "service_role";



GRANT ALL ON TABLE "public"."promotional_events" TO "anon";
GRANT ALL ON TABLE "public"."promotional_events" TO "authenticated";
GRANT ALL ON TABLE "public"."promotional_events" TO "service_role";



GRANT ALL ON TABLE "public"."quizzes" TO "anon";
GRANT ALL ON TABLE "public"."quizzes" TO "authenticated";
GRANT ALL ON TABLE "public"."quizzes" TO "service_role";



GRANT ALL ON TABLE "public"."razorpay_orders" TO "anon";
GRANT ALL ON TABLE "public"."razorpay_orders" TO "authenticated";
GRANT ALL ON TABLE "public"."razorpay_orders" TO "service_role";



GRANT ALL ON TABLE "public"."recent_updates" TO "anon";
GRANT ALL ON TABLE "public"."recent_updates" TO "authenticated";
GRANT ALL ON TABLE "public"."recent_updates" TO "service_role";



GRANT ALL ON TABLE "public"."recruiter_activities" TO "anon";
GRANT ALL ON TABLE "public"."recruiter_activities" TO "authenticated";
GRANT ALL ON TABLE "public"."recruiter_activities" TO "service_role";



GRANT ALL ON TABLE "public"."recruiter_saved_searches" TO "anon";
GRANT ALL ON TABLE "public"."recruiter_saved_searches" TO "authenticated";
GRANT ALL ON TABLE "public"."recruiter_saved_searches" TO "service_role";



GRANT ALL ON TABLE "public"."requisitions" TO "anon";
GRANT ALL ON TABLE "public"."requisitions" TO "authenticated";
GRANT ALL ON TABLE "public"."requisitions" TO "service_role";



GRANT ALL ON TABLE "public"."requisitions_with_pipeline_stats" TO "anon";
GRANT ALL ON TABLE "public"."requisitions_with_pipeline_stats" TO "authenticated";
GRANT ALL ON TABLE "public"."requisitions_with_pipeline_stats" TO "service_role";



GRANT ALL ON TABLE "public"."reset_tokens" TO "anon";
GRANT ALL ON TABLE "public"."reset_tokens" TO "authenticated";
GRANT ALL ON TABLE "public"."reset_tokens" TO "service_role";



GRANT ALL ON TABLE "public"."role_permissions" TO "anon";
GRANT ALL ON TABLE "public"."role_permissions" TO "authenticated";
GRANT ALL ON TABLE "public"."role_permissions" TO "service_role";



GRANT ALL ON TABLE "public"."roles" TO "anon";
GRANT ALL ON TABLE "public"."roles" TO "authenticated";
GRANT ALL ON TABLE "public"."roles" TO "service_role";



GRANT ALL ON TABLE "public"."saved_jobs" TO "anon";
GRANT ALL ON TABLE "public"."saved_jobs" TO "authenticated";
GRANT ALL ON TABLE "public"."saved_jobs" TO "service_role";



GRANT ALL ON TABLE "public"."saved_jobs_backup_migration" TO "anon";
GRANT ALL ON TABLE "public"."saved_jobs_backup_migration" TO "authenticated";
GRANT ALL ON TABLE "public"."saved_jobs_backup_migration" TO "service_role";



GRANT ALL ON TABLE "public"."school_classes" TO "anon";
GRANT ALL ON TABLE "public"."school_classes" TO "authenticated";
GRANT ALL ON TABLE "public"."school_classes" TO "service_role";



GRANT ALL ON TABLE "public"."school_educator_class_assignments" TO "anon";
GRANT ALL ON TABLE "public"."school_educator_class_assignments" TO "authenticated";
GRANT ALL ON TABLE "public"."school_educator_class_assignments" TO "service_role";



GRANT ALL ON TABLE "public"."school_educators" TO "anon";
GRANT ALL ON TABLE "public"."school_educators" TO "authenticated";
GRANT ALL ON TABLE "public"."school_educators" TO "service_role";



GRANT ALL ON TABLE "public"."search_history" TO "anon";
GRANT ALL ON TABLE "public"."search_history" TO "authenticated";
GRANT ALL ON TABLE "public"."search_history" TO "service_role";



GRANT ALL ON SEQUENCE "public"."search_history_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."search_history_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."search_history_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."shortlist_candidates" TO "anon";
GRANT ALL ON TABLE "public"."shortlist_candidates" TO "authenticated";
GRANT ALL ON TABLE "public"."shortlist_candidates" TO "service_role";



GRANT ALL ON SEQUENCE "public"."shortlist_candidates_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."shortlist_candidates_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."shortlist_candidates_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."shortlists" TO "anon";
GRANT ALL ON TABLE "public"."shortlists" TO "authenticated";
GRANT ALL ON TABLE "public"."shortlists" TO "service_role";



GRANT ALL ON TABLE "public"."shortlists_with_counts" TO "anon";
GRANT ALL ON TABLE "public"."shortlists_with_counts" TO "authenticated";
GRANT ALL ON TABLE "public"."shortlists_with_counts" TO "service_role";



GRANT ALL ON TABLE "public"."skill_assessments" TO "anon";
GRANT ALL ON TABLE "public"."skill_assessments" TO "authenticated";
GRANT ALL ON TABLE "public"."skill_assessments" TO "service_role";



GRANT ALL ON TABLE "public"."skill_badges" TO "anon";
GRANT ALL ON TABLE "public"."skill_badges" TO "authenticated";
GRANT ALL ON TABLE "public"."skill_badges" TO "service_role";



GRANT ALL ON TABLE "public"."skill_passports" TO "anon";
GRANT ALL ON TABLE "public"."skill_passports" TO "authenticated";
GRANT ALL ON TABLE "public"."skill_passports" TO "service_role";



GRANT ALL ON TABLE "public"."skill_trends" TO "anon";
GRANT ALL ON TABLE "public"."skill_trends" TO "authenticated";
GRANT ALL ON TABLE "public"."skill_trends" TO "service_role";



GRANT ALL ON TABLE "public"."skill_verification_requests" TO "anon";
GRANT ALL ON TABLE "public"."skill_verification_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."skill_verification_requests" TO "service_role";



GRANT ALL ON TABLE "public"."streak_notification_log" TO "anon";
GRANT ALL ON TABLE "public"."streak_notification_log" TO "authenticated";
GRANT ALL ON TABLE "public"."streak_notification_log" TO "service_role";



GRANT ALL ON TABLE "public"."stream_recommendation_reports" TO "anon";
GRANT ALL ON TABLE "public"."stream_recommendation_reports" TO "authenticated";
GRANT ALL ON TABLE "public"."stream_recommendation_reports" TO "service_role";



GRANT ALL ON TABLE "public"."student_applications_with_pipeline" TO "anon";
GRANT ALL ON TABLE "public"."student_applications_with_pipeline" TO "authenticated";
GRANT ALL ON TABLE "public"."student_applications_with_pipeline" TO "service_role";



GRANT ALL ON TABLE "public"."student_assignments" TO "anon";
GRANT ALL ON TABLE "public"."student_assignments" TO "authenticated";
GRANT ALL ON TABLE "public"."student_assignments" TO "service_role";



GRANT ALL ON TABLE "public"."student_skill_badges" TO "anon";
GRANT ALL ON TABLE "public"."student_skill_badges" TO "authenticated";
GRANT ALL ON TABLE "public"."student_skill_badges" TO "service_role";



GRANT ALL ON TABLE "public"."student_badges_summary" TO "anon";
GRANT ALL ON TABLE "public"."student_badges_summary" TO "authenticated";
GRANT ALL ON TABLE "public"."student_badges_summary" TO "service_role";



GRANT ALL ON TABLE "public"."student_course_progress" TO "anon";
GRANT ALL ON TABLE "public"."student_course_progress" TO "authenticated";
GRANT ALL ON TABLE "public"."student_course_progress" TO "service_role";



GRANT ALL ON TABLE "public"."student_course_recommendations" TO "anon";
GRANT ALL ON TABLE "public"."student_course_recommendations" TO "authenticated";
GRANT ALL ON TABLE "public"."student_course_recommendations" TO "service_role";



GRANT ALL ON SEQUENCE "public"."student_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."student_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."student_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."student_job_matches" TO "anon";
GRANT ALL ON TABLE "public"."student_job_matches" TO "authenticated";
GRANT ALL ON TABLE "public"."student_job_matches" TO "service_role";



GRANT ALL ON TABLE "public"."student_ledgers" TO "anon";
GRANT ALL ON TABLE "public"."student_ledgers" TO "authenticated";
GRANT ALL ON TABLE "public"."student_ledgers" TO "service_role";



GRANT ALL ON TABLE "public"."student_management_records" TO "anon";
GRANT ALL ON TABLE "public"."student_management_records" TO "authenticated";
GRANT ALL ON TABLE "public"."student_management_records" TO "service_role";



GRANT ALL ON TABLE "public"."student_promotions" TO "anon";
GRANT ALL ON TABLE "public"."student_promotions" TO "authenticated";
GRANT ALL ON TABLE "public"."student_promotions" TO "service_role";



GRANT ALL ON TABLE "public"."student_quiz_progress" TO "anon";
GRANT ALL ON TABLE "public"."student_quiz_progress" TO "authenticated";
GRANT ALL ON TABLE "public"."student_quiz_progress" TO "service_role";



GRANT ALL ON TABLE "public"."student_reports" TO "anon";
GRANT ALL ON TABLE "public"."student_reports" TO "authenticated";
GRANT ALL ON TABLE "public"."student_reports" TO "service_role";



GRANT ALL ON TABLE "public"."student_streaks" TO "anon";
GRANT ALL ON TABLE "public"."student_streaks" TO "authenticated";
GRANT ALL ON TABLE "public"."student_streaks" TO "service_role";



GRANT ALL ON TABLE "public"."subscription_cancellations" TO "anon";
GRANT ALL ON TABLE "public"."subscription_cancellations" TO "authenticated";
GRANT ALL ON TABLE "public"."subscription_cancellations" TO "service_role";



GRANT ALL ON TABLE "public"."subscription_migrations" TO "anon";
GRANT ALL ON TABLE "public"."subscription_migrations" TO "authenticated";
GRANT ALL ON TABLE "public"."subscription_migrations" TO "service_role";



GRANT ALL ON TABLE "public"."subscription_plan_features" TO "anon";
GRANT ALL ON TABLE "public"."subscription_plan_features" TO "authenticated";
GRANT ALL ON TABLE "public"."subscription_plan_features" TO "service_role";



GRANT ALL ON TABLE "public"."subscription_plans" TO "anon";
GRANT ALL ON TABLE "public"."subscription_plans" TO "authenticated";
GRANT ALL ON TABLE "public"."subscription_plans" TO "service_role";



GRANT ALL ON TABLE "public"."subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."teacher_journal" TO "anon";
GRANT ALL ON TABLE "public"."teacher_journal" TO "authenticated";
GRANT ALL ON TABLE "public"."teacher_journal" TO "service_role";



GRANT ALL ON TABLE "public"."timetable_slots" TO "anon";
GRANT ALL ON TABLE "public"."timetable_slots" TO "authenticated";
GRANT ALL ON TABLE "public"."timetable_slots" TO "service_role";



GRANT ALL ON TABLE "public"."timetables" TO "anon";
GRANT ALL ON TABLE "public"."timetables" TO "authenticated";
GRANT ALL ON TABLE "public"."timetables" TO "service_role";



GRANT ALL ON TABLE "public"."teacher_weekly_timetable" TO "anon";
GRANT ALL ON TABLE "public"."teacher_weekly_timetable" TO "authenticated";
GRANT ALL ON TABLE "public"."teacher_weekly_timetable" TO "service_role";



GRANT ALL ON TABLE "public"."teacher_workload" TO "anon";
GRANT ALL ON TABLE "public"."teacher_workload" TO "authenticated";
GRANT ALL ON TABLE "public"."teacher_workload" TO "service_role";



GRANT ALL ON TABLE "public"."timetable_conflicts" TO "anon";
GRANT ALL ON TABLE "public"."timetable_conflicts" TO "authenticated";
GRANT ALL ON TABLE "public"."timetable_conflicts" TO "service_role";



GRANT ALL ON TABLE "public"."training_notifications" TO "anon";
GRANT ALL ON TABLE "public"."training_notifications" TO "authenticated";
GRANT ALL ON TABLE "public"."training_notifications" TO "service_role";



GRANT ALL ON TABLE "public"."transcript_requests" TO "anon";
GRANT ALL ON TABLE "public"."transcript_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."transcript_requests" TO "service_role";



GRANT ALL ON TABLE "public"."transcripts" TO "anon";
GRANT ALL ON TABLE "public"."transcripts" TO "authenticated";
GRANT ALL ON TABLE "public"."transcripts" TO "service_role";



GRANT ALL ON TABLE "public"."tutor_conversations" TO "anon";
GRANT ALL ON TABLE "public"."tutor_conversations" TO "authenticated";
GRANT ALL ON TABLE "public"."tutor_conversations" TO "service_role";



GRANT ALL ON TABLE "public"."tutor_feedback" TO "anon";
GRANT ALL ON TABLE "public"."tutor_feedback" TO "authenticated";
GRANT ALL ON TABLE "public"."tutor_feedback" TO "service_role";



GRANT ALL ON TABLE "public"."university_courses" TO "anon";
GRANT ALL ON TABLE "public"."university_courses" TO "authenticated";
GRANT ALL ON TABLE "public"."university_courses" TO "service_role";



GRANT ALL ON TABLE "public"."university_performance" TO "anon";
GRANT ALL ON TABLE "public"."university_performance" TO "authenticated";
GRANT ALL ON TABLE "public"."university_performance" TO "service_role";



GRANT ALL ON TABLE "public"."upcoming_interviews" TO "anon";
GRANT ALL ON TABLE "public"."upcoming_interviews" TO "authenticated";
GRANT ALL ON TABLE "public"."upcoming_interviews" TO "service_role";



GRANT ALL ON TABLE "public"."user_categories" TO "anon";
GRANT ALL ON TABLE "public"."user_categories" TO "authenticated";
GRANT ALL ON TABLE "public"."user_categories" TO "service_role";



GRANT ALL ON TABLE "public"."user_entitlements" TO "anon";
GRANT ALL ON TABLE "public"."user_entitlements" TO "authenticated";
GRANT ALL ON TABLE "public"."user_entitlements" TO "service_role";



GRANT ALL ON TABLE "public"."user_login_history" TO "anon";
GRANT ALL ON TABLE "public"."user_login_history" TO "authenticated";
GRANT ALL ON TABLE "public"."user_login_history" TO "service_role";



GRANT ALL ON TABLE "public"."user_profiles" TO "anon";
GRANT ALL ON TABLE "public"."user_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."user_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."user_sessions" TO "anon";
GRANT ALL ON TABLE "public"."user_sessions" TO "authenticated";
GRANT ALL ON TABLE "public"."user_sessions" TO "service_role";



GRANT ALL ON TABLE "public"."user_settings" TO "anon";
GRANT ALL ON TABLE "public"."user_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."user_settings" TO "service_role";



GRANT ALL ON TABLE "public"."user_state_history" TO "anon";
GRANT ALL ON TABLE "public"."user_state_history" TO "authenticated";
GRANT ALL ON TABLE "public"."user_state_history" TO "service_role";



GRANT ALL ON TABLE "public"."verifications" TO "anon";
GRANT ALL ON TABLE "public"."verifications" TO "authenticated";
GRANT ALL ON TABLE "public"."verifications" TO "service_role";



GRANT ALL ON TABLE "public"."video_summaries" TO "anon";
GRANT ALL ON TABLE "public"."video_summaries" TO "authenticated";
GRANT ALL ON TABLE "public"."video_summaries" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";
































  create policy "Anyone can view course images"
  on "storage"."objects"
  as permissive
  for select
  to public
using ((bucket_id = 'course-images'::text));



  create policy "Authenticated users can upload course images"
  on "storage"."objects"
  as permissive
  for insert
  to public
with check (((bucket_id = 'course-images'::text) AND (auth.role() = 'authenticated'::text)));



  create policy "School staff can upload admission documents"
  on "storage"."objects"
  as permissive
  for insert
  to public
with check (((bucket_id = 'admission-documents'::text) AND (auth.role() = 'authenticated'::text)));



  create policy "School staff can view admission documents"
  on "storage"."objects"
  as permissive
  for select
  to public
using (((bucket_id = 'admission-documents'::text) AND (auth.role() = 'authenticated'::text)));



  create policy "Users can delete course images"
  on "storage"."objects"
  as permissive
  for delete
  to public
using (((bucket_id = 'course-images'::text) AND (auth.role() = 'authenticated'::text)));



  create policy "Users can update course images"
  on "storage"."objects"
  as permissive
  for update
  to public
using (((bucket_id = 'course-images'::text) AND (auth.role() = 'authenticated'::text)));


-- Storage triggers commented out - these functions are managed by Supabase storage service
-- CREATE TRIGGER objects_delete_delete_prefix AFTER DELETE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();
-- CREATE TRIGGER objects_insert_create_prefix BEFORE INSERT ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.objects_insert_prefix_trigger();
-- CREATE TRIGGER objects_update_create_prefix BEFORE UPDATE ON storage.objects FOR EACH ROW WHEN (((new.name <> old.name) OR (new.bucket_id <> old.bucket_id))) EXECUTE FUNCTION storage.objects_update_prefix_trigger();
-- CREATE TRIGGER prefixes_create_hierarchy BEFORE INSERT ON storage.prefixes FOR EACH ROW WHEN ((pg_trigger_depth() < 1)) EXECUTE FUNCTION storage.prefixes_insert_trigger();
-- CREATE TRIGGER prefixes_delete_hierarchy AFTER DELETE ON storage.prefixes FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();


