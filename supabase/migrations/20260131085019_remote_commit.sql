create extension if not exists "pg_cron" with schema "pg_catalog";

create extension if not exists "pg_trgm" with schema "extensions";

create extension if not exists "vector" with schema "extensions";

create type "public"."account_status" as enum ('pending', 'active', 'suspended', 'deactivated', 'approved', 'rejected', 'inactive', 'blacklisted');

create type "public"."approval_status" as enum ('pending', 'approved', 'rejected', 'under_review');

create type "public"."assessment_status" as enum ('pending', 'in_progress', 'completed', 'abandoned');

create type "public"."collegeType" as enum ('standalone', 'university_department');

create type "public"."confidence_tag" as enum ('high', 'medium', 'low');

create type "public"."educator_types" as enum ('school', 'college');

create type "public"."enrollmentStatus" as enum ('active', 'completed', 'withdrawn', 'transferred', 'suspended');

create type "public"."entity_type" as enum ('school', 'college', 'university', 'company');

create type "public"."grade_level" as enum ('middle_school', 'high_school', 'higher_secondary');

create type "public"."path_classification" as enum ('ascending', 'descending', 'stable', 'fluctuating');

create type "public"."payment_status_enum" as enum ('pending', 'completed', 'failed', 'refunded', 'cancelled');

create type "public"."placement_status" as enum ('applied', 'shortlisted', 'offered', 'hired', 'rejected', 'withdrawn');

create type "public"."question_subtag" as enum ('numerical_reasoning', 'logical_reasoning', 'verbal_reasoning', 'spatial_reasoning', 'data_interpretation', 'pattern_recognition');

create type "public"."session_status" as enum ('in_progress', 'completed', 'abandoned');

create type "public"."student_type" as enum ('school', 'college', 'university');

create type "public"."subscription_status" as enum ('pending', 'active', 'cancelled', 'expired', 'paused');

create type "public"."test_phase" as enum ('diagnostic_screener', 'adaptive_core', 'stability_confirmation');

create type "public"."tier_classification" as enum ('L', 'M', 'H');

create type "public"."user_approval_status" as enum ('approved', 'pending', 'rejected');

create type "public"."user_role" as enum ('super_admin', 'rm_admin', 'rm_manager', 'school_admin', 'college_admin', 'university_admin', 'company_admin', 'school_educator', 'recruiter', 'school_student', 'college_student', 'college_educator');

create type "public"."verification_status" as enum ('pending', 'verified', 'rejected', 'in_review');

create sequence "public"."export_activities_id_seq";

create sequence "public"."interview_reminders_id_seq";

create sequence "public"."messages_id_seq";

create sequence "public"."pipeline_activities_id_seq";

create sequence "public"."search_history_id_seq";

create sequence "public"."shortlist_candidates_id_seq";

create sequence "public"."student_id_seq";


  create table "public"."adaptive_aptitude_questions_cache" (
    "id" uuid not null default gen_random_uuid(),
    "question_id" text not null,
    "text" text not null,
    "options" jsonb not null,
    "correct_answer" character(1) not null,
    "difficulty" smallint not null,
    "subtag" public.question_subtag not null,
    "grade_level" public.grade_level not null,
    "phase" public.test_phase not null,
    "explanation" text,
    "created_at" timestamp with time zone not null default now(),
    "last_used_at" timestamp with time zone,
    "usage_count" integer not null default 0,
    "is_active" boolean not null default true
      );



  create table "public"."adaptive_aptitude_responses" (
    "id" uuid not null default gen_random_uuid(),
    "session_id" uuid not null,
    "question_id" text not null,
    "selected_answer" character(1) not null,
    "is_correct" boolean not null,
    "response_time_ms" integer not null,
    "difficulty_at_time" smallint not null,
    "subtag" public.question_subtag not null,
    "phase" public.test_phase not null,
    "sequence_number" integer not null,
    "answered_at" timestamp with time zone not null default now(),
    "question_text" text,
    "question_options" jsonb,
    "correct_answer" character(1),
    "explanation" text
      );


alter table "public"."adaptive_aptitude_responses" enable row level security;


  create table "public"."adaptive_aptitude_results" (
    "id" uuid not null default gen_random_uuid(),
    "session_id" uuid not null,
    "student_id" uuid not null,
    "aptitude_level" smallint not null,
    "confidence_tag" public.confidence_tag not null,
    "tier" public.tier_classification not null,
    "total_questions" integer not null,
    "total_correct" integer not null,
    "overall_accuracy" numeric(5,2) not null,
    "accuracy_by_difficulty" jsonb not null default '{}'::jsonb,
    "accuracy_by_subtag" jsonb not null default '{}'::jsonb,
    "difficulty_path" smallint[] not null,
    "path_classification" public.path_classification not null,
    "average_response_time_ms" integer not null,
    "grade_level" public.grade_level not null,
    "completed_at" timestamp with time zone not null default now(),
    "created_at" timestamp with time zone not null default now(),
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."adaptive_aptitude_results" enable row level security;


  create table "public"."adaptive_aptitude_sessions" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "grade_level" public.grade_level not null,
    "current_phase" public.test_phase not null default 'diagnostic_screener'::public.test_phase,
    "tier" public.tier_classification,
    "current_difficulty" smallint not null default 3,
    "difficulty_path" smallint[] not null default ARRAY[]::smallint[],
    "questions_answered" integer not null default 0,
    "correct_answers" integer not null default 0,
    "current_question_index" integer not null default 0,
    "current_phase_questions" jsonb not null default '[]'::jsonb,
    "provisional_band" smallint,
    "status" public.session_status not null default 'in_progress'::public.session_status,
    "started_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "completed_at" timestamp with time zone
      );


alter table "public"."adaptive_aptitude_sessions" enable row level security;


  create table "public"."addon_discount_codes" (
    "id" uuid not null default gen_random_uuid(),
    "code" character varying(50) not null,
    "discount_type" character varying(20) not null,
    "discount_value" numeric(10,2) not null,
    "applicable_feature_keys" text[],
    "applicable_bundle_ids" uuid[],
    "max_uses" integer,
    "current_uses" integer default 0,
    "valid_from" timestamp with time zone not null,
    "valid_until" timestamp with time zone not null,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."addon_discount_codes" enable row level security;


  create table "public"."addon_events" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid,
    "event_type" character varying(50) not null,
    "feature_key" text,
    "bundle_id" uuid,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."addon_events" enable row level security;


  create table "public"."addon_pending_orders" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "addon_feature_key" text not null,
    "razorpay_order_id" character varying(100) not null,
    "razorpay_payment_id" character varying(100),
    "amount" numeric(10,2) not null,
    "currency" character varying(10) default 'INR'::character varying,
    "billing_period" character varying(10) not null,
    "status" character varying(20) not null default 'pending'::character varying,
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "organization_id" uuid,
    "target_member_type" text,
    "target_member_ids" uuid[] default '{}'::uuid[],
    "is_bulk_order" boolean default false
      );


alter table "public"."addon_pending_orders" enable row level security;


  create table "public"."admin_users" (
    "id" uuid not null,
    "admin_role" text not null,
    "granted_by" uuid,
    "granted_at" timestamp with time zone not null default now()
      );



  create table "public"."admission_applications" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid not null,
    "application_number" text not null,
    "student_name" text not null,
    "date_of_birth" date not null,
    "gender" text,
    "aadhar_number" text,
    "passport_number" text,
    "email" text not null,
    "phone" text not null,
    "father_name" text not null,
    "father_occupation" text,
    "father_phone" text,
    "father_email" text,
    "mother_name" text not null,
    "mother_occupation" text,
    "mother_phone" text,
    "guardian_name" text,
    "guardian_relation" text,
    "guardian_phone" text,
    "address" text not null,
    "city" text not null,
    "state" text not null,
    "pincode" text not null,
    "previous_school" text,
    "previous_class" text,
    "previous_board" text,
    "documents" jsonb default '{}'::jsonb,
    "status" text default 'pending'::text,
    "applied_for" text not null,
    "applied_date" timestamp with time zone default now(),
    "verified_by" uuid,
    "verified_date" timestamp with time zone,
    "enrollment_number" text,
    "fee_status" text default 'pending'::text,
    "fee_amount" numeric(10,2),
    "fee_paid" numeric(10,2) default 0,
    "remarks" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."admission_applications" enable row level security;


  create table "public"."ai_evaluations" (
    "id" uuid not null default gen_random_uuid(),
    "conversation_id" uuid not null,
    "student_id" uuid not null,
    "message_id" text not null,
    "user_message" text not null,
    "ai_response" text not null,
    "detected_intent" text,
    "intent_confidence" text,
    "conversation_phase" text,
    "thumbs_up" boolean,
    "user_rating" integer,
    "user_feedback" text,
    "response_time_ms" integer,
    "model_used" text default 'openai/gpt-4o-mini'::text,
    "created_at" timestamp with time zone default now(),
    "feedback_at" timestamp with time zone
      );


alter table "public"."ai_evaluations" enable row level security;


  create table "public"."app_config" (
    "key" text not null,
    "value" text not null
      );


alter table "public"."app_config" enable row level security;


  create table "public"."applied_jobs" (
    "id_old" integer,
    "student_id" uuid not null,
    "opportunity_id_old" integer,
    "application_status" text not null default 'applied'::text,
    "applied_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "viewed_at" timestamp with time zone,
    "responded_at" timestamp with time zone,
    "interview_scheduled_at" timestamp with time zone,
    "notes" text,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "id" uuid not null default gen_random_uuid(),
    "opportunity_id" uuid not null
      );



  create table "public"."applied_jobs_backup_migration" (
    "id" integer,
    "student_id" uuid,
    "opportunity_id" integer,
    "application_status" text,
    "applied_at" timestamp with time zone,
    "viewed_at" timestamp with time zone,
    "responded_at" timestamp with time zone,
    "interview_scheduled_at" timestamp with time zone,
    "notes" text,
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone
      );



  create table "public"."approval_actions" (
    "id" uuid not null default gen_random_uuid(),
    "request_id" uuid,
    "approver_id" uuid,
    "action" public.approval_status not null,
    "comment" text,
    "created_at" timestamp with time zone not null default now()
      );



  create table "public"."approval_requests" (
    "id" uuid not null default gen_random_uuid(),
    "workflow_id" uuid,
    "requester_id" uuid,
    "status" public.approval_status default 'pending'::public.approval_status,
    "request_data" jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );



  create table "public"."approval_types" (
    "name" character varying(100) not null,
    "description" text not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );



  create table "public"."approval_workflows" (
    "id" uuid not null default gen_random_uuid(),
    "approval_type" character varying(100),
    "name" character varying(255) not null,
    "description" text,
    "required_approvers" integer not null default 1,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );



  create table "public"."assessment_types" (
    "id" uuid not null default gen_random_uuid(),
    "name" character varying(100) not null,
    "description" text,
    "is_active" boolean default true,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now(),
    "institution_id" uuid,
    "institution_type" character varying(20)
      );


alter table "public"."assessment_types" enable row level security;


  create table "public"."assessments" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "assessment_code" text not null,
    "type" text not null,
    "academic_year" text not null,
    "department_id" uuid,
    "program_id" uuid,
    "semester" integer not null,
    "course_id" uuid,
    "course_name" text not null,
    "course_code" text not null,
    "duration_minutes" integer not null default 180,
    "total_marks" numeric(5,2) not null default 100,
    "pass_marks" numeric(5,2) not null default 40,
    "weightage" numeric(5,2),
    "instructions" text,
    "syllabus_coverage" jsonb default '[]'::jsonb,
    "question_paper_pattern" jsonb,
    "status" text default 'draft'::text,
    "is_published" boolean default false,
    "is_locked" boolean default false,
    "created_by" uuid,
    "approved_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "approved_at" timestamp with time zone,
    "faculty_id" uuid,
    "college_id" uuid,
    "school_id" uuid,
    "teacher_id" uuid,
    "start_date" date,
    "end_date" date,
    "target_classes" jsonb
      );



  create table "public"."assignment_attachments" (
    "attachment_id" uuid not null default gen_random_uuid(),
    "assignment_id" uuid not null,
    "file_name" text not null,
    "file_type" text,
    "file_size" integer,
    "file_url" text,
    "uploaded_date" timestamp with time zone not null default now()
      );


alter table "public"."assignment_attachments" enable row level security;


  create table "public"."assignments" (
    "assignment_id" uuid not null default gen_random_uuid(),
    "title" text not null,
    "description" text,
    "instructions" text,
    "course_name" text not null,
    "course_code" text,
    "educator_name" text,
    "total_points" numeric(7,2) not null default 100,
    "assignment_type" text,
    "skill_outcomes" text[],
    "assign_classes" text,
    "document_pdf" text,
    "due_date" timestamp with time zone not null,
    "available_from" timestamp with time zone,
    "created_date" timestamp with time zone not null default now(),
    "allow_late_submission" boolean not null default true,
    "is_deleted" boolean not null default false,
    "updated_date" timestamp with time zone not null default now(),
    "educator_id" uuid,
    "school_class_id" uuid
      );



  create table "public"."attendance_alerts" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "school_id" uuid not null,
    "alert_type" text not null,
    "message" text not null,
    "days_absent" integer,
    "attendance_percentage" numeric(5,2),
    "parent_notified" boolean default false,
    "notified_date" timestamp with time zone,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."attendance_alerts" enable row level security;


  create table "public"."attendance_records" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "school_id" uuid not null,
    "date" date not null,
    "status" text not null,
    "mode" text default 'manual'::text,
    "time_in" time without time zone,
    "time_out" time without time zone,
    "marked_by" uuid,
    "remarks" text,
    "otp_verified" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "slot_id" uuid
      );



  create table "public"."audit_logs" (
    "actorId" uuid,
    "action" text not null,
    "target" text,
    "payload" jsonb default '{}'::jsonb,
    "ip" text,
    "createdAt" timestamp with time zone default now(),
    "id" uuid not null default gen_random_uuid()
      );


alter table "public"."audit_logs" enable row level security;


  create table "public"."budget_alerts" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "budget_id" uuid not null,
    "department_id" uuid not null,
    "budget_head_name" text,
    "alert_type" text not null,
    "alert_level" text not null,
    "allocated_amount" numeric(12,2) not null,
    "spent_amount" numeric(12,2) not null,
    "remaining_amount" numeric(12,2) not null,
    "utilization_percentage" numeric(5,2) not null,
    "alert_message" text not null,
    "notified_users" uuid[] default '{}'::uuid[],
    "notification_sent" boolean default false,
    "notification_sent_at" timestamp with time zone,
    "is_acknowledged" boolean default false,
    "acknowledged_by" uuid,
    "acknowledged_at" timestamp with time zone,
    "created_at" timestamp with time zone default now()
      );



  create table "public"."budget_revisions" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "budget_id" uuid not null,
    "department_id" uuid not null,
    "revision_number" integer not null,
    "revision_type" text not null,
    "revision_reason" text not null,
    "previous_total" numeric(12,2) not null,
    "new_total" numeric(12,2) not null,
    "difference" numeric(12,2) generated always as ((new_total - previous_total)) stored,
    "previous_heads" jsonb not null,
    "new_heads" jsonb not null,
    "requested_by" uuid not null,
    "requested_at" timestamp with time zone default now(),
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "approval_status" text default 'pending'::text,
    "approval_remarks" text,
    "created_at" timestamp with time zone default now()
      );



  create table "public"."bundle_features" (
    "id" uuid not null default gen_random_uuid(),
    "bundle_id" uuid not null,
    "feature_key" text not null,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."bundle_features" enable row level security;


  create table "public"."bundles" (
    "id" uuid not null default gen_random_uuid(),
    "name" character varying(100) not null,
    "slug" character varying(100) not null,
    "description" text,
    "target_roles" text[] not null default '{}'::text[],
    "monthly_price" numeric(10,2) not null,
    "annual_price" numeric(10,2) not null,
    "discount_percentage" integer not null default 0,
    "is_active" boolean default true,
    "display_order" integer default 0,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."bundles" enable row level security;


  create table "public"."career_ai_conversations" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "title" text not null,
    "messages" jsonb default '[]'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."career_ai_conversations" enable row level security;


  create table "public"."career_assessment_ai_questions" (
    "id" uuid not null default gen_random_uuid(),
    "stream_id" character varying(50) not null,
    "question_type" character varying(50) not null,
    "category" character varying(100),
    "questions" jsonb not null,
    "generated_at" timestamp with time zone default now(),
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "student_id" uuid,
    "attempt_id" uuid,
    "grade_level" text not null default 'Grade 10'::text
      );



  create table "public"."certificates" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "title" character varying(200) not null,
    "issuer" character varying(150),
    "level" character varying(100),
    "credential_id" character varying(150),
    "link" text,
    "issued_on" date,
    "description" text,
    "status" character varying(50),
    "approval_status" character varying(20) default 'pending'::character varying,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "upload" character varying,
    "document_url" text,
    "enabled" boolean default true,
    "training_id" uuid,
    "platform" character varying(100),
    "instructor" character varying(255),
    "category" character varying(100),
    "expiry_date" date,
    "embedding" extensions.vector(1536),
    "pending_edit_data" jsonb,
    "has_pending_edit" boolean default false,
    "verified_data" jsonb
      );



  create table "public"."class_swap_history" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "swap_request_id" uuid not null,
    "action" character varying(50) not null,
    "actor_id" uuid not null,
    "actor_role" character varying(20) not null,
    "notes" text,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."class_swap_history" enable row level security;


  create table "public"."class_swap_requests" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "requester_faculty_id" uuid not null,
    "requester_slot_id" uuid not null,
    "target_faculty_id" uuid not null,
    "target_slot_id" uuid not null,
    "reason" text not null,
    "request_type" character varying(20) not null,
    "swap_date" date,
    "status" character varying(20) not null default 'pending'::character varying,
    "target_response" text,
    "target_responded_at" timestamp with time zone,
    "requires_admin_approval" boolean default true,
    "admin_approval_status" character varying(20),
    "admin_id" uuid,
    "admin_response" text,
    "admin_responded_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "completed_at" timestamp with time zone
      );


alter table "public"."class_swap_requests" enable row level security;


  create table "public"."club_activities" (
    "activity_id" uuid not null default gen_random_uuid(),
    "club_id" uuid not null,
    "title" character varying(255) not null,
    "description" text,
    "activity_date" date not null,
    "activity_time" character varying(50),
    "location" character varying(255),
    "activity_type" character varying(50),
    "status" character varying(20) default 'scheduled'::character varying,
    "expected_participants" integer default 0,
    "actual_participants" integer default 0,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by_type" character varying(20),
    "created_by_educator_id" uuid,
    "created_by_admin_id" uuid
      );



  create table "public"."club_attendance" (
    "attendance_id" uuid not null default gen_random_uuid(),
    "club_id" uuid not null,
    "session_date" date not null,
    "session_topic" character varying(255),
    "session_description" text,
    "duration_minutes" integer,
    "created_at" timestamp with time zone default now(),
    "created_by_type" character varying(20),
    "created_by_educator_id" uuid,
    "created_by_admin_id" uuid
      );


alter table "public"."club_attendance" enable row level security;


  create table "public"."club_attendance_records" (
    "record_id" uuid not null default gen_random_uuid(),
    "attendance_id" uuid not null,
    "student_email" character varying(255) not null,
    "status" character varying(20) not null,
    "remarks" text,
    "marked_at" timestamp with time zone default now(),
    "marked_by_type" character varying(20),
    "marked_by_educator_id" uuid,
    "marked_by_admin_id" uuid
      );


alter table "public"."club_attendance_records" enable row level security;


  create table "public"."club_certificates" (
    "certificate_id" uuid not null default gen_random_uuid(),
    "student_email" character varying(255) not null,
    "school_id" uuid not null,
    "title" character varying(255) not null,
    "description" text,
    "certificate_type" character varying(50),
    "issuer" character varying(255),
    "issued_date" date not null,
    "valid_until" date,
    "credential_id" character varying(100),
    "verification_url" text,
    "qr_code_url" text,
    "related_club_id" uuid,
    "related_comp_id" uuid,
    "related_badge_id" uuid,
    "certificate_pdf_url" text,
    "certificate_image_url" text,
    "template_used" character varying(100),
    "created_at" timestamp with time zone default now(),
    "issued_by_type" character varying(20),
    "issued_by_educator_id" uuid,
    "issued_by_admin_id" uuid,
    "is_verified" boolean default true,
    "metadata" jsonb default '{}'::jsonb
      );



  create table "public"."club_memberships" (
    "membership_id" uuid not null default gen_random_uuid(),
    "club_id" uuid not null,
    "student_email" character varying(255) not null,
    "enrolled_at" timestamp with time zone default now(),
    "enrolled_by_type" character varying(20),
    "enrolled_by_educator_id" uuid,
    "enrolled_by_admin_id" uuid,
    "status" character varying(20) default 'active'::character varying,
    "withdrawn_at" timestamp with time zone,
    "withdrawal_reason" text,
    "total_sessions_attended" integer default 0,
    "total_sessions_held" integer default 0,
    "attendance_percentage" numeric(5,2) default 0,
    "performance_score" numeric(5,2) default 0,
    "achievements" jsonb default '[]'::jsonb
      );


alter table "public"."club_memberships" enable row level security;


  create table "public"."clubs" (
    "club_id" uuid not null default gen_random_uuid(),
    "school_id" uuid not null,
    "name" character varying(255) not null,
    "category" character varying(50) not null,
    "description" text,
    "capacity" integer not null default 30,
    "meeting_day" character varying(100),
    "meeting_time" character varying(50),
    "location" character varying(255),
    "mentor_type" character varying(20),
    "mentor_educator_id" uuid,
    "mentor_school_id" uuid,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by_type" character varying(20),
    "created_by_educator_id" uuid,
    "created_by_admin_id" uuid
      );


alter table "public"."clubs" enable row level security;


  create table "public"."college_assignment_attachments" (
    "attachment_id" uuid not null default gen_random_uuid(),
    "assignment_id" uuid not null,
    "file_name" text not null,
    "file_type" text,
    "file_size" integer,
    "file_url" text,
    "uploaded_date" timestamp with time zone not null default now(),
    "uploaded_by" uuid
      );



  create table "public"."college_assignments" (
    "assignment_id" uuid not null default gen_random_uuid(),
    "title" text not null,
    "description" text,
    "instructions" text,
    "course_name" text not null,
    "course_code" text,
    "college_id" uuid not null,
    "college_educator_id" uuid not null,
    "program_section_id" uuid not null,
    "department_id" uuid not null,
    "program_id" uuid not null,
    "educator_name" text,
    "total_points" numeric(7,2) not null default 100,
    "assignment_type" text,
    "skill_outcomes" text[],
    "document_pdf" text,
    "due_date" timestamp with time zone not null,
    "available_from" timestamp with time zone,
    "created_date" timestamp with time zone not null default now(),
    "updated_date" timestamp with time zone not null default now(),
    "allow_late_submission" boolean not null default true,
    "is_deleted" boolean not null default false,
    "instruction_files" jsonb default '[]'::jsonb
      );



  create table "public"."college_attendance_records" (
    "id" uuid not null default gen_random_uuid(),
    "session_id" uuid,
    "student_id" uuid,
    "student_name" character varying(255) not null,
    "roll_number" character varying(50) not null,
    "department_name" character varying(255) not null,
    "program_name" character varying(255) not null,
    "semester" integer not null,
    "section" character varying(10) not null,
    "date" date not null,
    "status" character varying(20) not null,
    "time_in" time without time zone,
    "time_out" time without time zone,
    "subject_name" character varying(255) not null,
    "subject_code" character varying(50),
    "faculty_id" uuid,
    "faculty_name" character varying(255) not null,
    "location" character varying(255),
    "remarks" text,
    "marked_by" uuid,
    "marked_at" timestamp with time zone default now(),
    "created_at" timestamp with time zone default now(),
    "college_id" uuid not null
      );



  create table "public"."college_attendance_sessions" (
    "id" uuid not null default gen_random_uuid(),
    "date" date not null,
    "start_time" time without time zone not null,
    "end_time" time without time zone not null,
    "subject_name" character varying(255) not null,
    "subject_code" character varying(50),
    "course_type" character varying(20),
    "faculty_id" uuid,
    "faculty_name" character varying(255) not null,
    "department_name" character varying(255) not null,
    "program_name" character varying(255) not null,
    "program_code" character varying(50),
    "semester" integer not null,
    "section" character varying(10) not null,
    "room_number" character varying(50),
    "academic_year" character varying(20) default '2024-25'::character varying,
    "total_students" integer default 0,
    "present_count" integer default 0,
    "absent_count" integer default 0,
    "late_count" integer default 0,
    "excused_count" integer default 0,
    "attendance_percentage" numeric(5,2) default 0.00,
    "status" character varying(20) default 'scheduled'::character varying,
    "remarks" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "college_id" uuid not null
      );



  create table "public"."college_attendance_settings" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid not null,
    "minimum_attendance_percentage" numeric(5,2) default 75.00,
    "late_arrival_threshold_minutes" integer default 15,
    "auto_mark_absent_after_minutes" integer default 30,
    "allow_retroactive_marking" boolean default true,
    "retroactive_days_limit" integer default 7,
    "require_remarks_for_excused" boolean default true,
    "enable_biometric_integration" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."college_breaks" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid not null,
    "timetable_id" uuid,
    "break_type" character varying(20) not null,
    "name" character varying(255) not null,
    "description" text,
    "start_time" time without time zone,
    "end_time" time without time zone,
    "start_date" date,
    "end_date" date,
    "applies_to_all" boolean default true,
    "class_ids" uuid[],
    "is_recurring" boolean default false,
    "recurring_days" integer[],
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."college_breaks" enable row level security;


  create table "public"."college_circulars" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid,
    "title" character varying(255) not null,
    "content" text not null,
    "audience" character varying(50) default 'all'::character varying,
    "priority" character varying(20) default 'medium'::character varying,
    "publish_date" date not null,
    "expire_date" date,
    "attachment_url" text,
    "status" character varying(20) default 'draft'::character varying,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "attachment_filename" text,
    "attachment_file_size" bigint
      );


alter table "public"."college_circulars" enable row level security;


  create table "public"."college_classes" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid not null,
    "name" character varying(255) not null,
    "grade" character varying(50) not null,
    "section" character varying(50),
    "academic_year" character varying(20) not null,
    "max_students" integer default 60,
    "current_students" integer default 0,
    "status" character varying(20) default 'active'::character varying,
    "room_no" character varying(50),
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "department_id" uuid
      );


alter table "public"."college_classes" enable row level security;


  create table "public"."college_course_mappings" (
    "id" uuid not null default gen_random_uuid(),
    "program_id" uuid not null,
    "semester" integer not null,
    "offering_type" character varying(20) not null,
    "faculty_id" uuid,
    "capacity" integer,
    "is_locked" boolean not null default false,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "created_by" uuid,
    "updated_by" uuid,
    "metadata" jsonb default '{}'::jsonb,
    "course_id" uuid not null,
    "current_enrollment" integer default 0
      );



  create table "public"."college_courses" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid not null,
    "course_name" character varying(255) not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "metadata" jsonb default '{}'::jsonb,
    "course_code" character varying(20) not null default 'TBD'::character varying,
    "credits" numeric(3,1) not null default 3.0,
    "description" text,
    "prerequisites" jsonb default '[]'::jsonb,
    "course_type" character varying(20) default 'theory'::character varying,
    "is_active" boolean default true,
    "created_by" uuid,
    "updated_by" uuid
      );



  create table "public"."college_curriculum_outcomes" (
    "id" uuid not null default gen_random_uuid(),
    "curriculum_id" uuid not null,
    "unit_id" uuid not null,
    "outcome_text" text not null,
    "bloom_level" character varying(20),
    "assessment_mappings" jsonb not null default '[]'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "updated_by" uuid
      );



  create table "public"."college_curriculum_units" (
    "id" uuid not null default gen_random_uuid(),
    "curriculum_id" uuid not null,
    "name" character varying(255) not null,
    "code" character varying(50),
    "description" text not null,
    "credits" numeric(4,2),
    "estimated_duration" integer,
    "duration_unit" character varying(10),
    "order_index" integer not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "updated_by" uuid
      );



  create table "public"."college_curriculums" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid not null,
    "department_id" uuid not null,
    "program_id" uuid not null,
    "academic_year" character varying(20) not null,
    "status" character varying(20) default 'draft'::character varying,
    "created_by" uuid not null,
    "approved_by" uuid,
    "approval_date" timestamp with time zone,
    "rejection_reason" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "published_date" timestamp with time zone,
    "archived_date" timestamp with time zone,
    "cloned_from_id" uuid,
    "version" integer default 1,
    "course_id" uuid not null,
    "requested_by" uuid,
    "request_date" timestamp without time zone,
    "request_message" text,
    "reviewed_by" uuid,
    "review_date" timestamp without time zone,
    "review_notes" text,
    "university_id" uuid,
    "pending_changes" jsonb default '[]'::jsonb,
    "change_history" jsonb default '[]'::jsonb,
    "has_pending_changes" boolean default false
      );



  create table "public"."college_event_registrations" (
    "id" uuid not null default gen_random_uuid(),
    "event_id" uuid not null,
    "student_id" uuid not null,
    "registered_at" timestamp with time zone default now(),
    "attended" boolean default false,
    "attendance_marked_at" timestamp with time zone,
    "notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."college_event_registrations" enable row level security;


  create table "public"."college_events" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid,
    "title" character varying(255) not null,
    "description" text,
    "event_type" character varying(50) not null,
    "start_date" timestamp with time zone not null,
    "end_date" timestamp with time zone not null,
    "venue" character varying(255),
    "capacity" integer,
    "status" character varying(20) default 'draft'::character varying,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."college_events" enable row level security;


  create table "public"."college_faculty_class_assignments" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid not null,
    "faculty_id" uuid not null,
    "class_id" uuid not null,
    "subject_name" character varying(255),
    "is_class_teacher" boolean default false,
    "academic_year" character varying(20),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."college_faculty_class_assignments" enable row level security;


  create table "public"."college_faculty_leave_balances" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid not null,
    "faculty_id" uuid not null,
    "leave_type_id" uuid not null,
    "academic_year" character varying(20) not null,
    "total_days" numeric(5,1) default 0,
    "used_days" numeric(5,1) default 0,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."college_faculty_leave_balances" enable row level security;


  create table "public"."college_faculty_leaves" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid not null,
    "faculty_id" uuid not null,
    "leave_type_id" uuid not null,
    "start_date" date not null,
    "end_date" date not null,
    "total_days" numeric(5,1) not null,
    "reason" text,
    "status" character varying(20) default 'pending'::character varying,
    "applied_at" timestamp with time zone default now(),
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone,
    "review_notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."college_faculty_leaves" enable row level security;


  create table "public"."college_faculty_substitutions" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid not null,
    "leave_id" uuid,
    "original_faculty_id" uuid not null,
    "substitute_faculty_id" uuid,
    "timetable_slot_id" uuid,
    "substitution_date" date not null,
    "period_number" integer not null,
    "class_id" uuid,
    "subject_name" character varying(255),
    "status" character varying(20) default 'pending'::character varying,
    "notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."college_faculty_substitutions" enable row level security;


  create table "public"."college_leave_types" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid not null,
    "name" character varying(100) not null,
    "code" character varying(20) not null,
    "max_days_per_year" integer default 12,
    "is_paid" boolean default true,
    "requires_approval" boolean default true,
    "color" character varying(20) default '#6366f1'::character varying,
    "description" text,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."college_leave_types" enable row level security;


  create table "public"."college_lecturer_course_assignments" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "lecturerId" uuid not null,
    "courseId" uuid not null,
    "subject" character varying(100) not null,
    "academicYear" character varying(20) not null,
    "assignedAt" timestamp with time zone default now(),
    "assignedBy" uuid,
    "createdAt" timestamp with time zone default now(),
    "updatedAt" timestamp with time zone default now()
      );


alter table "public"."college_lecturer_course_assignments" enable row level security;


  create table "public"."college_lecturers" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "collegeId" uuid not null,
    "employeeId" character varying(50),
    "department" character varying(100),
    "specialization" character varying(100),
    "qualification" character varying(255),
    "experienceYears" integer,
    "dateOfJoining" date,
    "accountStatus" public.account_status default 'active'::public.account_status,
    "createdAt" timestamp with time zone default now(),
    "updatedAt" timestamp with time zone default now(),
    "metadata" jsonb default '{}'::jsonb,
    "user_id" uuid,
    "degree_certificate_url" text,
    "id_proof_url" text,
    "experience_letters_url" jsonb default '[]'::jsonb,
    "first_name" character varying(255),
    "last_name" character varying(255),
    "email" character varying(255),
    "phone" character varying(20),
    "address" text,
    "date_of_birth" date,
    "gender" character varying(10),
    "designation" character varying(100),
    "subject_expertise" jsonb default '[]'::jsonb,
    "temporary_password" character varying(255),
    "password_created_at" timestamp with time zone,
    "created_by" uuid,
    "verification_status" character varying(50) default 'pending'::character varying,
    "verified_by" uuid,
    "verified_at" timestamp with time zone
      );



  create table "public"."college_lecturers_backup" (
    "id" uuid,
    "userId" uuid,
    "collegeId" uuid,
    "employeeId" character varying(50),
    "department" character varying(100),
    "specialization" character varying(100),
    "qualification" character varying(255),
    "experienceYears" integer,
    "dateOfJoining" date,
    "accountStatus" public.account_status,
    "createdAt" timestamp with time zone,
    "updatedAt" timestamp with time zone,
    "metadata" jsonb,
    "user_id" uuid,
    "degree_certificate_url" text,
    "id_proof_url" text,
    "experience_letters_url" jsonb
      );



  create table "public"."college_lesson_plans" (
    "id" uuid not null default gen_random_uuid(),
    "title" character varying(255) not null,
    "session_date" date not null,
    "duration_minutes" integer,
    "college_id" uuid not null,
    "department_id" uuid not null,
    "program_id" uuid not null,
    "course_id" uuid not null,
    "semester" integer not null,
    "academic_year" character varying(20) not null,
    "curriculum_id" uuid,
    "unit_id" uuid,
    "selected_learning_outcomes" uuid[] default '{}'::uuid[],
    "session_objectives" text not null,
    "teaching_methodology" text not null,
    "required_materials" text,
    "resource_files" jsonb default '[]'::jsonb,
    "resource_links" jsonb default '[]'::jsonb,
    "evaluation_criteria" text,
    "evaluation_items" jsonb default '[]'::jsonb,
    "follow_up_activities" text,
    "additional_notes" text,
    "status" character varying(20) default 'draft'::character varying,
    "created_by" uuid not null,
    "updated_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "published_at" timestamp with time zone,
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."college_lesson_plans" enable row level security;


  create table "public"."college_mentor_notes" (
    "id" uuid not null default gen_random_uuid(),
    "allocation_id" uuid not null,
    "mentor_id" uuid not null,
    "student_id" uuid not null,
    "title" character varying(255),
    "note_text" text not null,
    "outcome" text,
    "intervention_type" character varying(50) default 'academic'::character varying,
    "status" character varying(20) default 'pending'::character varying,
    "is_private" boolean default false,
    "note_date" date default CURRENT_DATE,
    "created_at" timestamp with time zone default now(),
    "created_by_role" character varying(20) default 'admin'::character varying,
    "created_by_id" uuid,
    "last_updated_by" uuid,
    "last_updated_at" timestamp with time zone default now(),
    "priority" character varying(20) default 'medium'::character varying,
    "follow_up_required" boolean default false,
    "follow_up_date" date,
    "admin_feedback" text,
    "educator_response" text,
    "action_taken" text,
    "next_steps" text,
    "resolved_at" timestamp with time zone,
    "resolved_by" uuid
      );



  create table "public"."college_mentor_periods" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid not null,
    "name" character varying(100) not null,
    "academic_year" character varying(20) not null,
    "start_date" date not null,
    "end_date" date not null,
    "default_mentor_capacity" integer default 15,
    "default_office_location" character varying(255),
    "default_available_hours" text,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "created_by" uuid
      );



  create table "public"."college_mentor_student_allocations" (
    "id" uuid not null default gen_random_uuid(),
    "mentor_id" uuid not null,
    "student_id" uuid not null,
    "period_id" uuid not null,
    "assigned_date" date default CURRENT_DATE,
    "assigned_by" uuid,
    "status" character varying(20) default 'active'::character varying,
    "transfer_reason" text,
    "completion_date" date,
    "created_at" timestamp with time zone default now()
      );



  create table "public"."college_role_module_permissions" (
    "id" uuid not null default gen_random_uuid(),
    "role_type" public.user_role not null,
    "module_id" uuid,
    "permission_id" uuid,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );



  create table "public"."college_role_scope_rules" (
    "id" uuid not null default gen_random_uuid(),
    "role_type" public.user_role not null,
    "scope_type" character varying(20) not null,
    "scope_value" character varying(100) not null,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );



  create table "public"."college_setting_modules" (
    "id" uuid not null default gen_random_uuid(),
    "module_name" character varying(100) not null,
    "description" text,
    "is_active" boolean default true,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );



  create table "public"."college_setting_permissions" (
    "id" uuid not null default gen_random_uuid(),
    "permission_name" character varying(50) not null,
    "description" text,
    "created_at" timestamp without time zone default now()
      );



  create table "public"."college_student_assignments" (
    "student_assignment_id" uuid not null default gen_random_uuid(),
    "assignment_id" uuid not null,
    "student_id" uuid not null,
    "status" text not null default 'todo'::text,
    "priority" text not null default 'medium'::text,
    "grade_received" numeric(7,2),
    "grade_percentage" numeric(5,2),
    "instructor_feedback" text,
    "feedback_date" timestamp with time zone,
    "graded_by" uuid,
    "graded_date" timestamp with time zone,
    "submission_date" timestamp with time zone,
    "submission_type" text,
    "submission_content" text,
    "submission_url" text,
    "submission_files" jsonb,
    "is_late" boolean not null default false,
    "late_penalty" numeric(5,2),
    "assigned_date" timestamp with time zone not null default now(),
    "started_date" timestamp with time zone,
    "completed_date" timestamp with time zone,
    "updated_date" timestamp with time zone not null default now(),
    "is_deleted" boolean not null default false
      );


alter table "public"."college_student_assignments" enable row level security;


  create table "public"."college_time_periods" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid not null,
    "timetable_id" uuid,
    "period_number" integer not null,
    "period_name" character varying(50),
    "start_time" time without time zone not null,
    "end_time" time without time zone not null,
    "is_break" boolean default false,
    "break_type" character varying(20),
    "sort_order" integer,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."college_time_periods" enable row level security;


  create table "public"."college_timetable_slots" (
    "id" uuid not null default gen_random_uuid(),
    "timetable_id" uuid,
    "educator_id" uuid,
    "class_id" uuid,
    "day_of_week" integer not null,
    "period_number" integer not null,
    "start_time" time without time zone not null,
    "end_time" time without time zone not null,
    "subject_name" character varying(255) not null,
    "room_number" character varying(50),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "schedule_date" date,
    "is_recurring" boolean default true,
    "recurring_end_date" date,
    "color" character varying(20)
      );


alter table "public"."college_timetable_slots" enable row level security;


  create table "public"."college_timetables" (
    "id" uuid not null default gen_random_uuid(),
    "college_id" uuid,
    "academic_year" character varying(20) not null,
    "term" character varying(50) not null,
    "start_date" date not null,
    "end_date" date not null,
    "status" character varying(20) default 'draft'::character varying,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."college_timetables" enable row level security;


  create table "public"."companies" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "name" character varying(255) not null,
    "code" character varying(50) not null,
    "industry" character varying(100),
    "companySize" character varying(50),
    "hqAddress" text,
    "hqCity" character varying(100),
    "hqState" character varying(100),
    "hqCountry" character varying(100) default 'India'::character varying,
    "hqPincode" character varying(10),
    "phone" character varying(20),
    "email" character varying(255),
    "website" character varying(255),
    "establishedYear" integer,
    "contactPersonName" character varying(200),
    "contactPersonDesignation" character varying(100),
    "contactPersonEmail" character varying(255),
    "contactPersonPhone" character varying(20),
    "accountStatus" public.account_status default 'pending'::public.account_status,
    "createdAt" timestamp with time zone default now(),
    "updatedAt" timestamp with time zone default now(),
    "metadata" jsonb default '{}'::jsonb,
    "approvalStatus" public.approval_status default 'pending'::public.approval_status,
    "approvedBy" uuid,
    "approvedAt" timestamp with time zone,
    "totalBranches" integer default 0,
    "totalRecruiters" integer default 0,
    "hqRecruiters" integer default 0,
    "branchRecruiters" integer default 0,
    "created_by" uuid,
    "updated_by" uuid
      );



  create table "public"."company_branches" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "companyId" uuid not null,
    "name" character varying(255) not null,
    "code" character varying(50) not null,
    "branchType" character varying(50),
    "address" text,
    "city" character varying(100),
    "state" character varying(100),
    "country" character varying(100) default 'India'::character varying,
    "pincode" character varying(10),
    "phone" character varying(20),
    "email" character varying(255),
    "branchHeadName" character varying(200),
    "branchHeadEmail" character varying(255),
    "branchHeadPhone" character varying(20),
    "accountStatus" public.account_status default 'active'::public.account_status,
    "createdAt" timestamp with time zone default now(),
    "updatedAt" timestamp with time zone default now(),
    "metadata" jsonb default '{}'::jsonb
      );



  create table "public"."competition_clubs" (
    "id" uuid not null default gen_random_uuid(),
    "comp_id" uuid not null,
    "club_id" uuid not null,
    "registered_at" timestamp with time zone default now(),
    "registered_by_type" character varying(20),
    "registered_by_educator_id" uuid,
    "registered_by_admin_id" uuid
      );


alter table "public"."competition_clubs" enable row level security;


  create table "public"."competition_registrations" (
    "registration_id" uuid not null default gen_random_uuid(),
    "comp_id" uuid not null,
    "student_email" character varying(255) not null,
    "team_name" character varying(255),
    "team_members" jsonb default '[]'::jsonb,
    "registration_date" timestamp with time zone default now(),
    "registered_by_type" character varying(20),
    "registered_by_educator_id" uuid,
    "registered_by_admin_id" uuid,
    "status" character varying(20) default 'registered'::character varying,
    "notes" text,
    "special_requirements" text
      );


alter table "public"."competition_registrations" enable row level security;


  create table "public"."competition_results" (
    "result_id" uuid not null default gen_random_uuid(),
    "comp_id" uuid not null,
    "registration_id" uuid,
    "student_email" character varying(255) not null,
    "rank" integer,
    "score" numeric(10,2),
    "award" character varying(255),
    "category" character varying(100),
    "performance_notes" text,
    "certificate_issued" boolean default false,
    "certificate_id" uuid,
    "recorded_at" timestamp with time zone default now(),
    "recorded_by_type" character varying(20),
    "recorded_by_educator_id" uuid,
    "recorded_by_admin_id" uuid
      );



  create table "public"."competitions" (
    "comp_id" uuid not null default gen_random_uuid(),
    "school_id" uuid not null,
    "name" character varying(255) not null,
    "description" text,
    "level" character varying(50) not null,
    "category" character varying(50),
    "competition_date" date not null,
    "registration_deadline" date,
    "venue" character varying(255),
    "team_size_min" integer default 1,
    "team_size_max" integer default 1,
    "eligibility_criteria" text,
    "rules" text,
    "prizes" jsonb default '[]'::jsonb,
    "status" character varying(20) default 'upcoming'::character varying,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by_type" character varying(20),
    "created_by_educator_id" uuid,
    "created_by_admin_id" uuid
      );


alter table "public"."competitions" enable row level security;


  create table "public"."conversations" (
    "id" text not null,
    "student_id" uuid,
    "recruiter_id" uuid,
    "application_id" integer,
    "opportunity_id" integer,
    "subject" text,
    "status" text default 'active'::text,
    "last_message_at" timestamp with time zone,
    "last_message_preview" text,
    "last_message_sender" text,
    "student_unread_count" integer default 0,
    "recruiter_unread_count" integer default 0,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "deleted_by_student" boolean not null default false,
    "deleted_by_recruiter" boolean not null default false,
    "student_deleted_at" timestamp with time zone,
    "recruiter_deleted_at" timestamp with time zone,
    "educator_id" uuid,
    "class_id" uuid,
    "conversation_type" character varying(50) default 'student_recruiter'::character varying,
    "educator_unread_count" integer default 0,
    "deleted_by_educator" boolean default false,
    "educator_deleted_at" timestamp with time zone,
    "school_id" uuid,
    "admin_unread_count" integer default 0,
    "deleted_by_admin" boolean default false,
    "admin_deleted_at" timestamp with time zone,
    "college_id" uuid,
    "college_admin_unread_count" integer default 0,
    "deleted_by_college_admin" boolean default false,
    "college_admin_deleted_at" timestamp with time zone,
    "program_section_id" uuid,
    "college_educator_unread_count" integer default 0,
    "deleted_by_college_educator" boolean default false,
    "college_educator_deleted_at" timestamp with time zone
      );



  create table "public"."conversations_backup_20251106" (
    "id" text,
    "student_id" uuid,
    "recruiter_id" uuid,
    "application_id" integer,
    "opportunity_id" integer,
    "subject" text,
    "status" text,
    "last_message_at" timestamp with time zone,
    "last_message_preview" text,
    "last_message_sender" text,
    "student_unread_count" integer,
    "recruiter_unread_count" integer,
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone
      );



  create table "public"."course_classes" (
    "course_class_id" uuid not null default gen_random_uuid(),
    "course_id" uuid not null,
    "class_name" character varying(100) not null,
    "created_at" timestamp with time zone default timezone('utc'::text, now())
      );



  create table "public"."course_co_educators" (
    "co_educator_id" uuid not null default gen_random_uuid(),
    "course_id" uuid not null,
    "educator_id" uuid not null,
    "educator_name" character varying(255),
    "created_at" timestamp with time zone default timezone('utc'::text, now())
      );


alter table "public"."course_co_educators" enable row level security;


  create table "public"."course_enrollments" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "student_name" text,
    "student_email" text not null,
    "course_id" uuid not null,
    "course_title" text,
    "educator_id" uuid,
    "educator_name" text,
    "enrolled_at" timestamp with time zone default now(),
    "last_accessed" timestamp with time zone default now(),
    "completed_at" timestamp with time zone,
    "progress" integer default 0,
    "completed_lessons" text[] default '{}'::text[],
    "total_lessons" integer default 0,
    "status" text default 'active'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "training_id" uuid,
    "skills_acquired" jsonb default '[]'::jsonb,
    "certificate_url" text,
    "grade" character varying(10),
    "last_module_index" integer default 0,
    "last_lesson_index" integer default 0,
    "last_lesson_id" uuid,
    "last_video_position" integer default 0,
    "total_time_spent_seconds" integer default 0,
    "sessions_count" integer default 1,
    "average_session_duration" integer default 0,
    "embedding" extensions.vector(1536)
      );



  create table "public"."course_modules" (
    "module_id" uuid not null default gen_random_uuid(),
    "course_id" uuid not null,
    "title" character varying(255) not null,
    "description" text,
    "order_index" integer not null default 0,
    "skill_tags" jsonb default '[]'::jsonb,
    "activities" jsonb default '[]'::jsonb,
    "created_at" timestamp with time zone default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone default timezone('utc'::text, now())
      );



  create table "public"."course_skills" (
    "course_skill_id" uuid not null default gen_random_uuid(),
    "course_id" uuid not null,
    "skill_name" character varying(100) not null,
    "proficiency_level" character varying(50),
    "created_at" timestamp with time zone default timezone('utc'::text, now())
      );



  create table "public"."courses" (
    "course_id" uuid not null default gen_random_uuid(),
    "title" character varying(255) not null,
    "code" character varying(50) not null,
    "description" text not null,
    "thumbnail" text,
    "status" character varying(20) default 'Draft'::character varying,
    "duration" character varying(50) not null,
    "enrollment_count" integer default 0,
    "completion_rate" integer default 0,
    "evidence_pending" integer default 0,
    "skills_mapped" integer default 0,
    "total_skills" integer default 0,
    "educator_id" uuid,
    "created_at" timestamp with time zone default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone default timezone('utc'::text, now()),
    "deleted_at" timestamp with time zone,
    "target_outcomes" jsonb default '[]'::jsonb,
    "university" text,
    "credits" numeric,
    "category" text,
    "approval_status" text default 'pending'::text,
    "rejection_reason" text,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "rejected_by" uuid,
    "rejected_at" timestamp with time zone,
    "skill_type" character varying(20) default 'soft'::character varying,
    "school_id" uuid,
    "embedding" extensions.vector(1536)
      );



  create table "public"."curriculum_academic_years" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid,
    "year" character varying(20) not null,
    "start_date" date,
    "end_date" date,
    "is_active" boolean default true,
    "is_current" boolean default false,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );


alter table "public"."curriculum_academic_years" enable row level security;


  create table "public"."curriculum_chapters" (
    "id" uuid not null default gen_random_uuid(),
    "curriculum_id" uuid not null,
    "name" character varying(200) not null,
    "code" character varying(50),
    "description" text not null,
    "order_number" integer not null,
    "estimated_duration" integer,
    "duration_unit" character varying(10),
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );



  create table "public"."curriculum_classes" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid,
    "name" character varying(50) not null,
    "description" text,
    "is_active" boolean default true,
    "display_order" integer default 0,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );


alter table "public"."curriculum_classes" enable row level security;


  create table "public"."curriculum_courses" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "college_id" uuid,
    "department_id" uuid,
    "program_id" uuid,
    "course_code" character varying(50) not null,
    "course_name" character varying(255) not null,
    "course_type" character varying(50),
    "semester" integer,
    "credits" numeric(4,2) default 0,
    "contact_hours" integer default 0,
    "syllabus" text,
    "learning_outcomes" jsonb default '[]'::jsonb,
    "prerequisites" jsonb default '[]'::jsonb,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid
      );



  create table "public"."curriculum_learning_outcomes" (
    "id" uuid not null default gen_random_uuid(),
    "chapter_id" uuid not null,
    "outcome" text not null,
    "bloom_level" character varying(20),
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );



  create table "public"."curriculum_subjects" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid,
    "name" character varying(100) not null,
    "description" text,
    "is_active" boolean default true,
    "display_order" integer default 0,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );


alter table "public"."curriculum_subjects" enable row level security;


  create table "public"."curriculums" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid not null,
    "subject" character varying(100) not null,
    "class" character varying(10) not null,
    "academic_year" character varying(20) not null,
    "status" character varying(20) default 'draft'::character varying,
    "created_by" uuid,
    "approved_by" uuid,
    "approval_date" timestamp without time zone,
    "rejection_reason" text,
    "last_modified" timestamp without time zone default now(),
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );



  create table "public"."department_budgets" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "department_id" uuid not null,
    "department_name" text not null,
    "financial_year" text not null,
    "period_from" date not null,
    "period_to" date not null,
    "quarter" text,
    "budget_heads" jsonb not null default '[]'::jsonb,
    "total_allocated" numeric(12,2) not null,
    "total_spent" numeric(12,2) default 0,
    "total_remaining" numeric(12,2) generated always as ((total_allocated - total_spent)) stored,
    "utilization_percentage" numeric(5,2) generated always as (
CASE
    WHEN (total_allocated > (0)::numeric) THEN ((total_spent / total_allocated) * (100)::numeric)
    ELSE (0)::numeric
END) stored,
    "carry_forward_amount" numeric(12,2) default 0,
    "carry_forward_from" text,
    "status" text default 'draft'::text,
    "is_locked" boolean default false,
    "submitted_by" uuid,
    "submitted_at" timestamp with time zone,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "approval_remarks" text,
    "revision_number" integer default 1,
    "previous_budget_id" uuid,
    "revision_reason" text,
    "alert_threshold_percentage" numeric(5,2) default 80,
    "alert_sent" boolean default false,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."department_faculty_assignments" (
    "id" uuid not null default gen_random_uuid(),
    "department_id" uuid not null,
    "lecturer_id" uuid not null,
    "assignment_type" character varying(50) default 'faculty'::character varying,
    "assigned_at" timestamp with time zone default now(),
    "assigned_by" uuid,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "metadata" jsonb default '{}'::jsonb,
    "is_hod" boolean default false
      );



  create table "public"."departments" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid,
    "name" character varying(255) not null,
    "code" character varying(50) not null,
    "description" text,
    "status" character varying(50) default 'active'::character varying,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "metadata" jsonb,
    "created_by" uuid,
    "updated_by" uuid,
    "college_id" uuid
      );



  create table "public"."document_access_history" (
    "id" uuid not null default gen_random_uuid(),
    "document_id" uuid not null,
    "user_id" uuid not null,
    "access_type" character varying(50) not null,
    "accessed_at" timestamp with time zone default now(),
    "ip_address" text,
    "user_agent" text,
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."document_access_history" enable row level security;


  create table "public"."education" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "level" character varying(50),
    "degree" character varying(100),
    "department" character varying(100),
    "university" character varying(150),
    "year_of_passing" character varying(10),
    "cgpa" character varying(10),
    "status" character varying(50),
    "approval_status" character varying(20) default 'pending'::character varying,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "enabled" boolean default true,
    "pending_edit_data" jsonb,
    "has_pending_edit" boolean default false,
    "verified_data" jsonb
      );



  create table "public"."embedding_cache" (
    "id" uuid not null default gen_random_uuid(),
    "text_hash" text not null,
    "cache_type" text not null,
    "embedding" extensions.vector(768) not null,
    "text_preview" text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."embedding_cache" enable row level security;


  create table "public"."embedding_queue" (
    "id" uuid not null default gen_random_uuid(),
    "table_name" text not null,
    "record_id" uuid not null,
    "priority" integer default 5,
    "status" text default 'pending'::text,
    "attempts" integer default 0,
    "max_attempts" integer default 3,
    "error_message" text,
    "created_at" timestamp with time zone default now(),
    "processed_at" timestamp with time zone,
    "operation" text not null default 'update'::text,
    "max_retries" integer not null default 3,
    "model_used" text,
    "started_at" timestamp with time zone,
    "next_retry_at" timestamp with time zone
      );



  create table "public"."event_registrations" (
    "id" uuid not null default gen_random_uuid(),
    "full_name" character varying(255) not null,
    "email" character varying(255) not null,
    "phone" character varying(20) not null,
    "plan_type" character varying(50) not null,
    "plan_amount" integer not null,
    "razorpay_order_id" character varying(255),
    "razorpay_payment_id" character varying(255),
    "event_name" character varying(255),
    "notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "role_type" character varying(50),
    "address" text,
    "city" text,
    "state" text,
    "student_tier_id" uuid,
    "student_count_min" integer,
    "student_count_max" integer,
    "role_details" jsonb default '{}'::jsonb,
    "pincode" character varying(10),
    "institution_name" character varying(255),
    "user_id" uuid,
    "student_count" integer,
    "price_per_student" numeric(10,2),
    "payment_status" public.payment_status_enum not null default 'pending'::public.payment_status_enum
      );



  create table "public"."exam_registrations" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "exam_window_id" uuid not null,
    "student_id" uuid not null,
    "assessment_id" uuid,
    "student_name" text not null,
    "roll_number" text not null,
    "program_id" uuid,
    "semester" integer not null,
    "registration_date" date not null default CURRENT_DATE,
    "registration_number" text not null,
    "registration_type" text default 'regular'::text,
    "registration_fee" numeric(10,2) default 0,
    "late_fee" numeric(10,2) default 0,
    "total_fee" numeric(10,2) default 0,
    "fee_paid" boolean default false,
    "payment_reference" text,
    "payment_date" date,
    "status" text default 'registered'::text,
    "hall_ticket_number" text,
    "hall_ticket_issued" boolean default false,
    "hall_ticket_issued_date" date,
    "hall_ticket_url" text,
    "special_requirements" text,
    "has_disability" boolean default false,
    "disability_details" text,
    "extra_time_minutes" integer default 0,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "student_record_id" uuid
      );



  create table "public"."exam_rooms" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "room_code" text not null,
    "room_name" text not null,
    "building" text,
    "floor" text,
    "school_id" uuid,
    "college_id" uuid,
    "total_capacity" integer not null,
    "exam_capacity" integer not null,
    "has_projector" boolean default false,
    "has_ac" boolean default false,
    "has_cctv" boolean default false,
    "has_backup_power" boolean default false,
    "is_accessible" boolean default true,
    "accessibility_features" text[],
    "status" text default 'active'::text,
    "location_description" text,
    "map_url" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."exam_seating_arrangements" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "exam_timetable_id" uuid not null,
    "exam_room_id" uuid not null,
    "student_id" uuid not null,
    "student_name" text not null,
    "roll_number" text not null,
    "hall_ticket_number" text,
    "seat_number" text not null,
    "row_number" text,
    "column_number" text,
    "attendance_status" text default 'expected'::text,
    "marked_at" timestamp with time zone,
    "marked_by" uuid,
    "has_special_arrangement" boolean default false,
    "special_arrangement_details" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "student_record_id" uuid
      );



  create table "public"."exam_timetable" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "assessment_id" uuid not null,
    "course_id" uuid,
    "course_name" text not null,
    "course_code" text not null,
    "exam_date" date not null,
    "start_time" time without time zone not null,
    "end_time" time without time zone not null,
    "duration_minutes" integer not null,
    "room" text not null,
    "building" text,
    "capacity" integer,
    "batch_section" text,
    "invigilators" uuid[] default '{}'::uuid[],
    "chief_invigilator" uuid,
    "status" text default 'scheduled'::text,
    "special_instructions" text,
    "seating_arrangement" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "subject_id" uuid,
    "school_id" uuid,
    "class_id" uuid
      );



  create table "public"."exam_windows" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "window_name" text not null,
    "window_code" text not null,
    "academic_year" text not null,
    "semester" text not null,
    "assessment_type_id" uuid,
    "assessment_type_name" text not null,
    "start_date" date not null,
    "end_date" date not null,
    "registration_start_date" date,
    "registration_end_date" date,
    "department_id" uuid,
    "program_id" uuid,
    "school_id" uuid,
    "college_id" uuid,
    "status" text default 'draft'::text,
    "is_published" boolean default false,
    "allow_late_registration" boolean default false,
    "late_fee_amount" numeric(10,2) default 0,
    "instructions" text,
    "special_notes" text,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."expenditures" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "department_id" uuid not null,
    "budget_id" uuid not null,
    "budget_head_id" text not null,
    "budget_head_name" text not null,
    "expenditure_number" text not null,
    "expenditure_date" date not null default CURRENT_DATE,
    "vendor_name" text not null,
    "vendor_contact" text,
    "vendor_email" text,
    "vendor_gstin" text,
    "amount" numeric(12,2) not null,
    "tax_amount" numeric(12,2) default 0,
    "total_amount" numeric(12,2) generated always as ((amount + tax_amount)) stored,
    "category" text not null,
    "sub_category" text,
    "description" text not null,
    "purpose" text,
    "invoice_number" text,
    "invoice_date" date,
    "invoice_file_id" text,
    "invoice_url" text,
    "payment_mode" text,
    "payment_reference" text,
    "payment_date" date,
    "payment_status" text default 'pending'::text,
    "status" text default 'draft'::text,
    "submitted_by" uuid,
    "submitted_at" timestamp with time zone,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "approval_remarks" text,
    "rejected_reason" text,
    "is_override" boolean default false,
    "override_reason" text,
    "override_approved_by" uuid,
    "override_approved_at" timestamp with time zone,
    "is_reimbursement" boolean default false,
    "reimbursement_to" uuid,
    "reimbursement_status" text,
    "attachments" jsonb default '[]'::jsonb,
    "remarks" text,
    "recorded_by" uuid not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."experience" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "organization" character varying(150),
    "role" character varying(150),
    "start_date" date,
    "end_date" date,
    "duration" character varying(100),
    "verified" boolean default false,
    "approval_status" character varying(20) default 'pending'::character varying,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "approval_authority" character varying(20),
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "rejected_by" uuid,
    "rejected_at" timestamp with time zone,
    "approval_notes" text,
    "description" text,
    "enabled" boolean default true,
    "pending_edit_data" jsonb,
    "has_pending_edit" boolean default false,
    "verified_data" jsonb
      );


alter table "public"."experience" enable row level security;


  create table "public"."export_activities" (
    "id" integer not null default nextval('public.export_activities_id_seq'::regclass),
    "shortlist_id" text not null,
    "export_format" text not null,
    "export_type" text not null,
    "exported_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "exported_by" text,
    "include_pii" boolean default false
      );


alter table "public"."export_activities" enable row level security;


  create table "public"."external_assessment_attempts" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "student_id" uuid not null,
    "course_name" text not null,
    "course_id" uuid,
    "assessment_level" text not null,
    "total_questions" integer not null default 15,
    "questions" jsonb not null,
    "student_answers" jsonb not null,
    "score" integer,
    "correct_answers" integer,
    "time_taken" integer,
    "started_at" timestamp with time zone not null default now(),
    "completed_at" timestamp with time zone default now(),
    "difficulty_breakdown" jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "current_question_index" integer default 0,
    "status" text default 'in_progress'::text,
    "time_remaining" integer default 900,
    "last_activity_at" timestamp with time zone default now()
      );


alter table "public"."external_assessment_attempts" enable row level security;


  create table "public"."external_courses" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "course_name" character varying(255) not null,
    "organization" character varying(255) not null,
    "course_url" text,
    "start_date" date,
    "completion_date" date,
    "duration" character varying(100),
    "certificate_url" text,
    "grade" character varying(10),
    "skills_acquired" jsonb default '[]'::jsonb,
    "training_id" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."fee_payments" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "ledger_id" uuid not null,
    "student_id" uuid not null,
    "amount" numeric(10,2) not null,
    "mode" text not null,
    "reference_number" text,
    "transaction_id" text,
    "bank_name" text,
    "cheque_number" text,
    "cheque_date" date,
    "dd_number" text,
    "receipt_number" text not null,
    "receipt_url" text,
    "paid_at" timestamp with time zone not null default now(),
    "payment_date" date not null default CURRENT_DATE,
    "is_verified" boolean default false,
    "verified_by" uuid,
    "verified_at" timestamp with time zone,
    "is_reconciled" boolean default false,
    "reconciled_by" uuid,
    "reconciled_at" timestamp with time zone,
    "status" text default 'completed'::text,
    "remarks" text,
    "recorded_by" uuid not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."fee_structures" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "program_id" uuid,
    "program_name" text not null,
    "semester" integer not null,
    "academic_year" text not null,
    "category" text not null,
    "quota" text,
    "fee_heads" jsonb not null default '[]'::jsonb,
    "total_amount" numeric(10,2) not null,
    "due_schedule" jsonb default '[]'::jsonb,
    "scholarship_applicable" boolean default false,
    "scholarship_amount" numeric(10,2) default 0,
    "discount_percentage" numeric(5,2) default 0,
    "is_active" boolean default true,
    "effective_from" date not null,
    "effective_to" date,
    "created_by" uuid,
    "approved_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "college_id" uuid
      );



  create table "public"."generated_external_assessment" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "certificate_name" text not null,
    "course_id" uuid,
    "assessment_level" text not null default 'Intermediate'::text,
    "total_questions" integer not null default 15,
    "questions" jsonb not null,
    "generated_at" timestamp with time zone not null default now(),
    "generated_by" text,
    "version" integer default 1,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."grading_systems" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "system_name" text not null,
    "system_code" text not null,
    "grade_label" text not null,
    "min_marks" numeric(5,2) not null,
    "max_marks" numeric(5,2) not null,
    "grade_point" numeric(3,2) not null,
    "is_pass" boolean default true,
    "is_distinction" boolean default false,
    "applicable_to" text default 'all'::text,
    "is_default" boolean default false,
    "is_active" boolean default true,
    "display_order" integer default 0,
    "color_code" text,
    "description" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."institution_pricing_tiers" (
    "id" uuid not null default gen_random_uuid(),
    "role_type" text not null,
    "tier_name" text not null,
    "min_students" integer not null,
    "max_students" integer not null,
    "price" integer not null,
    "price_per_student" numeric(10,2),
    "duration" text not null default 'month'::text,
    "features" jsonb default '[]'::jsonb,
    "is_recommended" boolean default false,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "esfe_price" integer,
    "esfe_discount_percent" integer default 0,
    "esfe_active" boolean default false
      );



  create table "public"."internships" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid,
    "student_email" text not null,
    "company_name" text not null,
    "role" text not null,
    "location" text,
    "internship_type" text,
    "start_date" date,
    "end_date" date,
    "duration" text,
    "stipend" text,
    "responsibilities" text,
    "achievements" text,
    "skills_learned" text,
    "offer_letter_url" text,
    "recommendation_letter_url" text,
    "enabled" boolean default true,
    "approval_status" text default 'pending'::text,
    "processing" boolean default false,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone,
    "rejection_reason" text,
    "admin_notes" text
      );


alter table "public"."internships" enable row level security;


  create table "public"."interview_reminders" (
    "id" integer not null default nextval('public.interview_reminders_id_seq'::regclass),
    "interview_id" text not null,
    "sent_to" text not null,
    "sent_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "reminder_type" text not null,
    "status" text default 'sent'::text,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now())
      );


alter table "public"."interview_reminders" enable row level security;


  create table "public"."interviews" (
    "id" text not null,
    "student_id" uuid,
    "candidate_name" text not null,
    "candidate_email" text,
    "candidate_phone" text,
    "job_title" text not null,
    "interviewer" text not null,
    "interviewer_email" text,
    "date" timestamp with time zone not null,
    "duration" integer default 60,
    "status" text default 'scheduled'::text,
    "type" text not null,
    "meeting_type" text,
    "meeting_link" text,
    "meeting_notes" text,
    "reminders_sent" integer default 0,
    "completed_date" timestamp with time zone,
    "scorecard" jsonb,
    "created_by" text,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
      );


alter table "public"."interviews" enable row level security;


  create table "public"."invigilator_assignments" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "exam_timetable_id" uuid not null,
    "exam_room_id" uuid,
    "invigilator_id" uuid not null,
    "invigilator_name" text not null,
    "invigilator_type" text default 'regular'::text,
    "duty_date" date not null,
    "duty_start_time" time without time zone not null,
    "duty_end_time" time without time zone not null,
    "attendance_status" text default 'assigned'::text,
    "check_in_time" timestamp with time zone,
    "check_out_time" timestamp with time zone,
    "duty_hours" numeric(4,2),
    "compensation_amount" numeric(10,2) default 0,
    "compensation_paid" boolean default false,
    "remarks" text,
    "issues_reported" text,
    "assigned_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "lecturer_record_id" uuid
      );



  create table "public"."lesson_plans" (
    "id" uuid not null default gen_random_uuid(),
    "educator_id" uuid,
    "class_id" uuid,
    "title" character varying(200) not null,
    "subject" character varying(100) not null,
    "class_name" character varying(50) not null,
    "date" date not null,
    "duration" integer not null,
    "learning_objectives" text not null,
    "activities" jsonb not null default '[]'::jsonb,
    "resources" jsonb not null default '[]'::jsonb,
    "assessment_methods" text,
    "homework" text,
    "notes" text,
    "status" character varying(20) default 'draft'::character varying,
    "submitted_at" timestamp without time zone,
    "reviewed_by" uuid,
    "reviewed_at" timestamp without time zone,
    "review_comments" text,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now(),
    "chapter_id" uuid,
    "chapter_name" character varying(255),
    "selected_learning_outcomes" jsonb default '[]'::jsonb,
    "teaching_methodology" text,
    "required_materials" text,
    "resource_files" jsonb default '[]'::jsonb,
    "resource_links" jsonb default '[]'::jsonb,
    "evaluation_criteria" text,
    "evaluation_items" jsonb default '[]'::jsonb,
    "differentiation_notes" text
      );



  create table "public"."lesson_resources" (
    "resource_id" uuid not null default gen_random_uuid(),
    "lesson_id" uuid not null,
    "name" character varying(255) not null,
    "type" character varying(20) not null,
    "url" text not null,
    "file_size" character varying(50),
    "thumbnail_url" text,
    "embed_url" text,
    "order_index" integer default 0,
    "created_at" timestamp with time zone default timezone('utc'::text, now()),
    "content" text
      );



  create table "public"."lessons" (
    "lesson_id" uuid not null default gen_random_uuid(),
    "module_id" uuid not null,
    "title" character varying(255) not null,
    "description" text,
    "content" text,
    "duration" character varying(50),
    "order_index" integer not null default 0,
    "created_at" timestamp with time zone default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone default timezone('utc'::text, now())
      );



  create table "public"."library_book_issues" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "book_id" uuid not null,
    "student_id" uuid not null,
    "student_name" text not null,
    "roll_number" text not null,
    "class" text not null,
    "academic_year" text not null,
    "issue_date" date not null default CURRENT_DATE,
    "due_date" date not null,
    "return_date" date,
    "status" text default 'issued'::text,
    "fine_amount" numeric(10,2) default 0,
    "fine_paid" boolean default false,
    "remarks" text,
    "issued_by" text,
    "returned_by" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."library_book_issues_college" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "college_id" uuid not null,
    "book_id" uuid not null,
    "student_id" text not null,
    "student_name" text not null,
    "roll_number" text not null,
    "class" text not null,
    "academic_year" text not null,
    "issue_date" date not null default CURRENT_DATE,
    "due_date" date not null,
    "return_date" date,
    "status" text default 'issued'::text,
    "fine_amount" numeric(10,2) default 0,
    "fine_paid" boolean default false,
    "remarks" text,
    "issued_by" text,
    "returned_by" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."library_book_issues_school" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "school_id" uuid not null,
    "book_id" uuid not null,
    "student_id" text not null,
    "student_name" text not null,
    "roll_number" text not null,
    "class" text not null,
    "academic_year" text not null,
    "issue_date" date not null default CURRENT_DATE,
    "due_date" date not null,
    "return_date" date,
    "status" text default 'issued'::text,
    "fine_amount" numeric(10,2) default 0,
    "fine_paid" boolean default false,
    "remarks" text,
    "issued_by" text,
    "returned_by" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."library_books" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "book_id" text not null,
    "isbn" text,
    "isbn13" text,
    "title" text not null,
    "subtitle" text,
    "author" text not null,
    "co_authors" text[],
    "publisher" text,
    "edition" text,
    "publication_year" integer,
    "language" text default 'English'::text,
    "category" text not null,
    "sub_category" text,
    "subject" text,
    "department_id" uuid,
    "pages" integer,
    "binding_type" text,
    "dimensions" text,
    "weight" text,
    "total_copies" integer not null default 1,
    "available_copies" integer not null default 1,
    "issued_copies" integer generated always as ((total_copies - available_copies)) stored,
    "damaged_copies" integer default 0,
    "lost_copies" integer default 0,
    "location" text not null,
    "rack_number" text,
    "floor" text,
    "section" text,
    "price" numeric(10,2),
    "currency" text default 'INR'::text,
    "acquisition_date" date,
    "acquisition_type" text,
    "vendor_name" text,
    "bill_number" text,
    "description" text,
    "keywords" text[],
    "table_of_contents" text,
    "cover_image_url" text,
    "ebook_url" text,
    "has_ebook" boolean default false,
    "status" text default 'available'::text,
    "is_reference_only" boolean default false,
    "is_popular" boolean default false,
    "average_rating" numeric(2,1) default 0,
    "total_reviews" integer default 0,
    "total_issues" integer default 0,
    "total_reservations" integer default 0,
    "last_issued_date" date,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "college_id" uuid
      );



  create table "public"."library_books_college" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "college_id" uuid not null,
    "title" text not null,
    "author" text not null,
    "isbn" text not null,
    "total_copies" integer not null default 1,
    "available_copies" integer not null default 1,
    "status" text default 'available'::text,
    "category" text,
    "publisher" text,
    "publication_year" integer,
    "description" text,
    "location_shelf" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."library_books_school" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "school_id" uuid not null,
    "title" text not null,
    "author" text not null,
    "isbn" text not null,
    "total_copies" integer not null default 1,
    "available_copies" integer not null default 1,
    "status" text default 'available'::text,
    "category" text,
    "publisher" text,
    "publication_year" integer,
    "description" text,
    "location_shelf" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."library_categories" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "name" text not null,
    "description" text,
    "color_code" text default '#3B82F6'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."library_categories_college" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "college_id" uuid not null,
    "name" text not null,
    "description" text,
    "color_code" text default '#3B82F6'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."library_categories_school" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "school_id" uuid not null,
    "name" text not null,
    "description" text,
    "color_code" text default '#3B82F6'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."library_categories_school" enable row level security;


  create table "public"."library_history" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "book_id" uuid,
    "book_title" text not null,
    "book_author" text not null,
    "book_isbn" text,
    "book_category" text,
    "student_id" uuid,
    "student_name" text not null,
    "roll_number" text not null,
    "email" text not null,
    "department_id" uuid,
    "program" text,
    "semester" text,
    "academic_year" text not null,
    "issue_date" date not null,
    "due_date" date not null,
    "return_date" date,
    "days_borrowed" integer default 0,
    "days_overdue" integer default 0,
    "fine_amount" numeric(10,2) default 0,
    "fine_paid" boolean default false,
    "fine_waived" boolean default false,
    "issue_condition" text,
    "return_condition" text,
    "damage_charges" numeric(10,2) default 0,
    "status" text not null,
    "renewal_count" integer default 0,
    "issued_by" uuid,
    "issued_by_name" text,
    "returned_to" uuid,
    "returned_to_name" text,
    "remarks" text,
    "created_at" timestamp with time zone default now(),
    "student_record_id" uuid
      );



  create table "public"."library_issued_books" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "book_id" uuid not null,
    "student_id" uuid not null,
    "student_name" text not null,
    "roll_number" text not null,
    "email" text not null,
    "phone" text,
    "class" text,
    "department_id" uuid,
    "academic_year" text not null,
    "issue_date" date not null default CURRENT_DATE,
    "due_date" date not null,
    "expected_return_date" date generated always as ((issue_date + '14 days'::interval)) stored,
    "return_date" date,
    "actual_return_date" date,
    "days_overdue" integer default 0,
    "fine_per_day" numeric(10,2) default 10.00,
    "fine_amount" numeric(10,2) default 0,
    "fine_paid" boolean default false,
    "fine_paid_amount" numeric(10,2) default 0,
    "fine_waived" boolean default false,
    "fine_waiver_reason" text,
    "issue_condition" text default 'good'::text,
    "return_condition" text,
    "damage_charges" numeric(10,2) default 0,
    "damage_description" text,
    "status" text default 'issued'::text,
    "renewal_count" integer default 0,
    "max_renewals" integer default 2,
    "last_renewed_date" date,
    "reminder_sent_count" integer default 0,
    "last_reminder_sent_at" timestamp with time zone,
    "issued_by" uuid not null,
    "returned_to" uuid,
    "issue_remarks" text,
    "return_remarks" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "student_record_id" uuid
      );



  create table "public"."library_reservations" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "book_id" uuid not null,
    "student_id" uuid not null,
    "student_name" text not null,
    "roll_number" text not null,
    "reserved_date" date not null default CURRENT_DATE,
    "expiry_date" date not null,
    "priority" integer default 1,
    "status" text default 'active'::text,
    "fulfilled_date" date,
    "issued_book_id" uuid,
    "notification_sent" boolean default false,
    "notification_sent_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."library_reviews" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "book_id" uuid not null,
    "student_id" uuid not null,
    "student_name" text not null,
    "rating" integer not null,
    "review_text" text,
    "is_approved" boolean default false,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."library_settings" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "setting_key" text not null,
    "setting_value" text not null,
    "description" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."library_settings_college" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "college_id" uuid not null,
    "setting_key" text not null,
    "setting_value" text not null,
    "description" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."library_settings_school" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "school_id" uuid not null,
    "setting_key" text not null,
    "setting_value" text not null,
    "description" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."library_settings_school" enable row level security;


  create table "public"."license_assignments" (
    "id" uuid not null default gen_random_uuid(),
    "license_pool_id" uuid not null,
    "organization_subscription_id" uuid not null,
    "user_id" uuid not null,
    "member_type" character varying(20) not null,
    "status" character varying(20) not null default 'active'::character varying,
    "assigned_at" timestamp with time zone default now(),
    "assigned_by" uuid not null,
    "expires_at" timestamp with time zone,
    "revoked_at" timestamp with time zone,
    "revoked_by" uuid,
    "revocation_reason" text,
    "transferred_from" uuid,
    "transferred_to" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."license_assignments" enable row level security;


  create table "public"."license_pools" (
    "id" uuid not null default gen_random_uuid(),
    "organization_subscription_id" uuid not null,
    "organization_id" uuid not null,
    "organization_type" character varying(20) not null,
    "pool_name" character varying(100),
    "member_type" character varying(20) not null,
    "allocated_seats" integer not null,
    "assigned_seats" integer default 0,
    "available_seats" integer generated always as ((allocated_seats - assigned_seats)) stored,
    "auto_assign_new_members" boolean default false,
    "assignment_criteria" jsonb default '{}'::jsonb,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid
      );


alter table "public"."license_pools" enable row level security;


  create table "public"."mark_entries" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "assessment_id" uuid not null,
    "student_id" uuid not null,
    "marks_obtained" numeric(5,2),
    "total_marks" numeric(5,2) not null,
    "percentage" numeric(5,2) generated always as (
CASE
    WHEN ((marks_obtained IS NOT NULL) AND (total_marks > (0)::numeric)) THEN ((marks_obtained / total_marks) * (100)::numeric)
    ELSE NULL::numeric
END) stored,
    "grade" text,
    "grade_point" numeric(3,2),
    "is_absent" boolean default false,
    "is_exempt" boolean default false,
    "is_pass" boolean generated always as (
CASE
    WHEN (is_absent OR is_exempt) THEN NULL::boolean
    WHEN (marks_obtained IS NOT NULL) THEN (marks_obtained >= (total_marks * 0.4))
    ELSE NULL::boolean
END) stored,
    "remarks" text,
    "exemption_reason" text,
    "original_marks" numeric(5,2),
    "moderated_by" uuid,
    "moderation_reason" text,
    "moderation_date" timestamp with time zone,
    "entered_by" uuid not null,
    "entered_at" timestamp with time zone default now(),
    "is_locked" boolean default false,
    "locked_by" uuid,
    "locked_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "student_record_id" uuid,
    "subject_id" text
      );



  create table "public"."mark_entry_batches" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "assessment_id" uuid not null,
    "batch_name" text not null,
    "batch_number" text not null,
    "total_students" integer not null default 0,
    "entries_completed" integer default 0,
    "entries_pending" integer default 0,
    "completion_percentage" numeric(5,2) default 0,
    "status" text default 'in_progress'::text,
    "is_locked" boolean default false,
    "entered_by" uuid not null,
    "started_at" timestamp with time zone default now(),
    "completed_at" timestamp with time zone,
    "locked_by" uuid,
    "locked_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."mark_moderation_log" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "mark_entry_id" uuid not null,
    "assessment_id" uuid not null,
    "student_id" uuid not null,
    "original_marks" numeric(5,2) not null,
    "moderated_marks" numeric(5,2) not null,
    "difference" numeric(5,2) default 0,
    "moderation_type" text not null,
    "reason" text not null,
    "justification" text,
    "moderated_by" uuid not null,
    "moderator_name" text not null,
    "moderated_at" timestamp with time zone default now(),
    "requires_approval" boolean default false,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "approval_status" text,
    "created_at" timestamp with time zone default now(),
    "subject_id" text
      );



  create table "public"."mentor_notes" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "mentor_type" text not null,
    "school_educator_id" uuid,
    "college_lecturer_id" uuid,
    "quick_notes" text[],
    "feedback" text,
    "action_points" text,
    "note_date" timestamp with time zone default now(),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."messages" (
    "id" integer not null default nextval('public.messages_id_seq'::regclass),
    "conversation_id" text not null,
    "sender_id" uuid not null,
    "sender_type" text not null,
    "receiver_id" uuid not null,
    "receiver_type" text not null,
    "message_text" text not null,
    "attachments" jsonb,
    "application_id" integer,
    "opportunity_id" integer,
    "is_read" boolean default false,
    "read_at" timestamp with time zone,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "class_id" uuid,
    "subject" character varying(100),
    "program_section_id" uuid
      );



  create table "public"."messages_backup" (
    "id" integer,
    "conversation_id" text,
    "sender_id" uuid,
    "sender_type" text,
    "receiver_id" uuid,
    "receiver_type" text,
    "message_text" text,
    "attachments" jsonb,
    "application_id" integer,
    "opportunity_id" integer,
    "is_read" boolean,
    "read_at" timestamp with time zone,
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone
      );



  create table "public"."metrics_snapshots" (
    "id" text not null default (gen_random_uuid())::text,
    "snapshotDate" date not null default CURRENT_DATE,
    "activeUniversities" integer default 0,
    "registeredStudents" integer default 0,
    "verifiedPassports" integer default 0,
    "aiVerifiedPercent" numeric(5,2) default 0,
    "employabilityIndex" numeric(5,2) default 0,
    "activeRecruiters" integer default 0,
    "createdAt" timestamp with time zone default now(),
    "totalSchools" integer default 0,
    "totalColleges" integer default 0,
    "totalCompanies" integer default 0,
    "metadata" jsonb default '{}'::jsonb,
    "jobsecured" integer default 0
      );


alter table "public"."metrics_snapshots" enable row level security;


  create table "public"."notifications" (
    "id" uuid not null default gen_random_uuid(),
    "recipient_id" uuid not null,
    "type" text not null,
    "title" text not null,
    "message" text not null,
    "read" boolean not null default false,
    "created_at" timestamp with time zone not null default now(),
    "assessment_id" uuid,
    "scheduled_for" timestamp with time zone,
    "status" character varying(20) default 'sent'::character varying
      );



  create table "public"."notifications_backup_20251106" (
    "id" uuid,
    "recruiter_id" uuid,
    "type" text,
    "title" text,
    "message" text,
    "read" boolean,
    "created_at" timestamp with time zone
      );



  create table "public"."offers" (
    "id" uuid not null default gen_random_uuid(),
    "inserted_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "candidate_id" uuid,
    "candidate_name" text not null,
    "job_id" text,
    "job_title" text not null,
    "template" text,
    "ctc_band" text,
    "offered_ctc" text,
    "offer_date" timestamp with time zone default timezone('utc'::text, now()),
    "expiry_date" timestamp with time zone not null,
    "status" text default 'pending'::text,
    "sent_via" text default 'email'::text,
    "benefits" text[],
    "notes" text,
    "response_deadline" timestamp with time zone,
    "acceptance_notes" text,
    "response_date" timestamp with time zone
      );


alter table "public"."offers" enable row level security;


  create table "public"."opportunities" (
    "id_old" integer,
    "title" text not null,
    "company_name" text not null,
    "company_logo" text,
    "employment_type" text not null,
    "location" text not null,
    "mode" text,
    "stipend_or_salary" text,
    "experience_required" text,
    "skills_required" jsonb,
    "description" text,
    "application_link" text,
    "deadline" timestamp with time zone,
    "is_active" boolean default true,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "department" text not null,
    "experience_level" text,
    "salary_range_min" integer,
    "salary_range_max" integer,
    "status" text default 'draft'::text,
    "posted_date" timestamp with time zone default timezone('utc'::text, now()),
    "closing_date" timestamp with time zone,
    "requirements" jsonb,
    "responsibilities" jsonb,
    "benefits" jsonb,
    "applications_count" integer default 0,
    "messages_count" integer default 0,
    "views_count" integer default 0,
    "created_by" text,
    "job_title" text not null,
    "recruiter_id" uuid,
    "embedding" extensions.vector(1536),
    "requisition_id" text,
    "requisition_id_uuid" uuid,
    "sector" text,
    "exposure_type" text,
    "total_hours" integer,
    "duration_weeks" integer,
    "duration_days" integer,
    "schedule_note" text,
    "what_youll_learn" text,
    "what_youll_do" text,
    "final_artifact_type" text,
    "final_artifact_description" text,
    "mentor_bio" text,
    "safety_note" text,
    "parent_role" text,
    "cost_inr" integer,
    "cost_note" text,
    "prerequiste" character varying,
    "id" uuid not null default gen_random_uuid()
      );



  create table "public"."opportunities_backup_migration" (
    "id" integer,
    "title" text,
    "company_name" text,
    "company_logo" text,
    "employment_type" text,
    "location" text,
    "mode" text,
    "stipend_or_salary" text,
    "experience_required" text,
    "skills_required" jsonb,
    "description" text,
    "application_link" text,
    "deadline" timestamp with time zone,
    "is_active" boolean,
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone,
    "department" text,
    "experience_level" text,
    "salary_range_min" integer,
    "salary_range_max" integer,
    "status" text,
    "posted_date" timestamp with time zone,
    "closing_date" timestamp with time zone,
    "requirements" jsonb,
    "responsibilities" jsonb,
    "benefits" jsonb,
    "applications_count" integer,
    "messages_count" integer,
    "views_count" integer,
    "created_by" text,
    "job_title" text,
    "recruiter_id" uuid,
    "embedding" extensions.vector(1536),
    "requisition_id" text,
    "requisition_id_uuid" uuid,
    "sector" text,
    "exposure_type" text,
    "total_hours" integer,
    "duration_weeks" integer,
    "duration_days" integer,
    "schedule_note" text,
    "what_youll_learn" text,
    "what_youll_do" text,
    "final_artifact_type" text,
    "final_artifact_description" text,
    "mentor_bio" text,
    "safety_note" text,
    "parent_role" text,
    "cost_inr" integer,
    "cost_note" text,
    "prerequiste" character varying
      );



  create table "public"."opportunities_duplicate" (
    "id" integer not null,
    "title" text not null,
    "company_name" text not null,
    "company_logo" text,
    "employment_type" text not null,
    "location" text not null,
    "mode" text,
    "stipend_or_salary" text,
    "experience_required" text,
    "skills_required" jsonb,
    "description" text,
    "application_link" text,
    "deadline" timestamp with time zone,
    "is_active" boolean default true,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "department" text not null,
    "experience_level" text,
    "salary_range_min" integer,
    "salary_range_max" integer,
    "status" text default 'draft'::text,
    "posted_date" timestamp with time zone default timezone('utc'::text, now()),
    "closing_date" timestamp with time zone,
    "requirements" jsonb,
    "responsibilities" jsonb,
    "benefits" jsonb,
    "applications_count" integer default 0,
    "messages_count" integer default 0,
    "views_count" integer default 0,
    "created_by" text,
    "job_title" text not null,
    "recruiter_id" uuid,
    "embedding" extensions.vector(1536),
    "requisition_id" text,
    "requisition_id_uuid" uuid,
    "sector" text,
    "exposure_type" text,
    "total_hours" integer,
    "duration_weeks" integer,
    "duration_days" integer,
    "schedule_note" text,
    "what_youll_learn" text,
    "what_youll_do" text,
    "final_artifact_type" text,
    "final_artifact_description" text,
    "mentor_bio" text,
    "safety_note" text,
    "parent_role" text,
    "cost_inr" integer,
    "cost_note" text,
    "prerequiste" character varying
      );



  create table "public"."opportunity_interactions" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "action" text not null,
    "created_at" timestamp with time zone default now(),
    "opportunity_id" uuid
      );


alter table "public"."opportunity_interactions" enable row level security;


  create table "public"."opportunity_interactions_backup_uuid_migration" (
    "id" uuid,
    "student_id" uuid,
    "opportunity_id" integer,
    "action" text,
    "created_at" timestamp with time zone
      );



  create table "public"."organization_invitations" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "organization_type" text not null,
    "invited_by" uuid not null,
    "invited_by_role" text not null,
    "invitee_email" text not null,
    "invitee_name" text,
    "invitee_role" text not null,
    "license_pool_id" uuid,
    "subscription_plan_id" uuid,
    "addon_ids" uuid[] default '{}'::uuid[],
    "invitation_token" text not null default encode(extensions.gen_random_bytes(32), 'hex'::text),
    "status" text not null default 'pending'::text,
    "expires_at" timestamp with time zone not null default (now() + '7 days'::interval),
    "accepted_at" timestamp with time zone,
    "accepted_by_user_id" uuid,
    "invitation_message" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "cancelled_at" timestamp with time zone,
    "cancelled_by" uuid,
    "cancellation_reason" text
      );


alter table "public"."organization_invitations" enable row level security;


  create table "public"."organization_subscriptions" (
    "id" uuid not null default gen_random_uuid(),
    "organization_id" uuid not null,
    "organization_type" character varying(20) not null,
    "subscription_plan_id" uuid not null,
    "purchased_by" uuid not null,
    "total_seats" integer not null,
    "assigned_seats" integer default 0,
    "available_seats" integer generated always as ((total_seats - assigned_seats)) stored,
    "target_member_type" character varying(20) not null,
    "status" character varying(20) not null default 'active'::character varying,
    "start_date" timestamp with time zone not null default now(),
    "end_date" timestamp with time zone not null,
    "auto_renew" boolean default true,
    "price_per_seat" numeric(10,2) not null,
    "total_amount" numeric(10,2) not null,
    "discount_percentage" integer default 0,
    "final_amount" numeric(10,2) not null,
    "razorpay_subscription_id" character varying(100),
    "razorpay_order_id" character varying(100),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "cancelled_at" timestamp with time zone,
    "cancellation_reason" text,
    "razorpay_payment_id" character varying(255)
      );


alter table "public"."organization_subscriptions" enable row level security;


  create table "public"."organizations" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "name" character varying(255) not null,
    "description" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "email" text,
    "phone" text,
    "state" text,
    "website" text,
    "verification_status" text default 'approved'::text,
    "is_active" boolean default true,
    "approval_status" character varying(20) default 'approved'::character varying,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "rejection_reason" text,
    "account_status" character varying(20) default 'active'::character varying,
    "organization_type" character varying(50),
    "admin_id" uuid,
    "address" text,
    "city" character varying(100),
    "country" character varying(100),
    "logo_url" text,
    "code" character varying(50),
    "pincode" character varying(20),
    "established_year" integer,
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."organizations" enable row level security;


  create table "public"."otp_requests_log" (
    "id" uuid not null default gen_random_uuid(),
    "phone" character varying(20) not null,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."otp_requests_log" enable row level security;


  create table "public"."outcome_assessment_mappings" (
    "id" uuid not null default gen_random_uuid(),
    "learning_outcome_id" uuid not null,
    "assessment_type_id" uuid not null,
    "weightage" numeric(5,2),
    "created_at" timestamp without time zone default now()
      );



  create table "public"."payment_transactions" (
    "id" uuid not null default gen_random_uuid(),
    "subscription_id" uuid,
    "user_id" uuid not null,
    "razorpay_payment_id" character varying(255),
    "razorpay_order_id" character varying(255),
    "amount" numeric(10,2) not null,
    "currency" character varying(10) default 'INR'::character varying,
    "status" character varying(50) not null,
    "payment_method" character varying(50),
    "failure_reason" text,
    "refund_id" character varying(255),
    "created_at" timestamp with time zone default now(),
    "organization_id" uuid,
    "organization_type" text,
    "seat_count" integer default 1,
    "is_bulk_purchase" boolean default false,
    "metadata" jsonb default '{}'::jsonb,
    "transaction_type" character varying(50) default 'subscription'::character varying
      );


alter table "public"."payment_transactions" enable row level security;


  create table "public"."permissions" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "name" character varying(100) not null,
    "resource" character varying(50) not null,
    "action" character varying(50) not null,
    "description" text,
    "createdAt" timestamp with time zone default now()
      );


alter table "public"."permissions" enable row level security;


  create table "public"."personal_assessment_attempts" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "stream_id" character varying(20) not null,
    "started_at" timestamp with time zone default now(),
    "completed_at" timestamp with time zone,
    "status" character varying(20) default 'in_progress'::character varying,
    "current_section_index" integer default 0,
    "current_question_index" integer default 0,
    "section_timings" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "timer_remaining" integer,
    "elapsed_time" integer default 0,
    "grade_level" text not null default 'after12'::text,
    "adaptive_aptitude_session_id" uuid,
    "all_responses" jsonb default '{}'::jsonb,
    "aptitude_scores" jsonb,
    "knowledge_scores" jsonb,
    "aptitude_question_timer" integer,
    "total_time_minutes" numeric generated always as (round(((((((((COALESCE(((section_timings ->> 'riasec'::text))::integer, 0) + COALESCE(((section_timings ->> 'bigfive'::text))::integer, 0)) + COALESCE(((section_timings ->> 'aptitude'::text))::integer, 0)) + COALESCE(((section_timings ->> 'values'::text))::integer, 0)) + COALESCE(((section_timings ->> 'work_values'::text))::integer, 0)) + COALESCE(((section_timings ->> 'employability'::text))::integer, 0)) + COALESCE(((section_timings ->> 'knowledge'::text))::integer, 0)))::numeric / (60)::numeric), 2)) stored,
    "student_context" jsonb
      );


alter table "public"."personal_assessment_attempts" enable row level security;


  create table "public"."personal_assessment_questions" (
    "id" uuid not null default gen_random_uuid(),
    "section_id" uuid not null,
    "stream_id" character varying(20),
    "question_text" text not null,
    "question_type" character varying(20) not null,
    "options" jsonb,
    "correct_answer" character varying(255),
    "subtype" character varying(50),
    "module_title" character varying(100),
    "part_type" character varying(30),
    "best_answer" character varying(255),
    "worst_answer" character varying(255),
    "scenario" text,
    "order_number" integer not null default 0,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "placeholder" text,
    "description" text,
    "strength_type" text,
    "task_type" text,
    "max_selections" integer,
    "category_mapping" jsonb
      );


alter table "public"."personal_assessment_questions" enable row level security;


  create table "public"."personal_assessment_response_scales" (
    "id" uuid not null default gen_random_uuid(),
    "section_id" uuid,
    "scale_name" text not null,
    "scale_values" jsonb not null,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."personal_assessment_response_scales" enable row level security;


  create table "public"."personal_assessment_responses" (
    "id" uuid not null default gen_random_uuid(),
    "attempt_id" uuid not null,
    "question_id" uuid not null,
    "response_value" jsonb not null,
    "is_correct" boolean,
    "responded_at" timestamp with time zone default now()
      );


alter table "public"."personal_assessment_responses" enable row level security;


  create table "public"."personal_assessment_restrictions" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" text not null,
    "last_attempt_date" timestamp with time zone not null,
    "next_allowed_date" timestamp with time zone not null,
    "grade_level" text not null,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."personal_assessment_restrictions" enable row level security;


  create table "public"."personal_assessment_results" (
    "id" uuid not null default gen_random_uuid(),
    "attempt_id" uuid not null,
    "student_id" uuid not null,
    "stream_id" character varying(50) not null,
    "riasec_scores" jsonb,
    "riasec_code" character varying(10),
    "aptitude_scores" jsonb,
    "aptitude_overall" numeric(5,2),
    "bigfive_scores" jsonb,
    "work_values_scores" jsonb,
    "employability_scores" jsonb,
    "employability_readiness" character varying(20),
    "knowledge_score" numeric(5,2),
    "knowledge_details" jsonb,
    "career_fit" jsonb,
    "skill_gap" jsonb,
    "roadmap" jsonb,
    "profile_snapshot" jsonb,
    "timing_analysis" jsonb,
    "final_note" jsonb,
    "overall_summary" text,
    "gemini_results" jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "status" public.assessment_status default 'pending'::public.assessment_status,
    "grade_level" text not null default 'after12'::text,
    "skill_gap_courses" jsonb,
    "platform_courses" jsonb,
    "courses_by_type" jsonb
      );


alter table "public"."personal_assessment_results" enable row level security;


  create table "public"."personal_assessment_sections" (
    "id" uuid not null default gen_random_uuid(),
    "name" character varying(50) not null,
    "title" character varying(100) not null,
    "description" text,
    "icon" character varying(50),
    "color" character varying(30),
    "order_number" integer not null,
    "is_timed" boolean default false,
    "time_limit_seconds" integer,
    "instruction" text,
    "response_scale" jsonb,
    "is_stream_specific" boolean default false,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "grade_level" text not null default 'after12'::text
      );


alter table "public"."personal_assessment_sections" enable row level security;


  create table "public"."personal_assessment_streams" (
    "id" character varying(50) not null,
    "label" character varying(100) not null,
    "description" text,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "name" text,
    "grade_level" text,
    "display_order" integer default 0,
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."personal_assessment_streams" enable row level security;


  create table "public"."phone_otps" (
    "id" uuid not null default gen_random_uuid(),
    "phone" character varying(20) not null,
    "otp_hash" character varying(64) not null,
    "expires_at" timestamp with time zone not null,
    "attempts" integer default 0,
    "verified" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."phone_otps" enable row level security;


  create table "public"."pipeline_activities" (
    "id" integer not null default nextval('public.pipeline_activities_id_seq'::regclass),
    "pipeline_candidate_id" integer not null,
    "activity_type" text not null,
    "from_stage" text,
    "to_stage" text,
    "activity_details" jsonb,
    "performed_by" text,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "student_id" uuid
      );


alter table "public"."pipeline_activities" enable row level security;


  create table "public"."pipeline_candidates" (
    "id_old" integer,
    "student_id" uuid not null,
    "candidate_name" text not null,
    "candidate_email" text,
    "candidate_phone" text,
    "stage" text not null default 'sourced'::text,
    "previous_stage" text,
    "stage_changed_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "stage_changed_by" text,
    "status" text default 'active'::text,
    "rejection_reason" text,
    "rejection_date" timestamp with time zone,
    "next_action" text,
    "next_action_date" timestamp with time zone,
    "next_action_notes" text,
    "recruiter_rating" integer,
    "recruiter_notes" text,
    "assigned_to" text,
    "source" text,
    "added_by" text,
    "added_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "opportunity_id_old" integer,
    "requisition_id" uuid,
    "id" uuid not null default gen_random_uuid(),
    "opportunity_id" uuid not null
      );


alter table "public"."pipeline_candidates" enable row level security;


  create table "public"."pipeline_candidates_backup_migration" (
    "id" integer,
    "student_id" uuid,
    "candidate_name" text,
    "candidate_email" text,
    "candidate_phone" text,
    "stage" text,
    "previous_stage" text,
    "stage_changed_at" timestamp with time zone,
    "stage_changed_by" text,
    "status" text,
    "rejection_reason" text,
    "rejection_date" timestamp with time zone,
    "next_action" text,
    "next_action_date" timestamp with time zone,
    "next_action_notes" text,
    "recruiter_rating" integer,
    "recruiter_notes" text,
    "assigned_to" text,
    "source" text,
    "added_by" text,
    "added_at" timestamp with time zone,
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone,
    "opportunity_id" integer,
    "requisition_id" uuid
      );



  create table "public"."placements" (
    "id" uuid not null default gen_random_uuid(),
    "studentId" uuid,
    "recruiterId" uuid,
    "jobTitle" text not null,
    "salaryOffered" numeric(10,2),
    "appliedDate" timestamp with time zone,
    "hiredDate" timestamp with time zone,
    "retentionDate" timestamp with time zone,
    "metadata" jsonb default '{}'::jsonb,
    "createdAt" timestamp with time zone default now(),
    "updatedAt" timestamp with time zone default now(),
    "placementStatus" public.placement_status default 'applied'::public.placement_status
      );


alter table "public"."placements" enable row level security;


  create table "public"."pre_registration_email_tracking" (
    "id" uuid not null default gen_random_uuid(),
    "pre_registration_id" uuid not null,
    "email_status" text not null default 'pending'::text,
    "scheduled_at" timestamp with time zone not null,
    "sent_at" timestamp with time zone,
    "delivered_at" timestamp with time zone,
    "failed_at" timestamp with time zone,
    "error_message" text,
    "retry_count" integer default 0,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."pre_registrations" (
    "id" uuid not null default gen_random_uuid(),
    "full_name" text not null,
    "email" text not null,
    "phone" text not null,
    "amount" numeric default 250,
    "razorpay_order_id" text,
    "razorpay_payment_id" text,
    "campaign" text,
    "role_type" text default 'pre_registration'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "payment_status" public.payment_status_enum not null default 'pending'::public.payment_status_enum,
    "payment_history" jsonb default '[]'::jsonb
      );


alter table "public"."pre_registrations" enable row level security;


  create table "public"."profile_views" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "viewer_type" text not null,
    "viewer_id" uuid,
    "viewed_at" timestamp with time zone default now()
      );


alter table "public"."profile_views" enable row level security;


  create table "public"."profile_views_backup_20251106" (
    "id" uuid,
    "student_id" uuid,
    "viewer_type" text,
    "viewer_id" uuid,
    "viewed_at" timestamp with time zone
      );



  create table "public"."program_sections" (
    "id" uuid not null default gen_random_uuid(),
    "department_id" uuid not null,
    "program_id" uuid not null,
    "semester" integer not null,
    "section" character varying(10) not null,
    "academic_year" character varying(20) not null,
    "max_students" integer not null default 60,
    "current_students" integer not null default 0,
    "faculty_id" uuid,
    "status" character varying(20) not null default 'active'::character varying,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "created_by" uuid,
    "updated_by" uuid
      );



  create table "public"."programs" (
    "id" uuid not null default gen_random_uuid(),
    "department_id" uuid,
    "name" character varying(255) not null,
    "code" character varying(50) not null,
    "description" text,
    "degree_level" character varying(50) not null,
    "status" character varying(50) default 'active'::character varying,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "metadata" jsonb,
    "created_by" uuid,
    "updated_by" uuid
      );



  create table "public"."projects" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "title" character varying(200) not null,
    "description" text,
    "status" character varying(50),
    "start_date" date,
    "end_date" date,
    "duration" character varying(100),
    "tech_stack" text[],
    "demo_link" text,
    "github_link" text,
    "approval_status" character varying(20) default 'pending'::character varying,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "certificate_url" text,
    "video_url" text,
    "ppt_url" text,
    "organization" text,
    "enabled" boolean default true,
    "approval_authority" character varying(20) default 'rareminds_admin'::character varying,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "rejected_by" uuid,
    "rejected_at" timestamp with time zone,
    "approval_notes" text,
    "role" text,
    "embedding" extensions.vector(1536),
    "pending_edit_data" jsonb,
    "has_pending_edit" boolean default false,
    "verified_data" jsonb
      );



  create table "public"."promotional_events" (
    "id" uuid not null default gen_random_uuid(),
    "event_code" text not null,
    "event_name" text not null,
    "description" text,
    "start_date" timestamp with time zone not null,
    "end_date" timestamp with time zone not null,
    "discount_type" text default 'percentage'::text,
    "is_active" boolean default true,
    "banner_text" text,
    "banner_subtitle" text,
    "banner_emoji" text default ''::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."quizzes" (
    "quiz_id" uuid not null default gen_random_uuid(),
    "lesson_id" uuid,
    "title" character varying(255) not null,
    "description" text,
    "passing_score" numeric default 70,
    "time_limit_seconds" integer default 600,
    "max_attempts" integer default 3,
    "questions" jsonb not null default '[]'::jsonb,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."razorpay_orders" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "order_id" text not null,
    "amount" integer not null,
    "currency" text not null default 'INR'::text,
    "receipt" text not null,
    "status" text not null default 'created'::text,
    "plan_id" text not null,
    "plan_name" text not null,
    "user_email" text not null,
    "user_name" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "razorpay_payment_id" text,
    "payment_method" text,
    "failure_reason" text,
    "refund_id" text,
    "refund_status" text,
    "subscription_id" uuid
      );



  create table "public"."recent_updates" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "created_at" timestamp with time zone default now(),
    "updates" jsonb default '{"updates": []}'::jsonb,
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."recent_updates" enable row level security;


  create table "public"."recruiter_activities" (
    "id" uuid not null default gen_random_uuid(),
    "recruiterId" uuid,
    "activityType" text not null,
    "targetStudentId" uuid,
    "searchCriteria" jsonb default '{}'::jsonb,
    "metadata" jsonb default '{}'::jsonb,
    "createdAt" timestamp with time zone default now()
      );


alter table "public"."recruiter_activities" enable row level security;


  create table "public"."recruiter_saved_searches" (
    "id" uuid not null default gen_random_uuid(),
    "recruiter_id" text not null,
    "name" text not null,
    "search_criteria" jsonb not null default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "last_used" timestamp with time zone,
    "use_count" integer default 0,
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."recruiter_saved_searches" enable row level security;


  create table "public"."recruiters" (
    "id" uuid not null default gen_random_uuid(),
    "name" text not null,
    "email" text,
    "phone" text,
    "state" text,
    "website" text,
    "verificationstatus" text default 'approved'::text,
    "isactive" boolean default true,
    "createdat" timestamp with time zone default now(),
    "updatedat" timestamp with time zone default now(),
    "approval_status" character varying(20) default 'approved'::character varying,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "rejection_reason" text,
    "account_status" character varying(20) default 'active'::character varying,
    "user_id" uuid not null,
    "company_id" uuid
      );



  create table "public"."requisitions" (
    "id" text not null,
    "title" text not null,
    "department" text not null,
    "location" text not null,
    "job_type" text default 'Full-time'::text,
    "openings" integer default 1,
    "status" text default 'active'::text,
    "priority" text default 'medium'::text,
    "description" text,
    "requirements" text,
    "salary_range" text,
    "owner" text,
    "hiring_manager" text,
    "created_by" text,
    "created_date" timestamp with time zone not null default timezone('utc'::text, now()),
    "target_date" timestamp with time zone,
    "filled_date" timestamp with time zone,
    "tags" text[],
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "id_uuid" uuid
      );


alter table "public"."requisitions" enable row level security;


  create table "public"."reset_tokens" (
    "id" uuid not null default gen_random_uuid(),
    "email" text not null,
    "token" text not null,
    "expires_at" timestamp with time zone not null,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."reset_tokens" enable row level security;


  create table "public"."role_permissions" (
    "role" character varying(50) not null,
    "permission_name" character varying(100) not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );



  create table "public"."roles" (
    "name" character varying(50) not null,
    "description" text not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );



  create table "public"."saved_jobs" (
    "id_old" integer,
    "student_id_old" uuid,
    "opportunity_id_old" integer,
    "saved_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "id" uuid not null default gen_random_uuid(),
    "opportunity_id" uuid not null,
    "student_id" uuid not null
      );



  create table "public"."saved_jobs_backup_migration" (
    "id" integer,
    "student_id" uuid,
    "opportunity_id" integer,
    "saved_at" timestamp with time zone,
    "created_at" timestamp with time zone,
    "updated_at" timestamp with time zone
      );



  create table "public"."school_classes" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid not null,
    "name" character varying(100) not null,
    "grade" character varying(20) not null,
    "section" character varying(10),
    "academic_year" character varying(20) not null,
    "max_students" integer default 40,
    "current_students" integer default 0,
    "account_status" character varying(20) default 'active'::character varying,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "metadata" jsonb default '{}'::jsonb,
    "room_no" character varying(50)
      );


alter table "public"."school_classes" enable row level security;


  create table "public"."school_educator_class_assignments" (
    "id" uuid not null default gen_random_uuid(),
    "educator_id" uuid not null,
    "class_id" uuid not null,
    "subject" character varying(100) not null,
    "academic_year" character varying(20) not null,
    "is_primary" boolean default false,
    "assigned_at" timestamp with time zone default now(),
    "assigned_by" uuid
      );



  create table "public"."school_educators" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "school_id" uuid not null,
    "employee_id" character varying(50),
    "specialization" character varying(100),
    "qualification" character varying(255),
    "experience_years" integer,
    "date_of_joining" date,
    "account_status" character varying(20) default 'active'::character varying,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "metadata" jsonb default '{}'::jsonb,
    "designation" character varying(100),
    "department" character varying(100),
    "first_name" character varying(100),
    "last_name" character varying(100),
    "email" character varying(255),
    "phone_number" character varying(20),
    "dob" date,
    "gender" character varying(20),
    "address" text,
    "city" character varying(100),
    "state" character varying(100),
    "country" character varying(100),
    "pincode" character varying(10),
    "subjects_handled" text[],
    "resume_url" text,
    "id_proof_url" text,
    "photo_url" text,
    "verification_status" public.user_approval_status,
    "verified_by" uuid,
    "verified_at" timestamp with time zone,
    "role" character varying(20) default 'subject_teacher'::character varying,
    "onboarding_status" character varying(20) default 'active'::character varying,
    "degree_certificate_url" text,
    "experience_letters_url" text[],
    "subject_expertise" jsonb default '[]'::jsonb,
    "teacher_id" character varying(20)
      );



  create table "public"."search_history" (
    "id" bigint not null default nextval('public.search_history_id_seq'::regclass),
    "student_id" uuid not null,
    "search_term" text not null,
    "search_count" integer default 1,
    "last_searched_at" timestamp with time zone default now(),
    "created_at" timestamp with time zone default now()
      );


alter table "public"."search_history" enable row level security;


  create table "public"."shortlist_candidates" (
    "id" integer not null default nextval('public.shortlist_candidates_id_seq'::regclass),
    "shortlist_id" text not null,
    "student_id" uuid not null,
    "added_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "added_by" text,
    "notes" text
      );


alter table "public"."shortlist_candidates" enable row level security;


  create table "public"."shortlists" (
    "id" text not null,
    "name" text not null,
    "description" text,
    "created_by" text,
    "created_date" timestamp with time zone not null default timezone('utc'::text, now()),
    "status" text default 'active'::text,
    "shared" boolean default false,
    "share_link" text,
    "share_expiry" timestamp with time zone,
    "watermark" boolean default false,
    "include_pii" boolean default false,
    "notify_on_access" boolean default false,
    "tags" text[],
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
      );


alter table "public"."shortlists" enable row level security;


  create table "public"."skill_assessments" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "school_id" uuid not null,
    "assessment_type" text not null,
    "assessment_date" date not null,
    "score" numeric(5,2) not null,
    "max_score" numeric(5,2) default 100,
    "subject" text,
    "topic" text,
    "remarks" text,
    "assessed_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."skill_assessments" enable row level security;


  create table "public"."skill_badges" (
    "badge_id" uuid not null default gen_random_uuid(),
    "school_id" uuid,
    "name" character varying(255) not null,
    "description" text,
    "icon" character varying(50),
    "category" character varying(50),
    "level" character varying(20),
    "criteria" jsonb default '{}'::jsonb,
    "points_required" integer,
    "auto_award_enabled" boolean default false,
    "auto_award_conditions" jsonb default '{}'::jsonb,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "created_by_type" character varying(20),
    "created_by_educator_id" uuid,
    "created_by_admin_id" uuid
      );



  create table "public"."skill_passports" (
    "studentId" uuid not null,
    "status" text not null,
    "aiVerification" boolean default false,
    "nsqfLevel" integer,
    "skills" jsonb default '[]'::jsonb,
    "createdAt" timestamp with time zone default now(),
    "updatedAt" timestamp with time zone default now(),
    "id" uuid not null default gen_random_uuid(),
    "projects" jsonb default '[]'::jsonb,
    "certificates" jsonb default '[]'::jsonb,
    "assessments" jsonb default '[]'::jsonb
      );


alter table "public"."skill_passports" enable row level security;


  create table "public"."skill_trends" (
    "id" uuid not null default gen_random_uuid(),
    "skillName" text not null,
    "category" text not null,
    "demandScore" integer default 0,
    "trendDirection" text,
    "weeklyGrowth" numeric(5,2) default 0,
    "monthlyGrowth" numeric(5,2) default 0,
    "snapshotDate" date not null default CURRENT_DATE,
    "createdAt" timestamp with time zone default now()
      );


alter table "public"."skill_trends" enable row level security;


  create table "public"."skill_verification_requests" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "skill_name" text not null,
    "skill_type" text not null,
    "skill_level" integer not null,
    "skill_icon" text,
    "skill_category" text,
    "institution_admin_status" text default 'pending'::text,
    "institution_admin_id" uuid,
    "institution_admin_reviewed_at" timestamp with time zone,
    "institution_admin_notes" text,
    "rareminds_admin_status" text default 'pending'::text,
    "rareminds_admin_id" uuid,
    "rareminds_admin_reviewed_at" timestamp with time zone,
    "rareminds_admin_notes" text,
    "overall_status" text default 'pending'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."skill_verification_requests" enable row level security;


  create table "public"."skills" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "name" character varying(100) not null,
    "type" character varying(20),
    "level" integer,
    "description" text,
    "verified" boolean default false,
    "enabled" boolean default true,
    "approval_status" character varying(20) default 'pending'::character varying,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "training_id" uuid,
    "proficiency_level" text,
    "embedding" extensions.vector(1536),
    "pending_edit_data" jsonb,
    "has_pending_edit" boolean default false,
    "verified_data" jsonb
      );



  create table "public"."streak_notification_log" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "student_id" uuid not null,
    "notification_type" character varying(20) default 'email'::character varying,
    "email_template_number" integer,
    "sent_at" timestamp with time zone default now(),
    "notification_date" date default CURRENT_DATE,
    "status" character varying(20) default 'sent'::character varying,
    "opened_at" timestamp with time zone,
    "clicked_at" timestamp with time zone,
    "error_message" text,
    "metadata" jsonb default '{}'::jsonb
      );



  create table "public"."stream_recommendation_reports" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "academic_year" character varying(20) not null,
    "current_grade" character varying(10) not null,
    "subject_marks" jsonb default '{}'::jsonb,
    "projects_summary" jsonb default '[]'::jsonb,
    "experiences_summary" jsonb default '[]'::jsonb,
    "interests" jsonb default '[]'::jsonb,
    "hobbies" jsonb default '[]'::jsonb,
    "extracurriculars" jsonb default '[]'::jsonb,
    "science_score" numeric(5,2),
    "commerce_score" numeric(5,2),
    "arts_score" numeric(5,2),
    "science_breakdown" jsonb default '{}'::jsonb,
    "commerce_breakdown" jsonb default '{}'::jsonb,
    "arts_breakdown" jsonb default '{}'::jsonb,
    "recommended_stream" character varying(20),
    "confidence_level" character varying(20),
    "alternative_stream" character varying(20),
    "ai_analysis" text,
    "strengths" jsonb default '[]'::jsonb,
    "areas_to_improve" jsonb default '[]'::jsonb,
    "career_suggestions" jsonb default '[]'::jsonb,
    "recommended_subjects" jsonb default '{}'::jsonb,
    "ai_model_used" character varying(100),
    "generation_timestamp" timestamp with time zone default now(),
    "is_latest" boolean default true,
    "status" character varying(20) default 'generated'::character varying,
    "reviewed_by" uuid,
    "reviewed_at" timestamp with time zone,
    "reviewer_notes" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."student_assignments" (
    "student_assignment_id" uuid not null default gen_random_uuid(),
    "assignment_id" uuid not null,
    "student_id" uuid not null,
    "status" text not null default 'todo'::text,
    "priority" text not null default 'medium'::text,
    "grade_received" numeric(7,2),
    "grade_percentage" numeric(5,2),
    "instructor_feedback" text,
    "feedback_date" timestamp with time zone,
    "graded_by" uuid,
    "graded_date" timestamp with time zone,
    "submission_date" timestamp with time zone,
    "submission_type" text,
    "submission_content" text,
    "submission_url" text,
    "is_late" boolean not null default false,
    "late_penalty" numeric(5,2),
    "assigned_date" timestamp with time zone not null default now(),
    "started_date" timestamp with time zone,
    "completed_date" timestamp with time zone,
    "is_deleted" boolean not null default false,
    "updated_date" timestamp with time zone not null default now()
      );



  create table "public"."student_course_progress" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "course_id" uuid not null,
    "lesson_id" uuid not null,
    "status" character varying(20) default 'not_started'::character varying,
    "time_spent_seconds" integer default 0,
    "last_accessed" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "video_position_seconds" integer default 0,
    "video_duration_seconds" integer default 0,
    "video_completed" boolean default false,
    "scroll_position_percent" numeric(5,2) default 0,
    "content_completed" boolean default false,
    "notes" text,
    "bookmarked" boolean default false
      );



  create table "public"."student_course_recommendations" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "course_id" uuid not null,
    "assessment_result_id" uuid,
    "relevance_score" integer,
    "match_reasons" jsonb default '[]'::jsonb,
    "skill_gaps_addressed" jsonb default '[]'::jsonb,
    "recommendation_type" character varying(50) default 'assessment'::character varying,
    "status" character varying(20) default 'active'::character varying,
    "dismissed_at" timestamp with time zone,
    "dismissed_reason" text,
    "recommended_at" timestamp with time zone default now(),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."student_enrollments" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "student_id" uuid not null,
    "program_id" uuid not null,
    "section_id" uuid,
    "semester" integer not null,
    "academic_year" character varying(20) not null,
    "enrollment_date" date not null default CURRENT_DATE,
    "enrollment_status" character varying(50) default 'active'::character varying,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "updated_by" uuid
      );


alter table "public"."student_enrollments" enable row level security;


  create table "public"."student_job_matches" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "matches" jsonb not null default '[]'::jsonb,
    "match_count" integer not null default 0,
    "algorithm_version" character varying(50) not null default 'v1.0'::character varying,
    "student_profile_hash" character varying(64),
    "is_valid" boolean not null default true,
    "invalidation_reason" character varying(255),
    "computed_at" timestamp with time zone not null default now(),
    "expires_at" timestamp with time zone not null default (now() + '24:00:00'::interval),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."student_job_matches" enable row level security;


  create table "public"."student_ledgers" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "student_id" uuid not null,
    "student_name" text not null,
    "roll_number" text not null,
    "fee_structure_id" uuid not null,
    "fee_head_id" text not null,
    "fee_head_name" text not null,
    "due_amount" numeric(10,2) not null,
    "paid_amount" numeric(10,2) default 0,
    "balance" numeric(10,2) generated always as ((due_amount - paid_amount)) stored,
    "due_date" date not null,
    "installment_number" integer,
    "payment_status" text default 'pending'::text,
    "is_overdue" boolean default false,
    "late_fee_amount" numeric(10,2) default 0,
    "late_fee_waived" boolean default false,
    "waiver_amount" numeric(10,2) default 0,
    "waiver_reason" text,
    "waived_by" uuid,
    "waived_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "student_record_id" uuid,
    "college_id" uuid
      );



  create table "public"."student_management_records" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "school_id" uuid not null,
    "enrollment_number" text,
    "class" text,
    "section" text,
    "roll_number" text,
    "admission_date" date,
    "academic_year" text,
    "blood_group" text,
    "allergies" text[],
    "chronic_conditions" text[],
    "medications" text[],
    "emergency_contact" text,
    "emergency_phone" text,
    "primary_interest" text,
    "secondary_interest" text,
    "career_skills" text[],
    "aspirations" text,
    "total_fee" numeric(10,2),
    "paid_amount" numeric(10,2) default 0,
    "pending_amount" numeric(10,2),
    "status" text default 'active'::text,
    "photo_url" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."student_management_records" enable row level security;


  create table "public"."student_promotions" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "academic_year" character varying(20) not null,
    "from_grade" character varying(10) not null,
    "to_grade" character varying(10),
    "school_id" uuid,
    "college_id" uuid,
    "overall_percentage" numeric(5,2),
    "overall_grade" character varying(5),
    "overall_grade_point" numeric(4,2),
    "total_marks_obtained" numeric(10,2),
    "total_max_marks" numeric(10,2),
    "is_passed" boolean not null default false,
    "is_promoted" boolean not null default false,
    "is_detained" boolean default false,
    "is_compartment" boolean default false,
    "compartment_subjects" jsonb default '[]'::jsonb,
    "promotion_date" date,
    "promotion_order_number" character varying(50),
    "promoted_by" uuid,
    "remarks" text,
    "attendance_percentage" numeric(5,2),
    "conduct_grade" character varying(10),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."student_quiz_progress" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "course_id" uuid not null,
    "lesson_id" uuid not null,
    "quiz_id" uuid not null,
    "attempt_number" integer default 1,
    "answers" jsonb default '{}'::jsonb,
    "current_question_index" integer default 0,
    "total_questions" integer default 0,
    "correct_answers" integer default 0,
    "score_percentage" numeric(5,2),
    "passing_score" numeric(5,2) default 70.00,
    "passed" boolean default false,
    "status" character varying(20) default 'in_progress'::character varying,
    "time_limit_seconds" integer,
    "time_spent_seconds" integer default 0,
    "started_at" timestamp with time zone default now(),
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."student_quiz_progress" enable row level security;


  create table "public"."student_reports" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "school_id" uuid not null,
    "report_type" text not null,
    "title" text not null,
    "generated_date" timestamp with time zone default now(),
    "generated_by" uuid,
    "academic_year" text not null,
    "term" text,
    "data" jsonb not null,
    "pdf_url" text,
    "has_school_logo" boolean default true,
    "is_parent_friendly" boolean default true,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."student_reports" enable row level security;


  create table "public"."student_skill_badges" (
    "id" uuid not null default gen_random_uuid(),
    "badge_id" uuid not null,
    "student_email" character varying(255) not null,
    "current_points" integer default 0,
    "progress_percentage" numeric(5,2) default 0,
    "status" character varying(20) default 'in_progress'::character varying,
    "earned_at" timestamp with time zone,
    "expires_at" timestamp with time zone,
    "started_at" timestamp with time zone default now(),
    "achievement_data" jsonb default '{}'::jsonb,
    "awarded_by_type" character varying(20),
    "awarded_by_educator_id" uuid,
    "awarded_by_admin_id" uuid
      );



  create table "public"."student_streaks" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "student_id" uuid not null,
    "current_streak" integer default 0,
    "longest_streak" integer default 0,
    "last_activity_date" date,
    "streak_completed_today" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."students" (
    "id" uuid not null default gen_random_uuid(),
    "universityId" uuid,
    "createdAt" timestamp with time zone default now(),
    "updatedAt" timestamp with time zone default now(),
    "email" text not null,
    "name" character varying(150),
    "age" integer,
    "date_of_birth" date,
    "contact_number" character varying(20),
    "alternate_number" character varying(20),
    "district_name" character varying(100),
    "university" character varying(150),
    "branch_field" character varying(150),
    "college_school_name" character varying(150),
    "registration_number" character varying(100),
    "github_link" text,
    "linkedin_link" text,
    "twitter_link" text,
    "facebook_link" text,
    "instagram_link" text,
    "portfolio_link" text,
    "other_social_links" jsonb default '[]'::jsonb,
    "approval_status" public.user_approval_status,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now(),
    "embedding" extensions.vector(1536),
    "universityCollegeId" uuid,
    "schoolClassId" uuid,
    "collegeCourseId" uuid,
    "universityCourseId" uuid,
    "enrollmentNumber" character varying(100),
    "guardianName" character varying(200),
    "guardianPhone" character varying(20),
    "guardianEmail" character varying(255),
    "guardianRelation" character varying(50),
    "dateOfBirth" date,
    "gender" character varying(20),
    "bloodGroup" character varying(5),
    "enrollmentDate" date,
    "expectedGraduationDate" date,
    "currentCgpa" numeric(4,2),
    "contactNumber" character varying(20),
    "address" text,
    "city" character varying(100),
    "state" character varying(100),
    "country" character varying(100) default 'India'::character varying,
    "pincode" character varying(10),
    "resumeUrl" text,
    "profilePicture" text,
    "metadata" jsonb default '{}'::jsonb,
    "university_college_id" uuid,
    "school_id" uuid,
    "school_class_id" uuid,
    "student_type" character varying(30) default 'direct'::character varying,
    "user_id" uuid,
    "student_id" text,
    "bio" text,
    "university_main" character varying(150),
    "imported_at" timestamp with time zone,
    "resume_imported_at" timestamp with time zone,
    "skill_summary" text,
    "course_name" character varying(150),
    "contact_dial_code" character varying(10),
    "trainer_name" character varying(150),
    "is_deleted" boolean default false,
    "deleted_at" timestamp with time zone,
    "deleted_by" uuid,
    "grade" character varying(10),
    "section" character varying(10),
    "roll_number" character varying(50),
    "admission_number" character varying(100),
    "college_id" uuid,
    "hobbies" jsonb default '[]'::jsonb,
    "languages" jsonb default '[]'::jsonb,
    "interests" jsonb default '[]'::jsonb,
    "category" character varying(50),
    "quota" character varying(50),
    "youtube_link" text,
    "notification_settings" jsonb default '{"weeklyDigest": false, "monthlyReport": false, "newOpportunities": true, "applicationUpdates": true, "emailNotifications": true, "recruitingMessages": true}'::jsonb,
    "documents" jsonb default '[]'::jsonb,
    "semester" integer,
    "program_id" uuid,
    "grade_start_date" date,
    "admission_academic_year" character varying(10),
    "college_class_id" uuid,
    "program_section_id" uuid,
    "tour_progress" jsonb not null default '{}'::jsonb,
    "gap_in_studies" boolean default false,
    "gap_years" integer default 0,
    "gap_reason" text,
    "work_experience" text,
    "aadhar_number" character varying(12),
    "backlogs_history" text,
    "current_backlogs" integer default 0
      );


alter table "public"."students" enable row level security;


  create table "public"."subscription_cancellations" (
    "id" uuid not null default gen_random_uuid(),
    "subscription_id" uuid not null,
    "user_id" uuid not null,
    "cancellation_reason" character varying(100) not null,
    "additional_feedback" text,
    "cancelled_at" timestamp with time zone not null default now(),
    "access_until" timestamp with time zone,
    "reactivated_at" timestamp with time zone,
    "created_at" timestamp with time zone default now()
      );



  create table "public"."subscription_migrations" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "old_plan_code" character varying(50) not null,
    "old_subscription_id" uuid,
    "migrated_feature_keys" text[] not null,
    "original_price" numeric(10,2) not null,
    "new_price" numeric(10,2) not null,
    "price_protected_until" timestamp with time zone,
    "migration_date" timestamp with time zone not null,
    "notification_sent_at" timestamp with time zone,
    "migration_status" character varying(20) default 'pending'::character varying,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."subscription_migrations" enable row level security;


  create table "public"."subscription_plan_features" (
    "id" uuid not null default gen_random_uuid(),
    "plan_id" uuid not null,
    "category" text not null,
    "feature_key" text not null,
    "feature_name" text not null,
    "feature_value" text,
    "is_included" boolean default true,
    "is_addon" boolean default false,
    "addon_price" integer,
    "display_order" integer default 0,
    "created_at" timestamp with time zone default now(),
    "addon_price_monthly" numeric(10,2),
    "addon_price_annual" numeric(10,2),
    "addon_description" text,
    "target_roles" text[] default '{}'::text[],
    "icon_url" text,
    "sort_order_addon" integer default 0
      );


alter table "public"."subscription_plan_features" enable row level security;


  create table "public"."subscription_plans" (
    "id" uuid not null default gen_random_uuid(),
    "plan_code" text not null,
    "name" character varying(100) not null,
    "business_type" text not null,
    "entity_type" text not null,
    "role_type" text not null,
    "price_monthly" integer not null,
    "price_yearly" integer,
    "currency" character varying(3) default 'INR'::character varying,
    "max_users" integer,
    "features" jsonb default '[]'::jsonb,
    "description" text,
    "is_recommended" boolean default false,
    "is_active" boolean default true,
    "display_order" integer default 0,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "tagline" text,
    "positioning" text,
    "color" text default 'bg-slate-600'::text,
    "max_admins" integer,
    "storage_limit" text,
    "ideal_for" text
      );


alter table "public"."subscription_plans" enable row level security;


  create table "public"."subscriptions" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "full_name" character varying(255) not null,
    "email" character varying(255) not null,
    "phone" character varying(20),
    "plan_type" character varying(50) not null,
    "plan_amount" numeric(10,2) not null,
    "billing_cycle" character varying(20) not null,
    "razorpay_subscription_id" character varying(255),
    "razorpay_customer_id" character varying(255),
    "razorpay_payment_id" character varying(255),
    "razorpay_order_id" character varying(255),
    "status" public.subscription_status not null default 'pending'::public.subscription_status,
    "auto_renew" boolean default true,
    "subscription_start_date" timestamp with time zone,
    "subscription_end_date" timestamp with time zone,
    "cancelled_at" timestamp with time zone,
    "last_webhook_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "cancellation_reason" character varying(100),
    "paused_at" timestamp with time zone,
    "paused_until" timestamp with time zone,
    "receipt_url" text,
    "plan_id" uuid,
    "organization_id" uuid,
    "organization_type" text,
    "purchased_by" uuid,
    "seat_count" integer default 1,
    "is_organization_subscription" boolean default false
      );


alter table "public"."subscriptions" enable row level security;


  create table "public"."teacher_journal" (
    "id" uuid not null default gen_random_uuid(),
    "educator_id" uuid,
    "lesson_plan_id" uuid,
    "date" date not null,
    "reflection" text,
    "student_engagement" character varying(20),
    "objectives_met" boolean default false,
    "challenges" text,
    "improvements" text,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );



  create table "public"."teacher_workload" (
    "id" uuid not null default gen_random_uuid(),
    "educator_id" uuid,
    "timetable_id" uuid,
    "total_periods_per_week" integer default 0,
    "max_consecutive_classes" integer default 0,
    "last_calculated" timestamp without time zone default now()
      );



  create table "public"."timetable_conflicts" (
    "id" uuid not null default gen_random_uuid(),
    "timetable_id" uuid,
    "conflict_type" character varying(50) not null,
    "educator_id" uuid,
    "slot_id" uuid,
    "conflict_details" jsonb,
    "resolved" boolean default false,
    "resolved_at" timestamp without time zone,
    "created_at" timestamp without time zone default now()
      );



  create table "public"."timetable_slots" (
    "id" uuid not null default gen_random_uuid(),
    "timetable_id" uuid,
    "educator_id" uuid,
    "class_id" uuid,
    "day_of_week" integer not null,
    "period_number" integer not null,
    "start_time" time without time zone not null,
    "end_time" time without time zone not null,
    "subject_name" character varying(100) not null,
    "room_number" character varying(20),
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );



  create table "public"."timetables" (
    "id" uuid not null default gen_random_uuid(),
    "school_id" uuid,
    "academic_year" character varying(20) not null,
    "term" character varying(20) not null,
    "start_date" date not null,
    "end_date" date not null,
    "status" character varying(20) default 'draft'::character varying,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now(),
    "created_by" uuid
      );



  create table "public"."training_notifications" (
    "id" uuid not null default gen_random_uuid(),
    "training_id" uuid,
    "recipient_type" character varying(20) not null,
    "school_id" uuid,
    "message" text not null,
    "is_read" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "experience_id" uuid,
    "project_id" uuid,
    "college_id" uuid
      );



  create table "public"."trainings" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "title" character varying(150) not null,
    "organization" character varying(150),
    "start_date" date,
    "end_date" date,
    "duration" character varying(100),
    "description" text,
    "approval_status" character varying(20) default 'pending'::character varying,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "status" text default 'ongoing'::text,
    "completed_modules" integer default 0,
    "total_modules" integer default 0,
    "hours_spent" integer default 0,
    "course_id" uuid,
    "source" character varying(50) default 'manual'::character varying,
    "approval_authority" character varying(20) default 'rareminds_admin'::character varying,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "approval_notes" text,
    "rejected_by" uuid,
    "rejected_at" timestamp with time zone,
    "embedding" extensions.vector(1536)
      );



  create table "public"."transcript_requests" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "student_id" uuid not null,
    "student_name" text not null,
    "roll_number" text not null,
    "request_number" text not null,
    "request_date" date not null default CURRENT_DATE,
    "transcript_type" text not null,
    "purpose" text not null,
    "purpose_details" text,
    "number_of_copies" integer default 1,
    "delivery_method" text default 'collect'::text,
    "delivery_address" text,
    "delivery_email" text,
    "processing_fee" numeric(10,2) default 0,
    "courier_charges" numeric(10,2) default 0,
    "total_fee" numeric(10,2) default 0,
    "fee_paid" boolean default false,
    "payment_reference" text,
    "payment_date" date,
    "status" text default 'pending'::text,
    "processed_by" uuid,
    "processed_at" timestamp with time zone,
    "ready_date" date,
    "dispatch_date" date,
    "delivery_date" date,
    "transcript_id" uuid,
    "remarks" text,
    "rejection_reason" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."transcripts" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "student_id" uuid not null,
    "student_name" text not null,
    "roll_number" text not null,
    "program_id" uuid,
    "program_name" text not null,
    "department_id" uuid,
    "type" text not null,
    "template_id" text,
    "academic_year" text not null,
    "semester_from" integer not null,
    "semester_to" integer not null,
    "cgpa" numeric(4,2),
    "sgpa" jsonb,
    "total_credits_earned" integer,
    "total_credits_required" integer,
    "include_qr" boolean default true,
    "verification_id" text,
    "qr_code_url" text,
    "status" text default 'draft'::text,
    "is_published" boolean default false,
    "file_url" text,
    "file_size" integer,
    "generated_at" timestamp with time zone,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "approval_remarks" text,
    "issue_date" date,
    "issue_number" text,
    "created_by" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "student_record_id" uuid
      );



  create table "public"."tutor_conversations" (
    "id" uuid not null default gen_random_uuid(),
    "student_id" uuid not null,
    "course_id" uuid not null,
    "lesson_id" uuid,
    "title" character varying(255),
    "messages" jsonb default '[]'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."tutor_feedback" (
    "id" uuid not null default gen_random_uuid(),
    "conversation_id" uuid not null,
    "message_index" integer not null,
    "rating" integer,
    "feedback_text" text,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."tutor_feedback" enable row level security;


  create table "public"."university_colleges" (
    "id" uuid not null default gen_random_uuid(),
    "university_id" uuid not null,
    "name" character varying(255) not null,
    "code" character varying(50) not null,
    "dean_name" character varying(200),
    "dean_email" character varying(255),
    "dean_phone" character varying(20),
    "established_year" integer,
    "account_status" character varying(20) default 'active'::character varying,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "metadata" jsonb default '{}'::jsonb,
    "created_by" uuid,
    "college_id" uuid
      );



  create table "public"."university_courses" (
    "id" uuid not null default gen_random_uuid(),
    "university_id" uuid not null,
    "name" character varying(255) not null,
    "code" character varying(50) not null,
    "duration" integer,
    "course_type" character varying(50),
    "description" text,
    "approval_status" public.approval_status default 'pending'::public.approval_status,
    "approved_by" uuid,
    "approved_at" timestamp with time zone,
    "is_active" boolean default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "total_students" integer default 0,
    "total_batches" integer default 0
      );


alter table "public"."university_courses" enable row level security;


  create table "public"."university_performance" (
    "id" uuid not null default gen_random_uuid(),
    "universityId" uuid not null,
    "enrollmentCount" integer default 0,
    "completionRate" numeric(5,2) default 0,
    "verificationRate" numeric(5,2) default 0,
    "placementRate" numeric(5,2) default 0,
    "avgSalary" numeric(10,2) default 0,
    "performanceScore" numeric(5,2) default 0,
    "rankPosition" integer,
    "snapshotDate" date not null default CURRENT_DATE,
    "createdAt" timestamp with time zone default now()
      );


alter table "public"."university_performance" enable row level security;


  create table "public"."user_categories" (
    "id" uuid not null default gen_random_uuid(),
    "name" character varying(100) not null,
    "description" text,
    "metadata" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "updated_by" uuid
      );


alter table "public"."user_categories" enable row level security;


  create table "public"."user_entitlements" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "feature_key" text not null,
    "bundle_id" uuid,
    "status" character varying(20) not null default 'active'::character varying,
    "billing_period" character varying(10) not null,
    "start_date" timestamp with time zone not null default now(),
    "end_date" timestamp with time zone not null,
    "auto_renew" boolean default true,
    "price_at_purchase" numeric(10,2) not null,
    "razorpay_subscription_id" character varying(100),
    "is_grandfathered" boolean default false,
    "grandfathered_until" timestamp with time zone,
    "cancelled_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "granted_by_organization" boolean default false,
    "organization_subscription_id" uuid,
    "granted_by" uuid
      );


alter table "public"."user_entitlements" enable row level security;


  create table "public"."user_login_history" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "login_at" timestamp with time zone default now(),
    "ip_address" text,
    "user_agent" text,
    "success" boolean not null,
    "failure_reason" text,
    "location_data" jsonb default '{}'::jsonb
      );


alter table "public"."user_login_history" enable row level security;


  create table "public"."user_profiles" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "avatar_url" text,
    "bio" text,
    "skills" text[],
    "interests" text[],
    "social_links" jsonb default '{}'::jsonb,
    "preferences" jsonb default '{}'::jsonb,
    "additional_contact" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "updated_by" uuid
      );


alter table "public"."user_profiles" enable row level security;


  create table "public"."user_sessions" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "session_token" text not null,
    "ip_address" text,
    "user_agent" text,
    "started_at" timestamp with time zone default now(),
    "ended_at" timestamp with time zone,
    "is_valid" boolean default true,
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."user_sessions" enable row level security;


  create table "public"."user_settings" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "notification_preferences" jsonb default '{}'::jsonb,
    "privacy_settings" jsonb default '{}'::jsonb,
    "ui_preferences" jsonb default '{}'::jsonb,
    "communication_preferences" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "updated_by" uuid
      );


alter table "public"."user_settings" enable row level security;


  create table "public"."user_state_history" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "previous_state" character varying(50),
    "new_state" character varying(50) not null,
    "change_reason" text,
    "changed_at" timestamp with time zone default now(),
    "changed_by" uuid,
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."user_state_history" enable row level security;


  create table "public"."users" (
    "email" text not null,
    "organizationId" uuid,
    "isActive" boolean default true,
    "metadata" jsonb default '{}'::jsonb,
    "createdAt" timestamp with time zone default now(),
    "updatedAt" timestamp with time zone default now(),
    "id" uuid not null default gen_random_uuid(),
    "firstName" character varying,
    "lastName" character varying,
    "last_activity_at" timestamp with time zone,
    "role" public.user_role not null,
    "temporary_password" character varying(255),
    "password_changed" boolean default false,
    "phone" character varying(20)
      );



  create table "public"."verifications" (
    "id" text not null default (gen_random_uuid())::text,
    "targetTable" text not null,
    "targetId" text not null,
    "action" text not null,
    "performedBy" uuid,
    "note" text,
    "createdAt" timestamp with time zone default now()
      );


alter table "public"."verifications" enable row level security;


  create table "public"."video_summaries" (
    "id" uuid not null default gen_random_uuid(),
    "lesson_id" uuid,
    "course_id" uuid,
    "video_url" text not null,
    "video_type" character varying(50) default 'uploaded'::character varying,
    "transcript" text,
    "transcript_segments" jsonb default '[]'::jsonb,
    "summary" text,
    "key_points" jsonb default '[]'::jsonb,
    "chapters" jsonb default '[]'::jsonb,
    "topics" jsonb default '[]'::jsonb,
    "duration_seconds" integer,
    "language" character varying(10) default 'en'::character varying,
    "processing_status" character varying(50) default 'pending'::character varying,
    "error_message" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "processed_at" timestamp with time zone,
    "sentiment_data" jsonb default '{}'::jsonb,
    "speakers" jsonb default '[]'::jsonb,
    "deepgram_summary" text,
    "notable_quotes" jsonb default '[]'::jsonb,
    "quiz_questions" jsonb default '[]'::jsonb,
    "flashcards" jsonb default '[]'::jsonb,
    "srt_content" text,
    "vtt_content" text
      );


alter table "public"."video_summaries" enable row level security;

alter sequence "public"."export_activities_id_seq" owned by "public"."export_activities"."id";

alter sequence "public"."interview_reminders_id_seq" owned by "public"."interview_reminders"."id";

alter sequence "public"."messages_id_seq" owned by "public"."messages"."id";

alter sequence "public"."pipeline_activities_id_seq" owned by "public"."pipeline_activities"."id";

alter sequence "public"."search_history_id_seq" owned by "public"."search_history"."id";

alter sequence "public"."shortlist_candidates_id_seq" owned by "public"."shortlist_candidates"."id";

CREATE UNIQUE INDEX adaptive_aptitude_questions_cache_pkey ON public.adaptive_aptitude_questions_cache USING btree (id);

CREATE UNIQUE INDEX adaptive_aptitude_questions_cache_question_id_key ON public.adaptive_aptitude_questions_cache USING btree (question_id);

CREATE UNIQUE INDEX adaptive_aptitude_responses_pkey ON public.adaptive_aptitude_responses USING btree (id);

CREATE UNIQUE INDEX adaptive_aptitude_results_pkey ON public.adaptive_aptitude_results USING btree (id);

CREATE UNIQUE INDEX adaptive_aptitude_results_session_id_key ON public.adaptive_aptitude_results USING btree (session_id);

CREATE UNIQUE INDEX adaptive_aptitude_sessions_pkey ON public.adaptive_aptitude_sessions USING btree (id);

CREATE UNIQUE INDEX addon_discount_codes_code_key ON public.addon_discount_codes USING btree (code);

CREATE UNIQUE INDEX addon_discount_codes_pkey ON public.addon_discount_codes USING btree (id);

CREATE UNIQUE INDEX addon_events_pkey ON public.addon_events USING btree (id);

CREATE UNIQUE INDEX addon_pending_orders_pkey ON public.addon_pending_orders USING btree (id);

CREATE UNIQUE INDEX addon_pending_orders_razorpay_order_id_key ON public.addon_pending_orders USING btree (razorpay_order_id);

CREATE UNIQUE INDEX admin_users_pkey ON public.admin_users USING btree (id, admin_role);

CREATE UNIQUE INDEX admin_users_user_id_key ON public.admin_users USING btree (id);

CREATE UNIQUE INDEX admission_applications_application_number_key ON public.admission_applications USING btree (application_number);

CREATE UNIQUE INDEX admission_applications_pkey ON public.admission_applications USING btree (id);

CREATE UNIQUE INDEX ai_evaluations_conversation_id_message_id_key ON public.ai_evaluations USING btree (conversation_id, message_id);

CREATE UNIQUE INDEX ai_evaluations_pkey ON public.ai_evaluations USING btree (id);

CREATE UNIQUE INDEX app_config_pkey ON public.app_config USING btree (key);

CREATE UNIQUE INDEX applied_jobs_id_old_unique ON public.applied_jobs USING btree (id_old);

CREATE UNIQUE INDEX applied_jobs_pkey ON public.applied_jobs USING btree (id);

CREATE UNIQUE INDEX approval_actions_pkey ON public.approval_actions USING btree (id);

CREATE UNIQUE INDEX approval_requests_pkey ON public.approval_requests USING btree (id);

CREATE UNIQUE INDEX approval_types_pkey ON public.approval_types USING btree (name);

CREATE UNIQUE INDEX approval_workflows_pkey ON public.approval_workflows USING btree (id);

CREATE UNIQUE INDEX assessment_attempts_pkey ON public.personal_assessment_attempts USING btree (id);

CREATE UNIQUE INDEX assessment_questions_pkey ON public.personal_assessment_questions USING btree (id);

CREATE UNIQUE INDEX assessment_responses_attempt_id_question_id_key ON public.personal_assessment_responses USING btree (attempt_id, question_id);

CREATE UNIQUE INDEX assessment_responses_pkey ON public.personal_assessment_responses USING btree (id);

CREATE UNIQUE INDEX assessment_results_attempt_id_key ON public.personal_assessment_results USING btree (attempt_id);

CREATE UNIQUE INDEX assessment_results_pkey ON public.personal_assessment_results USING btree (id);

CREATE UNIQUE INDEX assessment_sections_name_key ON public.personal_assessment_sections USING btree (name);

CREATE UNIQUE INDEX assessment_sections_pkey ON public.personal_assessment_sections USING btree (id);

CREATE UNIQUE INDEX assessment_streams_pkey ON public.personal_assessment_streams USING btree (id);

CREATE UNIQUE INDEX assessment_types_pkey ON public.assessment_types USING btree (id);

CREATE UNIQUE INDEX assessments_assessment_code_key ON public.assessments USING btree (assessment_code);

CREATE UNIQUE INDEX assessments_pkey ON public.assessments USING btree (id);

CREATE UNIQUE INDEX assignment_attachments_pkey ON public.assignment_attachments USING btree (attachment_id);

CREATE UNIQUE INDEX assignments_pkey ON public.assignments USING btree (assignment_id);

CREATE UNIQUE INDEX attendance_alerts_pkey ON public.attendance_alerts USING btree (id);

CREATE UNIQUE INDEX attendance_records_pkey ON public.attendance_records USING btree (id);

CREATE UNIQUE INDEX attendance_records_student_date_slot_key ON public.attendance_records USING btree (student_id, date, slot_id);

CREATE UNIQUE INDEX audit_logs_pkey ON public.audit_logs USING btree (id);

CREATE UNIQUE INDEX budget_alerts_pkey ON public.budget_alerts USING btree (id);

CREATE UNIQUE INDEX budget_revisions_pkey ON public.budget_revisions USING btree (id);

CREATE UNIQUE INDEX bundle_features_bundle_id_feature_key_key ON public.bundle_features USING btree (bundle_id, feature_key);

CREATE UNIQUE INDEX bundle_features_pkey ON public.bundle_features USING btree (id);

CREATE UNIQUE INDEX bundles_pkey ON public.bundles USING btree (id);

CREATE UNIQUE INDEX bundles_slug_key ON public.bundles USING btree (slug);

CREATE UNIQUE INDEX career_ai_conversations_pkey ON public.career_ai_conversations USING btree (id);

CREATE UNIQUE INDEX career_assessment_ai_questions_pkey ON public.career_assessment_ai_questions USING btree (id);

CREATE UNIQUE INDEX career_assessment_ai_questions_student_stream_type_key ON public.career_assessment_ai_questions USING btree (student_id, stream_id, question_type);

CREATE INDEX certificates_embedding_idx ON public.certificates USING hnsw (embedding extensions.vector_cosine_ops) WITH (m='16', ef_construction='64');

CREATE UNIQUE INDEX certificates_pkey ON public.certificates USING btree (id);

CREATE UNIQUE INDEX class_swap_history_pkey ON public.class_swap_history USING btree (id);

CREATE UNIQUE INDEX class_swap_requests_pkey ON public.class_swap_requests USING btree (id);

CREATE UNIQUE INDEX club_activities_pkey ON public.club_activities USING btree (activity_id);

CREATE UNIQUE INDEX club_attendance_pkey ON public.club_attendance USING btree (attendance_id);

CREATE UNIQUE INDEX club_attendance_records_pkey ON public.club_attendance_records USING btree (record_id);

CREATE UNIQUE INDEX club_certificates_credential_id_key ON public.club_certificates USING btree (credential_id);

CREATE UNIQUE INDEX club_certificates_pkey ON public.club_certificates USING btree (certificate_id);

CREATE UNIQUE INDEX club_memberships_pkey ON public.club_memberships USING btree (membership_id);

CREATE UNIQUE INDEX clubs_pkey ON public.clubs USING btree (club_id);

CREATE UNIQUE INDEX college_assignment_attachments_pkey ON public.college_assignment_attachments USING btree (attachment_id);

CREATE UNIQUE INDEX college_assignments_pkey ON public.college_assignments USING btree (assignment_id);

CREATE UNIQUE INDEX college_attendance_records_pkey ON public.college_attendance_records USING btree (id);

CREATE UNIQUE INDEX college_attendance_sessions_pkey ON public.college_attendance_sessions USING btree (id);

CREATE UNIQUE INDEX college_attendance_settings_college_id_key ON public.college_attendance_settings USING btree (college_id);

CREATE UNIQUE INDEX college_attendance_settings_pkey ON public.college_attendance_settings USING btree (id);

CREATE UNIQUE INDEX college_breaks_pkey ON public.college_breaks USING btree (id);

CREATE UNIQUE INDEX college_circulars_pkey ON public.college_circulars USING btree (id);

CREATE UNIQUE INDEX college_classes_pkey ON public.college_classes USING btree (id);

CREATE UNIQUE INDEX college_course_mappings_pkey ON public.college_course_mappings USING btree (id);

CREATE UNIQUE INDEX college_courses_pkey ON public.college_courses USING btree (id);

CREATE UNIQUE INDEX college_curriculum_outcomes_pkey ON public.college_curriculum_outcomes USING btree (id);

CREATE UNIQUE INDEX college_curriculum_units_curriculum_id_order_index_key ON public.college_curriculum_units USING btree (curriculum_id, order_index);

CREATE UNIQUE INDEX college_curriculum_units_pkey ON public.college_curriculum_units USING btree (id);

CREATE UNIQUE INDEX college_curriculums_pkey ON public.college_curriculums USING btree (id);

CREATE UNIQUE INDEX college_event_registrations_event_id_student_id_key ON public.college_event_registrations USING btree (event_id, student_id);

CREATE UNIQUE INDEX college_event_registrations_pkey ON public.college_event_registrations USING btree (id);

CREATE UNIQUE INDEX college_events_pkey ON public.college_events USING btree (id);

CREATE UNIQUE INDEX college_faculty_class_assignm_faculty_id_class_id_subject_n_key ON public.college_faculty_class_assignments USING btree (faculty_id, class_id, subject_name);

CREATE UNIQUE INDEX college_faculty_class_assignments_pkey ON public.college_faculty_class_assignments USING btree (id);

CREATE UNIQUE INDEX college_faculty_leave_balance_faculty_id_leave_type_id_acad_key ON public.college_faculty_leave_balances USING btree (faculty_id, leave_type_id, academic_year);

CREATE UNIQUE INDEX college_faculty_leave_balances_pkey ON public.college_faculty_leave_balances USING btree (id);

CREATE UNIQUE INDEX college_faculty_leaves_pkey ON public.college_faculty_leaves USING btree (id);

CREATE UNIQUE INDEX college_faculty_substitutions_pkey ON public.college_faculty_substitutions USING btree (id);

CREATE UNIQUE INDEX college_leave_types_college_id_code_key ON public.college_leave_types USING btree (college_id, code);

CREATE UNIQUE INDEX college_leave_types_pkey ON public.college_leave_types USING btree (id);

CREATE UNIQUE INDEX college_lecturers_pkey ON public.college_lecturers USING btree (id);

CREATE UNIQUE INDEX college_lecturers_user_id_key ON public.college_lecturers USING btree (user_id);

CREATE UNIQUE INDEX college_lesson_plans_pkey ON public.college_lesson_plans USING btree (id);

CREATE UNIQUE INDEX college_mentor_notes_pkey ON public.college_mentor_notes USING btree (id);

CREATE UNIQUE INDEX college_mentor_periods_pkey ON public.college_mentor_periods USING btree (id);

CREATE UNIQUE INDEX college_mentor_student_allocations_pkey ON public.college_mentor_student_allocations USING btree (id);

CREATE UNIQUE INDEX college_role_module_permissio_role_type_module_id_permissio_key ON public.college_role_module_permissions USING btree (role_type, module_id, permission_id);

CREATE UNIQUE INDEX college_role_module_permissions_pkey ON public.college_role_module_permissions USING btree (id);

CREATE UNIQUE INDEX college_role_scope_rules_pkey ON public.college_role_scope_rules USING btree (id);

CREATE UNIQUE INDEX college_role_scope_rules_role_type_scope_type_scope_value_key ON public.college_role_scope_rules USING btree (role_type, scope_type, scope_value);

CREATE UNIQUE INDEX college_setting_modules_module_name_key ON public.college_setting_modules USING btree (module_name);

CREATE UNIQUE INDEX college_setting_modules_pkey ON public.college_setting_modules USING btree (id);

CREATE UNIQUE INDEX college_setting_permissions_permission_name_key ON public.college_setting_permissions USING btree (permission_name);

CREATE UNIQUE INDEX college_setting_permissions_pkey ON public.college_setting_permissions USING btree (id);

CREATE UNIQUE INDEX college_student_assignments_pkey ON public.college_student_assignments USING btree (student_assignment_id);

CREATE UNIQUE INDEX college_time_periods_pkey ON public.college_time_periods USING btree (id);

CREATE UNIQUE INDEX college_time_periods_timetable_id_period_number_key ON public.college_time_periods USING btree (timetable_id, period_number);

CREATE UNIQUE INDEX college_timetable_slots_pkey ON public.college_timetable_slots USING btree (id);

CREATE UNIQUE INDEX college_timetable_slots_timetable_id_day_of_week_period_num_key ON public.college_timetable_slots USING btree (timetable_id, day_of_week, period_number, educator_id);

CREATE UNIQUE INDEX college_timetables_pkey ON public.college_timetables USING btree (id);

CREATE UNIQUE INDEX companies_pkey ON public.companies USING btree (id);

CREATE UNIQUE INDEX competition_clubs_pkey ON public.competition_clubs USING btree (id);

CREATE UNIQUE INDEX competition_registrations_pkey ON public.competition_registrations USING btree (registration_id);

CREATE UNIQUE INDEX competition_results_pkey ON public.competition_results USING btree (result_id);

CREATE UNIQUE INDEX competitions_pkey ON public.competitions USING btree (comp_id);

CREATE UNIQUE INDEX conversations_pkey ON public.conversations USING btree (id);

CREATE UNIQUE INDEX conversations_student_id_recruiter_id_application_id_key ON public.conversations USING btree (student_id, recruiter_id, application_id);

CREATE UNIQUE INDEX course_classes_pkey ON public.course_classes USING btree (course_class_id);

CREATE UNIQUE INDEX course_co_educators_pkey ON public.course_co_educators USING btree (co_educator_id);

CREATE INDEX course_enrollments_embedding_hnsw_idx ON public.course_enrollments USING hnsw (embedding extensions.vector_cosine_ops) WITH (m='16', ef_construction='64');

CREATE UNIQUE INDEX course_enrollments_pkey ON public.course_enrollments USING btree (id);

CREATE UNIQUE INDEX course_enrollments_student_id_course_id_key ON public.course_enrollments USING btree (student_id, course_id);

CREATE UNIQUE INDEX course_modules_pkey ON public.course_modules USING btree (module_id);

CREATE UNIQUE INDEX course_skills_pkey ON public.course_skills USING btree (course_skill_id);

CREATE UNIQUE INDEX courses_code_key ON public.courses USING btree (code);

CREATE INDEX courses_embedding_idx ON public.courses USING ivfflat (embedding extensions.vector_cosine_ops) WITH (lists='100');

CREATE UNIQUE INDEX courses_pkey ON public.courses USING btree (course_id);

CREATE UNIQUE INDEX curriculum_academic_years_pkey ON public.curriculum_academic_years USING btree (id);

CREATE UNIQUE INDEX curriculum_academic_years_school_id_year_key ON public.curriculum_academic_years USING btree (school_id, year);

CREATE UNIQUE INDEX curriculum_chapters_curriculum_id_order_number_key ON public.curriculum_chapters USING btree (curriculum_id, order_number);

CREATE UNIQUE INDEX curriculum_chapters_pkey ON public.curriculum_chapters USING btree (id);

CREATE UNIQUE INDEX curriculum_classes_pkey ON public.curriculum_classes USING btree (id);

CREATE UNIQUE INDEX curriculum_classes_school_id_name_key ON public.curriculum_classes USING btree (school_id, name);

CREATE UNIQUE INDEX curriculum_courses_college_id_course_code_semester_key ON public.curriculum_courses USING btree (college_id, course_code, semester);

CREATE UNIQUE INDEX curriculum_courses_pkey ON public.curriculum_courses USING btree (id);

CREATE UNIQUE INDEX curriculum_learning_outcomes_pkey ON public.curriculum_learning_outcomes USING btree (id);

CREATE UNIQUE INDEX curriculum_subjects_pkey ON public.curriculum_subjects USING btree (id);

CREATE UNIQUE INDEX curriculum_subjects_school_id_name_key ON public.curriculum_subjects USING btree (school_id, name);

CREATE UNIQUE INDEX curriculums_pkey ON public.curriculums USING btree (id);

CREATE UNIQUE INDEX curriculums_school_id_subject_class_academic_year_key ON public.curriculums USING btree (school_id, subject, class, academic_year);

CREATE UNIQUE INDEX department_budgets_department_id_financial_year_quarter_key ON public.department_budgets USING btree (department_id, financial_year, quarter);

CREATE UNIQUE INDEX department_budgets_pkey ON public.department_budgets USING btree (id);

CREATE UNIQUE INDEX department_faculty_assignments_pkey ON public.department_faculty_assignments USING btree (id);

select 1; 
-- CREATE INDEX department_faculty_assignments_single_hod ON public.department_faculty_assignments USING btree (department_id) WHERE ((is_hod = true) AND (is_active = true));

CREATE UNIQUE INDEX department_faculty_assignments_unique_lecturer_dept ON public.department_faculty_assignments USING btree (department_id, lecturer_id);

CREATE UNIQUE INDEX departments_pkey ON public.departments USING btree (id);

CREATE UNIQUE INDEX document_access_history_pkey ON public.document_access_history USING btree (id);

CREATE UNIQUE INDEX education_pkey ON public.education USING btree (id);

CREATE UNIQUE INDEX embedding_cache_pkey ON public.embedding_cache USING btree (id);

CREATE UNIQUE INDEX embedding_queue_pkey ON public.embedding_queue USING btree (id);

CREATE UNIQUE INDEX embedding_queue_record_status_unique ON public.embedding_queue USING btree (record_id, table_name, status);

CREATE UNIQUE INDEX event_registrations_pkey ON public.event_registrations USING btree (id);

CREATE UNIQUE INDEX exam_registrations_exam_window_id_student_id_assessment_id_key ON public.exam_registrations USING btree (exam_window_id, student_id, assessment_id);

CREATE UNIQUE INDEX exam_registrations_hall_ticket_number_key ON public.exam_registrations USING btree (hall_ticket_number);

CREATE UNIQUE INDEX exam_registrations_pkey ON public.exam_registrations USING btree (id);

CREATE UNIQUE INDEX exam_registrations_registration_number_key ON public.exam_registrations USING btree (registration_number);

CREATE UNIQUE INDEX exam_rooms_pkey ON public.exam_rooms USING btree (id);

CREATE UNIQUE INDEX exam_rooms_room_code_key ON public.exam_rooms USING btree (room_code);

CREATE UNIQUE INDEX exam_seating_arrangements_exam_timetable_id_exam_room_id_se_key ON public.exam_seating_arrangements USING btree (exam_timetable_id, exam_room_id, seat_number);

CREATE UNIQUE INDEX exam_seating_arrangements_exam_timetable_id_student_id_key ON public.exam_seating_arrangements USING btree (exam_timetable_id, student_id);

CREATE UNIQUE INDEX exam_seating_arrangements_pkey ON public.exam_seating_arrangements USING btree (id);

CREATE UNIQUE INDEX exam_timetable_pkey ON public.exam_timetable USING btree (id);

CREATE UNIQUE INDEX exam_windows_pkey ON public.exam_windows USING btree (id);

CREATE UNIQUE INDEX exam_windows_window_code_key ON public.exam_windows USING btree (window_code);

CREATE UNIQUE INDEX expenditures_expenditure_number_key ON public.expenditures USING btree (expenditure_number);

CREATE UNIQUE INDEX expenditures_pkey ON public.expenditures USING btree (id);

CREATE UNIQUE INDEX experience_pkey ON public.experience USING btree (id);

CREATE UNIQUE INDEX export_activities_pkey ON public.export_activities USING btree (id);

CREATE UNIQUE INDEX external_assessment_attempts_pkey ON public.external_assessment_attempts USING btree (id);

CREATE UNIQUE INDEX external_courses_pkey ON public.external_courses USING btree (id);

CREATE UNIQUE INDEX fee_payments_pkey ON public.fee_payments USING btree (id);

CREATE UNIQUE INDEX fee_payments_receipt_number_key ON public.fee_payments USING btree (receipt_number);

CREATE UNIQUE INDEX fee_structures_pkey ON public.fee_structures USING btree (id);

CREATE UNIQUE INDEX fee_structures_program_id_semester_category_academic_year_key ON public.fee_structures USING btree (program_id, semester, category, academic_year);

CREATE UNIQUE INDEX generated_external_assessment_certificate_name_key ON public.generated_external_assessment USING btree (certificate_name);

CREATE UNIQUE INDEX generated_external_assessment_pkey ON public.generated_external_assessment USING btree (id);

CREATE UNIQUE INDEX grading_systems_pkey ON public.grading_systems USING btree (id);

CREATE UNIQUE INDEX grading_systems_system_code_grade_label_key ON public.grading_systems USING btree (system_code, grade_label);

CREATE UNIQUE INDEX grading_systems_system_code_key ON public.grading_systems USING btree (system_code);

CREATE INDEX idx_adaptive_responses_difficulty ON public.adaptive_aptitude_responses USING btree (difficulty_at_time);

CREATE INDEX idx_adaptive_responses_phase ON public.adaptive_aptitude_responses USING btree (phase);

CREATE INDEX idx_adaptive_responses_question ON public.adaptive_aptitude_responses USING btree (question_id);

CREATE INDEX idx_adaptive_responses_session ON public.adaptive_aptitude_responses USING btree (session_id);

CREATE INDEX idx_adaptive_responses_session_sequence ON public.adaptive_aptitude_responses USING btree (session_id, sequence_number);

CREATE INDEX idx_adaptive_responses_subtag ON public.adaptive_aptitude_responses USING btree (subtag);

CREATE INDEX idx_adaptive_results_accuracy_difficulty_gin ON public.adaptive_aptitude_results USING gin (accuracy_by_difficulty);

CREATE INDEX idx_adaptive_results_accuracy_subtag_gin ON public.adaptive_aptitude_results USING gin (accuracy_by_subtag);

CREATE INDEX idx_adaptive_results_aptitude_level ON public.adaptive_aptitude_results USING btree (aptitude_level);

CREATE INDEX idx_adaptive_results_completed_at ON public.adaptive_aptitude_results USING btree (completed_at);

CREATE INDEX idx_adaptive_results_confidence ON public.adaptive_aptitude_results USING btree (confidence_tag);

CREATE INDEX idx_adaptive_results_grade_level ON public.adaptive_aptitude_results USING btree (grade_level);

CREATE INDEX idx_adaptive_results_session ON public.adaptive_aptitude_results USING btree (session_id);

CREATE INDEX idx_adaptive_results_student ON public.adaptive_aptitude_results USING btree (student_id);

CREATE INDEX idx_adaptive_results_student_completed ON public.adaptive_aptitude_results USING btree (student_id, completed_at DESC);

CREATE INDEX idx_adaptive_sessions_grade_level ON public.adaptive_aptitude_sessions USING btree (grade_level);

CREATE INDEX idx_adaptive_sessions_started_at ON public.adaptive_aptitude_sessions USING btree (started_at);

CREATE INDEX idx_adaptive_sessions_status ON public.adaptive_aptitude_sessions USING btree (status);

CREATE INDEX idx_adaptive_sessions_student ON public.adaptive_aptitude_sessions USING btree (student_id);

CREATE INDEX idx_adaptive_sessions_student_status ON public.adaptive_aptitude_sessions USING btree (student_id, status);

CREATE INDEX idx_addon_events_created_at ON public.addon_events USING btree (created_at);

CREATE INDEX idx_addon_events_event_type ON public.addon_events USING btree (event_type);

CREATE INDEX idx_addon_events_feature_key ON public.addon_events USING btree (feature_key);

CREATE INDEX idx_addon_events_user_id ON public.addon_events USING btree (user_id);

CREATE INDEX idx_addon_pending_orders_bulk_status ON public.addon_pending_orders USING btree (is_bulk_order, status, created_at DESC) WHERE (is_bulk_order = true);

CREATE INDEX idx_addon_pending_orders_member_type ON public.addon_pending_orders USING btree (organization_id, target_member_type) WHERE (is_bulk_order = true);

CREATE INDEX idx_addon_pending_orders_organization ON public.addon_pending_orders USING btree (organization_id) WHERE (is_bulk_order = true);

CREATE INDEX idx_addon_pending_orders_razorpay_order_id ON public.addon_pending_orders USING btree (razorpay_order_id);

CREATE INDEX idx_addon_pending_orders_status ON public.addon_pending_orders USING btree (status);

CREATE INDEX idx_addon_pending_orders_user_id ON public.addon_pending_orders USING btree (user_id);

CREATE INDEX idx_admission_applications_applied_date ON public.admission_applications USING btree (applied_date);

CREATE INDEX idx_admission_applications_school ON public.admission_applications USING btree (school_id);

CREATE INDEX idx_admission_applications_status ON public.admission_applications USING btree (status);

CREATE INDEX idx_ai_eval_conversation ON public.ai_evaluations USING btree (conversation_id);

CREATE INDEX idx_ai_eval_created ON public.ai_evaluations USING btree (created_at DESC);

CREATE INDEX idx_ai_eval_intent ON public.ai_evaluations USING btree (detected_intent);

CREATE INDEX idx_ai_eval_student ON public.ai_evaluations USING btree (student_id);

CREATE INDEX idx_ai_eval_thumbs ON public.ai_evaluations USING btree (thumbs_up) WHERE (thumbs_up IS NOT NULL);

CREATE INDEX idx_applied_jobs_applied_at ON public.applied_jobs USING btree (applied_at DESC);

CREATE INDEX idx_applied_jobs_opportunity_id ON public.applied_jobs USING btree (opportunity_id_old);

CREATE INDEX idx_applied_jobs_opportunity_student ON public.applied_jobs USING btree (opportunity_id_old, student_id);

CREATE INDEX idx_applied_jobs_status ON public.applied_jobs USING btree (application_status);

CREATE INDEX idx_applied_jobs_student_date ON public.applied_jobs USING btree (student_id, applied_at DESC);

CREATE INDEX idx_applied_jobs_student_id ON public.applied_jobs USING btree (student_id);

CREATE INDEX idx_approval_actions_request ON public.approval_actions USING btree (request_id);

CREATE INDEX idx_approval_requests_status ON public.approval_requests USING btree (status);

CREATE INDEX idx_approval_requests_workflow ON public.approval_requests USING btree (workflow_id);

CREATE INDEX idx_assessment_attempts_status ON public.personal_assessment_attempts USING btree (status);

CREATE INDEX idx_assessment_attempts_student ON public.personal_assessment_attempts USING btree (student_id);

CREATE INDEX idx_assessment_attempts_total_time_minutes ON public.personal_assessment_attempts USING btree (total_time_minutes) WHERE (total_time_minutes IS NOT NULL);

CREATE INDEX idx_assessment_questions_section ON public.personal_assessment_questions USING btree (section_id);

CREATE INDEX idx_assessment_questions_stream ON public.personal_assessment_questions USING btree (stream_id);

CREATE INDEX idx_assessment_responses_attempt ON public.personal_assessment_responses USING btree (attempt_id);

CREATE INDEX idx_assessment_results_stream ON public.personal_assessment_results USING btree (stream_id);

CREATE INDEX idx_assessment_results_student ON public.personal_assessment_results USING btree (student_id);

CREATE INDEX idx_assessment_types_active ON public.assessment_types USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_assessment_types_institution ON public.assessment_types USING btree (institution_id, institution_type);

CREATE INDEX idx_assessments_academic_year ON public.assessments USING btree (academic_year);

CREATE INDEX idx_assessments_college ON public.assessments USING btree (college_id);

CREATE INDEX idx_assessments_course ON public.assessments USING btree (course_id);

CREATE INDEX idx_assessments_department ON public.assessments USING btree (department_id);

CREATE INDEX idx_assessments_faculty ON public.assessments USING btree (faculty_id);

CREATE INDEX idx_assessments_program ON public.assessments USING btree (program_id);

CREATE INDEX idx_assessments_semester ON public.assessments USING btree (semester);

CREATE INDEX idx_assessments_status ON public.assessments USING btree (status);

CREATE INDEX idx_assessments_target_classes ON public.assessments USING gin (target_classes);

CREATE INDEX idx_assessments_type ON public.assessments USING btree (type);

CREATE INDEX idx_assignments_course ON public.assignments USING btree (course_name);

CREATE INDEX idx_assignments_due_date ON public.assignments USING btree (due_date);

CREATE INDEX idx_assignments_educator ON public.assignments USING btree (educator_id);

CREATE INDEX idx_attachments_assignment ON public.assignment_attachments USING btree (assignment_id);

CREATE INDEX idx_attempts_adaptive_session ON public.personal_assessment_attempts USING btree (adaptive_aptitude_session_id) WHERE (adaptive_aptitude_session_id IS NOT NULL);

CREATE INDEX idx_attempts_grade_level ON public.personal_assessment_attempts USING btree (grade_level);

CREATE INDEX idx_attempts_student_status ON public.personal_assessment_attempts USING btree (student_id, status);

CREATE INDEX idx_attendance_alerts_notified ON public.attendance_alerts USING btree (parent_notified);

CREATE INDEX idx_attendance_alerts_school ON public.attendance_alerts USING btree (school_id);

CREATE INDEX idx_attendance_alerts_student ON public.attendance_alerts USING btree (student_id);

CREATE INDEX idx_attendance_records_date ON public.attendance_records USING btree (date);

CREATE INDEX idx_attendance_records_school ON public.attendance_records USING btree (school_id);

CREATE INDEX idx_attendance_records_school_date_slot ON public.attendance_records USING btree (school_id, date, slot_id);

CREATE INDEX idx_attendance_records_slot_id_date ON public.attendance_records USING btree (slot_id, date);

CREATE INDEX idx_attendance_records_status ON public.attendance_records USING btree (status);

CREATE INDEX idx_attendance_records_student ON public.attendance_records USING btree (student_id);

CREATE INDEX idx_audit_action ON public.audit_logs USING btree (action);

CREATE INDEX idx_audit_action_date ON public.audit_logs USING btree (action, "createdAt" DESC);

CREATE INDEX idx_audit_actor ON public.audit_logs USING btree ("actorId");

CREATE INDEX idx_audit_actor_action ON public.audit_logs USING btree ("actorId", action);

CREATE INDEX idx_audit_actorid ON public.audit_logs USING btree ("actorId");

CREATE INDEX idx_audit_created ON public.audit_logs USING btree ("createdAt" DESC);

CREATE INDEX idx_audit_createdat ON public.audit_logs USING btree ("createdAt" DESC);

CREATE INDEX idx_audit_ip_trgm ON public.audit_logs USING gin (ip extensions.gin_trgm_ops);

CREATE INDEX idx_audit_target ON public.audit_logs USING btree (target);

CREATE INDEX idx_audit_target_trgm ON public.audit_logs USING gin (target extensions.gin_trgm_ops);

CREATE INDEX idx_budget_alerts_acknowledged ON public.budget_alerts USING btree (is_acknowledged);

CREATE INDEX idx_budget_alerts_budget ON public.budget_alerts USING btree (budget_id);

CREATE INDEX idx_budget_alerts_department ON public.budget_alerts USING btree (department_id);

CREATE INDEX idx_budget_alerts_level ON public.budget_alerts USING btree (alert_level);

CREATE INDEX idx_budget_alerts_type ON public.budget_alerts USING btree (alert_type);

CREATE INDEX idx_budget_revisions_budget ON public.budget_revisions USING btree (budget_id);

CREATE INDEX idx_budget_revisions_date ON public.budget_revisions USING btree (requested_at);

CREATE INDEX idx_budget_revisions_department ON public.budget_revisions USING btree (department_id);

CREATE INDEX idx_budget_revisions_status ON public.budget_revisions USING btree (approval_status);

CREATE INDEX idx_bundle_features_bundle_id ON public.bundle_features USING btree (bundle_id);

CREATE INDEX idx_bundle_features_feature_key ON public.bundle_features USING btree (feature_key);

CREATE INDEX idx_career_ai_conversations_student_id ON public.career_ai_conversations USING btree (student_id);

CREATE INDEX idx_career_ai_conversations_updated_at ON public.career_ai_conversations USING btree (updated_at DESC);

CREATE INDEX idx_career_ai_questions_active ON public.career_assessment_ai_questions USING btree (is_active);

CREATE INDEX idx_career_ai_questions_stream ON public.career_assessment_ai_questions USING btree (stream_id);

CREATE INDEX idx_career_ai_questions_type ON public.career_assessment_ai_questions USING btree (question_type);

CREATE INDEX idx_career_assessment_ai_questions_grade_level ON public.career_assessment_ai_questions USING btree (grade_level);

CREATE INDEX idx_career_assessment_ai_questions_grade_stream ON public.career_assessment_ai_questions USING btree (grade_level, stream_id, question_type);

CREATE INDEX idx_career_assessment_ai_questions_student ON public.career_assessment_ai_questions USING btree (student_id);

CREATE INDEX idx_certificates_active ON public.certificates USING btree (student_id, created_at DESC) WHERE (((status IS NULL) OR ((status)::text = 'active'::text)) AND ((approval_status)::text <> 'rejected'::text));

CREATE INDEX idx_certificates_approval ON public.certificates USING btree (approval_status, created_at DESC) WHERE ((approval_status)::text = 'pending'::text);

CREATE INDEX idx_certificates_credential ON public.club_certificates USING btree (credential_id);

CREATE INDEX idx_certificates_issued_date ON public.club_certificates USING btree (issued_date);

CREATE INDEX idx_certificates_issued_on ON public.certificates USING btree (student_id, issued_on DESC) WHERE (enabled = true);

CREATE INDEX idx_certificates_school ON public.club_certificates USING btree (school_id);

CREATE INDEX idx_certificates_status ON public.certificates USING btree (status) WHERE (status IS NOT NULL);

CREATE INDEX idx_certificates_student ON public.club_certificates USING btree (student_email);

CREATE INDEX idx_certificates_student_created ON public.certificates USING btree (student_id, created_at DESC);

CREATE UNIQUE INDEX idx_certificates_student_credential_platform_unique ON public.certificates USING btree (student_id, credential_id, platform) WHERE ((credential_id IS NOT NULL) AND ((credential_id)::text <> ''::text));

CREATE INDEX idx_certificates_student_id ON public.certificates USING btree (student_id);

CREATE UNIQUE INDEX idx_certificates_student_link_unique ON public.certificates USING btree (student_id, link) WHERE ((link IS NOT NULL) AND (link <> ''::text));

CREATE INDEX idx_certificates_student_lookup ON public.certificates USING btree (student_id, enabled, approval_status) WHERE ((enabled = true) AND ((approval_status)::text = ANY ((ARRAY['approved'::character varying, 'verified'::character varying])::text[])));

CREATE INDEX idx_certificates_training_id ON public.certificates USING btree (training_id);

CREATE INDEX idx_certificates_type ON public.club_certificates USING btree (certificate_type);

CREATE INDEX idx_chapters_curriculum ON public.curriculum_chapters USING btree (curriculum_id);

CREATE INDEX idx_chapters_order ON public.curriculum_chapters USING btree (curriculum_id, order_number);

CREATE INDEX idx_club_activities_club ON public.club_activities USING btree (club_id);

CREATE INDEX idx_club_activities_date ON public.club_activities USING btree (activity_date);

CREATE INDEX idx_club_activities_status ON public.club_activities USING btree (status);

CREATE INDEX idx_club_attendance_club_date ON public.club_attendance USING btree (club_id, session_date);

CREATE INDEX idx_club_attendance_created_by_admin ON public.club_attendance USING btree (created_by_admin_id);

CREATE INDEX idx_club_attendance_created_by_educator ON public.club_attendance USING btree (created_by_educator_id);

CREATE INDEX idx_club_attendance_records_attendance ON public.club_attendance_records USING btree (attendance_id);

CREATE INDEX idx_club_attendance_records_status ON public.club_attendance_records USING btree (status);

CREATE INDEX idx_club_attendance_records_student ON public.club_attendance_records USING btree (student_email);

CREATE INDEX idx_club_memberships_club ON public.club_memberships USING btree (club_id);

CREATE INDEX idx_club_memberships_enrolled_by_admin ON public.club_memberships USING btree (enrolled_by_admin_id);

CREATE INDEX idx_club_memberships_enrolled_by_educator ON public.club_memberships USING btree (enrolled_by_educator_id);

CREATE INDEX idx_club_memberships_status ON public.club_memberships USING btree (status);

CREATE INDEX idx_club_memberships_student ON public.club_memberships USING btree (student_email);

CREATE INDEX idx_clubs_category ON public.clubs USING btree (category);

CREATE INDEX idx_clubs_created_by_admin ON public.clubs USING btree (created_by_admin_id);

CREATE INDEX idx_clubs_created_by_educator ON public.clubs USING btree (created_by_educator_id);

CREATE INDEX idx_clubs_is_active ON public.clubs USING btree (is_active);

CREATE INDEX idx_clubs_mentor_educator ON public.clubs USING btree (mentor_educator_id);

CREATE INDEX idx_clubs_mentor_school ON public.clubs USING btree (mentor_school_id);

CREATE INDEX idx_clubs_mentor_type ON public.clubs USING btree (mentor_type);

CREATE INDEX idx_clubs_school ON public.clubs USING btree (school_id);

CREATE INDEX idx_co_educators_course ON public.course_co_educators USING btree (course_id);

CREATE INDEX idx_college_assignment_attachments_assignment ON public.college_assignment_attachments USING btree (assignment_id);

CREATE INDEX idx_college_assignment_attachments_uploaded_by ON public.college_assignment_attachments USING btree (uploaded_by);

CREATE INDEX idx_college_assignments_college_id ON public.college_assignments USING btree (college_id);

CREATE INDEX idx_college_assignments_course ON public.college_assignments USING btree (course_name);

CREATE INDEX idx_college_assignments_department_id ON public.college_assignments USING btree (department_id);

CREATE INDEX idx_college_assignments_due_date ON public.college_assignments USING btree (due_date);

CREATE INDEX idx_college_assignments_educator_id ON public.college_assignments USING btree (college_educator_id);

CREATE INDEX idx_college_assignments_program_id ON public.college_assignments USING btree (program_id);

CREATE INDEX idx_college_assignments_program_section_id ON public.college_assignments USING btree (program_section_id);

CREATE INDEX idx_college_attendance_records_class ON public.college_attendance_records USING btree (department_name, program_name, semester, section);

CREATE INDEX idx_college_attendance_records_college ON public.college_attendance_records USING btree (college_id);

CREATE INDEX idx_college_attendance_records_date ON public.college_attendance_records USING btree (date);

CREATE INDEX idx_college_attendance_records_session ON public.college_attendance_records USING btree (session_id);

CREATE INDEX idx_college_attendance_records_status ON public.college_attendance_records USING btree (status);

CREATE INDEX idx_college_attendance_records_student ON public.college_attendance_records USING btree (student_id);

CREATE INDEX idx_college_attendance_records_subject ON public.college_attendance_records USING btree (subject_name);

CREATE INDEX idx_college_attendance_sessions_academic_year ON public.college_attendance_sessions USING btree (academic_year);

CREATE INDEX idx_college_attendance_sessions_class ON public.college_attendance_sessions USING btree (department_name, program_name, semester, section);

CREATE INDEX idx_college_attendance_sessions_college ON public.college_attendance_sessions USING btree (college_id);

CREATE INDEX idx_college_attendance_sessions_date ON public.college_attendance_sessions USING btree (date);

CREATE INDEX idx_college_attendance_sessions_faculty ON public.college_attendance_sessions USING btree (faculty_id);

CREATE INDEX idx_college_attendance_sessions_status ON public.college_attendance_sessions USING btree (status);

CREATE INDEX idx_college_attendance_sessions_subject ON public.college_attendance_sessions USING btree (subject_name);

CREATE INDEX idx_college_breaks_college_id ON public.college_breaks USING btree (college_id);

CREATE INDEX idx_college_breaks_dates ON public.college_breaks USING btree (start_date, end_date);

CREATE INDEX idx_college_breaks_timetable_id ON public.college_breaks USING btree (timetable_id);

CREATE INDEX idx_college_circulars_audience ON public.college_circulars USING btree (audience);

CREATE INDEX idx_college_circulars_college_id ON public.college_circulars USING btree (college_id);

CREATE INDEX idx_college_circulars_priority ON public.college_circulars USING btree (priority);

CREATE INDEX idx_college_circulars_publish_date ON public.college_circulars USING btree (publish_date);

CREATE INDEX idx_college_circulars_status ON public.college_circulars USING btree (status);

CREATE INDEX idx_college_classes_college_id ON public.college_classes USING btree (college_id);

CREATE INDEX idx_college_classes_department_id ON public.college_classes USING btree (department_id);

CREATE INDEX idx_college_classes_status ON public.college_classes USING btree (status);

CREATE INDEX idx_college_courses_active ON public.college_courses USING btree (is_active);

CREATE INDEX idx_college_courses_college_id ON public.college_courses USING btree (college_id);

CREATE INDEX idx_college_courses_course_code ON public.college_courses USING btree (course_code);

CREATE INDEX idx_college_courses_course_type ON public.college_courses USING btree (course_type);

CREATE INDEX idx_college_courses_created_by ON public.college_courses USING btree (created_by);

CREATE INDEX idx_college_curriculum_units_order ON public.college_curriculum_units USING btree (curriculum_id, order_index);

CREATE INDEX idx_college_curriculums_academic_year ON public.college_curriculums USING btree (academic_year);

CREATE INDEX idx_college_curriculums_college_id ON public.college_curriculums USING btree (college_id);

CREATE INDEX idx_college_curriculums_course_id ON public.college_curriculums USING btree (course_id);

CREATE INDEX idx_college_curriculums_requested_by ON public.college_curriculums USING btree (requested_by);

CREATE INDEX idx_college_curriculums_reviewed_by ON public.college_curriculums USING btree (reviewed_by);

CREATE INDEX idx_college_curriculums_status ON public.college_curriculums USING btree (status);

CREATE INDEX idx_college_curriculums_university_id ON public.college_curriculums USING btree (university_id);

CREATE INDEX idx_college_events_college_id ON public.college_events USING btree (college_id);

CREATE INDEX idx_college_events_event_type ON public.college_events USING btree (event_type);

CREATE INDEX idx_college_events_start_date ON public.college_events USING btree (start_date);

CREATE INDEX idx_college_events_status ON public.college_events USING btree (status);

CREATE INDEX idx_college_lesson_plans_academic_year ON public.college_lesson_plans USING btree (academic_year);

CREATE INDEX idx_college_lesson_plans_college_id ON public.college_lesson_plans USING btree (college_id);

CREATE INDEX idx_college_lesson_plans_course_id ON public.college_lesson_plans USING btree (course_id);

CREATE INDEX idx_college_lesson_plans_course_semester ON public.college_lesson_plans USING btree (course_id, semester);

CREATE INDEX idx_college_lesson_plans_curriculum_id ON public.college_lesson_plans USING btree (curriculum_id);

CREATE INDEX idx_college_lesson_plans_department_id ON public.college_lesson_plans USING btree (department_id);

CREATE INDEX idx_college_lesson_plans_program_id ON public.college_lesson_plans USING btree (program_id);

CREATE INDEX idx_college_lesson_plans_program_semester_year ON public.college_lesson_plans USING btree (program_id, semester, academic_year);

CREATE INDEX idx_college_lesson_plans_semester ON public.college_lesson_plans USING btree (semester);

CREATE INDEX idx_college_lesson_plans_session_date ON public.college_lesson_plans USING btree (session_date);

CREATE INDEX idx_college_lesson_plans_status ON public.college_lesson_plans USING btree (status);

CREATE INDEX idx_college_lesson_plans_unit_id ON public.college_lesson_plans USING btree (unit_id);

CREATE INDEX idx_college_mentor_notes_allocation_id ON public.college_mentor_notes USING btree (allocation_id);

CREATE INDEX idx_college_mentor_notes_date ON public.college_mentor_notes USING btree (note_date);

CREATE INDEX idx_college_mentor_notes_intervention_type ON public.college_mentor_notes USING btree (intervention_type);

CREATE INDEX idx_college_mentor_notes_mentor_id ON public.college_mentor_notes USING btree (mentor_id);

CREATE INDEX idx_college_mentor_notes_mentor_status ON public.college_mentor_notes USING btree (mentor_id, status);

CREATE INDEX idx_college_mentor_notes_status ON public.college_mentor_notes USING btree (status);

CREATE INDEX idx_college_mentor_notes_student_id ON public.college_mentor_notes USING btree (student_id);

CREATE INDEX idx_college_mentor_periods_academic_year ON public.college_mentor_periods USING btree (academic_year);

CREATE INDEX idx_college_mentor_periods_active ON public.college_mentor_periods USING btree (is_active);

CREATE INDEX idx_college_mentor_periods_college_id ON public.college_mentor_periods USING btree (college_id);

CREATE INDEX idx_college_mentor_periods_dates ON public.college_mentor_periods USING btree (start_date, end_date);

CREATE INDEX idx_college_mentor_student_allocations_mentor_id ON public.college_mentor_student_allocations USING btree (mentor_id);

CREATE INDEX idx_college_mentor_student_allocations_mentor_period ON public.college_mentor_student_allocations USING btree (mentor_id, period_id);

CREATE INDEX idx_college_mentor_student_allocations_period_id ON public.college_mentor_student_allocations USING btree (period_id);

CREATE INDEX idx_college_mentor_student_allocations_status ON public.college_mentor_student_allocations USING btree (status);

CREATE INDEX idx_college_mentor_student_allocations_student_id ON public.college_mentor_student_allocations USING btree (student_id);

CREATE INDEX idx_college_role_module_permissions_module ON public.college_role_module_permissions USING btree (module_id);

CREATE INDEX idx_college_role_module_permissions_role ON public.college_role_module_permissions USING btree (role_type);

CREATE INDEX idx_college_role_scope_rules_role ON public.college_role_scope_rules USING btree (role_type);

CREATE INDEX idx_college_role_scope_rules_scope ON public.college_role_scope_rules USING btree (scope_type, scope_value);

CREATE INDEX idx_college_setting_modules_active ON public.college_setting_modules USING btree (is_active);

CREATE INDEX idx_college_setting_modules_name ON public.college_setting_modules USING btree (module_name);

CREATE INDEX idx_college_student_assignments_assignment ON public.college_student_assignments USING btree (assignment_id);

CREATE INDEX idx_college_student_assignments_lookup ON public.college_student_assignments USING btree (student_id, is_deleted) WHERE (is_deleted = false);

CREATE INDEX idx_college_student_assignments_status ON public.college_student_assignments USING btree (status);

CREATE INDEX idx_college_student_assignments_student ON public.college_student_assignments USING btree (student_id);

CREATE INDEX idx_college_student_assignments_student_status ON public.college_student_assignments USING btree (student_id, status);

CREATE INDEX idx_college_student_assignments_submission_date ON public.college_student_assignments USING btree (submission_date);

CREATE INDEX idx_college_time_periods_timetable ON public.college_time_periods USING btree (timetable_id);

CREATE INDEX idx_college_timetable_slots_date ON public.college_timetable_slots USING btree (schedule_date);

CREATE INDEX idx_college_timetable_slots_educator_id ON public.college_timetable_slots USING btree (educator_id);

CREATE INDEX idx_college_timetable_slots_timetable_id ON public.college_timetable_slots USING btree (timetable_id);

CREATE INDEX idx_college_timetables_academic_year ON public.college_timetables USING btree (academic_year);

CREATE INDEX idx_college_timetables_college_id ON public.college_timetables USING btree (college_id);

CREATE INDEX idx_comp_clubs_club ON public.competition_clubs USING btree (club_id);

CREATE INDEX idx_comp_clubs_comp ON public.competition_clubs USING btree (comp_id);

CREATE INDEX idx_comp_registrations_comp ON public.competition_registrations USING btree (comp_id);

CREATE INDEX idx_comp_registrations_status ON public.competition_registrations USING btree (status);

CREATE INDEX idx_comp_registrations_student ON public.competition_registrations USING btree (student_email);

CREATE INDEX idx_comp_results_comp ON public.competition_results USING btree (comp_id);

CREATE INDEX idx_comp_results_registration ON public.competition_results USING btree (registration_id);

CREATE INDEX idx_comp_results_student ON public.competition_results USING btree (student_email);

CREATE INDEX idx_competitions_category ON public.competitions USING btree (category);

CREATE INDEX idx_competitions_created_by_admin ON public.competitions USING btree (created_by_admin_id);

CREATE INDEX idx_competitions_created_by_educator ON public.competitions USING btree (created_by_educator_id);

CREATE INDEX idx_competitions_date ON public.competitions USING btree (competition_date);

CREATE INDEX idx_competitions_level ON public.competitions USING btree (level);

CREATE INDEX idx_competitions_school ON public.competitions USING btree (school_id);

CREATE INDEX idx_competitions_status ON public.competitions USING btree (status);

CREATE INDEX idx_conversations_admin_active ON public.conversations USING btree (school_id, status, deleted_by_admin) WHERE ((conversation_type)::text = 'student_admin'::text);

CREATE INDEX idx_conversations_admin_unread ON public.conversations USING btree (admin_unread_count) WHERE (admin_unread_count > 0);

CREATE INDEX idx_conversations_application_id ON public.conversations USING btree (application_id);

CREATE INDEX idx_conversations_class_id ON public.conversations USING btree (class_id);

CREATE INDEX idx_conversations_college_admin_active ON public.conversations USING btree (college_id, status, deleted_by_college_admin) WHERE ((conversation_type)::text = 'student_college_admin'::text);

CREATE INDEX idx_conversations_college_admin_educator_active ON public.conversations USING btree (college_id, status, deleted_by_college_admin) WHERE ((conversation_type)::text = 'college_educator_admin'::text);

CREATE INDEX idx_conversations_college_admin_unread ON public.conversations USING btree (college_admin_unread_count) WHERE (college_admin_unread_count > 0);

CREATE INDEX idx_conversations_college_educator_active ON public.conversations USING btree (educator_id, status, deleted_by_college_educator) WHERE ((conversation_type)::text = 'student_college_educator'::text);

CREATE INDEX idx_conversations_college_educator_admin ON public.conversations USING btree (educator_id, college_id, conversation_type) WHERE ((conversation_type)::text = 'college_educator_admin'::text);

CREATE INDEX idx_conversations_college_educator_admin_active ON public.conversations USING btree (educator_id, status, deleted_by_educator) WHERE ((conversation_type)::text = 'college_educator_admin'::text);

CREATE INDEX idx_conversations_college_educator_unread ON public.conversations USING btree (college_educator_unread_count) WHERE (college_educator_unread_count > 0);

CREATE INDEX idx_conversations_college_id ON public.conversations USING btree (college_id);

CREATE INDEX idx_conversations_deleted_by_recruiter ON public.conversations USING btree (recruiter_id, deleted_by_recruiter) WHERE (deleted_by_recruiter = false);

CREATE INDEX idx_conversations_deleted_by_student ON public.conversations USING btree (student_id, deleted_by_student) WHERE (deleted_by_student = false);

CREATE INDEX idx_conversations_educator_active ON public.conversations USING btree (educator_id, status, deleted_by_educator) WHERE ((conversation_type)::text = 'student_educator'::text);

CREATE INDEX idx_conversations_educator_admin ON public.conversations USING btree (educator_id, school_id, conversation_type) WHERE ((conversation_type)::text = 'educator_admin'::text);

CREATE INDEX idx_conversations_educator_id ON public.conversations USING btree (educator_id);

CREATE INDEX idx_conversations_educator_unread ON public.conversations USING btree (educator_unread_count) WHERE (educator_unread_count > 0);

CREATE INDEX idx_conversations_last_message_at ON public.conversations USING btree (last_message_at DESC);

CREATE INDEX idx_conversations_opportunity_id ON public.conversations USING btree (opportunity_id);

CREATE INDEX idx_conversations_program_section_id ON public.conversations USING btree (program_section_id);

CREATE INDEX idx_conversations_recruiter_active ON public.conversations USING btree (recruiter_id, deleted_by_recruiter, last_message_at DESC) WHERE ((deleted_by_recruiter = false) AND (status <> 'archived'::text));

CREATE INDEX idx_conversations_recruiter_id ON public.conversations USING btree (recruiter_id);

CREATE INDEX idx_conversations_school_id ON public.conversations USING btree (school_id);

CREATE INDEX idx_conversations_status ON public.conversations USING btree (status);

CREATE INDEX idx_conversations_student_active ON public.conversations USING btree (student_id, deleted_by_student, last_message_at DESC) WHERE ((deleted_by_student = false) AND (status <> 'archived'::text));

CREATE INDEX idx_conversations_student_admin ON public.conversations USING btree (student_id, school_id, conversation_type) WHERE ((conversation_type)::text = 'student_admin'::text);

CREATE INDEX idx_conversations_student_college_admin ON public.conversations USING btree (student_id, college_id, conversation_type) WHERE ((conversation_type)::text = 'student_college_admin'::text);

CREATE INDEX idx_conversations_student_college_educator ON public.conversations USING btree (student_id, educator_id, college_id, conversation_type) WHERE ((conversation_type)::text = 'student_college_educator'::text);

CREATE INDEX idx_conversations_student_educator ON public.conversations USING btree (student_id, educator_id, conversation_type) WHERE ((conversation_type)::text = 'student_educator'::text);

CREATE INDEX idx_conversations_student_id ON public.conversations USING btree (student_id);

CREATE INDEX idx_conversations_subject ON public.conversations USING btree (subject);

CREATE INDEX idx_conversations_type ON public.conversations USING btree (conversation_type);

CREATE INDEX idx_course_classes_course ON public.course_classes USING btree (course_id);

CREATE INDEX idx_course_enrollments_course ON public.course_enrollments USING btree (course_id);

CREATE INDEX idx_course_enrollments_educator ON public.course_enrollments USING btree (educator_id);

CREATE INDEX idx_course_enrollments_status ON public.course_enrollments USING btree (status);

CREATE INDEX idx_course_enrollments_student ON public.course_enrollments USING btree (student_id);

CREATE INDEX idx_course_enrollments_student_status ON public.course_enrollments USING btree (student_id, status) WHERE (status = ANY (ARRAY['in_progress'::text, 'active'::text, 'completed'::text]));

CREATE INDEX idx_course_enrollments_training ON public.course_enrollments USING btree (training_id);

CREATE INDEX idx_course_mappings_course_id ON public.college_course_mappings USING btree (course_id);

CREATE INDEX idx_course_mappings_faculty ON public.college_course_mappings USING btree (faculty_id);

CREATE INDEX idx_course_mappings_offering_type ON public.college_course_mappings USING btree (offering_type);

CREATE INDEX idx_course_mappings_program_semester ON public.college_course_mappings USING btree (program_id, semester);

CREATE INDEX idx_course_skills_course ON public.course_skills USING btree (course_id);

CREATE INDEX idx_course_skills_name ON public.course_skills USING btree (skill_name);

CREATE INDEX idx_courses_approval_status ON public.courses USING btree (approval_status);

CREATE INDEX idx_courses_category ON public.courses USING btree (category);

CREATE INDEX idx_courses_code ON public.courses USING btree (code);

CREATE INDEX idx_courses_educator ON public.courses USING btree (educator_id);

CREATE INDEX idx_courses_educator_id ON public.courses USING btree (educator_id);

CREATE INDEX idx_courses_school_id ON public.courses USING btree (school_id);

CREATE INDEX idx_courses_status ON public.courses USING btree (status);

CREATE INDEX idx_courses_university ON public.courses USING btree (university);

CREATE INDEX idx_curriculum_academic_years_active ON public.curriculum_academic_years USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_curriculum_academic_years_current ON public.curriculum_academic_years USING btree (is_current) WHERE (is_current = true);

CREATE INDEX idx_curriculum_academic_years_school ON public.curriculum_academic_years USING btree (school_id);

CREATE INDEX idx_curriculum_classes_active ON public.curriculum_classes USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_curriculum_classes_order ON public.curriculum_classes USING btree (display_order);

CREATE INDEX idx_curriculum_classes_school ON public.curriculum_classes USING btree (school_id);

CREATE INDEX idx_curriculum_courses_active ON public.curriculum_courses USING btree (is_active);

CREATE INDEX idx_curriculum_courses_college ON public.curriculum_courses USING btree (college_id);

CREATE INDEX idx_curriculum_courses_department ON public.curriculum_courses USING btree (department_id);

CREATE INDEX idx_curriculum_courses_program ON public.curriculum_courses USING btree (program_id);

CREATE INDEX idx_curriculum_courses_semester ON public.curriculum_courses USING btree (semester);

CREATE INDEX idx_curriculum_subjects_active ON public.curriculum_subjects USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_curriculum_subjects_order ON public.curriculum_subjects USING btree (display_order);

CREATE INDEX idx_curriculum_subjects_school ON public.curriculum_subjects USING btree (school_id);

CREATE INDEX idx_curriculums_academic_year ON public.curriculums USING btree (academic_year);

CREATE INDEX idx_curriculums_course_id ON public.college_curriculums USING btree (course_id);

CREATE INDEX idx_curriculums_created_by ON public.curriculums USING btree (created_by);

CREATE INDEX idx_curriculums_pending_changes ON public.college_curriculums USING btree (has_pending_changes) WHERE (has_pending_changes = true);

CREATE INDEX idx_curriculums_pending_changes_jsonb ON public.college_curriculums USING gin (pending_changes);

CREATE INDEX idx_curriculums_program_id ON public.college_curriculums USING btree (program_id);

CREATE INDEX idx_curriculums_school ON public.curriculums USING btree (school_id);

CREATE INDEX idx_curriculums_status ON public.curriculums USING btree (status);

CREATE INDEX idx_curriculums_subject_class ON public.curriculums USING btree (subject, class, academic_year);

CREATE INDEX idx_department_budgets_department ON public.department_budgets USING btree (department_id);

CREATE INDEX idx_department_budgets_financial_year ON public.department_budgets USING btree (financial_year);

CREATE INDEX idx_department_budgets_period ON public.department_budgets USING btree (period_from, period_to);

CREATE INDEX idx_department_budgets_status ON public.department_budgets USING btree (status);

CREATE INDEX idx_department_budgets_utilization ON public.department_budgets USING btree (utilization_percentage);

CREATE INDEX idx_departments_college ON public.departments USING btree (college_id);

CREATE UNIQUE INDEX idx_departments_college_code_unique ON public.departments USING btree (college_id, code) WHERE (college_id IS NOT NULL);

CREATE INDEX idx_departments_school ON public.departments USING btree (school_id);

CREATE UNIQUE INDEX idx_departments_school_code_unique ON public.departments USING btree (school_id, code) WHERE (school_id IS NOT NULL);

CREATE INDEX idx_dept_faculty_assignments_active ON public.department_faculty_assignments USING btree (is_active);

CREATE INDEX idx_dept_faculty_assignments_department_id ON public.department_faculty_assignments USING btree (department_id);

CREATE INDEX idx_dept_faculty_assignments_lecturer_id ON public.department_faculty_assignments USING btree (lecturer_id);

CREATE INDEX idx_dept_faculty_assignments_type ON public.department_faculty_assignments USING btree (assignment_type);

CREATE INDEX idx_document_access_user ON public.document_access_history USING btree (user_id);

CREATE INDEX idx_education_student_id ON public.education USING btree (student_id);

CREATE INDEX idx_educator_assignments_class ON public.school_educator_class_assignments USING btree (class_id);

CREATE INDEX idx_educator_assignments_educator ON public.school_educator_class_assignments USING btree (educator_id);

CREATE INDEX idx_email_tracking_pre_reg_id ON public.pre_registration_email_tracking USING btree (pre_registration_id);

CREATE INDEX idx_email_tracking_scheduled ON public.pre_registration_email_tracking USING btree (scheduled_at) WHERE (email_status = 'pending'::text);

CREATE INDEX idx_email_tracking_sent_at ON public.pre_registration_email_tracking USING btree (sent_at);

CREATE INDEX idx_email_tracking_status ON public.pre_registration_email_tracking USING btree (email_status);

CREATE INDEX idx_embedding_cache_created_at ON public.embedding_cache USING btree (created_at);

CREATE INDEX idx_embedding_cache_lookup ON public.embedding_cache USING btree (text_hash, cache_type);

CREATE INDEX idx_embedding_cache_type ON public.embedding_cache USING btree (cache_type);

CREATE INDEX idx_embedding_queue_pending ON public.embedding_queue USING btree (status, priority DESC, created_at) WHERE (status = 'pending'::text);

CREATE INDEX idx_embedding_queue_record ON public.embedding_queue USING btree (record_id, table_name);

CREATE INDEX idx_embedding_queue_status ON public.embedding_queue USING btree (status, priority, created_at);

CREATE INDEX idx_embedding_queue_table_record ON public.embedding_queue USING btree (table_name, record_id);

CREATE INDEX idx_enrollments_restore ON public.course_enrollments USING btree (student_id, course_id, last_accessed DESC);

CREATE INDEX idx_event_registrations_attended ON public.college_event_registrations USING btree (attended);

CREATE INDEX idx_event_registrations_created_at ON public.event_registrations USING btree (created_at DESC);

CREATE INDEX idx_event_registrations_email ON public.event_registrations USING btree (email);

CREATE INDEX idx_event_registrations_email_status ON public.event_registrations USING btree (email, payment_status);

CREATE INDEX idx_event_registrations_event ON public.college_event_registrations USING btree (event_id);

CREATE INDEX idx_event_registrations_payment_status ON public.event_registrations USING btree (payment_status);

CREATE INDEX idx_event_registrations_student ON public.college_event_registrations USING btree (student_id);

CREATE INDEX idx_exam_registrations_assessment ON public.exam_registrations USING btree (assessment_id);

CREATE INDEX idx_exam_registrations_hall_ticket ON public.exam_registrations USING btree (hall_ticket_number);

CREATE INDEX idx_exam_registrations_status ON public.exam_registrations USING btree (status);

CREATE INDEX idx_exam_registrations_student ON public.exam_registrations USING btree (student_id);

CREATE INDEX idx_exam_registrations_student_record ON public.exam_registrations USING btree (student_record_id);

CREATE INDEX idx_exam_registrations_window ON public.exam_registrations USING btree (exam_window_id);

CREATE INDEX idx_exam_rooms_building ON public.exam_rooms USING btree (building);

CREATE INDEX idx_exam_rooms_code ON public.exam_rooms USING btree (room_code);

CREATE INDEX idx_exam_rooms_college ON public.exam_rooms USING btree (college_id);

CREATE INDEX idx_exam_rooms_school ON public.exam_rooms USING btree (school_id);

CREATE INDEX idx_exam_rooms_status ON public.exam_rooms USING btree (status);

CREATE INDEX idx_exam_seating_attendance ON public.exam_seating_arrangements USING btree (attendance_status);

CREATE INDEX idx_exam_seating_room ON public.exam_seating_arrangements USING btree (exam_room_id);

CREATE INDEX idx_exam_seating_student ON public.exam_seating_arrangements USING btree (student_id);

CREATE INDEX idx_exam_seating_student_record ON public.exam_seating_arrangements USING btree (student_record_id);

CREATE INDEX idx_exam_seating_timetable ON public.exam_seating_arrangements USING btree (exam_timetable_id);

CREATE INDEX idx_exam_timetable_assessment ON public.exam_timetable USING btree (assessment_id);

CREATE INDEX idx_exam_timetable_date ON public.exam_timetable USING btree (exam_date);

CREATE INDEX idx_exam_timetable_room ON public.exam_timetable USING btree (room);

CREATE INDEX idx_exam_timetable_status ON public.exam_timetable USING btree (status);

CREATE INDEX idx_exam_windows_academic_year ON public.exam_windows USING btree (academic_year);

CREATE INDEX idx_exam_windows_college ON public.exam_windows USING btree (college_id);

CREATE INDEX idx_exam_windows_dates ON public.exam_windows USING btree (start_date, end_date);

CREATE INDEX idx_exam_windows_school ON public.exam_windows USING btree (school_id);

CREATE INDEX idx_exam_windows_semester ON public.exam_windows USING btree (semester);

CREATE INDEX idx_exam_windows_status ON public.exam_windows USING btree (status);

CREATE INDEX idx_expenditures_budget ON public.expenditures USING btree (budget_id);

CREATE INDEX idx_expenditures_category ON public.expenditures USING btree (category);

CREATE INDEX idx_expenditures_date ON public.expenditures USING btree (expenditure_date);

CREATE INDEX idx_expenditures_department ON public.expenditures USING btree (department_id);

CREATE INDEX idx_expenditures_number ON public.expenditures USING btree (expenditure_number);

CREATE INDEX idx_expenditures_override ON public.expenditures USING btree (is_override);

CREATE INDEX idx_expenditures_payment_status ON public.expenditures USING btree (payment_status);

CREATE INDEX idx_expenditures_status ON public.expenditures USING btree (status);

CREATE INDEX idx_expenditures_vendor ON public.expenditures USING btree (vendor_name);

CREATE INDEX idx_experience_approval_authority ON public.experience USING btree (approval_authority);

CREATE INDEX idx_experience_approval_status ON public.experience USING btree (approval_status);

CREATE INDEX idx_experience_student ON public.experience USING btree (student_id);

CREATE INDEX idx_experience_student_id ON public.experience USING btree (student_id);

CREATE INDEX idx_export_activities_shortlist_id ON public.export_activities USING btree (shortlist_id);

CREATE INDEX idx_external_assessment_attempts_completed_at ON public.external_assessment_attempts USING btree (completed_at DESC);

CREATE INDEX idx_external_assessment_attempts_course_name ON public.external_assessment_attempts USING btree (course_name);

CREATE INDEX idx_external_assessment_attempts_score ON public.external_assessment_attempts USING btree (score);

CREATE INDEX idx_external_assessment_attempts_status ON public.external_assessment_attempts USING btree (status);

CREATE INDEX idx_external_assessment_attempts_student_id ON public.external_assessment_attempts USING btree (student_id);

CREATE UNIQUE INDEX idx_external_assessment_one_per_course ON public.external_assessment_attempts USING btree (student_id, course_name);

CREATE INDEX idx_external_courses_organization ON public.external_courses USING btree (organization);

CREATE INDEX idx_external_courses_student ON public.external_courses USING btree (student_id);

CREATE INDEX idx_external_courses_training ON public.external_courses USING btree (training_id);

CREATE INDEX idx_faculty_class_assignments_class ON public.college_faculty_class_assignments USING btree (class_id);

CREATE INDEX idx_faculty_class_assignments_college ON public.college_faculty_class_assignments USING btree (college_id);

CREATE INDEX idx_faculty_class_assignments_faculty ON public.college_faculty_class_assignments USING btree (faculty_id);

CREATE INDEX idx_faculty_leaves_college ON public.college_faculty_leaves USING btree (college_id);

CREATE INDEX idx_faculty_leaves_dates ON public.college_faculty_leaves USING btree (start_date, end_date);

CREATE INDEX idx_faculty_leaves_faculty ON public.college_faculty_leaves USING btree (faculty_id);

CREATE INDEX idx_faculty_leaves_status ON public.college_faculty_leaves USING btree (status);

CREATE INDEX idx_fee_payments_date ON public.fee_payments USING btree (payment_date);

CREATE INDEX idx_fee_payments_ledger ON public.fee_payments USING btree (ledger_id);

CREATE INDEX idx_fee_payments_mode ON public.fee_payments USING btree (mode);

CREATE INDEX idx_fee_payments_receipt ON public.fee_payments USING btree (receipt_number);

CREATE INDEX idx_fee_payments_status ON public.fee_payments USING btree (status);

CREATE INDEX idx_fee_payments_student ON public.fee_payments USING btree (student_id);

CREATE INDEX idx_fee_payments_verified ON public.fee_payments USING btree (is_verified);

CREATE INDEX idx_fee_structures_academic_year ON public.fee_structures USING btree (academic_year);

CREATE INDEX idx_fee_structures_active ON public.fee_structures USING btree (is_active);

CREATE INDEX idx_fee_structures_category ON public.fee_structures USING btree (category);

CREATE INDEX idx_fee_structures_college_id ON public.fee_structures USING btree (college_id);

CREATE INDEX idx_fee_structures_program ON public.fee_structures USING btree (program_id);

CREATE INDEX idx_fee_structures_semester ON public.fee_structures USING btree (semester);

CREATE INDEX idx_generated_external_assessment_course_id ON public.generated_external_assessment USING btree (course_id);

CREATE INDEX idx_generated_external_assessment_name ON public.generated_external_assessment USING btree (certificate_name);

CREATE INDEX idx_grading_systems_active ON public.grading_systems USING btree (is_active);

CREATE INDEX idx_grading_systems_code ON public.grading_systems USING btree (system_code);

CREATE INDEX idx_grading_systems_default ON public.grading_systems USING btree (is_default);

CREATE INDEX idx_institution_pricing_active ON public.institution_pricing_tiers USING btree (is_active);

CREATE INDEX idx_institution_pricing_role_type ON public.institution_pricing_tiers USING btree (role_type);

CREATE INDEX idx_interactions_opportunity ON public.opportunity_interactions USING btree (opportunity_id);

CREATE INDEX idx_interactions_student ON public.opportunity_interactions USING btree (student_id, action);

CREATE INDEX idx_internships_approval_status ON public.internships USING btree (approval_status);

CREATE INDEX idx_internships_created_at ON public.internships USING btree (created_at DESC);

CREATE INDEX idx_internships_enabled ON public.internships USING btree (enabled);

CREATE INDEX idx_internships_student_email ON public.internships USING btree (student_email);

CREATE INDEX idx_internships_student_enabled ON public.internships USING btree (student_email, enabled);

CREATE INDEX idx_internships_student_id ON public.internships USING btree (student_id);

CREATE INDEX idx_interview_reminders_interview_id ON public.interview_reminders USING btree (interview_id);

CREATE INDEX idx_interview_reminders_sent_at ON public.interview_reminders USING btree (sent_at);

CREATE INDEX idx_interviews_created_by ON public.interviews USING btree (created_by);

CREATE INDEX idx_interviews_date ON public.interviews USING btree (date);

CREATE INDEX idx_interviews_status ON public.interviews USING btree (status);

CREATE INDEX idx_interviews_student_id ON public.interviews USING btree (student_id);

CREATE INDEX idx_invigilator_assignments_date ON public.invigilator_assignments USING btree (duty_date);

CREATE INDEX idx_invigilator_assignments_invigilator ON public.invigilator_assignments USING btree (invigilator_id);

CREATE INDEX idx_invigilator_assignments_room ON public.invigilator_assignments USING btree (exam_room_id);

CREATE INDEX idx_invigilator_assignments_status ON public.invigilator_assignments USING btree (attendance_status);

CREATE INDEX idx_invigilator_assignments_timetable ON public.invigilator_assignments USING btree (exam_timetable_id);

CREATE INDEX idx_invigilator_lecturer ON public.invigilator_assignments USING btree (lecturer_record_id);

CREATE INDEX idx_lesson_plans_chapter_id ON public.lesson_plans USING btree (chapter_id);

CREATE INDEX idx_lesson_plans_class ON public.lesson_plans USING btree (class_id);

CREATE INDEX idx_lesson_plans_date ON public.lesson_plans USING btree (date);

CREATE INDEX idx_lesson_plans_educator ON public.lesson_plans USING btree (educator_id);

CREATE INDEX idx_lesson_plans_status ON public.lesson_plans USING btree (status);

CREATE INDEX idx_lessons_module ON public.lessons USING btree (module_id);

CREATE INDEX idx_lessons_order ON public.lessons USING btree (module_id, order_index);

CREATE INDEX idx_library_book_issues_book_id ON public.library_book_issues USING btree (book_id);

CREATE INDEX idx_library_book_issues_college_book_id ON public.library_book_issues_college USING btree (book_id);

CREATE INDEX idx_library_book_issues_college_college_id ON public.library_book_issues_college USING btree (college_id);

CREATE INDEX idx_library_book_issues_college_due_date ON public.library_book_issues_college USING btree (college_id, due_date);

CREATE INDEX idx_library_book_issues_college_issue_date ON public.library_book_issues_college USING btree (college_id, issue_date);

CREATE INDEX idx_library_book_issues_college_return_date ON public.library_book_issues_college USING btree (college_id, return_date);

CREATE INDEX idx_library_book_issues_college_status ON public.library_book_issues_college USING btree (college_id, status);

CREATE INDEX idx_library_book_issues_college_student_id ON public.library_book_issues_college USING btree (college_id, student_id);

CREATE INDEX idx_library_book_issues_due_date ON public.library_book_issues USING btree (due_date);

CREATE INDEX idx_library_book_issues_issue_date ON public.library_book_issues USING btree (issue_date);

CREATE INDEX idx_library_book_issues_return_date ON public.library_book_issues USING btree (return_date);

CREATE INDEX idx_library_book_issues_school_book_id ON public.library_book_issues_school USING btree (book_id);

CREATE INDEX idx_library_book_issues_school_due_date ON public.library_book_issues_school USING btree (school_id, due_date);

CREATE INDEX idx_library_book_issues_school_issue_date ON public.library_book_issues_school USING btree (school_id, issue_date);

CREATE INDEX idx_library_book_issues_school_return_date ON public.library_book_issues_school USING btree (school_id, return_date);

CREATE INDEX idx_library_book_issues_school_school_id ON public.library_book_issues_school USING btree (school_id);

CREATE INDEX idx_library_book_issues_school_status ON public.library_book_issues_school USING btree (school_id, status);

CREATE INDEX idx_library_book_issues_school_student_id ON public.library_book_issues_school USING btree (student_id);

CREATE INDEX idx_library_book_issues_status ON public.library_book_issues USING btree (status);

CREATE INDEX idx_library_book_issues_student_id ON public.library_book_issues USING btree (student_id);

CREATE INDEX idx_library_books_author ON public.library_books USING gin (to_tsvector('english'::regconfig, author));

CREATE INDEX idx_library_books_available ON public.library_books USING btree (available_copies) WHERE (available_copies > 0);

CREATE INDEX idx_library_books_book_id ON public.library_books USING btree (book_id);

CREATE INDEX idx_library_books_category ON public.library_books USING btree (category);

CREATE INDEX idx_library_books_college ON public.library_books USING btree (college_id);

CREATE INDEX idx_library_books_college_author ON public.library_books_college USING btree (college_id, author);

CREATE INDEX idx_library_books_college_category ON public.library_books_college USING btree (college_id, category);

CREATE INDEX idx_library_books_college_college_id ON public.library_books_college USING btree (college_id);

CREATE INDEX idx_library_books_college_isbn ON public.library_books_college USING btree (college_id, isbn);

CREATE INDEX idx_library_books_college_status ON public.library_books_college USING btree (college_id, status);

CREATE INDEX idx_library_books_college_title ON public.library_books_college USING btree (college_id, title);

CREATE INDEX idx_library_books_department ON public.library_books USING btree (department_id);

CREATE INDEX idx_library_books_isbn ON public.library_books USING btree (isbn);

CREATE INDEX idx_library_books_location ON public.library_books USING btree (location);

CREATE INDEX idx_library_books_school_author ON public.library_books_school USING btree (school_id, author);

CREATE INDEX idx_library_books_school_category ON public.library_books_school USING btree (school_id, category);

CREATE INDEX idx_library_books_school_isbn ON public.library_books_school USING btree (school_id, isbn);

CREATE INDEX idx_library_books_school_school_id ON public.library_books_school USING btree (school_id);

CREATE INDEX idx_library_books_school_status ON public.library_books_school USING btree (school_id, status);

CREATE INDEX idx_library_books_school_title ON public.library_books_school USING btree (school_id, title);

CREATE INDEX idx_library_books_status ON public.library_books USING btree (status);

CREATE INDEX idx_library_books_title ON public.library_books USING gin (to_tsvector('english'::regconfig, title));

CREATE INDEX idx_library_categories_school_school_id ON public.library_categories_school USING btree (school_id);

CREATE INDEX idx_library_history_academic_year ON public.library_history USING btree (academic_year);

CREATE INDEX idx_library_history_book ON public.library_history USING btree (book_id);

CREATE INDEX idx_library_history_department ON public.library_history USING btree (department_id);

CREATE INDEX idx_library_history_issue_date ON public.library_history USING btree (issue_date);

CREATE INDEX idx_library_history_return_date ON public.library_history USING btree (return_date);

CREATE INDEX idx_library_history_status ON public.library_history USING btree (status);

CREATE INDEX idx_library_history_student ON public.library_history USING btree (student_id);

CREATE INDEX idx_library_history_student_record ON public.library_history USING btree (student_record_id);

CREATE INDEX idx_library_issued_books_academic_year ON public.library_issued_books USING btree (academic_year);

CREATE INDEX idx_library_issued_books_book ON public.library_issued_books USING btree (book_id);

CREATE INDEX idx_library_issued_books_department ON public.library_issued_books USING btree (department_id);

CREATE INDEX idx_library_issued_books_due_date ON public.library_issued_books USING btree (due_date);

CREATE INDEX idx_library_issued_books_overdue ON public.library_issued_books USING btree (days_overdue) WHERE (days_overdue > 0);

CREATE INDEX idx_library_issued_books_status ON public.library_issued_books USING btree (status);

CREATE INDEX idx_library_issued_books_student ON public.library_issued_books USING btree (student_id);

CREATE INDEX idx_library_issued_books_student_record ON public.library_issued_books USING btree (student_record_id);

CREATE INDEX idx_library_reservations_book ON public.library_reservations USING btree (book_id);

CREATE INDEX idx_library_reservations_priority ON public.library_reservations USING btree (priority);

CREATE INDEX idx_library_reservations_status ON public.library_reservations USING btree (status);

CREATE INDEX idx_library_reservations_student ON public.library_reservations USING btree (student_id);

CREATE UNIQUE INDEX idx_library_reservations_unique_active ON public.library_reservations USING btree (book_id, student_id) WHERE (status = 'active'::text);

CREATE INDEX idx_library_reviews_approved ON public.library_reviews USING btree (is_approved);

CREATE INDEX idx_library_reviews_book ON public.library_reviews USING btree (book_id);

CREATE INDEX idx_library_reviews_rating ON public.library_reviews USING btree (rating);

CREATE INDEX idx_library_reviews_student ON public.library_reviews USING btree (student_id);

CREATE INDEX idx_library_settings_school_key ON public.library_settings_school USING btree (school_id, setting_key);

CREATE INDEX idx_library_settings_school_school_id ON public.library_settings_school USING btree (school_id);

CREATE INDEX idx_license_assign_assigned_by ON public.license_assignments USING btree (assigned_by);

CREATE INDEX idx_license_assign_expires_at ON public.license_assignments USING btree (expires_at) WHERE (expires_at IS NOT NULL);

CREATE INDEX idx_license_assign_org_sub ON public.license_assignments USING btree (organization_subscription_id);

CREATE INDEX idx_license_assign_pool ON public.license_assignments USING btree (license_pool_id);

CREATE INDEX idx_license_assign_pool_status ON public.license_assignments USING btree (license_pool_id, status);

CREATE INDEX idx_license_assign_status ON public.license_assignments USING btree (status);

CREATE INDEX idx_license_assign_user ON public.license_assignments USING btree (user_id);

CREATE INDEX idx_license_assign_user_status ON public.license_assignments USING btree (user_id, status);

CREATE INDEX idx_license_pools_is_active ON public.license_pools USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_license_pools_member_type ON public.license_pools USING btree (member_type);

CREATE INDEX idx_license_pools_org_id ON public.license_pools USING btree (organization_id);

CREATE INDEX idx_license_pools_org_member ON public.license_pools USING btree (organization_id, member_type, is_active);

CREATE INDEX idx_license_pools_org_sub ON public.license_pools USING btree (organization_subscription_id);

CREATE INDEX idx_license_pools_org_type ON public.license_pools USING btree (organization_type);

CREATE INDEX idx_mappings_assessment ON public.outcome_assessment_mappings USING btree (assessment_type_id);

CREATE INDEX idx_mappings_outcome ON public.outcome_assessment_mappings USING btree (learning_outcome_id);

CREATE INDEX idx_mark_entries_absent ON public.mark_entries USING btree (is_absent);

CREATE INDEX idx_mark_entries_assessment ON public.mark_entries USING btree (assessment_id);

CREATE INDEX idx_mark_entries_assessment_subject ON public.mark_entries USING btree (assessment_id, subject_id);

CREATE INDEX idx_mark_entries_grade ON public.mark_entries USING btree (grade);

CREATE INDEX idx_mark_entries_locked ON public.mark_entries USING btree (is_locked);

CREATE INDEX idx_mark_entries_student ON public.mark_entries USING btree (student_id);

CREATE INDEX idx_mark_entries_student_record ON public.mark_entries USING btree (student_record_id);

CREATE INDEX idx_mark_entries_subject_id ON public.mark_entries USING btree (subject_id);

CREATE INDEX idx_mark_entry_batches_assessment ON public.mark_entry_batches USING btree (assessment_id);

CREATE INDEX idx_mark_entry_batches_entered_by ON public.mark_entry_batches USING btree (entered_by);

CREATE INDEX idx_mark_entry_batches_status ON public.mark_entry_batches USING btree (status);

CREATE INDEX idx_mark_moderation_log_assessment ON public.mark_moderation_log USING btree (assessment_id);

CREATE INDEX idx_mark_moderation_log_entry ON public.mark_moderation_log USING btree (mark_entry_id);

CREATE INDEX idx_mark_moderation_log_moderator ON public.mark_moderation_log USING btree (moderated_by);

CREATE INDEX idx_mark_moderation_log_student ON public.mark_moderation_log USING btree (student_id);

CREATE INDEX idx_mark_moderation_log_type ON public.mark_moderation_log USING btree (moderation_type);

CREATE INDEX idx_mentor_notes_created_by ON public.college_mentor_notes USING btree (created_by_id);

CREATE INDEX idx_mentor_notes_follow_up ON public.college_mentor_notes USING btree (follow_up_date) WHERE (follow_up_required = true);

CREATE INDEX idx_mentor_notes_priority ON public.college_mentor_notes USING btree (priority);

CREATE INDEX idx_messages_application_id ON public.messages USING btree (application_id);

CREATE INDEX idx_messages_class_id ON public.messages USING btree (class_id);

CREATE INDEX idx_messages_conversation_created ON public.messages USING btree (conversation_id, created_at DESC);

CREATE INDEX idx_messages_conversation_id ON public.messages USING btree (conversation_id);

CREATE INDEX idx_messages_created_at ON public.messages USING btree (created_at DESC);

CREATE INDEX idx_messages_is_read ON public.messages USING btree (is_read);

CREATE INDEX idx_messages_opportunity_id ON public.messages USING btree (opportunity_id);

CREATE INDEX idx_messages_program_section_id ON public.messages USING btree (program_section_id);

CREATE INDEX idx_messages_receiver_id ON public.messages USING btree (receiver_id);

CREATE INDEX idx_messages_receiver_type ON public.messages USING btree (receiver_type);

CREATE INDEX idx_messages_receiver_unread ON public.messages USING btree (receiver_id, is_read) WHERE (is_read = false);

CREATE INDEX idx_messages_sender_id ON public.messages USING btree (sender_id);

CREATE INDEX idx_messages_sender_type ON public.messages USING btree (sender_type);

CREATE INDEX idx_messages_subject ON public.messages USING btree (subject);

CREATE INDEX idx_metrics_date ON public.metrics_snapshots USING btree ("snapshotDate" DESC);

CREATE INDEX idx_metrics_snapshotdate ON public.metrics_snapshots USING btree ("snapshotDate" DESC);

CREATE INDEX idx_modules_course ON public.course_modules USING btree (course_id);

CREATE INDEX idx_modules_order ON public.course_modules USING btree (course_id, order_index);

CREATE INDEX idx_notification_log_sent_at ON public.streak_notification_log USING btree (sent_at DESC);

CREATE INDEX idx_notification_log_status ON public.streak_notification_log USING btree (status);

CREATE INDEX idx_notification_log_student_date ON public.streak_notification_log USING btree (student_id, notification_date);

CREATE INDEX idx_notification_log_student_id ON public.streak_notification_log USING btree (student_id);

CREATE INDEX idx_notifications_created ON public.notifications USING btree (created_at DESC);

CREATE INDEX idx_notifications_read ON public.notifications USING btree (read);

CREATE INDEX idx_notifications_recipient_created ON public.notifications USING btree (recipient_id, created_at DESC);

CREATE INDEX idx_notifications_recruiter ON public.notifications USING btree (recipient_id);

CREATE INDEX idx_notifications_scheduled ON public.notifications USING btree (status, scheduled_for) WHERE ((status)::text = 'scheduled'::text);

CREATE INDEX idx_notifications_type_created ON public.notifications USING btree (type, created_at DESC);

CREATE INDEX idx_offers_candidate_name_lower ON public.offers USING btree (lower(candidate_name));

CREATE INDEX idx_offers_expiry_date ON public.offers USING btree (expiry_date);

CREATE INDEX idx_offers_inserted_at ON public.offers USING btree (inserted_at DESC);

CREATE INDEX idx_offers_job_title_lower ON public.offers USING btree (lower(job_title));

CREATE INDEX idx_offers_offer_date ON public.offers USING btree (offer_date);

CREATE INDEX idx_offers_sent_via ON public.offers USING btree (sent_via);

CREATE INDEX idx_offers_status ON public.offers USING btree (status);

CREATE INDEX idx_offers_status_expiry ON public.offers USING btree (status, expiry_date);

CREATE INDEX idx_offers_status_inserted ON public.offers USING btree (status, inserted_at DESC);

CREATE INDEX idx_offers_template ON public.offers USING btree (template);

CREATE INDEX idx_opportunities_active_posted ON public.opportunities USING btree (is_active, posted_date DESC) WHERE (is_active = true);

CREATE INDEX idx_opportunities_active_status_deadline ON public.opportunities USING btree (is_active, status, deadline) WHERE ((is_active = true) AND (status = 'open'::text));

CREATE INDEX idx_opportunities_company_name ON public.opportunities USING btree (lower(company_name));

CREATE INDEX idx_opportunities_cost ON public.opportunities USING btree (cost_inr);

CREATE INDEX idx_opportunities_created_at ON public.opportunities USING btree (created_at DESC);

CREATE INDEX idx_opportunities_deadline ON public.opportunities USING btree (deadline, closing_date);

CREATE INDEX idx_opportunities_description_lower ON public.opportunities USING btree (lower(description)) WHERE (description IS NOT NULL);

CREATE INDEX idx_opportunities_embedding ON public.opportunities USING ivfflat (embedding extensions.vector_cosine_ops) WITH (lists='100');

CREATE INDEX idx_opportunities_embedding_hnsw ON public.opportunities USING hnsw (embedding extensions.vector_cosine_ops) WITH (m='16', ef_construction='64');

CREATE INDEX idx_opportunities_employment_type ON public.opportunities USING btree (employment_type) WHERE (employment_type IS NOT NULL);

CREATE INDEX idx_opportunities_experience_level ON public.opportunities USING btree (experience_level) WHERE (experience_level IS NOT NULL);

CREATE INDEX idx_opportunities_exposure_type ON public.opportunities USING btree (exposure_type);

CREATE INDEX idx_opportunities_job_title ON public.opportunities USING btree (lower(job_title));

CREATE INDEX idx_opportunities_posted_date ON public.opportunities USING btree (posted_date DESC NULLS LAST);

CREATE INDEX idx_opportunities_requisition_id ON public.opportunities USING btree (requisition_id);

CREATE INDEX idx_opportunities_salary ON public.opportunities USING btree (salary_range_max DESC, salary_range_min DESC);

CREATE INDEX idx_opportunities_search ON public.opportunities USING gin (to_tsvector('english'::regconfig, ((((((((((COALESCE(job_title, ''::text) || ' '::text) || COALESCE(title, ''::text)) || ' '::text) || COALESCE(company_name, ''::text)) || ' '::text) || COALESCE(description, ''::text)) || ' '::text) || COALESCE(sector, ''::text)) || ' '::text) || COALESCE(exposure_type, ''::text))));

CREATE INDEX idx_opportunities_sector ON public.opportunities USING btree (sector);

CREATE INDEX idx_opportunities_skills_gin ON public.opportunities USING gin (skills_required);

CREATE INDEX idx_opportunities_title_lower ON public.opportunities USING btree (lower(title));

CREATE INDEX idx_opportunity_interactions_action ON public.opportunity_interactions USING btree (action);

CREATE INDEX idx_opportunity_interactions_opportunity ON public.opportunity_interactions USING btree (opportunity_id, action);

CREATE INDEX idx_opportunity_interactions_student ON public.opportunity_interactions USING btree (student_id);

CREATE INDEX idx_opportunity_interactions_student_action ON public.opportunity_interactions USING btree (student_id, action);

CREATE INDEX idx_org_invitations_email ON public.organization_invitations USING btree (invitee_email) WHERE (status = 'pending'::text);

CREATE INDEX idx_org_invitations_expired ON public.organization_invitations USING btree (expires_at) WHERE (status = 'pending'::text);

CREATE INDEX idx_org_invitations_invited_by ON public.organization_invitations USING btree (invited_by, created_at DESC);

CREATE INDEX idx_org_invitations_license_pool ON public.organization_invitations USING btree (license_pool_id) WHERE ((license_pool_id IS NOT NULL) AND (status = 'pending'::text));

CREATE INDEX idx_org_invitations_organization ON public.organization_invitations USING btree (organization_id, organization_type);

CREATE INDEX idx_org_invitations_pending_active ON public.organization_invitations USING btree (organization_id, status, expires_at) WHERE (status = 'pending'::text);

CREATE INDEX idx_org_invitations_status ON public.organization_invitations USING btree (status, expires_at);

CREATE INDEX idx_org_invitations_token ON public.organization_invitations USING btree (invitation_token) WHERE (status = 'pending'::text);

CREATE INDEX idx_org_subs_end_date ON public.organization_subscriptions USING btree (end_date);

CREATE INDEX idx_org_subs_org_id ON public.organization_subscriptions USING btree (organization_id);

CREATE INDEX idx_org_subs_org_status ON public.organization_subscriptions USING btree (organization_id, status);

CREATE INDEX idx_org_subs_org_type ON public.organization_subscriptions USING btree (organization_type);

CREATE INDEX idx_org_subs_plan_id ON public.organization_subscriptions USING btree (subscription_plan_id);

CREATE INDEX idx_org_subs_purchased_by ON public.organization_subscriptions USING btree (purchased_by);

CREATE INDEX idx_org_subs_status ON public.organization_subscriptions USING btree (status);

CREATE INDEX idx_org_subscriptions_razorpay_payment_id ON public.organization_subscriptions USING btree (razorpay_payment_id);

CREATE INDEX idx_organizations_admin_id ON public.organizations USING btree (admin_id);

CREATE INDEX idx_organizations_code ON public.organizations USING btree (code);

CREATE INDEX idx_organizations_name ON public.organizations USING btree (name);

CREATE INDEX idx_organizations_type ON public.organizations USING btree (organization_type);

CREATE INDEX idx_otp_requests_log_phone_created ON public.otp_requests_log USING btree (phone, created_at);

CREATE INDEX idx_outcomes_bloom ON public.curriculum_learning_outcomes USING btree (bloom_level);

CREATE INDEX idx_outcomes_chapter ON public.curriculum_learning_outcomes USING btree (chapter_id);

CREATE INDEX idx_passports_assessments_gin ON public.skill_passports USING gin (assessments);

CREATE INDEX idx_passports_certificates_gin ON public.skill_passports USING gin (certificates);

CREATE INDEX idx_passports_createdat ON public.skill_passports USING btree ("createdAt" DESC);

CREATE INDEX idx_passports_nsqflevel ON public.skill_passports USING btree ("nsqfLevel");

CREATE INDEX idx_passports_projects_gin ON public.skill_passports USING gin (projects);

CREATE INDEX idx_passports_status ON public.skill_passports USING btree (status);

CREATE INDEX idx_passports_status_nsqf ON public.skill_passports USING btree (status, "nsqfLevel");

CREATE INDEX idx_passports_student ON public.skill_passports USING btree ("studentId");

CREATE INDEX idx_passports_student_status ON public.skill_passports USING btree ("studentId", status);

CREATE INDEX idx_passports_studentid ON public.skill_passports USING btree ("studentId");

CREATE INDEX idx_passports_updatedat ON public.skill_passports USING btree ("updatedAt" DESC);

CREATE INDEX idx_payment_transactions_bulk ON public.payment_transactions USING btree (is_bulk_purchase, created_at DESC) WHERE (is_bulk_purchase = true);

CREATE INDEX idx_payment_transactions_org_history ON public.payment_transactions USING btree (organization_id, status, created_at DESC) WHERE (organization_id IS NOT NULL);

CREATE INDEX idx_payment_transactions_organization ON public.payment_transactions USING btree (organization_id, organization_type) WHERE (is_bulk_purchase = true);

CREATE INDEX idx_payment_transactions_razorpay_payment_id ON public.payment_transactions USING btree (razorpay_payment_id);

CREATE INDEX idx_payment_transactions_subscription_id ON public.payment_transactions USING btree (subscription_id);

CREATE INDEX idx_payment_transactions_type ON public.payment_transactions USING btree (transaction_type);

CREATE INDEX idx_payment_transactions_user_id ON public.payment_transactions USING btree (user_id);

CREATE INDEX idx_permissions_action ON public.permissions USING btree (action);

CREATE INDEX idx_permissions_resource ON public.permissions USING btree (resource);

CREATE INDEX idx_phone_otps_expires_at ON public.phone_otps USING btree (expires_at);

CREATE INDEX idx_phone_otps_phone ON public.phone_otps USING btree (phone);

CREATE INDEX idx_pipeline_activities_created_at ON public.pipeline_activities USING btree (created_at);

CREATE INDEX idx_pipeline_activities_pipeline_candidate_id ON public.pipeline_activities USING btree (pipeline_candidate_id);

CREATE INDEX idx_pipeline_activities_student_id ON public.pipeline_activities USING btree (student_id);

CREATE INDEX idx_pipeline_candidates_next_action_date ON public.pipeline_candidates USING btree (next_action_date);

CREATE INDEX idx_pipeline_candidates_stage ON public.pipeline_candidates USING btree (stage);

CREATE INDEX idx_pipeline_candidates_status ON public.pipeline_candidates USING btree (status);

CREATE INDEX idx_pipeline_candidates_student_id ON public.pipeline_candidates USING btree (student_id);

CREATE INDEX idx_pipeline_opportunity_id ON public.pipeline_candidates USING btree (opportunity_id_old);

CREATE INDEX idx_placements_hired_date ON public.placements USING btree ("hiredDate" DESC);

CREATE INDEX idx_placements_recruiter ON public.placements USING btree ("recruiterId");

CREATE INDEX idx_placements_status ON public.placements USING btree ("placementStatus");

CREATE INDEX idx_placements_student ON public.placements USING btree ("studentId");

CREATE INDEX idx_plan_features_category ON public.subscription_plan_features USING btree (category);

CREATE INDEX idx_plan_features_plan_id ON public.subscription_plan_features USING btree (plan_id);

CREATE INDEX idx_pre_registrations_email_status ON public.pre_registrations USING btree (email, payment_status);

CREATE UNIQUE INDEX idx_pre_registrations_email_unique ON public.pre_registrations USING btree (lower(email));

CREATE INDEX idx_pre_registrations_payment_history ON public.pre_registrations USING gin (payment_history);

CREATE INDEX idx_pre_registrations_payment_status ON public.pre_registrations USING btree (payment_status);

CREATE INDEX idx_profile_views_date ON public.profile_views USING btree (viewed_at);

CREATE INDEX idx_profile_views_student ON public.profile_views USING btree (student_id);

CREATE INDEX idx_program_sections_department ON public.program_sections USING btree (department_id);

CREATE INDEX idx_program_sections_faculty ON public.program_sections USING btree (faculty_id);

CREATE INDEX idx_program_sections_program ON public.program_sections USING btree (program_id);

CREATE INDEX idx_program_sections_status ON public.program_sections USING btree (status);

CREATE INDEX idx_programs_department ON public.programs USING btree (department_id);

CREATE INDEX idx_progress_active ON public.student_course_progress USING btree (student_id, course_id) WHERE ((status)::text = 'in_progress'::text);

CREATE INDEX idx_progress_lesson_lookup ON public.student_course_progress USING btree (student_id, course_id, lesson_id);

CREATE INDEX idx_projects_created_at ON public.projects USING btree (student_id, created_at DESC) WHERE (enabled = true);

CREATE INDEX idx_projects_student ON public.projects USING btree (student_id);

CREATE INDEX idx_projects_student_id ON public.projects USING btree (student_id);

CREATE INDEX idx_projects_student_lookup ON public.projects USING btree (student_id, enabled, approval_status) WHERE ((enabled = true) AND ((approval_status)::text = ANY ((ARRAY['approved'::character varying, 'verified'::character varying])::text[])));

CREATE INDEX idx_promotional_events_active ON public.promotional_events USING btree (is_active, start_date, end_date);

CREATE INDEX idx_promotional_events_code ON public.promotional_events USING btree (event_code);

CREATE INDEX idx_questions_cache_active ON public.adaptive_aptitude_questions_cache USING btree (is_active);

CREATE INDEX idx_questions_cache_difficulty ON public.adaptive_aptitude_questions_cache USING btree (difficulty);

CREATE INDEX idx_questions_cache_grade_level ON public.adaptive_aptitude_questions_cache USING btree (grade_level);

CREATE INDEX idx_questions_cache_lookup ON public.adaptive_aptitude_questions_cache USING btree (grade_level, phase, difficulty, subtag) WHERE (is_active = true);

CREATE INDEX idx_questions_cache_options_gin ON public.adaptive_aptitude_questions_cache USING gin (options);

CREATE INDEX idx_questions_cache_phase ON public.adaptive_aptitude_questions_cache USING btree (phase);

CREATE INDEX idx_questions_cache_question_id ON public.adaptive_aptitude_questions_cache USING btree (question_id);

CREATE INDEX idx_questions_cache_subtag ON public.adaptive_aptitude_questions_cache USING btree (subtag);

CREATE INDEX idx_questions_stream_id ON public.personal_assessment_questions USING btree (stream_id);

CREATE INDEX idx_quiz_progress_lookup ON public.student_quiz_progress USING btree (student_id, quiz_id, attempt_number);

CREATE INDEX idx_quiz_progress_status ON public.student_quiz_progress USING btree (status) WHERE ((status)::text = 'in_progress'::text);

CREATE INDEX idx_quiz_progress_student_course ON public.student_quiz_progress USING btree (student_id, course_id);

CREATE INDEX idx_quizzes_lesson_id ON public.quizzes USING btree (lesson_id);

CREATE INDEX idx_razorpay_orders_order_id ON public.razorpay_orders USING btree (order_id);

CREATE INDEX idx_razorpay_orders_payment_id ON public.razorpay_orders USING btree (razorpay_payment_id);

CREATE INDEX idx_razorpay_orders_status ON public.razorpay_orders USING btree (status);

CREATE INDEX idx_razorpay_orders_subscription_id ON public.razorpay_orders USING btree (subscription_id);

CREATE INDEX idx_razorpay_orders_user_id ON public.razorpay_orders USING btree (user_id);

CREATE INDEX idx_razorpay_orders_user_status ON public.razorpay_orders USING btree (user_id, status);

CREATE INDEX idx_recent_updates_student ON public.recent_updates USING btree (student_id);

CREATE INDEX idx_recent_updates_updated_at ON public.recent_updates USING btree (updated_at);

CREATE INDEX idx_recommendations_assessment ON public.student_course_recommendations USING btree (assessment_result_id);

CREATE INDEX idx_recommendations_course ON public.student_course_recommendations USING btree (course_id);

CREATE INDEX idx_recommendations_status ON public.student_course_recommendations USING btree (status);

CREATE INDEX idx_recommendations_student ON public.student_course_recommendations USING btree (student_id);

CREATE INDEX idx_recommendations_student_status ON public.student_course_recommendations USING btree (student_id, status);

CREATE INDEX idx_recruiter_activities_created ON public.recruiter_activities USING btree ("createdAt" DESC);

CREATE INDEX idx_recruiter_activities_recruiter ON public.recruiter_activities USING btree ("recruiterId");

CREATE INDEX idx_recruiter_activities_student ON public.recruiter_activities USING btree ("targetStudentId");

CREATE INDEX idx_recruiter_activities_type ON public.recruiter_activities USING btree ("activityType");

CREATE INDEX idx_recruiters_approval ON public.recruiters USING btree (approval_status);

CREATE INDEX idx_recruiters_createdat ON public.recruiters USING btree (createdat DESC);

CREATE INDEX idx_recruiters_email ON public.recruiters USING btree (email);

CREATE INDEX idx_recruiters_isactive ON public.recruiters USING btree (isactive);

CREATE INDEX idx_recruiters_name_trgm ON public.recruiters USING gin (name extensions.gin_trgm_ops);

CREATE INDEX idx_recruiters_state ON public.recruiters USING btree (state);

CREATE INDEX idx_recruiters_state_status ON public.recruiters USING btree (state, verificationstatus);

CREATE INDEX idx_recruiters_status ON public.recruiters USING btree (account_status);

CREATE INDEX idx_recruiters_status_active ON public.recruiters USING btree (verificationstatus, isactive);

CREATE INDEX idx_recruiters_user_id ON public.recruiters USING btree (user_id);

CREATE INDEX idx_recruiters_verificationstatus ON public.recruiters USING btree (verificationstatus);

CREATE INDEX idx_requisitions_created_by ON public.requisitions USING btree (created_by);

CREATE INDEX idx_requisitions_created_date ON public.requisitions USING btree (created_date);

CREATE INDEX idx_requisitions_status ON public.requisitions USING btree (status);

CREATE INDEX idx_resources_lesson ON public.lesson_resources USING btree (lesson_id);

CREATE INDEX idx_response_scales_section ON public.personal_assessment_response_scales USING btree (section_id);

CREATE INDEX idx_restrictions_student_grade ON public.personal_assessment_restrictions USING btree (student_id, grade_level);

CREATE INDEX idx_results_grade_level ON public.personal_assessment_results USING btree (grade_level);

CREATE INDEX idx_results_metadata_duplicates ON public.adaptive_aptitude_results USING gin (((metadata -> 'duplicateValidation'::text)));

CREATE INDEX idx_saved_jobs_opportunity_id ON public.saved_jobs USING btree (opportunity_id_old);

CREATE INDEX idx_saved_jobs_saved_at ON public.saved_jobs USING btree (saved_at DESC);

CREATE INDEX idx_saved_jobs_student_date ON public.saved_jobs USING btree (student_id_old, saved_at DESC);

CREATE INDEX idx_saved_jobs_student_id ON public.saved_jobs USING btree (student_id_old);

CREATE INDEX idx_saved_searches_created ON public.recruiter_saved_searches USING btree (created_at DESC);

CREATE INDEX idx_saved_searches_last_used ON public.recruiter_saved_searches USING btree (last_used DESC NULLS LAST);

CREATE INDEX idx_saved_searches_recruiter ON public.recruiter_saved_searches USING btree (recruiter_id);

CREATE INDEX idx_school_classes_academic_year ON public.school_classes USING btree (academic_year);

CREATE INDEX idx_school_classes_school ON public.school_classes USING btree (school_id);

CREATE INDEX idx_school_educators_role ON public.school_educators USING btree (role);

CREATE INDEX idx_school_educators_school ON public.school_educators USING btree (school_id);

CREATE INDEX idx_school_educators_status ON public.school_educators USING btree (onboarding_status);

CREATE INDEX idx_school_educators_user ON public.school_educators USING btree (user_id);

CREATE INDEX idx_search_history_last_searched ON public.search_history USING btree (last_searched_at DESC);

CREATE INDEX idx_search_history_search_count ON public.search_history USING btree (search_count DESC);

CREATE INDEX idx_search_history_student_id ON public.search_history USING btree (student_id);

CREATE INDEX idx_sections_grade_active ON public.personal_assessment_sections USING btree (grade_level, is_active) WHERE (is_active = true);

CREATE INDEX idx_sections_grade_level ON public.personal_assessment_sections USING btree (grade_level);

CREATE INDEX idx_shortlist_candidates_shortlist_id ON public.shortlist_candidates USING btree (shortlist_id);

CREATE INDEX idx_shortlist_candidates_student_id ON public.shortlist_candidates USING btree (student_id);

CREATE INDEX idx_shortlists_created_by ON public.shortlists USING btree (created_by);

CREATE INDEX idx_shortlists_created_date ON public.shortlists USING btree (created_date);

CREATE INDEX idx_skill_assessments_date ON public.skill_assessments USING btree (assessment_date);

CREATE INDEX idx_skill_assessments_school ON public.skill_assessments USING btree (school_id);

CREATE INDEX idx_skill_assessments_student ON public.skill_assessments USING btree (student_id);

CREATE INDEX idx_skill_assessments_type ON public.skill_assessments USING btree (assessment_type);

CREATE INDEX idx_skill_badges_category ON public.skill_badges USING btree (category);

CREATE INDEX idx_skill_badges_is_active ON public.skill_badges USING btree (is_active);

CREATE INDEX idx_skill_badges_level ON public.skill_badges USING btree (level);

CREATE INDEX idx_skill_badges_school ON public.skill_badges USING btree (school_id);

CREATE INDEX idx_skill_trends_category ON public.skill_trends USING btree (category);

CREATE INDEX idx_skill_trends_snapshot ON public.skill_trends USING btree ("snapshotDate" DESC);

CREATE INDEX idx_skill_verifications_institution_status ON public.skill_verification_requests USING btree (institution_admin_status);

CREATE INDEX idx_skill_verifications_overall_status ON public.skill_verification_requests USING btree (overall_status);

CREATE INDEX idx_skill_verifications_rareminds_status ON public.skill_verification_requests USING btree (rareminds_admin_status);

CREATE INDEX idx_skill_verifications_student_id ON public.skill_verification_requests USING btree (student_id);

CREATE INDEX idx_skills_student_enabled ON public.skills USING btree (student_id, enabled) WHERE (enabled = true);

CREATE INDEX idx_skills_student_id ON public.skills USING btree (student_id);

CREATE INDEX idx_skills_student_lookup ON public.skills USING btree (student_id, enabled) WHERE (enabled = true);

CREATE INDEX idx_skills_training_id ON public.skills USING btree (training_id);

CREATE INDEX idx_skills_type ON public.skills USING btree (type);

CREATE INDEX idx_stream_reports_academic_year ON public.stream_recommendation_reports USING btree (academic_year);

CREATE INDEX idx_stream_reports_grade ON public.stream_recommendation_reports USING btree (current_grade);

CREATE INDEX idx_stream_reports_is_latest ON public.stream_recommendation_reports USING btree (is_latest);

CREATE INDEX idx_stream_reports_recommended ON public.stream_recommendation_reports USING btree (recommended_stream);

CREATE INDEX idx_stream_reports_student ON public.stream_recommendation_reports USING btree (student_id);

CREATE INDEX idx_student_assignments_assignment ON public.student_assignments USING btree (assignment_id);

CREATE INDEX idx_student_assignments_lookup ON public.student_assignments USING btree (student_id, is_deleted) WHERE (is_deleted = false);

CREATE INDEX idx_student_assignments_status ON public.student_assignments USING btree (status);

CREATE INDEX idx_student_assignments_student ON public.student_assignments USING btree (student_id);

CREATE INDEX idx_student_assignments_student_status ON public.student_assignments USING btree (student_id, status);

CREATE INDEX idx_student_assignments_submission_date ON public.student_assignments USING btree (submission_date);

CREATE INDEX idx_student_badges_badge ON public.student_skill_badges USING btree (badge_id);

CREATE INDEX idx_student_badges_status ON public.student_skill_badges USING btree (status);

CREATE INDEX idx_student_badges_student ON public.student_skill_badges USING btree (student_email);

CREATE INDEX idx_student_course_progress_course_id ON public.student_course_progress USING btree (course_id);

CREATE INDEX idx_student_course_progress_student_course ON public.student_course_progress USING btree (student_id, course_id);

CREATE INDEX idx_student_course_progress_student_id ON public.student_course_progress USING btree (student_id);

CREATE INDEX idx_student_enrollments_academic_year ON public.student_enrollments USING btree (academic_year);

CREATE INDEX idx_student_enrollments_program ON public.student_enrollments USING btree (program_id);

CREATE INDEX idx_student_enrollments_section ON public.student_enrollments USING btree (section_id);

CREATE INDEX idx_student_enrollments_status ON public.student_enrollments USING btree (enrollment_status);

CREATE INDEX idx_student_enrollments_student ON public.student_enrollments USING btree (student_id);

CREATE INDEX idx_student_job_matches_expires ON public.student_job_matches USING btree (expires_at);

CREATE INDEX idx_student_job_matches_student_id ON public.student_job_matches USING btree (student_id);

CREATE INDEX idx_student_job_matches_valid ON public.student_job_matches USING btree (is_valid) WHERE (is_valid = true);

CREATE INDEX idx_student_ledgers_college ON public.student_ledgers USING btree (college_id);

CREATE INDEX idx_student_ledgers_due_date ON public.student_ledgers USING btree (due_date);

CREATE INDEX idx_student_ledgers_fee_structure ON public.student_ledgers USING btree (fee_structure_id);

CREATE INDEX idx_student_ledgers_overdue ON public.student_ledgers USING btree (is_overdue);

CREATE INDEX idx_student_ledgers_status ON public.student_ledgers USING btree (payment_status);

CREATE INDEX idx_student_ledgers_student ON public.student_ledgers USING btree (student_id);

CREATE INDEX idx_student_ledgers_student_record ON public.student_ledgers USING btree (student_record_id);

CREATE INDEX idx_student_management_records_enrollment ON public.student_management_records USING btree (enrollment_number);

CREATE INDEX idx_student_management_records_school ON public.student_management_records USING btree (school_id);

CREATE INDEX idx_student_management_records_student ON public.student_management_records USING btree (student_id);

CREATE INDEX idx_student_promotions_academic_year ON public.student_promotions USING btree (academic_year);

CREATE INDEX idx_student_promotions_college ON public.student_promotions USING btree (college_id);

CREATE INDEX idx_student_promotions_from_grade ON public.student_promotions USING btree (from_grade);

CREATE INDEX idx_student_promotions_is_passed ON public.student_promotions USING btree (is_passed);

CREATE INDEX idx_student_promotions_is_promoted ON public.student_promotions USING btree (is_promoted);

CREATE INDEX idx_student_promotions_school ON public.student_promotions USING btree (school_id);

CREATE INDEX idx_student_promotions_student ON public.student_promotions USING btree (student_id);

CREATE INDEX idx_student_reports_date ON public.student_reports USING btree (generated_date);

CREATE INDEX idx_student_reports_school ON public.student_reports USING btree (school_id);

CREATE INDEX idx_student_reports_student ON public.student_reports USING btree (student_id);

CREATE INDEX idx_student_reports_type ON public.student_reports USING btree (report_type);

CREATE INDEX idx_student_streaks_incomplete_today ON public.student_streaks USING btree (streak_completed_today) WHERE (streak_completed_today = false);

CREATE INDEX idx_student_streaks_last_activity ON public.student_streaks USING btree (last_activity_date);

CREATE INDEX idx_student_streaks_student_id ON public.student_streaks USING btree (student_id);

CREATE INDEX idx_students_aadhar_number ON public.students USING btree (aadhar_number) WHERE (aadhar_number IS NOT NULL);

CREATE INDEX idx_students_admission_number ON public.students USING btree (admission_number);

CREATE INDEX idx_students_branch_course ON public.students USING btree (branch_field, course_name) WHERE ((branch_field IS NOT NULL) OR (course_name IS NOT NULL));

CREATE INDEX idx_students_college_class_id ON public.students USING btree (college_class_id);

CREATE INDEX idx_students_createdat ON public.students USING btree ("createdAt" DESC);

CREATE INDEX idx_students_current_backlogs ON public.students USING btree (current_backlogs);

CREATE INDEX idx_students_documents ON public.students USING gin (documents);

CREATE INDEX idx_students_embedding ON public.students USING ivfflat (embedding extensions.vector_cosine_ops) WITH (lists='100');

CREATE INDEX idx_students_gap_in_studies ON public.students USING btree (gap_in_studies);

CREATE INDEX idx_students_grade ON public.students USING btree (grade);

CREATE INDEX idx_students_grade_semester_type ON public.students USING btree (grade, semester, student_type) WHERE (grade IS NOT NULL);

CREATE INDEX idx_students_hobbies_gin ON public.students USING gin (hobbies);

CREATE INDEX idx_students_interests_gin ON public.students USING gin (interests);

CREATE INDEX idx_students_is_deleted ON public.students USING btree (is_deleted);

CREATE INDEX idx_students_languages_gin ON public.students USING gin (languages);

CREATE INDEX idx_students_notification_settings ON public.students USING gin (notification_settings);

CREATE INDEX idx_students_program_id ON public.students USING btree (program_id);

CREATE INDEX idx_students_roll_number ON public.students USING btree (roll_number);

CREATE INDEX idx_students_school ON public.students USING btree (school_id);

CREATE INDEX idx_students_school_class ON public.students USING btree (school_class_id);

CREATE INDEX idx_students_section ON public.students USING btree (section);

CREATE INDEX idx_students_student_id ON public.students USING btree (student_id);

CREATE INDEX idx_students_tour_progress ON public.students USING gin (tour_progress);

CREATE INDEX idx_students_univ_college ON public.students USING btree (university_college_id);

CREATE INDEX idx_students_university ON public.students USING btree ("universityId");

CREATE INDEX idx_students_user_id ON public.students USING btree (user_id) WHERE (user_id IS NOT NULL);

CREATE INDEX idx_subscription_cancellations_cancelled_at ON public.subscription_cancellations USING btree (cancelled_at);

CREATE INDEX idx_subscription_cancellations_reason ON public.subscription_cancellations USING btree (cancellation_reason);

CREATE INDEX idx_subscription_cancellations_subscription_id ON public.subscription_cancellations USING btree (subscription_id);

CREATE INDEX idx_subscription_cancellations_user_id ON public.subscription_cancellations USING btree (user_id);

CREATE INDEX idx_subscription_migrations_status ON public.subscription_migrations USING btree (migration_status);

CREATE INDEX idx_subscription_migrations_user_id ON public.subscription_migrations USING btree (user_id);

CREATE INDEX idx_subscription_plan_features_is_addon ON public.subscription_plan_features USING btree (is_addon) WHERE (is_addon = true);

CREATE INDEX idx_subscription_plans_active ON public.subscription_plans USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_subscription_plans_business_type ON public.subscription_plans USING btree (business_type);

CREATE INDEX idx_subscription_plans_entity_role ON public.subscription_plans USING btree (entity_type, role_type);

CREATE INDEX idx_subscription_plans_lookup ON public.subscription_plans USING btree (business_type, entity_type, role_type, is_active);

CREATE INDEX idx_subscriptions_cancellation_reason ON public.subscriptions USING btree (cancellation_reason);

CREATE INDEX idx_subscriptions_cancelled_at ON public.subscriptions USING btree (cancelled_at);

CREATE INDEX idx_subscriptions_organization ON public.subscriptions USING btree (organization_id, organization_type) WHERE (is_organization_subscription = true);

CREATE INDEX idx_subscriptions_plan_id ON public.subscriptions USING btree (plan_id);

CREATE INDEX idx_subscriptions_plan_type ON public.subscriptions USING btree (plan_type);

CREATE INDEX idx_subscriptions_purchased_by ON public.subscriptions USING btree (purchased_by, created_at DESC) WHERE (is_organization_subscription = true);

CREATE INDEX idx_subscriptions_razorpay_sub_id ON public.subscriptions USING btree (razorpay_subscription_id);

CREATE INDEX idx_subscriptions_seat_count ON public.subscriptions USING btree (organization_id, seat_count) WHERE (is_organization_subscription = true);

CREATE INDEX idx_subscriptions_status ON public.subscriptions USING btree (status);

CREATE INDEX idx_subscriptions_user_id ON public.subscriptions USING btree (user_id);

CREATE INDEX idx_subscriptions_user_plan_status ON public.subscriptions USING btree (user_id, plan_type, status);

CREATE INDEX idx_subscriptions_user_status ON public.subscriptions USING btree (user_id, status);

CREATE INDEX idx_subscriptions_user_status_enddate ON public.subscriptions USING btree (user_id, status, subscription_end_date DESC);

CREATE INDEX idx_substitutions_date ON public.college_faculty_substitutions USING btree (substitution_date);

CREATE INDEX idx_substitutions_status ON public.college_faculty_substitutions USING btree (status);

CREATE INDEX idx_swap_history_created_at ON public.class_swap_history USING btree (created_at DESC);

CREATE INDEX idx_swap_history_request ON public.class_swap_history USING btree (swap_request_id);

CREATE INDEX idx_swap_requests_created_at ON public.class_swap_requests USING btree (created_at DESC);

CREATE INDEX idx_swap_requests_date ON public.class_swap_requests USING btree (swap_date) WHERE (swap_date IS NOT NULL);

CREATE INDEX idx_swap_requests_requester ON public.class_swap_requests USING btree (requester_faculty_id, status);

CREATE INDEX idx_swap_requests_status ON public.class_swap_requests USING btree (status);

CREATE INDEX idx_swap_requests_target ON public.class_swap_requests USING btree (target_faculty_id, status);

CREATE INDEX idx_teacher_journal_educator ON public.teacher_journal USING btree (educator_id);

CREATE INDEX idx_teacher_workload_educator ON public.teacher_workload USING btree (educator_id);

CREATE INDEX idx_timetable_class_date ON public.exam_timetable USING btree (class_id, exam_date);

CREATE INDEX idx_timetable_school_date ON public.exam_timetable USING btree (school_id, exam_date);

CREATE INDEX idx_timetable_slots_class ON public.timetable_slots USING btree (class_id);

CREATE INDEX idx_timetable_slots_educator ON public.timetable_slots USING btree (educator_id);

CREATE INDEX idx_timetable_slots_schedule ON public.timetable_slots USING btree (timetable_id, day_of_week, period_number);

CREATE INDEX idx_timetable_subject_school ON public.exam_timetable USING btree (subject_id, school_id);

CREATE INDEX idx_training_notifications_created ON public.training_notifications USING btree (created_at DESC);

CREATE INDEX idx_training_notifications_experience ON public.training_notifications USING btree (experience_id);

CREATE INDEX idx_training_notifications_project ON public.training_notifications USING btree (project_id);

CREATE INDEX idx_training_notifications_read ON public.training_notifications USING btree (is_read);

CREATE INDEX idx_training_notifications_recipient ON public.training_notifications USING btree (recipient_type, school_id, college_id);

CREATE INDEX idx_trainings_approval_authority ON public.trainings USING btree (approval_authority);

CREATE INDEX idx_trainings_approval_status ON public.trainings USING btree (approval_status);

CREATE INDEX idx_trainings_course_id ON public.trainings USING btree (course_id);

CREATE INDEX idx_trainings_status ON public.trainings USING btree (status);

CREATE INDEX idx_trainings_student ON public.trainings USING btree (student_id);

CREATE INDEX idx_trainings_student_id ON public.trainings USING btree (student_id);

CREATE INDEX idx_transcript_requests_date ON public.transcript_requests USING btree (request_date);

CREATE INDEX idx_transcript_requests_number ON public.transcript_requests USING btree (request_number);

CREATE INDEX idx_transcript_requests_status ON public.transcript_requests USING btree (status);

CREATE INDEX idx_transcript_requests_student ON public.transcript_requests USING btree (student_id);

CREATE INDEX idx_transcript_requests_type ON public.transcript_requests USING btree (transcript_type);

CREATE INDEX idx_transcripts_academic_year ON public.transcripts USING btree (academic_year);

CREATE INDEX idx_transcripts_program ON public.transcripts USING btree (program_id);

CREATE INDEX idx_transcripts_status ON public.transcripts USING btree (status);

CREATE INDEX idx_transcripts_student ON public.transcripts USING btree (student_id);

CREATE INDEX idx_transcripts_student_record ON public.transcripts USING btree (student_record_id);

CREATE INDEX idx_transcripts_type ON public.transcripts USING btree (type);

CREATE INDEX idx_transcripts_verification ON public.transcripts USING btree (verification_id);

CREATE INDEX idx_tutor_conversations_course_id ON public.tutor_conversations USING btree (course_id);

CREATE INDEX idx_tutor_conversations_student_course ON public.tutor_conversations USING btree (student_id, course_id);

CREATE INDEX idx_tutor_conversations_student_id ON public.tutor_conversations USING btree (student_id);

CREATE INDEX idx_tutor_feedback_conversation_id ON public.tutor_feedback USING btree (conversation_id);

CREATE UNIQUE INDEX idx_unique_active_user_plan ON public.subscriptions USING btree (user_id, plan_type) WHERE (status = 'active'::public.subscription_status);

CREATE INDEX idx_univ_colleges_college ON public.university_colleges USING btree (college_id);

CREATE INDEX idx_univ_colleges_university ON public.university_colleges USING btree (university_id);

CREATE INDEX idx_university_colleges_college_university ON public.university_colleges USING btree (college_id, university_id);

CREATE INDEX idx_university_performance_rank ON public.university_performance USING btree ("rankPosition");

CREATE INDEX idx_university_performance_snapshot ON public.university_performance USING btree ("snapshotDate" DESC);

CREATE INDEX idx_user_entitlements_end_date ON public.user_entitlements USING btree (end_date);

CREATE INDEX idx_user_entitlements_feature_key ON public.user_entitlements USING btree (feature_key);

CREATE INDEX idx_user_entitlements_granted_by ON public.user_entitlements USING btree (granted_by, created_at DESC) WHERE (granted_by IS NOT NULL);

CREATE INDEX idx_user_entitlements_org_provided ON public.user_entitlements USING btree (user_id, granted_by_organization) WHERE (granted_by_organization = true);

CREATE INDEX idx_user_entitlements_org_subscription ON public.user_entitlements USING btree (organization_subscription_id, user_id) WHERE (organization_subscription_id IS NOT NULL);

CREATE INDEX idx_user_entitlements_status ON public.user_entitlements USING btree (status);

CREATE INDEX idx_user_entitlements_user_id ON public.user_entitlements USING btree (user_id);

CREATE INDEX idx_user_login_history_success ON public.user_login_history USING btree (success);

CREATE INDEX idx_user_login_history_user ON public.user_login_history USING btree (user_id);

CREATE INDEX idx_user_profiles_social_links ON public.user_profiles USING gin (social_links);

CREATE INDEX idx_user_profiles_updated ON public.user_profiles USING btree (updated_at);

CREATE INDEX idx_user_profiles_user ON public.user_profiles USING btree (user_id);

CREATE INDEX idx_user_sessions_token ON public.user_sessions USING btree (session_token);

CREATE INDEX idx_user_sessions_user ON public.user_sessions USING btree (user_id);

CREATE INDEX idx_user_settings_notifications ON public.user_settings USING gin (notification_preferences);

CREATE INDEX idx_user_settings_user ON public.user_settings USING btree (user_id);

CREATE INDEX idx_user_state_history_user ON public.user_state_history USING btree (user_id);

CREATE INDEX idx_verifications_createdat ON public.verifications USING btree ("createdAt" DESC);

CREATE INDEX idx_verifications_performedby ON public.verifications USING btree ("performedBy");

CREATE INDEX idx_verifications_target ON public.verifications USING btree ("targetTable", "targetId");

CREATE INDEX idx_verifications_target_date ON public.verifications USING btree ("targetId", "createdAt" DESC);

CREATE INDEX idx_verifications_targetid ON public.verifications USING btree ("targetId");

CREATE INDEX idx_video_summaries_course_id ON public.video_summaries USING btree (course_id);

CREATE INDEX idx_video_summaries_lesson_id ON public.video_summaries USING btree (lesson_id);

CREATE INDEX idx_video_summaries_status ON public.video_summaries USING btree (processing_status);

CREATE UNIQUE INDEX institution_pricing_tiers_pkey ON public.institution_pricing_tiers USING btree (id);

CREATE UNIQUE INDEX internships_pkey ON public.internships USING btree (id);

CREATE UNIQUE INDEX interview_reminders_pkey ON public.interview_reminders USING btree (id);

CREATE UNIQUE INDEX interviews_pkey ON public.interviews USING btree (id);

CREATE UNIQUE INDEX invigilator_assignments_pkey ON public.invigilator_assignments USING btree (id);

CREATE UNIQUE INDEX lesson_plans_pkey ON public.lesson_plans USING btree (id);

CREATE UNIQUE INDEX lesson_resources_pkey ON public.lesson_resources USING btree (resource_id);

CREATE UNIQUE INDEX lessons_pkey ON public.lessons USING btree (lesson_id);

CREATE UNIQUE INDEX library_book_issues_college_pkey ON public.library_book_issues_college USING btree (id);

CREATE UNIQUE INDEX library_book_issues_pkey ON public.library_book_issues USING btree (id);

CREATE UNIQUE INDEX library_book_issues_school_pkey ON public.library_book_issues_school USING btree (id);

CREATE UNIQUE INDEX library_books_book_id_key ON public.library_books USING btree (book_id);

CREATE UNIQUE INDEX library_books_college_college_id_isbn_key ON public.library_books_college USING btree (college_id, isbn);

CREATE UNIQUE INDEX library_books_college_pkey ON public.library_books_college USING btree (id);

CREATE UNIQUE INDEX library_books_isbn_key ON public.library_books USING btree (isbn);

CREATE UNIQUE INDEX library_books_pkey ON public.library_books USING btree (id);

CREATE UNIQUE INDEX library_books_school_pkey ON public.library_books_school USING btree (id);

CREATE UNIQUE INDEX library_categories_college_college_id_name_key ON public.library_categories_college USING btree (college_id, name);

CREATE UNIQUE INDEX library_categories_college_pkey ON public.library_categories_college USING btree (id);

CREATE UNIQUE INDEX library_categories_name_key ON public.library_categories USING btree (name);

CREATE UNIQUE INDEX library_categories_pkey ON public.library_categories USING btree (id);

CREATE UNIQUE INDEX library_categories_school_pkey ON public.library_categories_school USING btree (id);

CREATE UNIQUE INDEX library_history_pkey ON public.library_history USING btree (id);

CREATE UNIQUE INDEX library_issued_books_pkey ON public.library_issued_books USING btree (id);

CREATE UNIQUE INDEX library_reservations_pkey ON public.library_reservations USING btree (id);

CREATE UNIQUE INDEX library_reviews_book_id_student_id_key ON public.library_reviews USING btree (book_id, student_id);

CREATE UNIQUE INDEX library_reviews_pkey ON public.library_reviews USING btree (id);

CREATE UNIQUE INDEX library_settings_college_college_id_setting_key_key ON public.library_settings_college USING btree (college_id, setting_key);

CREATE UNIQUE INDEX library_settings_college_pkey ON public.library_settings_college USING btree (id);

CREATE UNIQUE INDEX library_settings_pkey ON public.library_settings USING btree (id);

CREATE UNIQUE INDEX library_settings_school_pkey ON public.library_settings_school USING btree (id);

CREATE UNIQUE INDEX library_settings_setting_key_key ON public.library_settings USING btree (setting_key);

CREATE UNIQUE INDEX license_assignments_pkey ON public.license_assignments USING btree (id);

CREATE UNIQUE INDEX license_pools_pkey ON public.license_pools USING btree (id);

CREATE UNIQUE INDEX mark_entries_assessment_student_subject_key ON public.mark_entries USING btree (assessment_id, student_id, subject_id);

CREATE UNIQUE INDEX mark_entries_pkey ON public.mark_entries USING btree (id);

CREATE UNIQUE INDEX mark_entry_batches_batch_number_key ON public.mark_entry_batches USING btree (batch_number);

CREATE UNIQUE INDEX mark_entry_batches_pkey ON public.mark_entry_batches USING btree (id);

CREATE UNIQUE INDEX mark_moderation_log_pkey ON public.mark_moderation_log USING btree (id);

CREATE UNIQUE INDEX mentor_notes_pkey ON public.mentor_notes USING btree (id);

CREATE UNIQUE INDEX messages_pkey ON public.messages USING btree (id);

CREATE UNIQUE INDEX metrics_snapshots_pkey ON public.metrics_snapshots USING btree (id);

CREATE UNIQUE INDEX notifications_pkey ON public.notifications USING btree (id);

CREATE UNIQUE INDEX offers_pkey ON public.offers USING btree (id);

CREATE INDEX opportunities_duplicate_cost_inr_idx ON public.opportunities_duplicate USING btree (cost_inr);

CREATE INDEX opportunities_duplicate_created_at_idx ON public.opportunities_duplicate USING btree (created_at DESC);

CREATE INDEX opportunities_duplicate_deadline_closing_date_idx ON public.opportunities_duplicate USING btree (deadline, closing_date);

CREATE INDEX opportunities_duplicate_embedding_idx ON public.opportunities_duplicate USING hnsw (embedding extensions.vector_cosine_ops) WITH (m='16', ef_construction='64');

CREATE INDEX opportunities_duplicate_exposure_type_idx ON public.opportunities_duplicate USING btree (exposure_type);

CREATE INDEX opportunities_duplicate_is_active_posted_date_idx ON public.opportunities_duplicate USING btree (is_active, posted_date DESC) WHERE (is_active = true);

CREATE INDEX opportunities_duplicate_lower_idx ON public.opportunities_duplicate USING btree (lower(company_name));

CREATE INDEX opportunities_duplicate_lower_idx1 ON public.opportunities_duplicate USING btree (lower(job_title));

CREATE UNIQUE INDEX opportunities_duplicate_pkey ON public.opportunities_duplicate USING btree (id);

CREATE INDEX opportunities_duplicate_posted_date_idx ON public.opportunities_duplicate USING btree (posted_date DESC NULLS LAST);

CREATE INDEX opportunities_duplicate_requisition_id_idx ON public.opportunities_duplicate USING btree (requisition_id);

CREATE INDEX opportunities_duplicate_salary_range_max_salary_range_min_idx ON public.opportunities_duplicate USING btree (salary_range_max DESC, salary_range_min DESC);

CREATE INDEX opportunities_duplicate_sector_idx ON public.opportunities_duplicate USING btree (sector);

CREATE INDEX opportunities_duplicate_skills_required_idx ON public.opportunities_duplicate USING gin (skills_required);

CREATE INDEX opportunities_duplicate_to_tsvector_idx ON public.opportunities_duplicate USING gin (to_tsvector('english'::regconfig, ((((((((((COALESCE(job_title, ''::text) || ' '::text) || COALESCE(title, ''::text)) || ' '::text) || COALESCE(company_name, ''::text)) || ' '::text) || COALESCE(description, ''::text)) || ' '::text) || COALESCE(sector, ''::text)) || ' '::text) || COALESCE(exposure_type, ''::text))));

CREATE UNIQUE INDEX opportunities_id_old_unique ON public.opportunities USING btree (id_old);

CREATE UNIQUE INDEX opportunities_pkey ON public.opportunities USING btree (id);

CREATE UNIQUE INDEX opportunity_interactions_pkey ON public.opportunity_interactions USING btree (id);

CREATE UNIQUE INDEX opportunity_interactions_student_id_opportunity_id_action_key ON public.opportunity_interactions USING btree (student_id, opportunity_id, action);

CREATE UNIQUE INDEX organization_invitations_invitation_token_key ON public.organization_invitations USING btree (invitation_token);

CREATE UNIQUE INDEX organization_invitations_pkey ON public.organization_invitations USING btree (id);

CREATE UNIQUE INDEX organization_subscriptions_pkey ON public.organization_subscriptions USING btree (id);

CREATE UNIQUE INDEX organizations_code_type_unique ON public.organizations USING btree (code, organization_type) WHERE (code IS NOT NULL);

CREATE UNIQUE INDEX organizations_pkey ON public.organizations USING btree (id);

CREATE UNIQUE INDEX otp_requests_log_pkey ON public.otp_requests_log USING btree (id);

CREATE UNIQUE INDEX outcome_assessment_mappings_learning_outcome_id_assessment__key ON public.outcome_assessment_mappings USING btree (learning_outcome_id, assessment_type_id);

CREATE UNIQUE INDEX outcome_assessment_mappings_pkey ON public.outcome_assessment_mappings USING btree (id);

CREATE UNIQUE INDEX payment_transactions_pkey ON public.payment_transactions USING btree (id);

CREATE UNIQUE INDEX payment_transactions_razorpay_payment_id_key ON public.payment_transactions USING btree (razorpay_payment_id);

CREATE UNIQUE INDEX permissions_pkey ON public.permissions USING btree (name);

CREATE UNIQUE INDEX personal_assessment_response_scales_pkey ON public.personal_assessment_response_scales USING btree (id);

CREATE UNIQUE INDEX personal_assessment_response_scales_section_id_scale_name_key ON public.personal_assessment_response_scales USING btree (section_id, scale_name);

CREATE UNIQUE INDEX personal_assessment_restrictions_pkey ON public.personal_assessment_restrictions USING btree (id);

CREATE UNIQUE INDEX personal_assessment_restrictions_student_id_grade_level_key ON public.personal_assessment_restrictions USING btree (student_id, grade_level);

CREATE UNIQUE INDEX phone_otps_phone_key ON public.phone_otps USING btree (phone);

CREATE UNIQUE INDEX phone_otps_pkey ON public.phone_otps USING btree (id);

CREATE UNIQUE INDEX pipeline_activities_pkey ON public.pipeline_activities USING btree (id);

CREATE UNIQUE INDEX pipeline_candidates_opportunity_id_student_id_key ON public.pipeline_candidates USING btree (opportunity_id, student_id);

CREATE UNIQUE INDEX pipeline_candidates_pkey ON public.pipeline_candidates USING btree (id);

CREATE UNIQUE INDEX placements_pkey ON public.placements USING btree (id);

CREATE UNIQUE INDEX pre_registration_email_tracking_pkey ON public.pre_registration_email_tracking USING btree (id);

CREATE UNIQUE INDEX pre_registrations_pkey ON public.pre_registrations USING btree (id);

CREATE UNIQUE INDEX profile_views_pkey ON public.profile_views USING btree (id);

CREATE UNIQUE INDEX program_sections_pkey ON public.program_sections USING btree (id);

CREATE UNIQUE INDEX program_sections_program_id_semester_section_academic_year_key ON public.program_sections USING btree (program_id, semester, section, academic_year);

CREATE UNIQUE INDEX programs_department_id_code_key ON public.programs USING btree (department_id, code);

CREATE UNIQUE INDEX programs_pkey ON public.programs USING btree (id);

CREATE INDEX projects_embedding_idx ON public.projects USING hnsw (embedding extensions.vector_cosine_ops) WITH (m='16', ef_construction='64');

CREATE UNIQUE INDEX projects_pkey ON public.projects USING btree (id);

CREATE UNIQUE INDEX promotional_events_event_code_key ON public.promotional_events USING btree (event_code);

CREATE UNIQUE INDEX promotional_events_pkey ON public.promotional_events USING btree (id);

CREATE UNIQUE INDEX quizzes_pkey ON public.quizzes USING btree (quiz_id);

CREATE UNIQUE INDEX razorpay_orders_order_id_key ON public.razorpay_orders USING btree (order_id);

CREATE UNIQUE INDEX razorpay_orders_pkey ON public.razorpay_orders USING btree (id);

CREATE UNIQUE INDEX recent_updates_pkey ON public.recent_updates USING btree (id);

CREATE UNIQUE INDEX recruiter_activities_pkey ON public.recruiter_activities USING btree (id);

CREATE UNIQUE INDEX recruiter_saved_searches_pkey ON public.recruiter_saved_searches USING btree (id);

CREATE UNIQUE INDEX recruiters_email_key ON public.recruiters USING btree (email);

CREATE UNIQUE INDEX recruiters_pkey ON public.recruiters USING btree (id);

CREATE UNIQUE INDEX requisitions_pkey ON public.requisitions USING btree (id);

CREATE INDEX reset_tokens_email_idx ON public.reset_tokens USING btree (email);

CREATE UNIQUE INDEX reset_tokens_pkey ON public.reset_tokens USING btree (id);

CREATE INDEX reset_tokens_token_idx ON public.reset_tokens USING btree (token);

CREATE UNIQUE INDEX role_permissions_pkey ON public.role_permissions USING btree (role, permission_name);

CREATE UNIQUE INDEX roles_pkey ON public.roles USING btree (name);

CREATE UNIQUE INDEX saved_jobs_pkey ON public.saved_jobs USING btree (id);

CREATE UNIQUE INDEX school_classes_pkey ON public.school_classes USING btree (id);

CREATE UNIQUE INDEX school_classes_school_id_name_academic_year_key ON public.school_classes USING btree (school_id, name, academic_year);

CREATE UNIQUE INDEX school_educator_class_assignm_educator_id_class_id_subject__key ON public.school_educator_class_assignments USING btree (educator_id, class_id, subject, academic_year);

CREATE UNIQUE INDEX school_educator_class_assignments_pkey ON public.school_educator_class_assignments USING btree (id);

CREATE UNIQUE INDEX school_educators_pkey ON public.school_educators USING btree (id);

CREATE UNIQUE INDEX school_educators_school_id_employee_id_key ON public.school_educators USING btree (school_id, employee_id);

CREATE UNIQUE INDEX school_educators_teacher_id_key ON public.school_educators USING btree (teacher_id);

CREATE UNIQUE INDEX school_educators_user_key ON public.school_educators USING btree (user_id);

CREATE UNIQUE INDEX search_history_pkey ON public.search_history USING btree (id);

CREATE UNIQUE INDEX search_history_student_id_search_term_key ON public.search_history USING btree (student_id, search_term);

CREATE UNIQUE INDEX shortlist_candidates_pkey ON public.shortlist_candidates USING btree (id);

CREATE UNIQUE INDEX shortlist_candidates_shortlist_id_student_id_key ON public.shortlist_candidates USING btree (shortlist_id, student_id);

CREATE UNIQUE INDEX shortlists_pkey ON public.shortlists USING btree (id);

CREATE UNIQUE INDEX skill_assessments_pkey ON public.skill_assessments USING btree (id);

CREATE UNIQUE INDEX skill_badges_pkey ON public.skill_badges USING btree (badge_id);

CREATE UNIQUE INDEX skill_passports_pkey ON public.skill_passports USING btree (id);

CREATE UNIQUE INDEX "skill_passports_studentId_key" ON public.skill_passports USING btree ("studentId");

CREATE UNIQUE INDEX skill_trends_pkey ON public.skill_trends USING btree (id);

CREATE UNIQUE INDEX skill_verification_requests_pkey ON public.skill_verification_requests USING btree (id);

CREATE INDEX skills_embedding_hnsw_idx ON public.skills USING hnsw (embedding extensions.vector_cosine_ops) WITH (m='16', ef_construction='64');

CREATE UNIQUE INDEX skills_pkey ON public.skills USING btree (id);

CREATE UNIQUE INDEX streak_notification_log_pkey ON public.streak_notification_log USING btree (id);

CREATE UNIQUE INDEX stream_recommendation_reports_pkey ON public.stream_recommendation_reports USING btree (id);

CREATE UNIQUE INDEX student_assignments_pkey ON public.student_assignments USING btree (student_assignment_id);

CREATE UNIQUE INDEX student_course_progress_pkey ON public.student_course_progress USING btree (id);

CREATE UNIQUE INDEX student_course_progress_student_id_course_id_lesson_id_key ON public.student_course_progress USING btree (student_id, course_id, lesson_id);

CREATE UNIQUE INDEX student_course_recommendation_student_id_course_id_assessme_key ON public.student_course_recommendations USING btree (student_id, course_id, assessment_result_id);

CREATE UNIQUE INDEX student_course_recommendations_pkey ON public.student_course_recommendations USING btree (id);

CREATE UNIQUE INDEX student_enrollments_pkey ON public.student_enrollments USING btree (id);

CREATE UNIQUE INDEX student_enrollments_student_id_program_id_academic_year_key ON public.student_enrollments USING btree (student_id, program_id, academic_year);

CREATE UNIQUE INDEX student_job_matches_pkey ON public.student_job_matches USING btree (id);

CREATE UNIQUE INDEX student_ledgers_pkey ON public.student_ledgers USING btree (id);

CREATE UNIQUE INDEX student_management_records_enrollment_number_key ON public.student_management_records USING btree (enrollment_number);

CREATE UNIQUE INDEX student_management_records_pkey ON public.student_management_records USING btree (id);

CREATE UNIQUE INDEX student_management_records_student_id_school_id_key ON public.student_management_records USING btree (student_id, school_id);

CREATE UNIQUE INDEX student_promotions_pkey ON public.student_promotions USING btree (id);

CREATE UNIQUE INDEX student_quiz_progress_pkey ON public.student_quiz_progress USING btree (id);

CREATE UNIQUE INDEX student_quiz_progress_student_id_course_id_lesson_id_quiz_i_key ON public.student_quiz_progress USING btree (student_id, course_id, lesson_id, quiz_id, attempt_number);

CREATE UNIQUE INDEX student_reports_pkey ON public.student_reports USING btree (id);

CREATE UNIQUE INDEX student_skill_badges_pkey ON public.student_skill_badges USING btree (id);

CREATE UNIQUE INDEX student_streaks_pkey ON public.student_streaks USING btree (id);

CREATE UNIQUE INDEX student_streaks_student_id_key ON public.student_streaks USING btree (student_id);

CREATE UNIQUE INDEX students_email_key ON public.students USING btree (email);

CREATE INDEX students_embedding_idx ON public.students USING ivfflat (embedding extensions.vector_cosine_ops);

CREATE UNIQUE INDEX students_pkey ON public.students USING btree (id);

CREATE UNIQUE INDEX students_student_id_key ON public.students USING btree (student_id);

CREATE UNIQUE INDEX students_user_id_key ON public.students USING btree (user_id);

CREATE UNIQUE INDEX subscription_cancellations_pkey ON public.subscription_cancellations USING btree (id);

CREATE UNIQUE INDEX subscription_migrations_pkey ON public.subscription_migrations USING btree (id);

CREATE UNIQUE INDEX subscription_plan_features_pkey ON public.subscription_plan_features USING btree (id);

CREATE UNIQUE INDEX subscription_plan_features_unique ON public.subscription_plan_features USING btree (plan_id, category, feature_key);

CREATE UNIQUE INDEX subscription_plans_pkey ON public.subscription_plans USING btree (id);

CREATE UNIQUE INDEX subscription_plans_plan_code_business_type_entity_type_role_key ON public.subscription_plans USING btree (plan_code, business_type, entity_type, role_type);

CREATE UNIQUE INDEX subscriptions_pkey ON public.subscriptions USING btree (id);

CREATE UNIQUE INDEX subscriptions_razorpay_subscription_id_key ON public.subscriptions USING btree (razorpay_subscription_id);

CREATE UNIQUE INDEX teacher_journal_educator_id_lesson_plan_id_date_key ON public.teacher_journal USING btree (educator_id, lesson_plan_id, date);

CREATE UNIQUE INDEX teacher_journal_pkey ON public.teacher_journal USING btree (id);

CREATE UNIQUE INDEX teacher_workload_educator_id_timetable_id_key ON public.teacher_workload USING btree (educator_id, timetable_id);

CREATE UNIQUE INDEX teacher_workload_pkey ON public.teacher_workload USING btree (id);

CREATE UNIQUE INDEX timetable_conflicts_pkey ON public.timetable_conflicts USING btree (id);

CREATE UNIQUE INDEX timetable_slots_pkey ON public.timetable_slots USING btree (id);

CREATE UNIQUE INDEX timetable_slots_timetable_id_day_of_week_period_number_educ_key ON public.timetable_slots USING btree (timetable_id, day_of_week, period_number, educator_id);

CREATE UNIQUE INDEX timetables_pkey ON public.timetables USING btree (id);

CREATE UNIQUE INDEX training_notifications_pkey ON public.training_notifications USING btree (id);

CREATE INDEX trainings_embedding_idx ON public.trainings USING hnsw (embedding extensions.vector_cosine_ops) WITH (m='16', ef_construction='64');

CREATE UNIQUE INDEX trainings_pkey ON public.trainings USING btree (id);

CREATE UNIQUE INDEX transcript_requests_pkey ON public.transcript_requests USING btree (id);

CREATE UNIQUE INDEX transcript_requests_request_number_key ON public.transcript_requests USING btree (request_number);

CREATE UNIQUE INDEX transcripts_pkey ON public.transcripts USING btree (id);

CREATE UNIQUE INDEX transcripts_verification_id_key ON public.transcripts USING btree (verification_id);

CREATE UNIQUE INDEX tutor_conversations_pkey ON public.tutor_conversations USING btree (id);

CREATE UNIQUE INDEX tutor_feedback_pkey ON public.tutor_feedback USING btree (id);

CREATE UNIQUE INDEX unique_active_assignment ON public.license_assignments USING btree (user_id, organization_subscription_id) WHERE ((status)::text = 'active'::text);

CREATE UNIQUE INDEX unique_active_student_period ON public.college_mentor_student_allocations USING btree (student_id, period_id) WHERE ((status)::text = 'active'::text);

CREATE UNIQUE INDEX unique_application ON public.applied_jobs USING btree (student_id, opportunity_id);

CREATE UNIQUE INDEX unique_badge_name ON public.skill_badges USING btree (school_id, name, level);

CREATE UNIQUE INDEX unique_category_per_school ON public.library_categories_school USING btree (school_id, name);

CREATE UNIQUE INDEX unique_club_name_per_school ON public.clubs USING btree (school_id, name);

CREATE UNIQUE INDEX unique_club_session ON public.club_attendance USING btree (club_id, session_date);

CREATE UNIQUE INDEX unique_co_educator ON public.course_co_educators USING btree (course_id, educator_id);

CREATE UNIQUE INDEX unique_college_academic_year ON public.college_timetables USING btree (college_id, academic_year);

CREATE UNIQUE INDEX unique_comp_club ON public.competition_clubs USING btree (comp_id, club_id);

CREATE UNIQUE INDEX unique_course_class ON public.course_classes USING btree (course_id, class_name);

CREATE UNIQUE INDEX unique_course_code_per_college ON public.college_courses USING btree (college_id, course_code);

CREATE UNIQUE INDEX unique_course_program_semester ON public.college_course_mappings USING btree (course_id, program_id, semester);

CREATE UNIQUE INDEX unique_course_skill ON public.course_skills USING btree (course_id, skill_name);

CREATE UNIQUE INDEX unique_curriculum_per_course_year ON public.college_curriculums USING btree (course_id, academic_year, program_id);

CREATE UNIQUE INDEX unique_isbn_per_school ON public.library_books_school USING btree (school_id, isbn);

CREATE UNIQUE INDEX unique_saved_job ON public.saved_jobs USING btree (student_id, opportunity_id);

CREATE UNIQUE INDEX unique_sequence_per_session ON public.adaptive_aptitude_responses USING btree (session_id, sequence_number);

CREATE UNIQUE INDEX unique_setting_per_school ON public.library_settings_school USING btree (school_id, setting_key);

CREATE UNIQUE INDEX unique_student_academic_year ON public.student_promotions USING btree (student_id, academic_year);

CREATE UNIQUE INDEX unique_student_badge ON public.student_skill_badges USING btree (badge_id, student_email);

CREATE UNIQUE INDEX unique_student_club ON public.club_memberships USING btree (club_id, student_email);

CREATE UNIQUE INDEX unique_student_comp_result ON public.competition_results USING btree (comp_id, student_email, category);

CREATE UNIQUE INDEX unique_student_competition ON public.competition_registrations USING btree (comp_id, student_email);

CREATE UNIQUE INDEX unique_student_id ON public.recent_updates USING btree (student_id);

CREATE UNIQUE INDEX unique_student_job_matches ON public.student_job_matches USING btree (student_id);

CREATE UNIQUE INDEX unique_student_session ON public.club_attendance_records USING btree (attendance_id, student_email);

CREATE UNIQUE INDEX unique_text_hash_type ON public.embedding_cache USING btree (text_hash, cache_type);

CREATE UNIQUE INDEX university_colleges_pkey ON public.university_colleges USING btree (id);

CREATE UNIQUE INDEX university_colleges_university_id_code_key ON public.university_colleges USING btree (university_id, code);

CREATE UNIQUE INDEX university_courses_pkey ON public.university_courses USING btree (id);

CREATE INDEX university_courses_university_id_idx ON public.university_courses USING btree (university_id);

CREATE UNIQUE INDEX university_performance_pkey ON public.university_performance USING btree (id);

CREATE UNIQUE INDEX uq_college_student_assignment ON public.college_student_assignments USING btree (assignment_id, student_id);

CREATE UNIQUE INDEX uq_student_assignment ON public.student_assignments USING btree (assignment_id, student_id);

CREATE UNIQUE INDEX user_categories_name_key ON public.user_categories USING btree (name);

CREATE UNIQUE INDEX user_categories_pkey ON public.user_categories USING btree (id);

CREATE UNIQUE INDEX user_entitlements_pkey ON public.user_entitlements USING btree (id);

CREATE UNIQUE INDEX user_login_history_pkey ON public.user_login_history USING btree (id);

CREATE UNIQUE INDEX user_profiles_pkey ON public.user_profiles USING btree (id);

CREATE UNIQUE INDEX user_profiles_user_id_key ON public.user_profiles USING btree (user_id);

CREATE UNIQUE INDEX user_sessions_pkey ON public.user_sessions USING btree (id);

CREATE UNIQUE INDEX user_settings_pkey ON public.user_settings USING btree (id);

CREATE UNIQUE INDEX user_settings_user_id_key ON public.user_settings USING btree (user_id);

CREATE UNIQUE INDEX user_state_history_pkey ON public.user_state_history USING btree (id);

CREATE UNIQUE INDEX users_email_key ON public.users USING btree (email);

CREATE UNIQUE INDEX users_pkey ON public.users USING btree (id);

CREATE UNIQUE INDEX ux_event_registrations_email_lowercase ON public.event_registrations USING btree (lower((email)::text));

CREATE UNIQUE INDEX verifications_pkey ON public.verifications USING btree (id);

CREATE UNIQUE INDEX video_summaries_pkey ON public.video_summaries USING btree (id);

alter table "public"."adaptive_aptitude_questions_cache" add constraint "adaptive_aptitude_questions_cache_pkey" PRIMARY KEY using index "adaptive_aptitude_questions_cache_pkey";

alter table "public"."adaptive_aptitude_responses" add constraint "adaptive_aptitude_responses_pkey" PRIMARY KEY using index "adaptive_aptitude_responses_pkey";

alter table "public"."adaptive_aptitude_results" add constraint "adaptive_aptitude_results_pkey" PRIMARY KEY using index "adaptive_aptitude_results_pkey";

alter table "public"."adaptive_aptitude_sessions" add constraint "adaptive_aptitude_sessions_pkey" PRIMARY KEY using index "adaptive_aptitude_sessions_pkey";

alter table "public"."addon_discount_codes" add constraint "addon_discount_codes_pkey" PRIMARY KEY using index "addon_discount_codes_pkey";

alter table "public"."addon_events" add constraint "addon_events_pkey" PRIMARY KEY using index "addon_events_pkey";

alter table "public"."addon_pending_orders" add constraint "addon_pending_orders_pkey" PRIMARY KEY using index "addon_pending_orders_pkey";

alter table "public"."admin_users" add constraint "admin_users_pkey" PRIMARY KEY using index "admin_users_pkey";

alter table "public"."admission_applications" add constraint "admission_applications_pkey" PRIMARY KEY using index "admission_applications_pkey";

alter table "public"."ai_evaluations" add constraint "ai_evaluations_pkey" PRIMARY KEY using index "ai_evaluations_pkey";

alter table "public"."app_config" add constraint "app_config_pkey" PRIMARY KEY using index "app_config_pkey";

alter table "public"."applied_jobs" add constraint "applied_jobs_pkey" PRIMARY KEY using index "applied_jobs_pkey";

alter table "public"."approval_actions" add constraint "approval_actions_pkey" PRIMARY KEY using index "approval_actions_pkey";

alter table "public"."approval_requests" add constraint "approval_requests_pkey" PRIMARY KEY using index "approval_requests_pkey";

alter table "public"."approval_types" add constraint "approval_types_pkey" PRIMARY KEY using index "approval_types_pkey";

alter table "public"."approval_workflows" add constraint "approval_workflows_pkey" PRIMARY KEY using index "approval_workflows_pkey";

alter table "public"."assessment_types" add constraint "assessment_types_pkey" PRIMARY KEY using index "assessment_types_pkey";

alter table "public"."assessments" add constraint "assessments_pkey" PRIMARY KEY using index "assessments_pkey";

alter table "public"."assignment_attachments" add constraint "assignment_attachments_pkey" PRIMARY KEY using index "assignment_attachments_pkey";

alter table "public"."assignments" add constraint "assignments_pkey" PRIMARY KEY using index "assignments_pkey";

alter table "public"."attendance_alerts" add constraint "attendance_alerts_pkey" PRIMARY KEY using index "attendance_alerts_pkey";

alter table "public"."attendance_records" add constraint "attendance_records_pkey" PRIMARY KEY using index "attendance_records_pkey";

alter table "public"."audit_logs" add constraint "audit_logs_pkey" PRIMARY KEY using index "audit_logs_pkey";

alter table "public"."budget_alerts" add constraint "budget_alerts_pkey" PRIMARY KEY using index "budget_alerts_pkey";

alter table "public"."budget_revisions" add constraint "budget_revisions_pkey" PRIMARY KEY using index "budget_revisions_pkey";

alter table "public"."bundle_features" add constraint "bundle_features_pkey" PRIMARY KEY using index "bundle_features_pkey";

alter table "public"."bundles" add constraint "bundles_pkey" PRIMARY KEY using index "bundles_pkey";

alter table "public"."career_ai_conversations" add constraint "career_ai_conversations_pkey" PRIMARY KEY using index "career_ai_conversations_pkey";

alter table "public"."career_assessment_ai_questions" add constraint "career_assessment_ai_questions_pkey" PRIMARY KEY using index "career_assessment_ai_questions_pkey";

alter table "public"."certificates" add constraint "certificates_pkey" PRIMARY KEY using index "certificates_pkey";

alter table "public"."class_swap_history" add constraint "class_swap_history_pkey" PRIMARY KEY using index "class_swap_history_pkey";

alter table "public"."class_swap_requests" add constraint "class_swap_requests_pkey" PRIMARY KEY using index "class_swap_requests_pkey";

alter table "public"."club_activities" add constraint "club_activities_pkey" PRIMARY KEY using index "club_activities_pkey";

alter table "public"."club_attendance" add constraint "club_attendance_pkey" PRIMARY KEY using index "club_attendance_pkey";

alter table "public"."club_attendance_records" add constraint "club_attendance_records_pkey" PRIMARY KEY using index "club_attendance_records_pkey";

alter table "public"."club_certificates" add constraint "club_certificates_pkey" PRIMARY KEY using index "club_certificates_pkey";

alter table "public"."club_memberships" add constraint "club_memberships_pkey" PRIMARY KEY using index "club_memberships_pkey";

alter table "public"."clubs" add constraint "clubs_pkey" PRIMARY KEY using index "clubs_pkey";

alter table "public"."college_assignment_attachments" add constraint "college_assignment_attachments_pkey" PRIMARY KEY using index "college_assignment_attachments_pkey";

alter table "public"."college_assignments" add constraint "college_assignments_pkey" PRIMARY KEY using index "college_assignments_pkey";

alter table "public"."college_attendance_records" add constraint "college_attendance_records_pkey" PRIMARY KEY using index "college_attendance_records_pkey";

alter table "public"."college_attendance_sessions" add constraint "college_attendance_sessions_pkey" PRIMARY KEY using index "college_attendance_sessions_pkey";

alter table "public"."college_attendance_settings" add constraint "college_attendance_settings_pkey" PRIMARY KEY using index "college_attendance_settings_pkey";

alter table "public"."college_breaks" add constraint "college_breaks_pkey" PRIMARY KEY using index "college_breaks_pkey";

alter table "public"."college_circulars" add constraint "college_circulars_pkey" PRIMARY KEY using index "college_circulars_pkey";

alter table "public"."college_classes" add constraint "college_classes_pkey" PRIMARY KEY using index "college_classes_pkey";

alter table "public"."college_course_mappings" add constraint "college_course_mappings_pkey" PRIMARY KEY using index "college_course_mappings_pkey";

alter table "public"."college_courses" add constraint "college_courses_pkey" PRIMARY KEY using index "college_courses_pkey";

alter table "public"."college_curriculum_outcomes" add constraint "college_curriculum_outcomes_pkey" PRIMARY KEY using index "college_curriculum_outcomes_pkey";

alter table "public"."college_curriculum_units" add constraint "college_curriculum_units_pkey" PRIMARY KEY using index "college_curriculum_units_pkey";

alter table "public"."college_curriculums" add constraint "college_curriculums_pkey" PRIMARY KEY using index "college_curriculums_pkey";

alter table "public"."college_event_registrations" add constraint "college_event_registrations_pkey" PRIMARY KEY using index "college_event_registrations_pkey";

alter table "public"."college_events" add constraint "college_events_pkey" PRIMARY KEY using index "college_events_pkey";

alter table "public"."college_faculty_class_assignments" add constraint "college_faculty_class_assignments_pkey" PRIMARY KEY using index "college_faculty_class_assignments_pkey";

alter table "public"."college_faculty_leave_balances" add constraint "college_faculty_leave_balances_pkey" PRIMARY KEY using index "college_faculty_leave_balances_pkey";

alter table "public"."college_faculty_leaves" add constraint "college_faculty_leaves_pkey" PRIMARY KEY using index "college_faculty_leaves_pkey";

alter table "public"."college_faculty_substitutions" add constraint "college_faculty_substitutions_pkey" PRIMARY KEY using index "college_faculty_substitutions_pkey";

alter table "public"."college_leave_types" add constraint "college_leave_types_pkey" PRIMARY KEY using index "college_leave_types_pkey";

alter table "public"."college_lecturers" add constraint "college_lecturers_pkey" PRIMARY KEY using index "college_lecturers_pkey";

alter table "public"."college_lesson_plans" add constraint "college_lesson_plans_pkey" PRIMARY KEY using index "college_lesson_plans_pkey";

alter table "public"."college_mentor_notes" add constraint "college_mentor_notes_pkey" PRIMARY KEY using index "college_mentor_notes_pkey";

alter table "public"."college_mentor_periods" add constraint "college_mentor_periods_pkey" PRIMARY KEY using index "college_mentor_periods_pkey";

alter table "public"."college_mentor_student_allocations" add constraint "college_mentor_student_allocations_pkey" PRIMARY KEY using index "college_mentor_student_allocations_pkey";

alter table "public"."college_role_module_permissions" add constraint "college_role_module_permissions_pkey" PRIMARY KEY using index "college_role_module_permissions_pkey";

alter table "public"."college_role_scope_rules" add constraint "college_role_scope_rules_pkey" PRIMARY KEY using index "college_role_scope_rules_pkey";

alter table "public"."college_setting_modules" add constraint "college_setting_modules_pkey" PRIMARY KEY using index "college_setting_modules_pkey";

alter table "public"."college_setting_permissions" add constraint "college_setting_permissions_pkey" PRIMARY KEY using index "college_setting_permissions_pkey";

alter table "public"."college_student_assignments" add constraint "college_student_assignments_pkey" PRIMARY KEY using index "college_student_assignments_pkey";

alter table "public"."college_time_periods" add constraint "college_time_periods_pkey" PRIMARY KEY using index "college_time_periods_pkey";

alter table "public"."college_timetable_slots" add constraint "college_timetable_slots_pkey" PRIMARY KEY using index "college_timetable_slots_pkey";

alter table "public"."college_timetables" add constraint "college_timetables_pkey" PRIMARY KEY using index "college_timetables_pkey";

alter table "public"."companies" add constraint "companies_pkey" PRIMARY KEY using index "companies_pkey";

alter table "public"."competition_clubs" add constraint "competition_clubs_pkey" PRIMARY KEY using index "competition_clubs_pkey";

alter table "public"."competition_registrations" add constraint "competition_registrations_pkey" PRIMARY KEY using index "competition_registrations_pkey";

alter table "public"."competition_results" add constraint "competition_results_pkey" PRIMARY KEY using index "competition_results_pkey";

alter table "public"."competitions" add constraint "competitions_pkey" PRIMARY KEY using index "competitions_pkey";

alter table "public"."conversations" add constraint "conversations_pkey" PRIMARY KEY using index "conversations_pkey";

alter table "public"."course_classes" add constraint "course_classes_pkey" PRIMARY KEY using index "course_classes_pkey";

alter table "public"."course_co_educators" add constraint "course_co_educators_pkey" PRIMARY KEY using index "course_co_educators_pkey";

alter table "public"."course_enrollments" add constraint "course_enrollments_pkey" PRIMARY KEY using index "course_enrollments_pkey";

alter table "public"."course_modules" add constraint "course_modules_pkey" PRIMARY KEY using index "course_modules_pkey";

alter table "public"."course_skills" add constraint "course_skills_pkey" PRIMARY KEY using index "course_skills_pkey";

alter table "public"."courses" add constraint "courses_pkey" PRIMARY KEY using index "courses_pkey";

alter table "public"."curriculum_academic_years" add constraint "curriculum_academic_years_pkey" PRIMARY KEY using index "curriculum_academic_years_pkey";

alter table "public"."curriculum_chapters" add constraint "curriculum_chapters_pkey" PRIMARY KEY using index "curriculum_chapters_pkey";

alter table "public"."curriculum_classes" add constraint "curriculum_classes_pkey" PRIMARY KEY using index "curriculum_classes_pkey";

alter table "public"."curriculum_courses" add constraint "curriculum_courses_pkey" PRIMARY KEY using index "curriculum_courses_pkey";

alter table "public"."curriculum_learning_outcomes" add constraint "curriculum_learning_outcomes_pkey" PRIMARY KEY using index "curriculum_learning_outcomes_pkey";

alter table "public"."curriculum_subjects" add constraint "curriculum_subjects_pkey" PRIMARY KEY using index "curriculum_subjects_pkey";

alter table "public"."curriculums" add constraint "curriculums_pkey" PRIMARY KEY using index "curriculums_pkey";

alter table "public"."department_budgets" add constraint "department_budgets_pkey" PRIMARY KEY using index "department_budgets_pkey";

alter table "public"."department_faculty_assignments" add constraint "department_faculty_assignments_pkey" PRIMARY KEY using index "department_faculty_assignments_pkey";

alter table "public"."departments" add constraint "departments_pkey" PRIMARY KEY using index "departments_pkey";

alter table "public"."document_access_history" add constraint "document_access_history_pkey" PRIMARY KEY using index "document_access_history_pkey";

alter table "public"."education" add constraint "education_pkey" PRIMARY KEY using index "education_pkey";

alter table "public"."embedding_cache" add constraint "embedding_cache_pkey" PRIMARY KEY using index "embedding_cache_pkey";

alter table "public"."embedding_queue" add constraint "embedding_queue_pkey" PRIMARY KEY using index "embedding_queue_pkey";

alter table "public"."event_registrations" add constraint "event_registrations_pkey" PRIMARY KEY using index "event_registrations_pkey";

alter table "public"."exam_registrations" add constraint "exam_registrations_pkey" PRIMARY KEY using index "exam_registrations_pkey";

alter table "public"."exam_rooms" add constraint "exam_rooms_pkey" PRIMARY KEY using index "exam_rooms_pkey";

alter table "public"."exam_seating_arrangements" add constraint "exam_seating_arrangements_pkey" PRIMARY KEY using index "exam_seating_arrangements_pkey";

alter table "public"."exam_timetable" add constraint "exam_timetable_pkey" PRIMARY KEY using index "exam_timetable_pkey";

alter table "public"."exam_windows" add constraint "exam_windows_pkey" PRIMARY KEY using index "exam_windows_pkey";

alter table "public"."expenditures" add constraint "expenditures_pkey" PRIMARY KEY using index "expenditures_pkey";

alter table "public"."experience" add constraint "experience_pkey" PRIMARY KEY using index "experience_pkey";

alter table "public"."export_activities" add constraint "export_activities_pkey" PRIMARY KEY using index "export_activities_pkey";

alter table "public"."external_assessment_attempts" add constraint "external_assessment_attempts_pkey" PRIMARY KEY using index "external_assessment_attempts_pkey";

alter table "public"."external_courses" add constraint "external_courses_pkey" PRIMARY KEY using index "external_courses_pkey";

alter table "public"."fee_payments" add constraint "fee_payments_pkey" PRIMARY KEY using index "fee_payments_pkey";

alter table "public"."fee_structures" add constraint "fee_structures_pkey" PRIMARY KEY using index "fee_structures_pkey";

alter table "public"."generated_external_assessment" add constraint "generated_external_assessment_pkey" PRIMARY KEY using index "generated_external_assessment_pkey";

alter table "public"."grading_systems" add constraint "grading_systems_pkey" PRIMARY KEY using index "grading_systems_pkey";

alter table "public"."institution_pricing_tiers" add constraint "institution_pricing_tiers_pkey" PRIMARY KEY using index "institution_pricing_tiers_pkey";

alter table "public"."internships" add constraint "internships_pkey" PRIMARY KEY using index "internships_pkey";

alter table "public"."interview_reminders" add constraint "interview_reminders_pkey" PRIMARY KEY using index "interview_reminders_pkey";

alter table "public"."interviews" add constraint "interviews_pkey" PRIMARY KEY using index "interviews_pkey";

alter table "public"."invigilator_assignments" add constraint "invigilator_assignments_pkey" PRIMARY KEY using index "invigilator_assignments_pkey";

alter table "public"."lesson_plans" add constraint "lesson_plans_pkey" PRIMARY KEY using index "lesson_plans_pkey";

alter table "public"."lesson_resources" add constraint "lesson_resources_pkey" PRIMARY KEY using index "lesson_resources_pkey";

alter table "public"."lessons" add constraint "lessons_pkey" PRIMARY KEY using index "lessons_pkey";

alter table "public"."library_book_issues" add constraint "library_book_issues_pkey" PRIMARY KEY using index "library_book_issues_pkey";

alter table "public"."library_book_issues_college" add constraint "library_book_issues_college_pkey" PRIMARY KEY using index "library_book_issues_college_pkey";

alter table "public"."library_book_issues_school" add constraint "library_book_issues_school_pkey" PRIMARY KEY using index "library_book_issues_school_pkey";

alter table "public"."library_books" add constraint "library_books_pkey" PRIMARY KEY using index "library_books_pkey";

alter table "public"."library_books_college" add constraint "library_books_college_pkey" PRIMARY KEY using index "library_books_college_pkey";

alter table "public"."library_books_school" add constraint "library_books_school_pkey" PRIMARY KEY using index "library_books_school_pkey";

alter table "public"."library_categories" add constraint "library_categories_pkey" PRIMARY KEY using index "library_categories_pkey";

alter table "public"."library_categories_college" add constraint "library_categories_college_pkey" PRIMARY KEY using index "library_categories_college_pkey";

alter table "public"."library_categories_school" add constraint "library_categories_school_pkey" PRIMARY KEY using index "library_categories_school_pkey";

alter table "public"."library_history" add constraint "library_history_pkey" PRIMARY KEY using index "library_history_pkey";

alter table "public"."library_issued_books" add constraint "library_issued_books_pkey" PRIMARY KEY using index "library_issued_books_pkey";

alter table "public"."library_reservations" add constraint "library_reservations_pkey" PRIMARY KEY using index "library_reservations_pkey";

alter table "public"."library_reviews" add constraint "library_reviews_pkey" PRIMARY KEY using index "library_reviews_pkey";

alter table "public"."library_settings" add constraint "library_settings_pkey" PRIMARY KEY using index "library_settings_pkey";

alter table "public"."library_settings_college" add constraint "library_settings_college_pkey" PRIMARY KEY using index "library_settings_college_pkey";

alter table "public"."library_settings_school" add constraint "library_settings_school_pkey" PRIMARY KEY using index "library_settings_school_pkey";

alter table "public"."license_assignments" add constraint "license_assignments_pkey" PRIMARY KEY using index "license_assignments_pkey";

alter table "public"."license_pools" add constraint "license_pools_pkey" PRIMARY KEY using index "license_pools_pkey";

alter table "public"."mark_entries" add constraint "mark_entries_pkey" PRIMARY KEY using index "mark_entries_pkey";

alter table "public"."mark_entry_batches" add constraint "mark_entry_batches_pkey" PRIMARY KEY using index "mark_entry_batches_pkey";

alter table "public"."mark_moderation_log" add constraint "mark_moderation_log_pkey" PRIMARY KEY using index "mark_moderation_log_pkey";

alter table "public"."mentor_notes" add constraint "mentor_notes_pkey" PRIMARY KEY using index "mentor_notes_pkey";

alter table "public"."messages" add constraint "messages_pkey" PRIMARY KEY using index "messages_pkey";

alter table "public"."metrics_snapshots" add constraint "metrics_snapshots_pkey" PRIMARY KEY using index "metrics_snapshots_pkey";

alter table "public"."notifications" add constraint "notifications_pkey" PRIMARY KEY using index "notifications_pkey";

alter table "public"."offers" add constraint "offers_pkey" PRIMARY KEY using index "offers_pkey";

alter table "public"."opportunities" add constraint "opportunities_pkey" PRIMARY KEY using index "opportunities_pkey";

alter table "public"."opportunities_duplicate" add constraint "opportunities_duplicate_pkey" PRIMARY KEY using index "opportunities_duplicate_pkey";

alter table "public"."opportunity_interactions" add constraint "opportunity_interactions_pkey" PRIMARY KEY using index "opportunity_interactions_pkey";

alter table "public"."organization_invitations" add constraint "organization_invitations_pkey" PRIMARY KEY using index "organization_invitations_pkey";

alter table "public"."organization_subscriptions" add constraint "organization_subscriptions_pkey" PRIMARY KEY using index "organization_subscriptions_pkey";

alter table "public"."organizations" add constraint "organizations_pkey" PRIMARY KEY using index "organizations_pkey";

alter table "public"."otp_requests_log" add constraint "otp_requests_log_pkey" PRIMARY KEY using index "otp_requests_log_pkey";

alter table "public"."outcome_assessment_mappings" add constraint "outcome_assessment_mappings_pkey" PRIMARY KEY using index "outcome_assessment_mappings_pkey";

alter table "public"."payment_transactions" add constraint "payment_transactions_pkey" PRIMARY KEY using index "payment_transactions_pkey";

alter table "public"."permissions" add constraint "permissions_pkey" PRIMARY KEY using index "permissions_pkey";

alter table "public"."personal_assessment_attempts" add constraint "assessment_attempts_pkey" PRIMARY KEY using index "assessment_attempts_pkey";

alter table "public"."personal_assessment_questions" add constraint "assessment_questions_pkey" PRIMARY KEY using index "assessment_questions_pkey";

alter table "public"."personal_assessment_response_scales" add constraint "personal_assessment_response_scales_pkey" PRIMARY KEY using index "personal_assessment_response_scales_pkey";

alter table "public"."personal_assessment_responses" add constraint "assessment_responses_pkey" PRIMARY KEY using index "assessment_responses_pkey";

alter table "public"."personal_assessment_restrictions" add constraint "personal_assessment_restrictions_pkey" PRIMARY KEY using index "personal_assessment_restrictions_pkey";

alter table "public"."personal_assessment_results" add constraint "assessment_results_pkey" PRIMARY KEY using index "assessment_results_pkey";

alter table "public"."personal_assessment_sections" add constraint "assessment_sections_pkey" PRIMARY KEY using index "assessment_sections_pkey";

alter table "public"."personal_assessment_streams" add constraint "assessment_streams_pkey" PRIMARY KEY using index "assessment_streams_pkey";

alter table "public"."phone_otps" add constraint "phone_otps_pkey" PRIMARY KEY using index "phone_otps_pkey";

alter table "public"."pipeline_activities" add constraint "pipeline_activities_pkey" PRIMARY KEY using index "pipeline_activities_pkey";

alter table "public"."pipeline_candidates" add constraint "pipeline_candidates_pkey" PRIMARY KEY using index "pipeline_candidates_pkey";

alter table "public"."placements" add constraint "placements_pkey" PRIMARY KEY using index "placements_pkey";

alter table "public"."pre_registration_email_tracking" add constraint "pre_registration_email_tracking_pkey" PRIMARY KEY using index "pre_registration_email_tracking_pkey";

alter table "public"."pre_registrations" add constraint "pre_registrations_pkey" PRIMARY KEY using index "pre_registrations_pkey";

alter table "public"."profile_views" add constraint "profile_views_pkey" PRIMARY KEY using index "profile_views_pkey";

alter table "public"."program_sections" add constraint "program_sections_pkey" PRIMARY KEY using index "program_sections_pkey";

alter table "public"."programs" add constraint "programs_pkey" PRIMARY KEY using index "programs_pkey";

alter table "public"."projects" add constraint "projects_pkey" PRIMARY KEY using index "projects_pkey";

alter table "public"."promotional_events" add constraint "promotional_events_pkey" PRIMARY KEY using index "promotional_events_pkey";

alter table "public"."quizzes" add constraint "quizzes_pkey" PRIMARY KEY using index "quizzes_pkey";

alter table "public"."razorpay_orders" add constraint "razorpay_orders_pkey" PRIMARY KEY using index "razorpay_orders_pkey";

alter table "public"."recent_updates" add constraint "recent_updates_pkey" PRIMARY KEY using index "recent_updates_pkey";

alter table "public"."recruiter_activities" add constraint "recruiter_activities_pkey" PRIMARY KEY using index "recruiter_activities_pkey";

alter table "public"."recruiter_saved_searches" add constraint "recruiter_saved_searches_pkey" PRIMARY KEY using index "recruiter_saved_searches_pkey";

alter table "public"."recruiters" add constraint "recruiters_pkey" PRIMARY KEY using index "recruiters_pkey";

alter table "public"."requisitions" add constraint "requisitions_pkey" PRIMARY KEY using index "requisitions_pkey";

alter table "public"."reset_tokens" add constraint "reset_tokens_pkey" PRIMARY KEY using index "reset_tokens_pkey";

alter table "public"."role_permissions" add constraint "role_permissions_pkey" PRIMARY KEY using index "role_permissions_pkey";

alter table "public"."roles" add constraint "roles_pkey" PRIMARY KEY using index "roles_pkey";

alter table "public"."saved_jobs" add constraint "saved_jobs_pkey" PRIMARY KEY using index "saved_jobs_pkey";

alter table "public"."school_classes" add constraint "school_classes_pkey" PRIMARY KEY using index "school_classes_pkey";

alter table "public"."school_educator_class_assignments" add constraint "school_educator_class_assignments_pkey" PRIMARY KEY using index "school_educator_class_assignments_pkey";

alter table "public"."school_educators" add constraint "school_educators_pkey" PRIMARY KEY using index "school_educators_pkey";

alter table "public"."search_history" add constraint "search_history_pkey" PRIMARY KEY using index "search_history_pkey";

alter table "public"."shortlist_candidates" add constraint "shortlist_candidates_pkey" PRIMARY KEY using index "shortlist_candidates_pkey";

alter table "public"."shortlists" add constraint "shortlists_pkey" PRIMARY KEY using index "shortlists_pkey";

alter table "public"."skill_assessments" add constraint "skill_assessments_pkey" PRIMARY KEY using index "skill_assessments_pkey";

alter table "public"."skill_badges" add constraint "skill_badges_pkey" PRIMARY KEY using index "skill_badges_pkey";

alter table "public"."skill_passports" add constraint "skill_passports_pkey" PRIMARY KEY using index "skill_passports_pkey";

alter table "public"."skill_trends" add constraint "skill_trends_pkey" PRIMARY KEY using index "skill_trends_pkey";

alter table "public"."skill_verification_requests" add constraint "skill_verification_requests_pkey" PRIMARY KEY using index "skill_verification_requests_pkey";

alter table "public"."skills" add constraint "skills_pkey" PRIMARY KEY using index "skills_pkey";

alter table "public"."streak_notification_log" add constraint "streak_notification_log_pkey" PRIMARY KEY using index "streak_notification_log_pkey";

alter table "public"."stream_recommendation_reports" add constraint "stream_recommendation_reports_pkey" PRIMARY KEY using index "stream_recommendation_reports_pkey";

alter table "public"."student_assignments" add constraint "student_assignments_pkey" PRIMARY KEY using index "student_assignments_pkey";

alter table "public"."student_course_progress" add constraint "student_course_progress_pkey" PRIMARY KEY using index "student_course_progress_pkey";

alter table "public"."student_course_recommendations" add constraint "student_course_recommendations_pkey" PRIMARY KEY using index "student_course_recommendations_pkey";

alter table "public"."student_enrollments" add constraint "student_enrollments_pkey" PRIMARY KEY using index "student_enrollments_pkey";

alter table "public"."student_job_matches" add constraint "student_job_matches_pkey" PRIMARY KEY using index "student_job_matches_pkey";

alter table "public"."student_ledgers" add constraint "student_ledgers_pkey" PRIMARY KEY using index "student_ledgers_pkey";

alter table "public"."student_management_records" add constraint "student_management_records_pkey" PRIMARY KEY using index "student_management_records_pkey";

alter table "public"."student_promotions" add constraint "student_promotions_pkey" PRIMARY KEY using index "student_promotions_pkey";

alter table "public"."student_quiz_progress" add constraint "student_quiz_progress_pkey" PRIMARY KEY using index "student_quiz_progress_pkey";

alter table "public"."student_reports" add constraint "student_reports_pkey" PRIMARY KEY using index "student_reports_pkey";

alter table "public"."student_skill_badges" add constraint "student_skill_badges_pkey" PRIMARY KEY using index "student_skill_badges_pkey";

alter table "public"."student_streaks" add constraint "student_streaks_pkey" PRIMARY KEY using index "student_streaks_pkey";

alter table "public"."students" add constraint "students_pkey" PRIMARY KEY using index "students_pkey";

alter table "public"."subscription_cancellations" add constraint "subscription_cancellations_pkey" PRIMARY KEY using index "subscription_cancellations_pkey";

alter table "public"."subscription_migrations" add constraint "subscription_migrations_pkey" PRIMARY KEY using index "subscription_migrations_pkey";

alter table "public"."subscription_plan_features" add constraint "subscription_plan_features_pkey" PRIMARY KEY using index "subscription_plan_features_pkey";

alter table "public"."subscription_plans" add constraint "subscription_plans_pkey" PRIMARY KEY using index "subscription_plans_pkey";

alter table "public"."subscriptions" add constraint "subscriptions_pkey" PRIMARY KEY using index "subscriptions_pkey";

alter table "public"."teacher_journal" add constraint "teacher_journal_pkey" PRIMARY KEY using index "teacher_journal_pkey";

alter table "public"."teacher_workload" add constraint "teacher_workload_pkey" PRIMARY KEY using index "teacher_workload_pkey";

alter table "public"."timetable_conflicts" add constraint "timetable_conflicts_pkey" PRIMARY KEY using index "timetable_conflicts_pkey";

alter table "public"."timetable_slots" add constraint "timetable_slots_pkey" PRIMARY KEY using index "timetable_slots_pkey";

alter table "public"."timetables" add constraint "timetables_pkey" PRIMARY KEY using index "timetables_pkey";

alter table "public"."training_notifications" add constraint "training_notifications_pkey" PRIMARY KEY using index "training_notifications_pkey";

alter table "public"."trainings" add constraint "trainings_pkey" PRIMARY KEY using index "trainings_pkey";

alter table "public"."transcript_requests" add constraint "transcript_requests_pkey" PRIMARY KEY using index "transcript_requests_pkey";

alter table "public"."transcripts" add constraint "transcripts_pkey" PRIMARY KEY using index "transcripts_pkey";

alter table "public"."tutor_conversations" add constraint "tutor_conversations_pkey" PRIMARY KEY using index "tutor_conversations_pkey";

alter table "public"."tutor_feedback" add constraint "tutor_feedback_pkey" PRIMARY KEY using index "tutor_feedback_pkey";

alter table "public"."university_colleges" add constraint "university_colleges_pkey" PRIMARY KEY using index "university_colleges_pkey";

alter table "public"."university_courses" add constraint "university_courses_pkey" PRIMARY KEY using index "university_courses_pkey";

alter table "public"."university_performance" add constraint "university_performance_pkey" PRIMARY KEY using index "university_performance_pkey";

alter table "public"."user_categories" add constraint "user_categories_pkey" PRIMARY KEY using index "user_categories_pkey";

alter table "public"."user_entitlements" add constraint "user_entitlements_pkey" PRIMARY KEY using index "user_entitlements_pkey";

alter table "public"."user_login_history" add constraint "user_login_history_pkey" PRIMARY KEY using index "user_login_history_pkey";

alter table "public"."user_profiles" add constraint "user_profiles_pkey" PRIMARY KEY using index "user_profiles_pkey";

alter table "public"."user_sessions" add constraint "user_sessions_pkey" PRIMARY KEY using index "user_sessions_pkey";

alter table "public"."user_settings" add constraint "user_settings_pkey" PRIMARY KEY using index "user_settings_pkey";

alter table "public"."user_state_history" add constraint "user_state_history_pkey" PRIMARY KEY using index "user_state_history_pkey";

alter table "public"."users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."verifications" add constraint "verifications_pkey" PRIMARY KEY using index "verifications_pkey";

alter table "public"."video_summaries" add constraint "video_summaries_pkey" PRIMARY KEY using index "video_summaries_pkey";

alter table "public"."adaptive_aptitude_questions_cache" add constraint "adaptive_aptitude_questions_cache_correct_answer_check" CHECK ((correct_answer = ANY (ARRAY['A'::bpchar, 'B'::bpchar, 'C'::bpchar, 'D'::bpchar]))) not valid;

alter table "public"."adaptive_aptitude_questions_cache" validate constraint "adaptive_aptitude_questions_cache_correct_answer_check";

alter table "public"."adaptive_aptitude_questions_cache" add constraint "adaptive_aptitude_questions_cache_difficulty_check" CHECK (((difficulty >= 1) AND (difficulty <= 5))) not valid;

alter table "public"."adaptive_aptitude_questions_cache" validate constraint "adaptive_aptitude_questions_cache_difficulty_check";

alter table "public"."adaptive_aptitude_questions_cache" add constraint "adaptive_aptitude_questions_cache_question_id_key" UNIQUE using index "adaptive_aptitude_questions_cache_question_id_key";

alter table "public"."adaptive_aptitude_questions_cache" add constraint "valid_options" CHECK (((options ? 'A'::text) AND (options ? 'B'::text) AND (options ? 'C'::text) AND (options ? 'D'::text))) not valid;

alter table "public"."adaptive_aptitude_questions_cache" validate constraint "valid_options";

alter table "public"."adaptive_aptitude_responses" add constraint "adaptive_aptitude_responses_difficulty_at_time_check" CHECK (((difficulty_at_time >= 1) AND (difficulty_at_time <= 5))) not valid;

alter table "public"."adaptive_aptitude_responses" validate constraint "adaptive_aptitude_responses_difficulty_at_time_check";

alter table "public"."adaptive_aptitude_responses" add constraint "adaptive_aptitude_responses_response_time_ms_check" CHECK ((response_time_ms >= 0)) not valid;

alter table "public"."adaptive_aptitude_responses" validate constraint "adaptive_aptitude_responses_response_time_ms_check";

alter table "public"."adaptive_aptitude_responses" add constraint "adaptive_aptitude_responses_selected_answer_check" CHECK ((selected_answer = ANY (ARRAY['A'::bpchar, 'B'::bpchar, 'C'::bpchar, 'D'::bpchar]))) not valid;

alter table "public"."adaptive_aptitude_responses" validate constraint "adaptive_aptitude_responses_selected_answer_check";

alter table "public"."adaptive_aptitude_responses" add constraint "adaptive_aptitude_responses_sequence_number_check" CHECK ((sequence_number > 0)) not valid;

alter table "public"."adaptive_aptitude_responses" validate constraint "adaptive_aptitude_responses_sequence_number_check";

alter table "public"."adaptive_aptitude_responses" add constraint "adaptive_aptitude_responses_session_id_fkey" FOREIGN KEY (session_id) REFERENCES public.adaptive_aptitude_sessions(id) ON DELETE CASCADE not valid;

alter table "public"."adaptive_aptitude_responses" validate constraint "adaptive_aptitude_responses_session_id_fkey";

alter table "public"."adaptive_aptitude_responses" add constraint "unique_sequence_per_session" UNIQUE using index "unique_sequence_per_session";

alter table "public"."adaptive_aptitude_results" add constraint "adaptive_aptitude_results_aptitude_level_check" CHECK (((aptitude_level >= 1) AND (aptitude_level <= 5))) not valid;

alter table "public"."adaptive_aptitude_results" validate constraint "adaptive_aptitude_results_aptitude_level_check";

alter table "public"."adaptive_aptitude_results" add constraint "adaptive_aptitude_results_average_response_time_ms_check" CHECK ((average_response_time_ms >= 0)) not valid;

alter table "public"."adaptive_aptitude_results" validate constraint "adaptive_aptitude_results_average_response_time_ms_check";

alter table "public"."adaptive_aptitude_results" add constraint "adaptive_aptitude_results_check" CHECK (((total_correct >= 0) AND (total_correct <= total_questions))) not valid;

alter table "public"."adaptive_aptitude_results" validate constraint "adaptive_aptitude_results_check";

alter table "public"."adaptive_aptitude_results" add constraint "adaptive_aptitude_results_overall_accuracy_check" CHECK (((overall_accuracy >= (0)::numeric) AND (overall_accuracy <= (100)::numeric))) not valid;

alter table "public"."adaptive_aptitude_results" validate constraint "adaptive_aptitude_results_overall_accuracy_check";

alter table "public"."adaptive_aptitude_results" add constraint "adaptive_aptitude_results_session_id_fkey" FOREIGN KEY (session_id) REFERENCES public.adaptive_aptitude_sessions(id) ON DELETE CASCADE not valid;

alter table "public"."adaptive_aptitude_results" validate constraint "adaptive_aptitude_results_session_id_fkey";

alter table "public"."adaptive_aptitude_results" add constraint "adaptive_aptitude_results_session_id_key" UNIQUE using index "adaptive_aptitude_results_session_id_key";

alter table "public"."adaptive_aptitude_results" add constraint "adaptive_aptitude_results_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."adaptive_aptitude_results" validate constraint "adaptive_aptitude_results_student_id_fkey";

alter table "public"."adaptive_aptitude_results" add constraint "adaptive_aptitude_results_total_questions_check" CHECK ((total_questions > 0)) not valid;

alter table "public"."adaptive_aptitude_results" validate constraint "adaptive_aptitude_results_total_questions_check";

alter table "public"."adaptive_aptitude_sessions" add constraint "adaptive_aptitude_sessions_current_difficulty_check" CHECK (((current_difficulty >= 1) AND (current_difficulty <= 5))) not valid;

alter table "public"."adaptive_aptitude_sessions" validate constraint "adaptive_aptitude_sessions_current_difficulty_check";

alter table "public"."adaptive_aptitude_sessions" add constraint "adaptive_aptitude_sessions_provisional_band_check" CHECK (((provisional_band IS NULL) OR ((provisional_band >= 1) AND (provisional_band <= 5)))) not valid;

alter table "public"."adaptive_aptitude_sessions" validate constraint "adaptive_aptitude_sessions_provisional_band_check";

alter table "public"."adaptive_aptitude_sessions" add constraint "adaptive_aptitude_sessions_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."adaptive_aptitude_sessions" validate constraint "adaptive_aptitude_sessions_student_id_fkey";

alter table "public"."adaptive_aptitude_sessions" add constraint "valid_correct_answers" CHECK (((correct_answers >= 0) AND (correct_answers <= questions_answered))) not valid;

alter table "public"."adaptive_aptitude_sessions" validate constraint "valid_correct_answers";

alter table "public"."adaptive_aptitude_sessions" add constraint "valid_question_index" CHECK ((current_question_index >= 0)) not valid;

alter table "public"."adaptive_aptitude_sessions" validate constraint "valid_question_index";

alter table "public"."adaptive_aptitude_sessions" add constraint "valid_questions_answered" CHECK ((questions_answered >= 0)) not valid;

alter table "public"."adaptive_aptitude_sessions" validate constraint "valid_questions_answered";

alter table "public"."addon_discount_codes" add constraint "addon_discount_codes_code_key" UNIQUE using index "addon_discount_codes_code_key";

alter table "public"."addon_discount_codes" add constraint "addon_discount_codes_discount_type_check" CHECK (((discount_type)::text = ANY ((ARRAY['percentage'::character varying, 'fixed'::character varying])::text[]))) not valid;

alter table "public"."addon_discount_codes" validate constraint "addon_discount_codes_discount_type_check";

alter table "public"."addon_events" add constraint "addon_events_bundle_id_fkey" FOREIGN KEY (bundle_id) REFERENCES public.bundles(id) not valid;

alter table "public"."addon_events" validate constraint "addon_events_bundle_id_fkey";

alter table "public"."addon_events" add constraint "addon_events_event_type_check" CHECK (((event_type)::text = ANY ((ARRAY['view'::character varying, 'purchase'::character varying, 'activation'::character varying, 'cancellation'::character varying, 'renewal'::character varying, 'expiry'::character varying, 'upgrade_prompt'::character varying])::text[]))) not valid;

alter table "public"."addon_events" validate constraint "addon_events_event_type_check";

alter table "public"."addon_events" add constraint "addon_events_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."addon_events" validate constraint "addon_events_user_id_fkey";

alter table "public"."addon_pending_orders" add constraint "addon_pending_orders_billing_period_check" CHECK (((billing_period)::text = ANY ((ARRAY['monthly'::character varying, 'annual'::character varying])::text[]))) not valid;

alter table "public"."addon_pending_orders" validate constraint "addon_pending_orders_billing_period_check";

alter table "public"."addon_pending_orders" add constraint "addon_pending_orders_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."addon_pending_orders" validate constraint "addon_pending_orders_organization_id_fkey";

alter table "public"."addon_pending_orders" add constraint "addon_pending_orders_razorpay_order_id_key" UNIQUE using index "addon_pending_orders_razorpay_order_id_key";

alter table "public"."addon_pending_orders" add constraint "addon_pending_orders_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'completed'::character varying, 'failed'::character varying, 'expired'::character varying])::text[]))) not valid;

alter table "public"."addon_pending_orders" validate constraint "addon_pending_orders_status_check";

alter table "public"."addon_pending_orders" add constraint "addon_pending_orders_target_member_type_check" CHECK ((target_member_type = ANY (ARRAY['school_student'::text, 'school_educator'::text, 'college_student'::text, 'college_educator'::text, 'all'::text]))) not valid;

alter table "public"."addon_pending_orders" validate constraint "addon_pending_orders_target_member_type_check";

alter table "public"."addon_pending_orders" add constraint "addon_pending_orders_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."addon_pending_orders" validate constraint "addon_pending_orders_user_id_fkey";

alter table "public"."addon_pending_orders" add constraint "check_bulk_order_has_org" CHECK ((((is_bulk_order = true) AND (organization_id IS NOT NULL)) OR (is_bulk_order = false))) not valid;

alter table "public"."addon_pending_orders" validate constraint "check_bulk_order_has_org";

alter table "public"."addon_pending_orders" add constraint "check_bulk_order_has_targets" CHECK ((((is_bulk_order = true) AND ((target_member_type IS NOT NULL) OR (array_length(target_member_ids, 1) > 0))) OR (is_bulk_order = false))) not valid;

alter table "public"."addon_pending_orders" validate constraint "check_bulk_order_has_targets";

alter table "public"."admin_users" add constraint "admin_users_admin_role_check" CHECK ((admin_role = ANY (ARRAY['super_admin'::text, 'platform_admin'::text]))) not valid;

alter table "public"."admin_users" validate constraint "admin_users_admin_role_check";

alter table "public"."admin_users" add constraint "admin_users_granted_by_fkey" FOREIGN KEY (granted_by) REFERENCES public.admin_users(id) not valid;

alter table "public"."admin_users" validate constraint "admin_users_granted_by_fkey";

alter table "public"."admin_users" add constraint "admin_users_id_fkey" FOREIGN KEY (id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."admin_users" validate constraint "admin_users_id_fkey";

alter table "public"."admin_users" add constraint "admin_users_user_id_key" UNIQUE using index "admin_users_user_id_key";

alter table "public"."admission_applications" add constraint "admission_applications_application_number_key" UNIQUE using index "admission_applications_application_number_key";

alter table "public"."admission_applications" add constraint "admission_applications_fee_status_check" CHECK ((fee_status = ANY (ARRAY['pending'::text, 'partial'::text, 'paid'::text]))) not valid;

alter table "public"."admission_applications" validate constraint "admission_applications_fee_status_check";

alter table "public"."admission_applications" add constraint "admission_applications_gender_check" CHECK ((gender = ANY (ARRAY['male'::text, 'female'::text, 'other'::text]))) not valid;

alter table "public"."admission_applications" validate constraint "admission_applications_gender_check";

alter table "public"."admission_applications" add constraint "admission_applications_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."admission_applications" validate constraint "admission_applications_school_id_fkey";

alter table "public"."admission_applications" add constraint "admission_applications_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'document_verification'::text, 'fee_payment'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."admission_applications" validate constraint "admission_applications_status_check";

alter table "public"."admission_applications" add constraint "admission_applications_verified_by_fkey" FOREIGN KEY (verified_by) REFERENCES auth.users(id) not valid;

alter table "public"."admission_applications" validate constraint "admission_applications_verified_by_fkey";

alter table "public"."ai_evaluations" add constraint "ai_evaluations_conversation_id_fkey" FOREIGN KEY (conversation_id) REFERENCES public.career_ai_conversations(id) ON DELETE CASCADE not valid;

alter table "public"."ai_evaluations" validate constraint "ai_evaluations_conversation_id_fkey";

alter table "public"."ai_evaluations" add constraint "ai_evaluations_conversation_id_message_id_key" UNIQUE using index "ai_evaluations_conversation_id_message_id_key";

alter table "public"."ai_evaluations" add constraint "ai_evaluations_user_rating_check" CHECK (((user_rating IS NULL) OR ((user_rating >= 1) AND (user_rating <= 5)))) not valid;

alter table "public"."ai_evaluations" validate constraint "ai_evaluations_user_rating_check";

alter table "public"."applied_jobs" add constraint "applied_jobs_id_old_unique" UNIQUE using index "applied_jobs_id_old_unique";

alter table "public"."applied_jobs" add constraint "check_application_status" CHECK ((application_status = ANY (ARRAY['applied'::text, 'viewed'::text, 'under_review'::text, 'interview_scheduled'::text, 'interviewed'::text, 'offer_received'::text, 'accepted'::text, 'rejected'::text, 'withdrawn'::text]))) not valid;

alter table "public"."applied_jobs" validate constraint "check_application_status";

alter table "public"."applied_jobs" add constraint "fk_applied_jobs_opportunity" FOREIGN KEY (opportunity_id) REFERENCES public.opportunities(id) not valid;

alter table "public"."applied_jobs" validate constraint "fk_applied_jobs_opportunity";

alter table "public"."applied_jobs" add constraint "fk_applied_jobs_student" FOREIGN KEY (student_id) REFERENCES public.students(id) not valid;

alter table "public"."applied_jobs" validate constraint "fk_applied_jobs_student";

alter table "public"."applied_jobs" add constraint "unique_application" UNIQUE using index "unique_application";

alter table "public"."approval_actions" add constraint "approval_actions_approver_id_fkey" FOREIGN KEY (approver_id) REFERENCES auth.users(id) not valid;

alter table "public"."approval_actions" validate constraint "approval_actions_approver_id_fkey";

alter table "public"."approval_actions" add constraint "approval_actions_request_id_fkey" FOREIGN KEY (request_id) REFERENCES public.approval_requests(id) not valid;

alter table "public"."approval_actions" validate constraint "approval_actions_request_id_fkey";

alter table "public"."approval_requests" add constraint "approval_requests_requester_id_fkey" FOREIGN KEY (requester_id) REFERENCES auth.users(id) not valid;

alter table "public"."approval_requests" validate constraint "approval_requests_requester_id_fkey";

alter table "public"."approval_requests" add constraint "approval_requests_workflow_id_fkey" FOREIGN KEY (workflow_id) REFERENCES public.approval_workflows(id) not valid;

alter table "public"."approval_requests" validate constraint "approval_requests_workflow_id_fkey";

alter table "public"."approval_workflows" add constraint "approval_workflows_approval_type_fkey" FOREIGN KEY (approval_type) REFERENCES public.approval_types(name) not valid;

alter table "public"."approval_workflows" validate constraint "approval_workflows_approval_type_fkey";

alter table "public"."assessment_types" add constraint "assessment_types_institution_type_check" CHECK (((institution_type)::text = ANY ((ARRAY['school'::character varying, 'college'::character varying])::text[]))) not valid;

alter table "public"."assessment_types" validate constraint "assessment_types_institution_type_check";

alter table "public"."assessments" add constraint "assessments_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) not valid;

alter table "public"."assessments" validate constraint "assessments_approved_by_fkey";

alter table "public"."assessments" add constraint "assessments_assessment_code_key" UNIQUE using index "assessments_assessment_code_key";

alter table "public"."assessments" add constraint "assessments_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."assessments" validate constraint "assessments_college_id_fkey";

alter table "public"."assessments" add constraint "assessments_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.curriculum_courses(id) ON DELETE RESTRICT not valid;

alter table "public"."assessments" validate constraint "assessments_course_id_fkey";

alter table "public"."assessments" add constraint "assessments_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."assessments" validate constraint "assessments_created_by_fkey";

alter table "public"."assessments" add constraint "assessments_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) ON DELETE CASCADE not valid;

alter table "public"."assessments" validate constraint "assessments_department_id_fkey";

alter table "public"."assessments" add constraint "assessments_faculty_id_fkey" FOREIGN KEY (faculty_id) REFERENCES public.college_lecturers(id) ON DELETE SET NULL not valid;

alter table "public"."assessments" validate constraint "assessments_faculty_id_fkey";

alter table "public"."assessments" add constraint "assessments_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) ON DELETE CASCADE not valid;

alter table "public"."assessments" validate constraint "assessments_program_id_fkey";

alter table "public"."assessments" add constraint "assessments_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."assessments" validate constraint "assessments_school_id_fkey";

alter table "public"."assessments" add constraint "assessments_semester_check" CHECK (((semester >= 1) AND (semester <= 12))) not valid;

alter table "public"."assessments" validate constraint "assessments_semester_check";

alter table "public"."assessments" add constraint "assessments_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'scheduled'::text, 'ongoing'::text, 'completed'::text, 'cancelled'::text, 'marks_pending'::text, 'moderation'::text, 'published'::text]))) not valid;

alter table "public"."assessments" validate constraint "assessments_status_check";

alter table "public"."assessments" add constraint "assessments_teacher_id_fkey" FOREIGN KEY (teacher_id) REFERENCES public.school_educators(id) not valid;

alter table "public"."assessments" validate constraint "assessments_teacher_id_fkey";

alter table "public"."assessments" add constraint "chk_assessments_date_range" CHECK ((end_date >= start_date)) not valid;

alter table "public"."assessments" validate constraint "chk_assessments_date_range";

alter table "public"."assessments" add constraint "valid_marks" CHECK ((pass_marks <= total_marks)) not valid;

alter table "public"."assessments" validate constraint "valid_marks";

alter table "public"."assessments" add constraint "valid_weightage" CHECK (((weightage IS NULL) OR ((weightage >= (0)::numeric) AND (weightage <= (100)::numeric)))) not valid;

alter table "public"."assessments" validate constraint "valid_weightage";

alter table "public"."assignment_attachments" add constraint "fk_attachment_assignment" FOREIGN KEY (assignment_id) REFERENCES public.assignments(assignment_id) ON DELETE CASCADE not valid;

alter table "public"."assignment_attachments" validate constraint "fk_attachment_assignment";

alter table "public"."assignments" add constraint "assignments_assignment_type_check" CHECK ((assignment_type = ANY (ARRAY['homework'::text, 'project'::text, 'quiz'::text, 'exam'::text, 'lab'::text, 'essay'::text, 'presentation'::text, 'other'::text]))) not valid;

alter table "public"."assignments" validate constraint "assignments_assignment_type_check";

alter table "public"."assignments" add constraint "assignments_educator_fk" FOREIGN KEY (educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."assignments" validate constraint "assignments_educator_fk";

alter table "public"."assignments" add constraint "assignments_school_class_id_fkey" FOREIGN KEY (school_class_id) REFERENCES public.school_classes(id) not valid;

alter table "public"."assignments" validate constraint "assignments_school_class_id_fkey";

alter table "public"."attendance_alerts" add constraint "attendance_alerts_alert_type_check" CHECK ((alert_type = ANY (ARRAY['consecutive_absent'::text, 'below_75'::text, 'irregular'::text]))) not valid;

alter table "public"."attendance_alerts" validate constraint "attendance_alerts_alert_type_check";

alter table "public"."attendance_alerts" add constraint "attendance_alerts_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."attendance_alerts" validate constraint "attendance_alerts_school_id_fkey";

alter table "public"."attendance_alerts" add constraint "attendance_alerts_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."attendance_alerts" validate constraint "attendance_alerts_student_id_fkey";

alter table "public"."attendance_records" add constraint "attendance_records_marked_by_fkey" FOREIGN KEY (marked_by) REFERENCES auth.users(id) not valid;

alter table "public"."attendance_records" validate constraint "attendance_records_marked_by_fkey";

alter table "public"."attendance_records" add constraint "attendance_records_mode_check" CHECK ((mode = ANY (ARRAY['manual'::text, 'rfid'::text, 'mobile'::text]))) not valid;

alter table "public"."attendance_records" validate constraint "attendance_records_mode_check";

alter table "public"."attendance_records" add constraint "attendance_records_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."attendance_records" validate constraint "attendance_records_school_id_fkey";

alter table "public"."attendance_records" add constraint "attendance_records_slot_id_fkey" FOREIGN KEY (slot_id) REFERENCES public.timetable_slots(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."attendance_records" validate constraint "attendance_records_slot_id_fkey";

alter table "public"."attendance_records" add constraint "attendance_records_status_check" CHECK ((status = ANY (ARRAY['present'::text, 'absent'::text, 'late'::text, 'excused'::text]))) not valid;

alter table "public"."attendance_records" validate constraint "attendance_records_status_check";

alter table "public"."attendance_records" add constraint "attendance_records_student_date_slot_key" UNIQUE using index "attendance_records_student_date_slot_key";

alter table "public"."attendance_records" add constraint "attendance_records_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."attendance_records" validate constraint "attendance_records_student_id_fkey";

alter table "public"."audit_logs" add constraint "audit_logs_actorid_fkey" FOREIGN KEY ("actorId") REFERENCES public.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."audit_logs" validate constraint "audit_logs_actorid_fkey";

alter table "public"."budget_alerts" add constraint "budget_alerts_acknowledged_by_fkey" FOREIGN KEY (acknowledged_by) REFERENCES public.users(id) not valid;

alter table "public"."budget_alerts" validate constraint "budget_alerts_acknowledged_by_fkey";

alter table "public"."budget_alerts" add constraint "budget_alerts_alert_level_check" CHECK ((alert_level = ANY (ARRAY['info'::text, 'warning'::text, 'critical'::text]))) not valid;

alter table "public"."budget_alerts" validate constraint "budget_alerts_alert_level_check";

alter table "public"."budget_alerts" add constraint "budget_alerts_alert_type_check" CHECK ((alert_type = ANY (ARRAY['threshold_reached'::text, 'budget_exceeded'::text, 'low_balance'::text, 'overspending'::text]))) not valid;

alter table "public"."budget_alerts" validate constraint "budget_alerts_alert_type_check";

alter table "public"."budget_alerts" add constraint "budget_alerts_budget_id_fkey" FOREIGN KEY (budget_id) REFERENCES public.department_budgets(id) ON DELETE CASCADE not valid;

alter table "public"."budget_alerts" validate constraint "budget_alerts_budget_id_fkey";

alter table "public"."budget_alerts" add constraint "budget_alerts_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) not valid;

alter table "public"."budget_alerts" validate constraint "budget_alerts_department_id_fkey";

alter table "public"."budget_revisions" add constraint "budget_revisions_approval_status_check" CHECK ((approval_status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."budget_revisions" validate constraint "budget_revisions_approval_status_check";

alter table "public"."budget_revisions" add constraint "budget_revisions_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) not valid;

alter table "public"."budget_revisions" validate constraint "budget_revisions_approved_by_fkey";

alter table "public"."budget_revisions" add constraint "budget_revisions_budget_id_fkey" FOREIGN KEY (budget_id) REFERENCES public.department_budgets(id) ON DELETE CASCADE not valid;

alter table "public"."budget_revisions" validate constraint "budget_revisions_budget_id_fkey";

alter table "public"."budget_revisions" add constraint "budget_revisions_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) not valid;

alter table "public"."budget_revisions" validate constraint "budget_revisions_department_id_fkey";

alter table "public"."budget_revisions" add constraint "budget_revisions_requested_by_fkey" FOREIGN KEY (requested_by) REFERENCES public.users(id) not valid;

alter table "public"."budget_revisions" validate constraint "budget_revisions_requested_by_fkey";

alter table "public"."budget_revisions" add constraint "budget_revisions_revision_type_check" CHECK ((revision_type = ANY (ARRAY['increase'::text, 'decrease'::text, 'reallocation'::text, 'correction'::text]))) not valid;

alter table "public"."budget_revisions" validate constraint "budget_revisions_revision_type_check";

alter table "public"."bundle_features" add constraint "bundle_features_bundle_id_feature_key_key" UNIQUE using index "bundle_features_bundle_id_feature_key_key";

alter table "public"."bundle_features" add constraint "bundle_features_bundle_id_fkey" FOREIGN KEY (bundle_id) REFERENCES public.bundles(id) ON DELETE CASCADE not valid;

alter table "public"."bundle_features" validate constraint "bundle_features_bundle_id_fkey";

alter table "public"."bundles" add constraint "bundles_slug_key" UNIQUE using index "bundles_slug_key";

alter table "public"."career_ai_conversations" add constraint "career_ai_conversations_student_id_fkey" FOREIGN KEY (student_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."career_ai_conversations" validate constraint "career_ai_conversations_student_id_fkey";

alter table "public"."career_assessment_ai_questions" add constraint "career_assessment_ai_questions_attempt_id_fkey" FOREIGN KEY (attempt_id) REFERENCES public.personal_assessment_attempts(id) not valid;

alter table "public"."career_assessment_ai_questions" validate constraint "career_assessment_ai_questions_attempt_id_fkey";

alter table "public"."career_assessment_ai_questions" add constraint "career_assessment_ai_questions_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) not valid;

alter table "public"."career_assessment_ai_questions" validate constraint "career_assessment_ai_questions_student_id_fkey";

alter table "public"."career_assessment_ai_questions" add constraint "career_assessment_ai_questions_student_stream_type_key" UNIQUE using index "career_assessment_ai_questions_student_stream_type_key";

alter table "public"."certificates" add constraint "certificates_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."certificates" validate constraint "certificates_student_id_fkey";

alter table "public"."certificates" add constraint "certificates_training_id_fkey" FOREIGN KEY (training_id) REFERENCES public.trainings(id) ON DELETE SET NULL not valid;

alter table "public"."certificates" validate constraint "certificates_training_id_fkey";

alter table "public"."class_swap_history" add constraint "class_swap_history_swap_request_id_fkey" FOREIGN KEY (swap_request_id) REFERENCES public.class_swap_requests(id) ON DELETE CASCADE not valid;

alter table "public"."class_swap_history" validate constraint "class_swap_history_swap_request_id_fkey";

alter table "public"."class_swap_requests" add constraint "class_swap_requests_admin_approval_status_check" CHECK (((admin_approval_status)::text = ANY ((ARRAY['pending'::character varying, 'approved'::character varying, 'rejected'::character varying])::text[]))) not valid;

alter table "public"."class_swap_requests" validate constraint "class_swap_requests_admin_approval_status_check";

alter table "public"."class_swap_requests" add constraint "class_swap_requests_request_type_check" CHECK (((request_type)::text = ANY ((ARRAY['one_time'::character varying, 'permanent'::character varying])::text[]))) not valid;

alter table "public"."class_swap_requests" validate constraint "class_swap_requests_request_type_check";

alter table "public"."class_swap_requests" add constraint "class_swap_requests_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'accepted'::character varying, 'rejected'::character varying, 'cancelled'::character varying, 'completed'::character varying])::text[]))) not valid;

alter table "public"."class_swap_requests" validate constraint "class_swap_requests_status_check";

alter table "public"."class_swap_requests" add constraint "different_faculty" CHECK ((requester_faculty_id <> target_faculty_id)) not valid;

alter table "public"."class_swap_requests" validate constraint "different_faculty";

alter table "public"."class_swap_requests" add constraint "different_slots" CHECK ((requester_slot_id <> target_slot_id)) not valid;

alter table "public"."class_swap_requests" validate constraint "different_slots";

alter table "public"."class_swap_requests" add constraint "swap_date_required_for_one_time" CHECK (((((request_type)::text = 'permanent'::text) AND (swap_date IS NULL)) OR (((request_type)::text = 'one_time'::text) AND (swap_date IS NOT NULL)))) not valid;

alter table "public"."class_swap_requests" validate constraint "swap_date_required_for_one_time";

alter table "public"."club_activities" add constraint "check_single_activity_creator" CHECK ((((created_by_educator_id IS NOT NULL) AND (created_by_admin_id IS NULL) AND ((created_by_type)::text = 'educator'::text)) OR ((created_by_educator_id IS NULL) AND (created_by_admin_id IS NOT NULL) AND ((created_by_type)::text = 'admin'::text)))) not valid;

alter table "public"."club_activities" validate constraint "check_single_activity_creator";

alter table "public"."club_activities" add constraint "club_activities_activity_type_check" CHECK (((activity_type)::text = ANY ((ARRAY['workshop'::character varying, 'meeting'::character varying, 'event'::character varying, 'competition_prep'::character varying, 'practice'::character varying, 'field_trip'::character varying, 'guest_lecture'::character varying, 'other'::character varying])::text[]))) not valid;

alter table "public"."club_activities" validate constraint "club_activities_activity_type_check";

alter table "public"."club_activities" add constraint "club_activities_club_id_fkey" FOREIGN KEY (club_id) REFERENCES public.clubs(club_id) ON DELETE CASCADE not valid;

alter table "public"."club_activities" validate constraint "club_activities_club_id_fkey";

alter table "public"."club_activities" add constraint "club_activities_created_by_educator_id_fkey" FOREIGN KEY (created_by_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."club_activities" validate constraint "club_activities_created_by_educator_id_fkey";

alter table "public"."club_activities" add constraint "club_activities_created_by_type_check" CHECK (((created_by_type)::text = ANY ((ARRAY['educator'::character varying, 'admin'::character varying])::text[]))) not valid;

alter table "public"."club_activities" validate constraint "club_activities_created_by_type_check";

alter table "public"."club_activities" add constraint "club_activities_status_check" CHECK (((status)::text = ANY ((ARRAY['scheduled'::character varying, 'ongoing'::character varying, 'completed'::character varying, 'cancelled'::character varying])::text[]))) not valid;

alter table "public"."club_activities" validate constraint "club_activities_status_check";

alter table "public"."club_attendance" add constraint "check_single_attendance_creator" CHECK ((((created_by_educator_id IS NOT NULL) AND (created_by_admin_id IS NULL) AND ((created_by_type)::text = 'educator'::text)) OR ((created_by_educator_id IS NULL) AND (created_by_admin_id IS NOT NULL) AND ((created_by_type)::text = 'admin'::text)))) not valid;

alter table "public"."club_attendance" validate constraint "check_single_attendance_creator";

alter table "public"."club_attendance" add constraint "club_attendance_club_id_fkey" FOREIGN KEY (club_id) REFERENCES public.clubs(club_id) ON DELETE CASCADE not valid;

alter table "public"."club_attendance" validate constraint "club_attendance_club_id_fkey";

alter table "public"."club_attendance" add constraint "club_attendance_created_by_educator_id_fkey" FOREIGN KEY (created_by_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."club_attendance" validate constraint "club_attendance_created_by_educator_id_fkey";

alter table "public"."club_attendance" add constraint "club_attendance_created_by_type_check" CHECK (((created_by_type)::text = ANY ((ARRAY['educator'::character varying, 'admin'::character varying])::text[]))) not valid;

alter table "public"."club_attendance" validate constraint "club_attendance_created_by_type_check";

alter table "public"."club_attendance" add constraint "unique_club_session" UNIQUE using index "unique_club_session";

alter table "public"."club_attendance_records" add constraint "check_single_marker" CHECK ((((marked_by_educator_id IS NOT NULL) AND (marked_by_admin_id IS NULL) AND ((marked_by_type)::text = 'educator'::text)) OR ((marked_by_educator_id IS NULL) AND (marked_by_admin_id IS NOT NULL) AND ((marked_by_type)::text = 'admin'::text)))) not valid;

alter table "public"."club_attendance_records" validate constraint "check_single_marker";

alter table "public"."club_attendance_records" add constraint "club_attendance_records_attendance_id_fkey" FOREIGN KEY (attendance_id) REFERENCES public.club_attendance(attendance_id) ON DELETE CASCADE not valid;

alter table "public"."club_attendance_records" validate constraint "club_attendance_records_attendance_id_fkey";

alter table "public"."club_attendance_records" add constraint "club_attendance_records_marked_by_educator_id_fkey" FOREIGN KEY (marked_by_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."club_attendance_records" validate constraint "club_attendance_records_marked_by_educator_id_fkey";

alter table "public"."club_attendance_records" add constraint "club_attendance_records_marked_by_type_check" CHECK (((marked_by_type)::text = ANY ((ARRAY['educator'::character varying, 'admin'::character varying])::text[]))) not valid;

alter table "public"."club_attendance_records" validate constraint "club_attendance_records_marked_by_type_check";

alter table "public"."club_attendance_records" add constraint "club_attendance_records_status_check" CHECK (((status)::text = ANY ((ARRAY['present'::character varying, 'absent'::character varying, 'late'::character varying, 'excused'::character varying])::text[]))) not valid;

alter table "public"."club_attendance_records" validate constraint "club_attendance_records_status_check";

alter table "public"."club_attendance_records" add constraint "fk_student_email" FOREIGN KEY (student_email) REFERENCES public.students(email) ON DELETE CASCADE not valid;

alter table "public"."club_attendance_records" validate constraint "fk_student_email";

alter table "public"."club_attendance_records" add constraint "unique_student_session" UNIQUE using index "unique_student_session";

alter table "public"."club_certificates" add constraint "check_single_certificate_issuer" CHECK ((((issued_by_educator_id IS NOT NULL) AND (issued_by_admin_id IS NULL) AND ((issued_by_type)::text = 'educator'::text)) OR ((issued_by_educator_id IS NULL) AND (issued_by_admin_id IS NOT NULL) AND ((issued_by_type)::text = 'admin'::text)))) not valid;

alter table "public"."club_certificates" validate constraint "check_single_certificate_issuer";

alter table "public"."club_certificates" add constraint "club_certificates_certificate_type_check" CHECK (((certificate_type)::text = ANY ((ARRAY['course_completion'::character varying, 'skill_achievement'::character varying, 'competition'::character varying, 'workshop'::character varying, 'leadership'::character varying, 'participation'::character varying, 'excellence'::character varying])::text[]))) not valid;

alter table "public"."club_certificates" validate constraint "club_certificates_certificate_type_check";

alter table "public"."club_certificates" add constraint "club_certificates_credential_id_key" UNIQUE using index "club_certificates_credential_id_key";

alter table "public"."club_certificates" add constraint "club_certificates_issued_by_educator_id_fkey" FOREIGN KEY (issued_by_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."club_certificates" validate constraint "club_certificates_issued_by_educator_id_fkey";

alter table "public"."club_certificates" add constraint "club_certificates_issued_by_type_check" CHECK (((issued_by_type)::text = ANY ((ARRAY['educator'::character varying, 'admin'::character varying])::text[]))) not valid;

alter table "public"."club_certificates" validate constraint "club_certificates_issued_by_type_check";

alter table "public"."club_certificates" add constraint "club_certificates_related_badge_id_fkey" FOREIGN KEY (related_badge_id) REFERENCES public.skill_badges(badge_id) ON DELETE SET NULL not valid;

alter table "public"."club_certificates" validate constraint "club_certificates_related_badge_id_fkey";

alter table "public"."club_certificates" add constraint "club_certificates_related_club_id_fkey" FOREIGN KEY (related_club_id) REFERENCES public.clubs(club_id) ON DELETE SET NULL not valid;

alter table "public"."club_certificates" validate constraint "club_certificates_related_club_id_fkey";

alter table "public"."club_certificates" add constraint "club_certificates_related_comp_id_fkey" FOREIGN KEY (related_comp_id) REFERENCES public.competitions(comp_id) ON DELETE SET NULL not valid;

alter table "public"."club_certificates" validate constraint "club_certificates_related_comp_id_fkey";

alter table "public"."club_certificates" add constraint "club_certificates_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."club_certificates" validate constraint "club_certificates_school_id_fkey";

alter table "public"."club_certificates" add constraint "fk_student_email" FOREIGN KEY (student_email) REFERENCES public.students(email) ON DELETE CASCADE not valid;

alter table "public"."club_certificates" validate constraint "fk_student_email";

alter table "public"."club_memberships" add constraint "check_single_enroller" CHECK ((((enrolled_by_educator_id IS NOT NULL) AND (enrolled_by_admin_id IS NULL) AND ((enrolled_by_type)::text = 'educator'::text)) OR ((enrolled_by_educator_id IS NULL) AND (enrolled_by_admin_id IS NOT NULL) AND ((enrolled_by_type)::text = 'admin'::text)) OR ((enrolled_by_educator_id IS NULL) AND (enrolled_by_admin_id IS NULL) AND ((enrolled_by_type)::text = 'self'::text)))) not valid;

alter table "public"."club_memberships" validate constraint "check_single_enroller";

alter table "public"."club_memberships" add constraint "club_memberships_club_id_fkey" FOREIGN KEY (club_id) REFERENCES public.clubs(club_id) ON DELETE CASCADE not valid;

alter table "public"."club_memberships" validate constraint "club_memberships_club_id_fkey";

alter table "public"."club_memberships" add constraint "club_memberships_enrolled_by_educator_id_fkey" FOREIGN KEY (enrolled_by_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."club_memberships" validate constraint "club_memberships_enrolled_by_educator_id_fkey";

alter table "public"."club_memberships" add constraint "club_memberships_enrolled_by_type_check" CHECK (((enrolled_by_type)::text = ANY ((ARRAY['educator'::character varying, 'admin'::character varying, 'self'::character varying])::text[]))) not valid;

alter table "public"."club_memberships" validate constraint "club_memberships_enrolled_by_type_check";

alter table "public"."club_memberships" add constraint "club_memberships_status_check" CHECK (((status)::text = ANY ((ARRAY['active'::character varying, 'withdrawn'::character varying, 'suspended'::character varying])::text[]))) not valid;

alter table "public"."club_memberships" validate constraint "club_memberships_status_check";

alter table "public"."club_memberships" add constraint "fk_student_email" FOREIGN KEY (student_email) REFERENCES public.students(email) ON DELETE CASCADE not valid;

alter table "public"."club_memberships" validate constraint "fk_student_email";

alter table "public"."club_memberships" add constraint "unique_student_club" UNIQUE using index "unique_student_club";

alter table "public"."clubs" add constraint "check_single_creator" CHECK ((((created_by_educator_id IS NOT NULL) AND (created_by_admin_id IS NULL) AND ((created_by_type)::text = 'educator'::text)) OR ((created_by_educator_id IS NULL) AND (created_by_admin_id IS NOT NULL) AND ((created_by_type)::text = 'admin'::text)) OR ((created_by_educator_id IS NULL) AND (created_by_admin_id IS NULL) AND (created_by_type IS NULL)))) not valid;

alter table "public"."clubs" validate constraint "check_single_creator";

alter table "public"."clubs" add constraint "check_single_mentor" CHECK ((((mentor_educator_id IS NOT NULL) AND (mentor_school_id IS NULL) AND ((mentor_type)::text = 'educator'::text)) OR ((mentor_educator_id IS NULL) AND (mentor_school_id IS NOT NULL) AND ((mentor_type)::text = 'school'::text)) OR ((mentor_educator_id IS NULL) AND (mentor_school_id IS NULL) AND (mentor_type IS NULL)))) not valid;

alter table "public"."clubs" validate constraint "check_single_mentor";

alter table "public"."clubs" add constraint "clubs_category_check" CHECK (((category)::text = ANY ((ARRAY['arts'::character varying, 'sports'::character varying, 'robotics'::character varying, 'science'::character varying, 'literature'::character varying])::text[]))) not valid;

alter table "public"."clubs" validate constraint "clubs_category_check";

alter table "public"."clubs" add constraint "clubs_created_by_educator_id_fkey" FOREIGN KEY (created_by_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."clubs" validate constraint "clubs_created_by_educator_id_fkey";

alter table "public"."clubs" add constraint "clubs_created_by_type_check" CHECK (((created_by_type)::text = ANY ((ARRAY['educator'::character varying, 'admin'::character varying])::text[]))) not valid;

alter table "public"."clubs" validate constraint "clubs_created_by_type_check";

alter table "public"."clubs" add constraint "clubs_mentor_educator_id_fkey" FOREIGN KEY (mentor_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."clubs" validate constraint "clubs_mentor_educator_id_fkey";

alter table "public"."clubs" add constraint "clubs_mentor_type_check" CHECK (((mentor_type)::text = ANY ((ARRAY['educator'::character varying, 'school'::character varying])::text[]))) not valid;

alter table "public"."clubs" validate constraint "clubs_mentor_type_check";

alter table "public"."clubs" add constraint "clubs_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."clubs" validate constraint "clubs_school_id_fkey";

alter table "public"."clubs" add constraint "unique_club_name_per_school" UNIQUE using index "unique_club_name_per_school";

alter table "public"."college_assignment_attachments" add constraint "college_assignment_attachments_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.college_assignments(assignment_id) ON DELETE CASCADE not valid;

alter table "public"."college_assignment_attachments" validate constraint "college_assignment_attachments_assignment_id_fkey";

alter table "public"."college_assignment_attachments" add constraint "college_assignment_attachments_uploaded_by_fkey" FOREIGN KEY (uploaded_by) REFERENCES public.college_lecturers(user_id) ON DELETE SET NULL not valid;

alter table "public"."college_assignment_attachments" validate constraint "college_assignment_attachments_uploaded_by_fkey";

alter table "public"."college_assignments" add constraint "college_assignments_assignment_type_check" CHECK ((assignment_type = ANY (ARRAY['homework'::text, 'project'::text, 'quiz'::text, 'exam'::text, 'lab'::text, 'essay'::text, 'presentation'::text, 'other'::text]))) not valid;

alter table "public"."college_assignments" validate constraint "college_assignments_assignment_type_check";

alter table "public"."college_assignments" add constraint "college_assignments_college_educator_id_fkey" FOREIGN KEY (college_educator_id) REFERENCES public.college_lecturers(user_id) ON DELETE SET NULL not valid;

alter table "public"."college_assignments" validate constraint "college_assignments_college_educator_id_fkey";

alter table "public"."college_assignments" add constraint "college_assignments_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_assignments" validate constraint "college_assignments_college_id_fkey";

alter table "public"."college_assignments" add constraint "college_assignments_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) ON DELETE CASCADE not valid;

alter table "public"."college_assignments" validate constraint "college_assignments_department_id_fkey";

alter table "public"."college_assignments" add constraint "college_assignments_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) ON DELETE CASCADE not valid;

alter table "public"."college_assignments" validate constraint "college_assignments_program_id_fkey";

alter table "public"."college_assignments" add constraint "college_assignments_program_section_id_fkey" FOREIGN KEY (program_section_id) REFERENCES public.program_sections(id) ON DELETE CASCADE not valid;

alter table "public"."college_assignments" validate constraint "college_assignments_program_section_id_fkey";

alter table "public"."college_attendance_records" add constraint "college_attendance_records_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_attendance_records" validate constraint "college_attendance_records_college_id_fkey";

alter table "public"."college_attendance_records" add constraint "college_attendance_records_faculty_id_fkey" FOREIGN KEY (faculty_id) REFERENCES public.college_lecturers(id) not valid;

alter table "public"."college_attendance_records" validate constraint "college_attendance_records_faculty_id_fkey";

alter table "public"."college_attendance_records" add constraint "college_attendance_records_marked_by_fkey" FOREIGN KEY (marked_by) REFERENCES auth.users(id) not valid;

alter table "public"."college_attendance_records" validate constraint "college_attendance_records_marked_by_fkey";

alter table "public"."college_attendance_records" add constraint "college_attendance_records_session_id_fkey" FOREIGN KEY (session_id) REFERENCES public.college_attendance_sessions(id) ON DELETE CASCADE not valid;

alter table "public"."college_attendance_records" validate constraint "college_attendance_records_session_id_fkey";

alter table "public"."college_attendance_records" add constraint "college_attendance_records_status_check" CHECK (((status)::text = ANY ((ARRAY['present'::character varying, 'absent'::character varying, 'late'::character varying, 'excused'::character varying])::text[]))) not valid;

alter table "public"."college_attendance_records" validate constraint "college_attendance_records_status_check";

alter table "public"."college_attendance_records" add constraint "college_attendance_records_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) not valid;

alter table "public"."college_attendance_records" validate constraint "college_attendance_records_student_id_fkey";

alter table "public"."college_attendance_sessions" add constraint "college_attendance_sessions_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_attendance_sessions" validate constraint "college_attendance_sessions_college_id_fkey";

alter table "public"."college_attendance_sessions" add constraint "college_attendance_sessions_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."college_attendance_sessions" validate constraint "college_attendance_sessions_created_by_fkey";

alter table "public"."college_attendance_sessions" add constraint "college_attendance_sessions_faculty_id_fkey" FOREIGN KEY (faculty_id) REFERENCES public.college_lecturers(id) not valid;

alter table "public"."college_attendance_sessions" validate constraint "college_attendance_sessions_faculty_id_fkey";

alter table "public"."college_attendance_sessions" add constraint "college_attendance_sessions_status_check" CHECK (((status)::text = ANY ((ARRAY['scheduled'::character varying, 'ongoing'::character varying, 'completed'::character varying, 'cancelled'::character varying])::text[]))) not valid;

alter table "public"."college_attendance_sessions" validate constraint "college_attendance_sessions_status_check";

alter table "public"."college_attendance_settings" add constraint "college_attendance_settings_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_attendance_settings" validate constraint "college_attendance_settings_college_id_fkey";

alter table "public"."college_attendance_settings" add constraint "college_attendance_settings_college_id_key" UNIQUE using index "college_attendance_settings_college_id_key";

alter table "public"."college_breaks" add constraint "college_breaks_break_type_check" CHECK (((break_type)::text = ANY ((ARRAY['lunch'::character varying, 'short'::character varying, 'holiday'::character varying, 'exam'::character varying, 'event'::character varying])::text[]))) not valid;

alter table "public"."college_breaks" validate constraint "college_breaks_break_type_check";

alter table "public"."college_breaks" add constraint "college_breaks_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_breaks" validate constraint "college_breaks_college_id_fkey";

alter table "public"."college_breaks" add constraint "college_breaks_timetable_id_fkey" FOREIGN KEY (timetable_id) REFERENCES public.college_timetables(id) ON DELETE CASCADE not valid;

alter table "public"."college_breaks" validate constraint "college_breaks_timetable_id_fkey";

alter table "public"."college_circulars" add constraint "college_circulars_audience_check" CHECK (((audience)::text = ANY ((ARRAY['all'::character varying, 'students'::character varying, 'faculty'::character varying, 'staff'::character varying])::text[]))) not valid;

alter table "public"."college_circulars" validate constraint "college_circulars_audience_check";

alter table "public"."college_circulars" add constraint "college_circulars_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_circulars" validate constraint "college_circulars_college_id_fkey";

alter table "public"."college_circulars" add constraint "college_circulars_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."college_circulars" validate constraint "college_circulars_created_by_fkey";

alter table "public"."college_circulars" add constraint "college_circulars_priority_check" CHECK (((priority)::text = ANY ((ARRAY['low'::character varying, 'medium'::character varying, 'high'::character varying, 'urgent'::character varying])::text[]))) not valid;

alter table "public"."college_circulars" validate constraint "college_circulars_priority_check";

alter table "public"."college_circulars" add constraint "college_circulars_status_check" CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'published'::character varying, 'archived'::character varying])::text[]))) not valid;

alter table "public"."college_circulars" validate constraint "college_circulars_status_check";

alter table "public"."college_classes" add constraint "college_classes_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_classes" validate constraint "college_classes_college_id_fkey";

alter table "public"."college_classes" add constraint "college_classes_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) not valid;

alter table "public"."college_classes" validate constraint "college_classes_department_id_fkey";

alter table "public"."college_course_mappings" add constraint "college_course_mappings_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.college_courses(id) not valid;

alter table "public"."college_course_mappings" validate constraint "college_course_mappings_course_id_fkey";

alter table "public"."college_course_mappings" add constraint "college_course_mappings_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."college_course_mappings" validate constraint "college_course_mappings_created_by_fkey";

alter table "public"."college_course_mappings" add constraint "college_course_mappings_faculty_id_fkey" FOREIGN KEY (faculty_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."college_course_mappings" validate constraint "college_course_mappings_faculty_id_fkey";

alter table "public"."college_course_mappings" add constraint "college_course_mappings_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) ON DELETE CASCADE not valid;

alter table "public"."college_course_mappings" validate constraint "college_course_mappings_program_id_fkey";

alter table "public"."college_course_mappings" add constraint "college_course_mappings_type_check" CHECK (((offering_type)::text = ANY ((ARRAY['core'::character varying, 'dept_elective'::character varying, 'open_elective'::character varying])::text[]))) not valid;

alter table "public"."college_course_mappings" validate constraint "college_course_mappings_type_check";

alter table "public"."college_course_mappings" add constraint "college_course_mappings_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."college_course_mappings" validate constraint "college_course_mappings_updated_by_fkey";

alter table "public"."college_course_mappings" add constraint "elective_capacity_required" CHECK (((((offering_type)::text = 'core'::text) AND (capacity IS NULL)) OR (((offering_type)::text = ANY ((ARRAY['dept_elective'::character varying, 'open_elective'::character varying])::text[])) AND (capacity IS NOT NULL)))) not valid;

alter table "public"."college_course_mappings" validate constraint "elective_capacity_required";

alter table "public"."college_course_mappings" add constraint "unique_course_program_semester" UNIQUE using index "unique_course_program_semester";

alter table "public"."college_courses" add constraint "check_course_type_valid" CHECK (((course_type)::text = ANY ((ARRAY['theory'::character varying, 'lab'::character varying, 'project'::character varying, 'seminar'::character varying, 'workshop'::character varying, 'practical'::character varying])::text[]))) not valid;

alter table "public"."college_courses" validate constraint "check_course_type_valid";

alter table "public"."college_courses" add constraint "check_credits_positive" CHECK ((credits > (0)::numeric)) not valid;

alter table "public"."college_courses" validate constraint "check_credits_positive";

alter table "public"."college_courses" add constraint "college_courses_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_courses" validate constraint "college_courses_college_id_fkey";

alter table "public"."college_courses" add constraint "unique_course_code_per_college" UNIQUE using index "unique_course_code_per_college";

alter table "public"."college_curriculum_outcomes" add constraint "college_curriculum_outcomes_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."college_curriculum_outcomes" validate constraint "college_curriculum_outcomes_created_by_fkey";

alter table "public"."college_curriculum_outcomes" add constraint "college_curriculum_outcomes_curriculum_id_fkey" FOREIGN KEY (curriculum_id) REFERENCES public.college_curriculums(id) ON DELETE CASCADE not valid;

alter table "public"."college_curriculum_outcomes" validate constraint "college_curriculum_outcomes_curriculum_id_fkey";

alter table "public"."college_curriculum_outcomes" add constraint "college_curriculum_outcomes_unit_id_fkey" FOREIGN KEY (unit_id) REFERENCES public.college_curriculum_units(id) ON DELETE CASCADE not valid;

alter table "public"."college_curriculum_outcomes" validate constraint "college_curriculum_outcomes_unit_id_fkey";

alter table "public"."college_curriculum_outcomes" add constraint "college_curriculum_outcomes_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES public.users(id) not valid;

alter table "public"."college_curriculum_outcomes" validate constraint "college_curriculum_outcomes_updated_by_fkey";

alter table "public"."college_curriculum_units" add constraint "college_curriculum_units_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."college_curriculum_units" validate constraint "college_curriculum_units_created_by_fkey";

alter table "public"."college_curriculum_units" add constraint "college_curriculum_units_curriculum_id_fkey" FOREIGN KEY (curriculum_id) REFERENCES public.college_curriculums(id) ON DELETE CASCADE not valid;

alter table "public"."college_curriculum_units" validate constraint "college_curriculum_units_curriculum_id_fkey";

alter table "public"."college_curriculum_units" add constraint "college_curriculum_units_curriculum_id_order_index_key" UNIQUE using index "college_curriculum_units_curriculum_id_order_index_key";

alter table "public"."college_curriculum_units" add constraint "college_curriculum_units_duration_unit_check" CHECK (((duration_unit)::text = ANY ((ARRAY['hours'::character varying, 'weeks'::character varying])::text[]))) not valid;

alter table "public"."college_curriculum_units" validate constraint "college_curriculum_units_duration_unit_check";

alter table "public"."college_curriculum_units" add constraint "college_curriculum_units_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES public.users(id) not valid;

alter table "public"."college_curriculum_units" validate constraint "college_curriculum_units_updated_by_fkey";

alter table "public"."college_curriculums" add constraint "college_curriculums_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) not valid;

alter table "public"."college_curriculums" validate constraint "college_curriculums_approved_by_fkey";

alter table "public"."college_curriculums" add constraint "college_curriculums_cloned_from_id_fkey" FOREIGN KEY (cloned_from_id) REFERENCES public.college_curriculums(id) not valid;

alter table "public"."college_curriculums" validate constraint "college_curriculums_cloned_from_id_fkey";

alter table "public"."college_curriculums" add constraint "college_curriculums_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_curriculums" validate constraint "college_curriculums_college_id_fkey";

alter table "public"."college_curriculums" add constraint "college_curriculums_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.college_courses(id) not valid;

alter table "public"."college_curriculums" validate constraint "college_curriculums_course_id_fkey";

alter table "public"."college_curriculums" add constraint "college_curriculums_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."college_curriculums" validate constraint "college_curriculums_created_by_fkey";

alter table "public"."college_curriculums" add constraint "college_curriculums_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) not valid;

alter table "public"."college_curriculums" validate constraint "college_curriculums_department_id_fkey";

alter table "public"."college_curriculums" add constraint "college_curriculums_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) not valid;

alter table "public"."college_curriculums" validate constraint "college_curriculums_program_id_fkey";

alter table "public"."college_curriculums" add constraint "college_curriculums_requested_by_fkey" FOREIGN KEY (requested_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."college_curriculums" validate constraint "college_curriculums_requested_by_fkey";

alter table "public"."college_curriculums" add constraint "college_curriculums_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."college_curriculums" validate constraint "college_curriculums_reviewed_by_fkey";

alter table "public"."college_curriculums" add constraint "college_curriculums_status_check" CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'submitted'::character varying, 'pending_approval'::character varying, 'approved'::character varying, 'published'::character varying, 'archived'::character varying, 'rejected'::character varying])::text[]))) not valid;

alter table "public"."college_curriculums" validate constraint "college_curriculums_status_check";

alter table "public"."college_curriculums" add constraint "college_curriculums_university_id_fkey" FOREIGN KEY (university_id) REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."college_curriculums" validate constraint "college_curriculums_university_id_fkey";

alter table "public"."college_curriculums" add constraint "fk_curriculum_course_id" FOREIGN KEY (course_id) REFERENCES public.college_courses(id) ON DELETE CASCADE not valid;

alter table "public"."college_curriculums" validate constraint "fk_curriculum_course_id";

alter table "public"."college_curriculums" add constraint "unique_curriculum_per_course_year" UNIQUE using index "unique_curriculum_per_course_year";

alter table "public"."college_event_registrations" add constraint "college_event_registrations_event_id_fkey" FOREIGN KEY (event_id) REFERENCES public.college_events(id) ON DELETE CASCADE not valid;

alter table "public"."college_event_registrations" validate constraint "college_event_registrations_event_id_fkey";

alter table "public"."college_event_registrations" add constraint "college_event_registrations_event_id_student_id_key" UNIQUE using index "college_event_registrations_event_id_student_id_key";

alter table "public"."college_event_registrations" add constraint "college_event_registrations_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."college_event_registrations" validate constraint "college_event_registrations_student_id_fkey";

alter table "public"."college_events" add constraint "college_events_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_events" validate constraint "college_events_college_id_fkey";

alter table "public"."college_events" add constraint "college_events_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."college_events" validate constraint "college_events_created_by_fkey";

alter table "public"."college_events" add constraint "college_events_event_type_check" CHECK (((event_type)::text = ANY ((ARRAY['seminar'::character varying, 'workshop'::character varying, 'cultural'::character varying, 'sports'::character varying, 'placement'::character varying, 'guest_lecture'::character varying, 'orientation'::character varying, 'other'::character varying])::text[]))) not valid;

alter table "public"."college_events" validate constraint "college_events_event_type_check";

alter table "public"."college_events" add constraint "college_events_status_check" CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'published'::character varying, 'cancelled'::character varying, 'completed'::character varying])::text[]))) not valid;

alter table "public"."college_events" validate constraint "college_events_status_check";

alter table "public"."college_faculty_class_assignments" add constraint "college_faculty_class_assignm_faculty_id_class_id_subject_n_key" UNIQUE using index "college_faculty_class_assignm_faculty_id_class_id_subject_n_key";

alter table "public"."college_faculty_class_assignments" add constraint "college_faculty_class_assignments_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.college_classes(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_class_assignments" validate constraint "college_faculty_class_assignments_class_id_fkey";

alter table "public"."college_faculty_class_assignments" add constraint "college_faculty_class_assignments_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_class_assignments" validate constraint "college_faculty_class_assignments_college_id_fkey";

alter table "public"."college_faculty_class_assignments" add constraint "college_faculty_class_assignments_faculty_id_fkey" FOREIGN KEY (faculty_id) REFERENCES public.college_lecturers(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_class_assignments" validate constraint "college_faculty_class_assignments_faculty_id_fkey";

alter table "public"."college_faculty_leave_balances" add constraint "college_faculty_leave_balance_faculty_id_leave_type_id_acad_key" UNIQUE using index "college_faculty_leave_balance_faculty_id_leave_type_id_acad_key";

alter table "public"."college_faculty_leave_balances" add constraint "college_faculty_leave_balances_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_leave_balances" validate constraint "college_faculty_leave_balances_college_id_fkey";

alter table "public"."college_faculty_leave_balances" add constraint "college_faculty_leave_balances_faculty_id_fkey" FOREIGN KEY (faculty_id) REFERENCES public.college_lecturers(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_leave_balances" validate constraint "college_faculty_leave_balances_faculty_id_fkey";

alter table "public"."college_faculty_leave_balances" add constraint "college_faculty_leave_balances_leave_type_id_fkey" FOREIGN KEY (leave_type_id) REFERENCES public.college_leave_types(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_leave_balances" validate constraint "college_faculty_leave_balances_leave_type_id_fkey";

alter table "public"."college_faculty_leaves" add constraint "college_faculty_leaves_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_leaves" validate constraint "college_faculty_leaves_college_id_fkey";

alter table "public"."college_faculty_leaves" add constraint "college_faculty_leaves_faculty_id_fkey" FOREIGN KEY (faculty_id) REFERENCES public.college_lecturers(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_leaves" validate constraint "college_faculty_leaves_faculty_id_fkey";

alter table "public"."college_faculty_leaves" add constraint "college_faculty_leaves_leave_type_id_fkey" FOREIGN KEY (leave_type_id) REFERENCES public.college_leave_types(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_leaves" validate constraint "college_faculty_leaves_leave_type_id_fkey";

alter table "public"."college_faculty_leaves" add constraint "college_faculty_leaves_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) not valid;

alter table "public"."college_faculty_leaves" validate constraint "college_faculty_leaves_reviewed_by_fkey";

alter table "public"."college_faculty_leaves" add constraint "college_faculty_leaves_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'approved'::character varying, 'rejected'::character varying, 'cancelled'::character varying])::text[]))) not valid;

alter table "public"."college_faculty_leaves" validate constraint "college_faculty_leaves_status_check";

alter table "public"."college_faculty_substitutions" add constraint "college_faculty_substitutions_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.college_classes(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_substitutions" validate constraint "college_faculty_substitutions_class_id_fkey";

alter table "public"."college_faculty_substitutions" add constraint "college_faculty_substitutions_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_substitutions" validate constraint "college_faculty_substitutions_college_id_fkey";

alter table "public"."college_faculty_substitutions" add constraint "college_faculty_substitutions_leave_id_fkey" FOREIGN KEY (leave_id) REFERENCES public.college_faculty_leaves(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_substitutions" validate constraint "college_faculty_substitutions_leave_id_fkey";

alter table "public"."college_faculty_substitutions" add constraint "college_faculty_substitutions_original_faculty_id_fkey" FOREIGN KEY (original_faculty_id) REFERENCES public.college_lecturers(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_substitutions" validate constraint "college_faculty_substitutions_original_faculty_id_fkey";

alter table "public"."college_faculty_substitutions" add constraint "college_faculty_substitutions_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'assigned'::character varying, 'confirmed'::character varying, 'completed'::character varying, 'cancelled'::character varying])::text[]))) not valid;

alter table "public"."college_faculty_substitutions" validate constraint "college_faculty_substitutions_status_check";

alter table "public"."college_faculty_substitutions" add constraint "college_faculty_substitutions_substitute_faculty_id_fkey" FOREIGN KEY (substitute_faculty_id) REFERENCES public.college_lecturers(id) ON DELETE SET NULL not valid;

alter table "public"."college_faculty_substitutions" validate constraint "college_faculty_substitutions_substitute_faculty_id_fkey";

alter table "public"."college_faculty_substitutions" add constraint "college_faculty_substitutions_timetable_slot_id_fkey" FOREIGN KEY (timetable_slot_id) REFERENCES public.college_timetable_slots(id) ON DELETE CASCADE not valid;

alter table "public"."college_faculty_substitutions" validate constraint "college_faculty_substitutions_timetable_slot_id_fkey";

alter table "public"."college_leave_types" add constraint "college_leave_types_college_id_code_key" UNIQUE using index "college_leave_types_college_id_code_key";

alter table "public"."college_leave_types" add constraint "college_leave_types_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_leave_types" validate constraint "college_leave_types_college_id_fkey";

alter table "public"."college_lecturers" add constraint "chk_college_lecturers_email_format" CHECK (((email IS NULL) OR ((email)::text ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'::text))) not valid;

alter table "public"."college_lecturers" validate constraint "chk_college_lecturers_email_format";

alter table "public"."college_lecturers" add constraint "college_lecturers_collegeid_fkey" FOREIGN KEY ("collegeId") REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_lecturers" validate constraint "college_lecturers_collegeid_fkey";

alter table "public"."college_lecturers" add constraint "college_lecturers_user_id_key" UNIQUE using index "college_lecturers_user_id_key";

alter table "public"."college_lecturers" add constraint "fk_college_lecturers_user" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."college_lecturers" validate constraint "fk_college_lecturers_user";

alter table "public"."college_lesson_plans" add constraint "college_lesson_plans_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_lesson_plans" validate constraint "college_lesson_plans_college_id_fkey";

alter table "public"."college_lesson_plans" add constraint "college_lesson_plans_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.college_courses(id) ON DELETE CASCADE not valid;

alter table "public"."college_lesson_plans" validate constraint "college_lesson_plans_course_id_fkey";

alter table "public"."college_lesson_plans" add constraint "college_lesson_plans_curriculum_id_fkey" FOREIGN KEY (curriculum_id) REFERENCES public.college_curriculums(id) ON DELETE SET NULL not valid;

alter table "public"."college_lesson_plans" validate constraint "college_lesson_plans_curriculum_id_fkey";

alter table "public"."college_lesson_plans" add constraint "college_lesson_plans_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) ON DELETE CASCADE not valid;

alter table "public"."college_lesson_plans" validate constraint "college_lesson_plans_department_id_fkey";

alter table "public"."college_lesson_plans" add constraint "college_lesson_plans_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) ON DELETE CASCADE not valid;

alter table "public"."college_lesson_plans" validate constraint "college_lesson_plans_program_id_fkey";

alter table "public"."college_lesson_plans" add constraint "college_lesson_plans_semester_check" CHECK (((semester >= 1) AND (semester <= 8))) not valid;

alter table "public"."college_lesson_plans" validate constraint "college_lesson_plans_semester_check";

alter table "public"."college_lesson_plans" add constraint "college_lesson_plans_status_check" CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'published'::character varying, 'archived'::character varying])::text[]))) not valid;

alter table "public"."college_lesson_plans" validate constraint "college_lesson_plans_status_check";

alter table "public"."college_lesson_plans" add constraint "college_lesson_plans_unit_id_fkey" FOREIGN KEY (unit_id) REFERENCES public.college_curriculum_units(id) ON DELETE SET NULL not valid;

alter table "public"."college_lesson_plans" validate constraint "college_lesson_plans_unit_id_fkey";

alter table "public"."college_mentor_notes" add constraint "college_mentor_notes_allocation_id_fkey" FOREIGN KEY (allocation_id) REFERENCES public.college_mentor_student_allocations(id) not valid;

alter table "public"."college_mentor_notes" validate constraint "college_mentor_notes_allocation_id_fkey";

alter table "public"."college_mentor_notes" add constraint "college_mentor_notes_created_by_id_fkey" FOREIGN KEY (created_by_id) REFERENCES auth.users(id) not valid;

alter table "public"."college_mentor_notes" validate constraint "college_mentor_notes_created_by_id_fkey";

alter table "public"."college_mentor_notes" add constraint "college_mentor_notes_intervention_type_check" CHECK (((intervention_type)::text = ANY ((ARRAY['academic'::character varying, 'personal'::character varying, 'career'::character varying, 'attendance'::character varying, 'behavioral'::character varying, 'financial'::character varying, 'other'::character varying])::text[]))) not valid;

alter table "public"."college_mentor_notes" validate constraint "college_mentor_notes_intervention_type_check";

alter table "public"."college_mentor_notes" add constraint "college_mentor_notes_last_updated_by_fkey" FOREIGN KEY (last_updated_by) REFERENCES auth.users(id) not valid;

alter table "public"."college_mentor_notes" validate constraint "college_mentor_notes_last_updated_by_fkey";

alter table "public"."college_mentor_notes" add constraint "college_mentor_notes_mentor_id_fkey" FOREIGN KEY (mentor_id) REFERENCES public.college_lecturers(id) not valid;

alter table "public"."college_mentor_notes" validate constraint "college_mentor_notes_mentor_id_fkey";

alter table "public"."college_mentor_notes" add constraint "college_mentor_notes_priority_check" CHECK (((priority)::text = ANY ((ARRAY['low'::character varying, 'medium'::character varying, 'high'::character varying, 'urgent'::character varying])::text[]))) not valid;

alter table "public"."college_mentor_notes" validate constraint "college_mentor_notes_priority_check";

alter table "public"."college_mentor_notes" add constraint "college_mentor_notes_resolved_by_fkey" FOREIGN KEY (resolved_by) REFERENCES auth.users(id) not valid;

alter table "public"."college_mentor_notes" validate constraint "college_mentor_notes_resolved_by_fkey";

alter table "public"."college_mentor_notes" add constraint "college_mentor_notes_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'acknowledged'::character varying, 'in_progress'::character varying, 'completed'::character varying, 'escalated'::character varying])::text[]))) not valid;

alter table "public"."college_mentor_notes" validate constraint "college_mentor_notes_status_check";

alter table "public"."college_mentor_notes" add constraint "college_mentor_notes_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) not valid;

alter table "public"."college_mentor_notes" validate constraint "college_mentor_notes_student_id_fkey";

alter table "public"."college_mentor_periods" add constraint "college_mentor_periods_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.university_colleges(id) not valid;

alter table "public"."college_mentor_periods" validate constraint "college_mentor_periods_college_id_fkey";

alter table "public"."college_mentor_periods" add constraint "college_mentor_periods_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.college_lecturers(id) not valid;

alter table "public"."college_mentor_periods" validate constraint "college_mentor_periods_created_by_fkey";

alter table "public"."college_mentor_student_allocations" add constraint "college_mentor_student_allocations_assigned_by_fkey" FOREIGN KEY (assigned_by) REFERENCES public.college_lecturers(id) not valid;

alter table "public"."college_mentor_student_allocations" validate constraint "college_mentor_student_allocations_assigned_by_fkey";

alter table "public"."college_mentor_student_allocations" add constraint "college_mentor_student_allocations_mentor_id_fkey" FOREIGN KEY (mentor_id) REFERENCES public.college_lecturers(id) not valid;

alter table "public"."college_mentor_student_allocations" validate constraint "college_mentor_student_allocations_mentor_id_fkey";

alter table "public"."college_mentor_student_allocations" add constraint "college_mentor_student_allocations_period_id_fkey" FOREIGN KEY (period_id) REFERENCES public.college_mentor_periods(id) not valid;

alter table "public"."college_mentor_student_allocations" validate constraint "college_mentor_student_allocations_period_id_fkey";

alter table "public"."college_mentor_student_allocations" add constraint "college_mentor_student_allocations_status_check" CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'active'::character varying, 'completed'::character varying, 'transferred'::character varying, 'cancelled'::character varying])::text[]))) not valid;

alter table "public"."college_mentor_student_allocations" validate constraint "college_mentor_student_allocations_status_check";

alter table "public"."college_mentor_student_allocations" add constraint "college_mentor_student_allocations_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) not valid;

alter table "public"."college_mentor_student_allocations" validate constraint "college_mentor_student_allocations_student_id_fkey";

alter table "public"."college_role_module_permissions" add constraint "college_role_module_permissio_role_type_module_id_permissio_key" UNIQUE using index "college_role_module_permissio_role_type_module_id_permissio_key";

alter table "public"."college_role_module_permissions" add constraint "college_role_module_permissions_module_id_fkey" FOREIGN KEY (module_id) REFERENCES public.college_setting_modules(id) ON DELETE CASCADE not valid;

alter table "public"."college_role_module_permissions" validate constraint "college_role_module_permissions_module_id_fkey";

alter table "public"."college_role_module_permissions" add constraint "college_role_module_permissions_permission_id_fkey" FOREIGN KEY (permission_id) REFERENCES public.college_setting_permissions(id) ON DELETE CASCADE not valid;

alter table "public"."college_role_module_permissions" validate constraint "college_role_module_permissions_permission_id_fkey";

alter table "public"."college_role_scope_rules" add constraint "college_role_scope_rules_role_type_scope_type_scope_value_key" UNIQUE using index "college_role_scope_rules_role_type_scope_type_scope_value_key";

alter table "public"."college_setting_modules" add constraint "college_setting_modules_module_name_key" UNIQUE using index "college_setting_modules_module_name_key";

alter table "public"."college_setting_permissions" add constraint "college_setting_permissions_permission_name_key" UNIQUE using index "college_setting_permissions_permission_name_key";

alter table "public"."college_student_assignments" add constraint "chk_college_grade_percentage_range" CHECK (((grade_percentage IS NULL) OR ((grade_percentage >= (0)::numeric) AND (grade_percentage <= (100)::numeric)))) not valid;

alter table "public"."college_student_assignments" validate constraint "chk_college_grade_percentage_range";

alter table "public"."college_student_assignments" add constraint "chk_college_status_dates" CHECK ((((status <> 'submitted'::text) OR (completed_date IS NOT NULL)) AND ((status <> 'graded'::text) OR (graded_date IS NOT NULL)))) not valid;

alter table "public"."college_student_assignments" validate constraint "chk_college_status_dates";

alter table "public"."college_student_assignments" add constraint "college_student_assignments_assignment_id_fkey" FOREIGN KEY (assignment_id) REFERENCES public.college_assignments(assignment_id) ON DELETE CASCADE not valid;

alter table "public"."college_student_assignments" validate constraint "college_student_assignments_assignment_id_fkey";

alter table "public"."college_student_assignments" add constraint "college_student_assignments_graded_by_fkey" FOREIGN KEY (graded_by) REFERENCES public.college_lecturers(user_id) ON DELETE SET NULL not valid;

alter table "public"."college_student_assignments" validate constraint "college_student_assignments_graded_by_fkey";

alter table "public"."college_student_assignments" add constraint "college_student_assignments_priority_check" CHECK ((priority = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text]))) not valid;

alter table "public"."college_student_assignments" validate constraint "college_student_assignments_priority_check";

alter table "public"."college_student_assignments" add constraint "college_student_assignments_status_check" CHECK ((status = ANY (ARRAY['todo'::text, 'in-progress'::text, 'submitted'::text, 'graded'::text]))) not valid;

alter table "public"."college_student_assignments" validate constraint "college_student_assignments_status_check";

alter table "public"."college_student_assignments" add constraint "college_student_assignments_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(user_id) ON DELETE CASCADE not valid;

alter table "public"."college_student_assignments" validate constraint "college_student_assignments_student_id_fkey";

alter table "public"."college_student_assignments" add constraint "college_student_assignments_submission_type_check" CHECK ((submission_type = ANY (ARRAY['file'::text, 'text'::text, 'url'::text, 'code'::text, 'other'::text]))) not valid;

alter table "public"."college_student_assignments" validate constraint "college_student_assignments_submission_type_check";

alter table "public"."college_student_assignments" add constraint "uq_college_student_assignment" UNIQUE using index "uq_college_student_assignment";

alter table "public"."college_time_periods" add constraint "college_time_periods_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_time_periods" validate constraint "college_time_periods_college_id_fkey";

alter table "public"."college_time_periods" add constraint "college_time_periods_timetable_id_fkey" FOREIGN KEY (timetable_id) REFERENCES public.college_timetables(id) ON DELETE CASCADE not valid;

alter table "public"."college_time_periods" validate constraint "college_time_periods_timetable_id_fkey";

alter table "public"."college_time_periods" add constraint "college_time_periods_timetable_id_period_number_key" UNIQUE using index "college_time_periods_timetable_id_period_number_key";

alter table "public"."college_timetable_slots" add constraint "college_timetable_slots_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.college_classes(id) ON DELETE SET NULL not valid;

alter table "public"."college_timetable_slots" validate constraint "college_timetable_slots_class_id_fkey";

alter table "public"."college_timetable_slots" add constraint "college_timetable_slots_day_of_week_check" CHECK (((day_of_week >= 1) AND (day_of_week <= 7))) not valid;

alter table "public"."college_timetable_slots" validate constraint "college_timetable_slots_day_of_week_check";

alter table "public"."college_timetable_slots" add constraint "college_timetable_slots_educator_id_fkey" FOREIGN KEY (educator_id) REFERENCES public.college_lecturers(id) ON DELETE SET NULL not valid;

alter table "public"."college_timetable_slots" validate constraint "college_timetable_slots_educator_id_fkey";

alter table "public"."college_timetable_slots" add constraint "college_timetable_slots_period_number_check" CHECK (((period_number >= 1) AND (period_number <= 15))) not valid;

alter table "public"."college_timetable_slots" validate constraint "college_timetable_slots_period_number_check";

alter table "public"."college_timetable_slots" add constraint "college_timetable_slots_timetable_id_day_of_week_period_num_key" UNIQUE using index "college_timetable_slots_timetable_id_day_of_week_period_num_key";

alter table "public"."college_timetable_slots" add constraint "college_timetable_slots_timetable_id_fkey" FOREIGN KEY (timetable_id) REFERENCES public.college_timetables(id) ON DELETE CASCADE not valid;

alter table "public"."college_timetable_slots" validate constraint "college_timetable_slots_timetable_id_fkey";

alter table "public"."college_timetables" add constraint "college_timetables_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."college_timetables" validate constraint "college_timetables_college_id_fkey";

alter table "public"."college_timetables" add constraint "unique_college_academic_year" UNIQUE using index "unique_college_academic_year";

alter table "public"."companies" add constraint "companies_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."companies" validate constraint "companies_created_by_fkey";

alter table "public"."companies" add constraint "companies_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."companies" validate constraint "companies_updated_by_fkey";

alter table "public"."competition_clubs" add constraint "check_single_comp_club_registrar" CHECK ((((registered_by_educator_id IS NOT NULL) AND (registered_by_admin_id IS NULL) AND ((registered_by_type)::text = 'educator'::text)) OR ((registered_by_educator_id IS NULL) AND (registered_by_admin_id IS NOT NULL) AND ((registered_by_type)::text = 'admin'::text)))) not valid;

alter table "public"."competition_clubs" validate constraint "check_single_comp_club_registrar";

alter table "public"."competition_clubs" add constraint "competition_clubs_club_id_fkey" FOREIGN KEY (club_id) REFERENCES public.clubs(club_id) ON DELETE CASCADE not valid;

alter table "public"."competition_clubs" validate constraint "competition_clubs_club_id_fkey";

alter table "public"."competition_clubs" add constraint "competition_clubs_comp_id_fkey" FOREIGN KEY (comp_id) REFERENCES public.competitions(comp_id) ON DELETE CASCADE not valid;

alter table "public"."competition_clubs" validate constraint "competition_clubs_comp_id_fkey";

alter table "public"."competition_clubs" add constraint "competition_clubs_registered_by_educator_id_fkey" FOREIGN KEY (registered_by_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."competition_clubs" validate constraint "competition_clubs_registered_by_educator_id_fkey";

alter table "public"."competition_clubs" add constraint "competition_clubs_registered_by_type_check" CHECK (((registered_by_type)::text = ANY ((ARRAY['educator'::character varying, 'admin'::character varying])::text[]))) not valid;

alter table "public"."competition_clubs" validate constraint "competition_clubs_registered_by_type_check";

alter table "public"."competition_clubs" add constraint "unique_comp_club" UNIQUE using index "unique_comp_club";

alter table "public"."competition_registrations" add constraint "check_single_comp_registrar" CHECK ((((registered_by_educator_id IS NOT NULL) AND (registered_by_admin_id IS NULL) AND ((registered_by_type)::text = 'educator'::text)) OR ((registered_by_educator_id IS NULL) AND (registered_by_admin_id IS NOT NULL) AND ((registered_by_type)::text = 'admin'::text)) OR ((registered_by_educator_id IS NULL) AND (registered_by_admin_id IS NULL) AND ((registered_by_type)::text = 'self'::text)))) not valid;

alter table "public"."competition_registrations" validate constraint "check_single_comp_registrar";

alter table "public"."competition_registrations" add constraint "competition_registrations_comp_id_fkey" FOREIGN KEY (comp_id) REFERENCES public.competitions(comp_id) ON DELETE CASCADE not valid;

alter table "public"."competition_registrations" validate constraint "competition_registrations_comp_id_fkey";

alter table "public"."competition_registrations" add constraint "competition_registrations_registered_by_educator_id_fkey" FOREIGN KEY (registered_by_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."competition_registrations" validate constraint "competition_registrations_registered_by_educator_id_fkey";

alter table "public"."competition_registrations" add constraint "competition_registrations_registered_by_type_check" CHECK (((registered_by_type)::text = ANY ((ARRAY['educator'::character varying, 'admin'::character varying, 'self'::character varying])::text[]))) not valid;

alter table "public"."competition_registrations" validate constraint "competition_registrations_registered_by_type_check";

alter table "public"."competition_registrations" add constraint "competition_registrations_status_check" CHECK (((status)::text = ANY ((ARRAY['registered'::character varying, 'confirmed'::character varying, 'withdrawn'::character varying, 'disqualified'::character varying])::text[]))) not valid;

alter table "public"."competition_registrations" validate constraint "competition_registrations_status_check";

alter table "public"."competition_registrations" add constraint "fk_student_email" FOREIGN KEY (student_email) REFERENCES public.students(email) ON DELETE CASCADE not valid;

alter table "public"."competition_registrations" validate constraint "fk_student_email";

alter table "public"."competition_registrations" add constraint "unique_student_competition" UNIQUE using index "unique_student_competition";

alter table "public"."competition_results" add constraint "check_single_result_recorder" CHECK ((((recorded_by_educator_id IS NOT NULL) AND (recorded_by_admin_id IS NULL) AND ((recorded_by_type)::text = 'educator'::text)) OR ((recorded_by_educator_id IS NULL) AND (recorded_by_admin_id IS NOT NULL) AND ((recorded_by_type)::text = 'admin'::text)))) not valid;

alter table "public"."competition_results" validate constraint "check_single_result_recorder";

alter table "public"."competition_results" add constraint "competition_results_comp_id_fkey" FOREIGN KEY (comp_id) REFERENCES public.competitions(comp_id) ON DELETE CASCADE not valid;

alter table "public"."competition_results" validate constraint "competition_results_comp_id_fkey";

alter table "public"."competition_results" add constraint "competition_results_recorded_by_educator_id_fkey" FOREIGN KEY (recorded_by_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."competition_results" validate constraint "competition_results_recorded_by_educator_id_fkey";

alter table "public"."competition_results" add constraint "competition_results_recorded_by_type_check" CHECK (((recorded_by_type)::text = ANY ((ARRAY['educator'::character varying, 'admin'::character varying])::text[]))) not valid;

alter table "public"."competition_results" validate constraint "competition_results_recorded_by_type_check";

alter table "public"."competition_results" add constraint "competition_results_registration_id_fkey" FOREIGN KEY (registration_id) REFERENCES public.competition_registrations(registration_id) ON DELETE CASCADE not valid;

alter table "public"."competition_results" validate constraint "competition_results_registration_id_fkey";

alter table "public"."competition_results" add constraint "fk_student_email" FOREIGN KEY (student_email) REFERENCES public.students(email) ON DELETE CASCADE not valid;

alter table "public"."competition_results" validate constraint "fk_student_email";

alter table "public"."competition_results" add constraint "unique_student_comp_result" UNIQUE using index "unique_student_comp_result";

alter table "public"."competitions" add constraint "check_single_comp_creator" CHECK ((((created_by_educator_id IS NOT NULL) AND (created_by_admin_id IS NULL) AND ((created_by_type)::text = 'educator'::text)) OR ((created_by_educator_id IS NULL) AND (created_by_admin_id IS NOT NULL) AND ((created_by_type)::text = 'admin'::text)))) not valid;

alter table "public"."competitions" validate constraint "check_single_comp_creator";

alter table "public"."competitions" add constraint "competitions_created_by_educator_id_fkey" FOREIGN KEY (created_by_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."competitions" validate constraint "competitions_created_by_educator_id_fkey";

alter table "public"."competitions" add constraint "competitions_created_by_type_check" CHECK (((created_by_type)::text = ANY ((ARRAY['educator'::character varying, 'admin'::character varying])::text[]))) not valid;

alter table "public"."competitions" validate constraint "competitions_created_by_type_check";

alter table "public"."competitions" add constraint "competitions_level_check" CHECK (((level)::text = ANY ((ARRAY['intraschool'::character varying, 'interschool'::character varying, 'district'::character varying, 'state'::character varying, 'national'::character varying, 'international'::character varying])::text[]))) not valid;

alter table "public"."competitions" validate constraint "competitions_level_check";

alter table "public"."competitions" add constraint "competitions_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."competitions" validate constraint "competitions_school_id_fkey";

alter table "public"."competitions" add constraint "competitions_status_check" CHECK (((status)::text = ANY ((ARRAY['upcoming'::character varying, 'ongoing'::character varying, 'completed'::character varying, 'cancelled'::character varying])::text[]))) not valid;

alter table "public"."competitions" validate constraint "competitions_status_check";

alter table "public"."conversations" add constraint "conversations_application_id_fkey" FOREIGN KEY (application_id) REFERENCES public.applied_jobs(id_old) not valid;

alter table "public"."conversations" validate constraint "conversations_application_id_fkey";

alter table "public"."conversations" add constraint "conversations_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.school_classes(id) not valid;

alter table "public"."conversations" validate constraint "conversations_class_id_fkey";

alter table "public"."conversations" add constraint "conversations_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."conversations" validate constraint "conversations_college_id_fkey";

alter table "public"."conversations" add constraint "conversations_opportunity_id_fkey" FOREIGN KEY (opportunity_id) REFERENCES public.opportunities(id_old) not valid;

alter table "public"."conversations" validate constraint "conversations_opportunity_id_fkey";

alter table "public"."conversations" add constraint "conversations_participant_check" CHECK ((((student_id IS NOT NULL) AND (recruiter_id IS NOT NULL) AND (educator_id IS NULL) AND (school_id IS NULL) AND (college_id IS NULL) AND ((conversation_type)::text = 'student_recruiter'::text)) OR ((student_id IS NOT NULL) AND (educator_id IS NOT NULL) AND (recruiter_id IS NULL) AND (school_id IS NULL) AND (college_id IS NULL) AND ((conversation_type)::text = 'student_educator'::text)) OR ((student_id IS NOT NULL) AND (school_id IS NOT NULL) AND (recruiter_id IS NULL) AND (educator_id IS NULL) AND (college_id IS NULL) AND ((conversation_type)::text = 'student_admin'::text)) OR ((student_id IS NOT NULL) AND (college_id IS NOT NULL) AND (recruiter_id IS NULL) AND (educator_id IS NULL) AND (school_id IS NULL) AND ((conversation_type)::text = 'student_college_admin'::text)) OR ((student_id IS NOT NULL) AND (recruiter_id IS NOT NULL) AND (educator_id IS NOT NULL) AND (school_id IS NULL) AND (college_id IS NULL) AND ((conversation_type)::text = 'educator_recruiter'::text)) OR ((student_id IS NULL) AND (educator_id IS NOT NULL) AND (school_id IS NOT NULL) AND (recruiter_id IS NULL) AND (college_id IS NULL) AND ((conversation_type)::text = 'educator_admin'::text)) OR ((student_id IS NOT NULL) AND (educator_id IS NOT NULL) AND (college_id IS NOT NULL) AND (recruiter_id IS NULL) AND (school_id IS NULL) AND ((conversation_type)::text = 'student_college_educator'::text)) OR ((student_id IS NULL) AND (educator_id IS NOT NULL) AND (college_id IS NOT NULL) AND (recruiter_id IS NULL) AND (school_id IS NULL) AND ((conversation_type)::text = 'college_educator_admin'::text)))) not valid;

alter table "public"."conversations" validate constraint "conversations_participant_check";

alter table "public"."conversations" add constraint "conversations_program_section_id_fkey" FOREIGN KEY (program_section_id) REFERENCES public.program_sections(id) ON DELETE SET NULL not valid;

alter table "public"."conversations" validate constraint "conversations_program_section_id_fkey";

alter table "public"."conversations" add constraint "conversations_recruiter_id_fkey" FOREIGN KEY (recruiter_id) REFERENCES public.recruiters(id) ON DELETE CASCADE not valid;

alter table "public"."conversations" validate constraint "conversations_recruiter_id_fkey";

alter table "public"."conversations" add constraint "conversations_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."conversations" validate constraint "conversations_school_id_fkey";

alter table "public"."conversations" add constraint "conversations_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(user_id) not valid;

alter table "public"."conversations" validate constraint "conversations_student_id_fkey";

alter table "public"."conversations" add constraint "conversations_student_id_recruiter_id_application_id_key" UNIQUE using index "conversations_student_id_recruiter_id_application_id_key";

alter table "public"."course_classes" add constraint "fk_course_class" FOREIGN KEY (course_id) REFERENCES public.courses(course_id) ON DELETE CASCADE not valid;

alter table "public"."course_classes" validate constraint "fk_course_class";

alter table "public"."course_classes" add constraint "unique_course_class" UNIQUE using index "unique_course_class";

alter table "public"."course_co_educators" add constraint "fk_course_co_edu" FOREIGN KEY (course_id) REFERENCES public.courses(course_id) ON DELETE CASCADE not valid;

alter table "public"."course_co_educators" validate constraint "fk_course_co_edu";

alter table "public"."course_co_educators" add constraint "fk_educator_co_edu" FOREIGN KEY (educator_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."course_co_educators" validate constraint "fk_educator_co_edu";

alter table "public"."course_co_educators" add constraint "unique_co_educator" UNIQUE using index "unique_co_educator";

alter table "public"."course_enrollments" add constraint "course_enrollments_student_id_course_id_key" UNIQUE using index "course_enrollments_student_id_course_id_key";

alter table "public"."course_enrollments" add constraint "course_enrollments_training_id_fkey" FOREIGN KEY (training_id) REFERENCES public.trainings(id) ON DELETE SET NULL not valid;

alter table "public"."course_enrollments" validate constraint "course_enrollments_training_id_fkey";

alter table "public"."course_modules" add constraint "fk_course" FOREIGN KEY (course_id) REFERENCES public.courses(course_id) ON DELETE CASCADE not valid;

alter table "public"."course_modules" validate constraint "fk_course";

alter table "public"."course_skills" add constraint "fk_course_skill" FOREIGN KEY (course_id) REFERENCES public.courses(course_id) ON DELETE CASCADE not valid;

alter table "public"."course_skills" validate constraint "fk_course_skill";

alter table "public"."course_skills" add constraint "unique_course_skill" UNIQUE using index "unique_course_skill";

alter table "public"."courses" add constraint "courses_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES auth.users(id) not valid;

alter table "public"."courses" validate constraint "courses_approved_by_fkey";

alter table "public"."courses" add constraint "courses_code_key" UNIQUE using index "courses_code_key";

alter table "public"."courses" add constraint "courses_completion_rate_check" CHECK (((completion_rate >= 0) AND (completion_rate <= 100))) not valid;

alter table "public"."courses" validate constraint "courses_completion_rate_check";

alter table "public"."courses" add constraint "courses_educator_id_fkey" FOREIGN KEY (educator_id) REFERENCES public.admin_users(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."courses" validate constraint "courses_educator_id_fkey";

alter table "public"."courses" add constraint "courses_rejected_by_fkey" FOREIGN KEY (rejected_by) REFERENCES auth.users(id) not valid;

alter table "public"."courses" validate constraint "courses_rejected_by_fkey";

alter table "public"."courses" add constraint "courses_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."courses" validate constraint "courses_school_id_fkey";

alter table "public"."courses" add constraint "courses_skill_type_check" CHECK (((skill_type)::text = ANY ((ARRAY['technical'::character varying, 'soft'::character varying])::text[]))) not valid;

alter table "public"."courses" validate constraint "courses_skill_type_check";

alter table "public"."courses" add constraint "courses_status_check" CHECK (((status)::text = ANY ((ARRAY['Active'::character varying, 'Draft'::character varying, 'Upcoming'::character varying, 'Archived'::character varying])::text[]))) not valid;

alter table "public"."courses" validate constraint "courses_status_check";

alter table "public"."curriculum_academic_years" add constraint "curriculum_academic_years_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."curriculum_academic_years" validate constraint "curriculum_academic_years_school_id_fkey";

alter table "public"."curriculum_academic_years" add constraint "curriculum_academic_years_school_id_year_key" UNIQUE using index "curriculum_academic_years_school_id_year_key";

alter table "public"."curriculum_chapters" add constraint "curriculum_chapters_curriculum_id_fkey" FOREIGN KEY (curriculum_id) REFERENCES public.curriculums(id) ON DELETE CASCADE not valid;

alter table "public"."curriculum_chapters" validate constraint "curriculum_chapters_curriculum_id_fkey";

alter table "public"."curriculum_chapters" add constraint "curriculum_chapters_curriculum_id_order_number_key" UNIQUE using index "curriculum_chapters_curriculum_id_order_number_key";

alter table "public"."curriculum_chapters" add constraint "curriculum_chapters_duration_unit_check" CHECK (((duration_unit)::text = ANY ((ARRAY['hours'::character varying, 'weeks'::character varying])::text[]))) not valid;

alter table "public"."curriculum_chapters" validate constraint "curriculum_chapters_duration_unit_check";

alter table "public"."curriculum_classes" add constraint "curriculum_classes_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."curriculum_classes" validate constraint "curriculum_classes_school_id_fkey";

alter table "public"."curriculum_classes" add constraint "curriculum_classes_school_id_name_key" UNIQUE using index "curriculum_classes_school_id_name_key";

alter table "public"."curriculum_courses" add constraint "curriculum_courses_college_id_course_code_semester_key" UNIQUE using index "curriculum_courses_college_id_course_code_semester_key";

alter table "public"."curriculum_courses" add constraint "curriculum_courses_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."curriculum_courses" validate constraint "curriculum_courses_college_id_fkey";

alter table "public"."curriculum_courses" add constraint "curriculum_courses_course_type_check" CHECK (((course_type)::text = ANY ((ARRAY['Theory'::character varying, 'Practical'::character varying, 'Lab'::character varying, 'Project'::character varying, 'Elective'::character varying, 'Core'::character varying])::text[]))) not valid;

alter table "public"."curriculum_courses" validate constraint "curriculum_courses_course_type_check";

alter table "public"."curriculum_courses" add constraint "curriculum_courses_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."curriculum_courses" validate constraint "curriculum_courses_created_by_fkey";

alter table "public"."curriculum_courses" add constraint "curriculum_courses_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) ON DELETE CASCADE not valid;

alter table "public"."curriculum_courses" validate constraint "curriculum_courses_department_id_fkey";

alter table "public"."curriculum_courses" add constraint "curriculum_courses_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) ON DELETE CASCADE not valid;

alter table "public"."curriculum_courses" validate constraint "curriculum_courses_program_id_fkey";

alter table "public"."curriculum_courses" add constraint "curriculum_courses_semester_check" CHECK (((semester >= 1) AND (semester <= 12))) not valid;

alter table "public"."curriculum_courses" validate constraint "curriculum_courses_semester_check";

alter table "public"."curriculum_learning_outcomes" add constraint "curriculum_learning_outcomes_bloom_level_check" CHECK (((bloom_level)::text = ANY ((ARRAY['Remember'::character varying, 'Understand'::character varying, 'Apply'::character varying, 'Analyze'::character varying, 'Evaluate'::character varying, 'Create'::character varying])::text[]))) not valid;

alter table "public"."curriculum_learning_outcomes" validate constraint "curriculum_learning_outcomes_bloom_level_check";

alter table "public"."curriculum_learning_outcomes" add constraint "curriculum_learning_outcomes_chapter_id_fkey" FOREIGN KEY (chapter_id) REFERENCES public.curriculum_chapters(id) ON DELETE CASCADE not valid;

alter table "public"."curriculum_learning_outcomes" validate constraint "curriculum_learning_outcomes_chapter_id_fkey";

alter table "public"."curriculum_subjects" add constraint "curriculum_subjects_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."curriculum_subjects" validate constraint "curriculum_subjects_school_id_fkey";

alter table "public"."curriculum_subjects" add constraint "curriculum_subjects_school_id_name_key" UNIQUE using index "curriculum_subjects_school_id_name_key";

alter table "public"."curriculums" add constraint "curriculums_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."curriculums" validate constraint "curriculums_approved_by_fkey";

alter table "public"."curriculums" add constraint "curriculums_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."curriculums" validate constraint "curriculums_created_by_fkey";

alter table "public"."curriculums" add constraint "curriculums_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."curriculums" validate constraint "curriculums_school_id_fkey";

alter table "public"."curriculums" add constraint "curriculums_school_id_subject_class_academic_year_key" UNIQUE using index "curriculums_school_id_subject_class_academic_year_key";

alter table "public"."curriculums" add constraint "curriculums_status_check" CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'pending_approval'::character varying, 'approved'::character varying, 'rejected'::character varying])::text[]))) not valid;

alter table "public"."curriculums" validate constraint "curriculums_status_check";

alter table "public"."department_budgets" add constraint "department_budgets_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) not valid;

alter table "public"."department_budgets" validate constraint "department_budgets_approved_by_fkey";

alter table "public"."department_budgets" add constraint "department_budgets_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."department_budgets" validate constraint "department_budgets_created_by_fkey";

alter table "public"."department_budgets" add constraint "department_budgets_department_id_financial_year_quarter_key" UNIQUE using index "department_budgets_department_id_financial_year_quarter_key";

alter table "public"."department_budgets" add constraint "department_budgets_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) ON DELETE CASCADE not valid;

alter table "public"."department_budgets" validate constraint "department_budgets_department_id_fkey";

alter table "public"."department_budgets" add constraint "department_budgets_previous_budget_id_fkey" FOREIGN KEY (previous_budget_id) REFERENCES public.department_budgets(id) not valid;

alter table "public"."department_budgets" validate constraint "department_budgets_previous_budget_id_fkey";

alter table "public"."department_budgets" add constraint "department_budgets_quarter_check" CHECK ((quarter = ANY (ARRAY['Q1'::text, 'Q2'::text, 'Q3'::text, 'Q4'::text, 'Annual'::text]))) not valid;

alter table "public"."department_budgets" validate constraint "department_budgets_quarter_check";

alter table "public"."department_budgets" add constraint "department_budgets_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'pending_approval'::text, 'approved'::text, 'active'::text, 'closed'::text, 'cancelled'::text]))) not valid;

alter table "public"."department_budgets" validate constraint "department_budgets_status_check";

alter table "public"."department_budgets" add constraint "department_budgets_submitted_by_fkey" FOREIGN KEY (submitted_by) REFERENCES public.users(id) not valid;

alter table "public"."department_budgets" validate constraint "department_budgets_submitted_by_fkey";

alter table "public"."department_budgets" add constraint "valid_budget_amounts" CHECK (((total_allocated >= (0)::numeric) AND (total_spent >= (0)::numeric) AND (carry_forward_amount >= (0)::numeric))) not valid;

alter table "public"."department_budgets" validate constraint "valid_budget_amounts";

alter table "public"."department_budgets" add constraint "valid_period" CHECK ((period_to > period_from)) not valid;

alter table "public"."department_budgets" validate constraint "valid_period";

alter table "public"."department_budgets" add constraint "valid_threshold" CHECK (((alert_threshold_percentage >= (0)::numeric) AND (alert_threshold_percentage <= (100)::numeric))) not valid;

alter table "public"."department_budgets" validate constraint "valid_threshold";

alter table "public"."department_faculty_assignments" add constraint "department_faculty_assignments_assigned_by_fkey" FOREIGN KEY (assigned_by) REFERENCES public.users(id) not valid;

alter table "public"."department_faculty_assignments" validate constraint "department_faculty_assignments_assigned_by_fkey";

alter table "public"."department_faculty_assignments" add constraint "department_faculty_assignments_assignment_type_check" CHECK (((assignment_type)::text = ANY ((ARRAY['faculty'::character varying, 'hod'::character varying, 'coordinator'::character varying, 'assistant'::character varying])::text[]))) not valid;

alter table "public"."department_faculty_assignments" validate constraint "department_faculty_assignments_assignment_type_check";

alter table "public"."department_faculty_assignments" add constraint "department_faculty_assignments_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) ON DELETE CASCADE not valid;

alter table "public"."department_faculty_assignments" validate constraint "department_faculty_assignments_department_id_fkey";

alter table "public"."department_faculty_assignments" add constraint "department_faculty_assignments_lecturer_id_fkey" FOREIGN KEY (lecturer_id) REFERENCES public.college_lecturers(id) ON DELETE CASCADE not valid;

alter table "public"."department_faculty_assignments" validate constraint "department_faculty_assignments_lecturer_id_fkey";

alter table "public"."department_faculty_assignments" add constraint "department_faculty_assignments_single_hod" EXCLUDE USING btree (department_id WITH =) WHERE (((is_hod = true) AND (is_active = true)));

alter table "public"."department_faculty_assignments" add constraint "department_faculty_assignments_unique_lecturer_dept" UNIQUE using index "department_faculty_assignments_unique_lecturer_dept";

alter table "public"."departments" add constraint "chk_departments_institution" CHECK ((((school_id IS NOT NULL) AND (college_id IS NULL)) OR ((school_id IS NULL) AND (college_id IS NOT NULL)))) not valid;

alter table "public"."departments" validate constraint "chk_departments_institution";

alter table "public"."departments" add constraint "departments_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."departments" validate constraint "departments_college_id_fkey";

alter table "public"."departments" add constraint "departments_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."departments" validate constraint "departments_created_by_fkey";

alter table "public"."departments" add constraint "departments_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."departments" validate constraint "departments_school_id_fkey";

alter table "public"."departments" add constraint "departments_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) not valid;

alter table "public"."departments" validate constraint "departments_updated_by_fkey";

alter table "public"."document_access_history" add constraint "document_access_history_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."document_access_history" validate constraint "document_access_history_user_id_fkey";

alter table "public"."education" add constraint "education_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."education" validate constraint "education_student_id_fkey";

alter table "public"."embedding_cache" add constraint "embedding_cache_cache_type_check" CHECK ((cache_type = ANY (ARRAY['profile'::text, 'skill'::text, 'course'::text]))) not valid;

alter table "public"."embedding_cache" validate constraint "embedding_cache_cache_type_check";

alter table "public"."embedding_cache" add constraint "unique_text_hash_type" UNIQUE using index "unique_text_hash_type";

alter table "public"."embedding_queue" add constraint "embedding_queue_priority_check" CHECK (((priority >= 1) AND (priority <= 10))) not valid;

alter table "public"."embedding_queue" validate constraint "embedding_queue_priority_check";

alter table "public"."embedding_queue" add constraint "embedding_queue_record_status_unique" UNIQUE using index "embedding_queue_record_status_unique";

alter table "public"."embedding_queue" add constraint "embedding_queue_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'processing'::text, 'completed'::text, 'failed'::text]))) not valid;

alter table "public"."embedding_queue" validate constraint "embedding_queue_status_check";

alter table "public"."embedding_queue" add constraint "embedding_queue_table_name_check" CHECK ((table_name = ANY (ARRAY['students'::text, 'opportunities'::text, 'courses'::text]))) not valid;

alter table "public"."embedding_queue" validate constraint "embedding_queue_table_name_check";

alter table "public"."event_registrations" add constraint "event_registrations_student_tier_id_fkey" FOREIGN KEY (student_tier_id) REFERENCES public.institution_pricing_tiers(id) not valid;

alter table "public"."event_registrations" validate constraint "event_registrations_student_tier_id_fkey";

alter table "public"."event_registrations" add constraint "event_registrations_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) not valid;

alter table "public"."event_registrations" validate constraint "event_registrations_user_id_fkey";

alter table "public"."exam_registrations" add constraint "exam_registrations_assessment_id_fkey" FOREIGN KEY (assessment_id) REFERENCES public.assessments(id) not valid;

alter table "public"."exam_registrations" validate constraint "exam_registrations_assessment_id_fkey";

alter table "public"."exam_registrations" add constraint "exam_registrations_exam_window_id_fkey" FOREIGN KEY (exam_window_id) REFERENCES public.exam_windows(id) ON DELETE CASCADE not valid;

alter table "public"."exam_registrations" validate constraint "exam_registrations_exam_window_id_fkey";

alter table "public"."exam_registrations" add constraint "exam_registrations_exam_window_id_student_id_assessment_id_key" UNIQUE using index "exam_registrations_exam_window_id_student_id_assessment_id_key";

alter table "public"."exam_registrations" add constraint "exam_registrations_hall_ticket_number_key" UNIQUE using index "exam_registrations_hall_ticket_number_key";

alter table "public"."exam_registrations" add constraint "exam_registrations_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) not valid;

alter table "public"."exam_registrations" validate constraint "exam_registrations_program_id_fkey";

alter table "public"."exam_registrations" add constraint "exam_registrations_registration_number_key" UNIQUE using index "exam_registrations_registration_number_key";

alter table "public"."exam_registrations" add constraint "exam_registrations_registration_type_check" CHECK ((registration_type = ANY (ARRAY['regular'::text, 'arrear'::text, 'improvement'::text, 'supplementary'::text]))) not valid;

alter table "public"."exam_registrations" validate constraint "exam_registrations_registration_type_check";

alter table "public"."exam_registrations" add constraint "exam_registrations_status_check" CHECK ((status = ANY (ARRAY['registered'::text, 'confirmed'::text, 'cancelled'::text, 'appeared'::text, 'absent'::text]))) not valid;

alter table "public"."exam_registrations" validate constraint "exam_registrations_status_check";

alter table "public"."exam_registrations" add constraint "exam_registrations_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."exam_registrations" validate constraint "exam_registrations_student_id_fkey";

alter table "public"."exam_registrations" add constraint "exam_registrations_student_record_id_fkey" FOREIGN KEY (student_record_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."exam_registrations" validate constraint "exam_registrations_student_record_id_fkey";

alter table "public"."exam_rooms" add constraint "chk_exam_room_institution" CHECK ((((school_id IS NOT NULL) AND (college_id IS NULL)) OR ((school_id IS NULL) AND (college_id IS NOT NULL)))) not valid;

alter table "public"."exam_rooms" validate constraint "chk_exam_room_institution";

alter table "public"."exam_rooms" add constraint "exam_rooms_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."exam_rooms" validate constraint "exam_rooms_college_id_fkey";

alter table "public"."exam_rooms" add constraint "exam_rooms_room_code_key" UNIQUE using index "exam_rooms_room_code_key";

alter table "public"."exam_rooms" add constraint "exam_rooms_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."exam_rooms" validate constraint "exam_rooms_school_id_fkey";

alter table "public"."exam_rooms" add constraint "exam_rooms_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'maintenance'::text, 'unavailable'::text, 'retired'::text]))) not valid;

alter table "public"."exam_rooms" validate constraint "exam_rooms_status_check";

alter table "public"."exam_rooms" add constraint "valid_capacity" CHECK ((exam_capacity <= total_capacity)) not valid;

alter table "public"."exam_rooms" validate constraint "valid_capacity";

alter table "public"."exam_seating_arrangements" add constraint "exam_seating_arrangements_attendance_status_check" CHECK ((attendance_status = ANY (ARRAY['expected'::text, 'present'::text, 'absent'::text, 'late'::text]))) not valid;

alter table "public"."exam_seating_arrangements" validate constraint "exam_seating_arrangements_attendance_status_check";

alter table "public"."exam_seating_arrangements" add constraint "exam_seating_arrangements_exam_room_id_fkey" FOREIGN KEY (exam_room_id) REFERENCES public.exam_rooms(id) not valid;

alter table "public"."exam_seating_arrangements" validate constraint "exam_seating_arrangements_exam_room_id_fkey";

alter table "public"."exam_seating_arrangements" add constraint "exam_seating_arrangements_exam_timetable_id_exam_room_id_se_key" UNIQUE using index "exam_seating_arrangements_exam_timetable_id_exam_room_id_se_key";

alter table "public"."exam_seating_arrangements" add constraint "exam_seating_arrangements_exam_timetable_id_fkey" FOREIGN KEY (exam_timetable_id) REFERENCES public.exam_timetable(id) ON DELETE CASCADE not valid;

alter table "public"."exam_seating_arrangements" validate constraint "exam_seating_arrangements_exam_timetable_id_fkey";

alter table "public"."exam_seating_arrangements" add constraint "exam_seating_arrangements_exam_timetable_id_student_id_key" UNIQUE using index "exam_seating_arrangements_exam_timetable_id_student_id_key";

alter table "public"."exam_seating_arrangements" add constraint "exam_seating_arrangements_marked_by_fkey" FOREIGN KEY (marked_by) REFERENCES public.users(id) not valid;

alter table "public"."exam_seating_arrangements" validate constraint "exam_seating_arrangements_marked_by_fkey";

alter table "public"."exam_seating_arrangements" add constraint "exam_seating_arrangements_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) not valid;

alter table "public"."exam_seating_arrangements" validate constraint "exam_seating_arrangements_student_id_fkey";

alter table "public"."exam_seating_arrangements" add constraint "exam_seating_arrangements_student_record_id_fkey" FOREIGN KEY (student_record_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."exam_seating_arrangements" validate constraint "exam_seating_arrangements_student_record_id_fkey";

alter table "public"."exam_timetable" add constraint "exam_timetable_assessment_id_fkey" FOREIGN KEY (assessment_id) REFERENCES public.assessments(id) ON DELETE CASCADE not valid;

alter table "public"."exam_timetable" validate constraint "exam_timetable_assessment_id_fkey";

alter table "public"."exam_timetable" add constraint "exam_timetable_chief_invigilator_fkey" FOREIGN KEY (chief_invigilator) REFERENCES public.users(id) not valid;

alter table "public"."exam_timetable" validate constraint "exam_timetable_chief_invigilator_fkey";

alter table "public"."exam_timetable" add constraint "exam_timetable_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."exam_timetable" validate constraint "exam_timetable_school_id_fkey";

alter table "public"."exam_timetable" add constraint "exam_timetable_status_check" CHECK ((status = ANY (ARRAY['scheduled'::text, 'ongoing'::text, 'completed'::text, 'cancelled'::text, 'rescheduled'::text]))) not valid;

alter table "public"."exam_timetable" validate constraint "exam_timetable_status_check";

alter table "public"."exam_timetable" add constraint "fk_timetable_class" FOREIGN KEY (class_id) REFERENCES public.school_classes(id) not valid;

alter table "public"."exam_timetable" validate constraint "fk_timetable_class";

alter table "public"."exam_timetable" add constraint "fk_timetable_subject" FOREIGN KEY (subject_id) REFERENCES public.curriculum_subjects(id) not valid;

alter table "public"."exam_timetable" validate constraint "fk_timetable_subject";

alter table "public"."exam_timetable" add constraint "valid_capacity" CHECK (((capacity IS NULL) OR (capacity > 0))) not valid;

alter table "public"."exam_timetable" validate constraint "valid_capacity";

alter table "public"."exam_timetable" add constraint "valid_time_range" CHECK ((end_time > start_time)) not valid;

alter table "public"."exam_timetable" validate constraint "valid_time_range";

alter table "public"."exam_windows" add constraint "chk_exam_window_institution" CHECK ((((school_id IS NOT NULL) AND (college_id IS NULL)) OR ((school_id IS NULL) AND (college_id IS NOT NULL)) OR ((school_id IS NULL) AND (college_id IS NULL)))) not valid;

alter table "public"."exam_windows" validate constraint "chk_exam_window_institution";

alter table "public"."exam_windows" add constraint "exam_windows_assessment_type_id_fkey" FOREIGN KEY (assessment_type_id) REFERENCES public.assessment_types(id) not valid;

alter table "public"."exam_windows" validate constraint "exam_windows_assessment_type_id_fkey";

alter table "public"."exam_windows" add constraint "exam_windows_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."exam_windows" validate constraint "exam_windows_college_id_fkey";

alter table "public"."exam_windows" add constraint "exam_windows_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."exam_windows" validate constraint "exam_windows_created_by_fkey";

alter table "public"."exam_windows" add constraint "exam_windows_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) not valid;

alter table "public"."exam_windows" validate constraint "exam_windows_department_id_fkey";

alter table "public"."exam_windows" add constraint "exam_windows_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) not valid;

alter table "public"."exam_windows" validate constraint "exam_windows_program_id_fkey";

alter table "public"."exam_windows" add constraint "exam_windows_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."exam_windows" validate constraint "exam_windows_school_id_fkey";

alter table "public"."exam_windows" add constraint "exam_windows_semester_check" CHECK ((semester = ANY (ARRAY['Odd'::text, 'Even'::text, 'Summer'::text, '1'::text, '2'::text]))) not valid;

alter table "public"."exam_windows" validate constraint "exam_windows_semester_check";

alter table "public"."exam_windows" add constraint "exam_windows_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'scheduled'::text, 'ongoing'::text, 'completed'::text, 'cancelled'::text]))) not valid;

alter table "public"."exam_windows" validate constraint "exam_windows_status_check";

alter table "public"."exam_windows" add constraint "exam_windows_window_code_key" UNIQUE using index "exam_windows_window_code_key";

alter table "public"."exam_windows" add constraint "valid_exam_window_dates" CHECK ((end_date >= start_date)) not valid;

alter table "public"."exam_windows" validate constraint "valid_exam_window_dates";

alter table "public"."exam_windows" add constraint "valid_registration_dates" CHECK (((registration_start_date IS NULL) OR (registration_end_date IS NULL) OR (registration_end_date >= registration_start_date))) not valid;

alter table "public"."exam_windows" validate constraint "valid_registration_dates";

alter table "public"."expenditures" add constraint "expenditures_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) not valid;

alter table "public"."expenditures" validate constraint "expenditures_approved_by_fkey";

alter table "public"."expenditures" add constraint "expenditures_budget_id_fkey" FOREIGN KEY (budget_id) REFERENCES public.department_budgets(id) ON DELETE CASCADE not valid;

alter table "public"."expenditures" validate constraint "expenditures_budget_id_fkey";

alter table "public"."expenditures" add constraint "expenditures_category_check" CHECK ((category = ANY (ARRAY['Salaries'::text, 'Equipment'::text, 'Maintenance'::text, 'Supplies'::text, 'Travel'::text, 'Training'::text, 'Software'::text, 'Infrastructure'::text, 'Events'::text, 'Research'::text, 'Consultancy'::text, 'Other'::text]))) not valid;

alter table "public"."expenditures" validate constraint "expenditures_category_check";

alter table "public"."expenditures" add constraint "expenditures_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) ON DELETE CASCADE not valid;

alter table "public"."expenditures" validate constraint "expenditures_department_id_fkey";

alter table "public"."expenditures" add constraint "expenditures_expenditure_number_key" UNIQUE using index "expenditures_expenditure_number_key";

alter table "public"."expenditures" add constraint "expenditures_override_approved_by_fkey" FOREIGN KEY (override_approved_by) REFERENCES public.users(id) not valid;

alter table "public"."expenditures" validate constraint "expenditures_override_approved_by_fkey";

alter table "public"."expenditures" add constraint "expenditures_payment_mode_check" CHECK ((payment_mode = ANY (ARRAY['cash'::text, 'cheque'::text, 'bank_transfer'::text, 'upi'::text, 'card'::text, 'dd'::text]))) not valid;

alter table "public"."expenditures" validate constraint "expenditures_payment_mode_check";

alter table "public"."expenditures" add constraint "expenditures_payment_status_check" CHECK ((payment_status = ANY (ARRAY['pending'::text, 'paid'::text, 'partial'::text, 'cancelled'::text]))) not valid;

alter table "public"."expenditures" validate constraint "expenditures_payment_status_check";

alter table "public"."expenditures" add constraint "expenditures_recorded_by_fkey" FOREIGN KEY (recorded_by) REFERENCES public.users(id) not valid;

alter table "public"."expenditures" validate constraint "expenditures_recorded_by_fkey";

alter table "public"."expenditures" add constraint "expenditures_reimbursement_status_check" CHECK ((reimbursement_status = ANY (ARRAY['pending'::text, 'processed'::text, 'paid'::text]))) not valid;

alter table "public"."expenditures" validate constraint "expenditures_reimbursement_status_check";

alter table "public"."expenditures" add constraint "expenditures_reimbursement_to_fkey" FOREIGN KEY (reimbursement_to) REFERENCES public.users(id) not valid;

alter table "public"."expenditures" validate constraint "expenditures_reimbursement_to_fkey";

alter table "public"."expenditures" add constraint "expenditures_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'pending_approval'::text, 'approved'::text, 'rejected'::text, 'paid'::text]))) not valid;

alter table "public"."expenditures" validate constraint "expenditures_status_check";

alter table "public"."expenditures" add constraint "expenditures_submitted_by_fkey" FOREIGN KEY (submitted_by) REFERENCES public.users(id) not valid;

alter table "public"."expenditures" validate constraint "expenditures_submitted_by_fkey";

alter table "public"."expenditures" add constraint "valid_expenditure_amounts" CHECK (((amount >= (0)::numeric) AND (tax_amount >= (0)::numeric))) not valid;

alter table "public"."expenditures" validate constraint "valid_expenditure_amounts";

alter table "public"."expenditures" add constraint "valid_payment_date" CHECK (((payment_date IS NULL) OR (payment_date >= expenditure_date))) not valid;

alter table "public"."expenditures" validate constraint "valid_payment_date";

alter table "public"."experience" add constraint "experience_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) not valid;

alter table "public"."experience" validate constraint "experience_approved_by_fkey";

alter table "public"."experience" add constraint "experience_rejected_by_fkey" FOREIGN KEY (rejected_by) REFERENCES public.users(id) not valid;

alter table "public"."experience" validate constraint "experience_rejected_by_fkey";

alter table "public"."experience" add constraint "experience_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."experience" validate constraint "experience_student_id_fkey";

alter table "public"."export_activities" add constraint "export_activities_shortlist_id_fkey" FOREIGN KEY (shortlist_id) REFERENCES public.shortlists(id) ON DELETE CASCADE not valid;

alter table "public"."export_activities" validate constraint "export_activities_shortlist_id_fkey";

alter table "public"."external_assessment_attempts" add constraint "external_assessment_attempts_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."external_assessment_attempts" validate constraint "external_assessment_attempts_student_id_fkey";

alter table "public"."external_courses" add constraint "external_courses_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(user_id) ON DELETE CASCADE not valid;

alter table "public"."external_courses" validate constraint "external_courses_student_id_fkey";

alter table "public"."external_courses" add constraint "external_courses_training_id_fkey" FOREIGN KEY (training_id) REFERENCES public.trainings(id) ON DELETE SET NULL not valid;

alter table "public"."external_courses" validate constraint "external_courses_training_id_fkey";

alter table "public"."fee_payments" add constraint "fee_payments_ledger_id_fkey" FOREIGN KEY (ledger_id) REFERENCES public.student_ledgers(id) ON DELETE CASCADE not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_ledger_id_fkey";

alter table "public"."fee_payments" add constraint "fee_payments_mode_check" CHECK ((mode = ANY (ARRAY['cash'::text, 'upi'::text, 'card'::text, 'cheque'::text, 'bank_transfer'::text, 'dd'::text, 'online'::text]))) not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_mode_check";

alter table "public"."fee_payments" add constraint "fee_payments_receipt_number_key" UNIQUE using index "fee_payments_receipt_number_key";

alter table "public"."fee_payments" add constraint "fee_payments_reconciled_by_fkey" FOREIGN KEY (reconciled_by) REFERENCES public.users(id) not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_reconciled_by_fkey";

alter table "public"."fee_payments" add constraint "fee_payments_recorded_by_fkey" FOREIGN KEY (recorded_by) REFERENCES public.users(id) not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_recorded_by_fkey";

alter table "public"."fee_payments" add constraint "fee_payments_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'completed'::text, 'failed'::text, 'refunded'::text, 'cancelled'::text]))) not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_status_check";

alter table "public"."fee_payments" add constraint "fee_payments_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_student_id_fkey";

alter table "public"."fee_payments" add constraint "fee_payments_verified_by_fkey" FOREIGN KEY (verified_by) REFERENCES public.users(id) not valid;

alter table "public"."fee_payments" validate constraint "fee_payments_verified_by_fkey";

alter table "public"."fee_payments" add constraint "valid_payment_amount" CHECK ((amount > (0)::numeric)) not valid;

alter table "public"."fee_payments" validate constraint "valid_payment_amount";

alter table "public"."fee_structures" add constraint "fee_structures_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) not valid;

alter table "public"."fee_structures" validate constraint "fee_structures_approved_by_fkey";

alter table "public"."fee_structures" add constraint "fee_structures_category_check" CHECK ((category = ANY (ARRAY['General'::text, 'OBC'::text, 'SC'::text, 'ST'::text, 'EWS'::text, 'Management'::text, 'NRI'::text, 'Foreign'::text]))) not valid;

alter table "public"."fee_structures" validate constraint "fee_structures_category_check";

alter table "public"."fee_structures" add constraint "fee_structures_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."fee_structures" validate constraint "fee_structures_college_id_fkey";

alter table "public"."fee_structures" add constraint "fee_structures_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."fee_structures" validate constraint "fee_structures_created_by_fkey";

alter table "public"."fee_structures" add constraint "fee_structures_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) ON DELETE CASCADE not valid;

alter table "public"."fee_structures" validate constraint "fee_structures_program_id_fkey";

alter table "public"."fee_structures" add constraint "fee_structures_program_id_semester_category_academic_year_key" UNIQUE using index "fee_structures_program_id_semester_category_academic_year_key";

alter table "public"."fee_structures" add constraint "fee_structures_quota_check" CHECK ((quota = ANY (ARRAY['Merit'::text, 'Management'::text, 'NRI'::text, 'Sports'::text, 'Defense'::text]))) not valid;

alter table "public"."fee_structures" validate constraint "fee_structures_quota_check";

alter table "public"."fee_structures" add constraint "fee_structures_semester_check" CHECK (((semester >= 1) AND (semester <= 12))) not valid;

alter table "public"."fee_structures" validate constraint "fee_structures_semester_check";

alter table "public"."fee_structures" add constraint "valid_discount" CHECK (((discount_percentage >= (0)::numeric) AND (discount_percentage <= (100)::numeric))) not valid;

alter table "public"."fee_structures" validate constraint "valid_discount";

alter table "public"."fee_structures" add constraint "valid_scholarship" CHECK (((scholarship_amount >= (0)::numeric) AND (scholarship_amount <= total_amount))) not valid;

alter table "public"."fee_structures" validate constraint "valid_scholarship";

alter table "public"."fee_structures" add constraint "valid_total" CHECK ((total_amount >= (0)::numeric)) not valid;

alter table "public"."fee_structures" validate constraint "valid_total";

alter table "public"."generated_external_assessment" add constraint "generated_external_assessment_certificate_name_key" UNIQUE using index "generated_external_assessment_certificate_name_key";

alter table "public"."grading_systems" add constraint "grading_systems_applicable_to_check" CHECK ((applicable_to = ANY (ARRAY['all'::text, 'school'::text, 'college'::text, 'university'::text]))) not valid;

alter table "public"."grading_systems" validate constraint "grading_systems_applicable_to_check";

alter table "public"."grading_systems" add constraint "grading_systems_system_code_grade_label_key" UNIQUE using index "grading_systems_system_code_grade_label_key";

alter table "public"."grading_systems" add constraint "grading_systems_system_code_key" UNIQUE using index "grading_systems_system_code_key";

alter table "public"."grading_systems" add constraint "valid_grade_point" CHECK (((grade_point >= (0)::numeric) AND (grade_point <= (10)::numeric))) not valid;

alter table "public"."grading_systems" validate constraint "valid_grade_point";

alter table "public"."grading_systems" add constraint "valid_marks_range" CHECK ((max_marks > min_marks)) not valid;

alter table "public"."grading_systems" validate constraint "valid_marks_range";

alter table "public"."internships" add constraint "internships_approval_status_check" CHECK ((approval_status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."internships" validate constraint "internships_approval_status_check";

alter table "public"."internships" add constraint "internships_internship_type_check" CHECK ((internship_type = ANY (ARRAY['Full-time'::text, 'Part-time'::text, 'Remote'::text, 'Hybrid'::text]))) not valid;

alter table "public"."internships" validate constraint "internships_internship_type_check";

alter table "public"."internships" add constraint "internships_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) not valid;

alter table "public"."internships" validate constraint "internships_reviewed_by_fkey";

alter table "public"."internships" add constraint "internships_student_id_fkey" FOREIGN KEY (student_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."internships" validate constraint "internships_student_id_fkey";

alter table "public"."interview_reminders" add constraint "interview_reminders_interview_id_fkey" FOREIGN KEY (interview_id) REFERENCES public.interviews(id) ON DELETE CASCADE not valid;

alter table "public"."interview_reminders" validate constraint "interview_reminders_interview_id_fkey";

alter table "public"."interviews" add constraint "interviews_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(user_id) not valid;

alter table "public"."interviews" validate constraint "interviews_student_id_fkey";

alter table "public"."invigilator_assignments" add constraint "invigilator_assignments_assigned_by_fkey" FOREIGN KEY (assigned_by) REFERENCES public.users(id) not valid;

alter table "public"."invigilator_assignments" validate constraint "invigilator_assignments_assigned_by_fkey";

alter table "public"."invigilator_assignments" add constraint "invigilator_assignments_attendance_status_check" CHECK ((attendance_status = ANY (ARRAY['assigned'::text, 'present'::text, 'absent'::text, 'relieved'::text]))) not valid;

alter table "public"."invigilator_assignments" validate constraint "invigilator_assignments_attendance_status_check";

alter table "public"."invigilator_assignments" add constraint "invigilator_assignments_exam_room_id_fkey" FOREIGN KEY (exam_room_id) REFERENCES public.exam_rooms(id) not valid;

alter table "public"."invigilator_assignments" validate constraint "invigilator_assignments_exam_room_id_fkey";

alter table "public"."invigilator_assignments" add constraint "invigilator_assignments_exam_timetable_id_fkey" FOREIGN KEY (exam_timetable_id) REFERENCES public.exam_timetable(id) ON DELETE CASCADE not valid;

alter table "public"."invigilator_assignments" validate constraint "invigilator_assignments_exam_timetable_id_fkey";

alter table "public"."invigilator_assignments" add constraint "invigilator_assignments_invigilator_id_fkey" FOREIGN KEY (invigilator_id) REFERENCES public.users(id) not valid;

alter table "public"."invigilator_assignments" validate constraint "invigilator_assignments_invigilator_id_fkey";

alter table "public"."invigilator_assignments" add constraint "invigilator_assignments_invigilator_type_check" CHECK ((invigilator_type = ANY (ARRAY['chief'::text, 'regular'::text, 'relief'::text, 'external'::text]))) not valid;

alter table "public"."invigilator_assignments" validate constraint "invigilator_assignments_invigilator_type_check";

alter table "public"."invigilator_assignments" add constraint "invigilator_assignments_lecturer_record_id_fkey" FOREIGN KEY (lecturer_record_id) REFERENCES public.college_lecturers(id) ON DELETE SET NULL not valid;

alter table "public"."invigilator_assignments" validate constraint "invigilator_assignments_lecturer_record_id_fkey";

alter table "public"."invigilator_assignments" add constraint "valid_duty_time" CHECK ((duty_end_time > duty_start_time)) not valid;

alter table "public"."invigilator_assignments" validate constraint "valid_duty_time";

alter table "public"."lesson_plans" add constraint "lesson_plans_chapter_id_fkey" FOREIGN KEY (chapter_id) REFERENCES public.curriculum_chapters(id) ON DELETE SET NULL not valid;

alter table "public"."lesson_plans" validate constraint "lesson_plans_chapter_id_fkey";

alter table "public"."lesson_plans" add constraint "lesson_plans_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.school_classes(id) ON DELETE SET NULL not valid;

alter table "public"."lesson_plans" validate constraint "lesson_plans_class_id_fkey";

alter table "public"."lesson_plans" add constraint "lesson_plans_educator_id_fkey" FOREIGN KEY (educator_id) REFERENCES public.school_educators(id) ON DELETE CASCADE not valid;

alter table "public"."lesson_plans" validate constraint "lesson_plans_educator_id_fkey";

alter table "public"."lesson_plans" add constraint "lesson_plans_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES auth.users(id) not valid;

alter table "public"."lesson_plans" validate constraint "lesson_plans_reviewed_by_fkey";

alter table "public"."lesson_plans" add constraint "lesson_plans_status_check" CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'submitted'::character varying, 'approved'::character varying, 'rejected'::character varying, 'revision_required'::character varying])::text[]))) not valid;

alter table "public"."lesson_plans" validate constraint "lesson_plans_status_check";

alter table "public"."lesson_resources" add constraint "fk_lesson" FOREIGN KEY (lesson_id) REFERENCES public.lessons(lesson_id) ON DELETE CASCADE not valid;

alter table "public"."lesson_resources" validate constraint "fk_lesson";

alter table "public"."lesson_resources" add constraint "lesson_resources_type_check" CHECK (((type)::text = ANY ((ARRAY['pdf'::character varying, 'video'::character varying, 'image'::character varying, 'document'::character varying, 'link'::character varying, 'youtube'::character varying, 'drive'::character varying])::text[]))) not valid;

alter table "public"."lesson_resources" validate constraint "lesson_resources_type_check";

alter table "public"."lessons" add constraint "fk_module" FOREIGN KEY (module_id) REFERENCES public.course_modules(module_id) ON DELETE CASCADE not valid;

alter table "public"."lessons" validate constraint "fk_module";

alter table "public"."library_book_issues" add constraint "check_return_date" CHECK (((return_date IS NULL) OR (return_date >= issue_date))) not valid;

alter table "public"."library_book_issues" validate constraint "check_return_date";

alter table "public"."library_book_issues" add constraint "library_book_issues_book_id_fkey" FOREIGN KEY (book_id) REFERENCES public.library_books(id) ON DELETE CASCADE not valid;

alter table "public"."library_book_issues" validate constraint "library_book_issues_book_id_fkey";

alter table "public"."library_book_issues" add constraint "library_book_issues_status_check" CHECK ((status = ANY (ARRAY['issued'::text, 'returned'::text, 'overdue'::text]))) not valid;

alter table "public"."library_book_issues" validate constraint "library_book_issues_status_check";

alter table "public"."library_book_issues" add constraint "library_book_issues_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."library_book_issues" validate constraint "library_book_issues_student_id_fkey";

alter table "public"."library_book_issues_college" add constraint "check_return_date" CHECK (((return_date IS NULL) OR (return_date >= issue_date))) not valid;

alter table "public"."library_book_issues_college" validate constraint "check_return_date";

alter table "public"."library_book_issues_college" add constraint "library_book_issues_college_book_id_fkey" FOREIGN KEY (book_id) REFERENCES public.library_books_college(id) ON DELETE CASCADE not valid;

alter table "public"."library_book_issues_college" validate constraint "library_book_issues_college_book_id_fkey";

alter table "public"."library_book_issues_college" add constraint "library_book_issues_college_status_check" CHECK ((status = ANY (ARRAY['issued'::text, 'returned'::text, 'overdue'::text]))) not valid;

alter table "public"."library_book_issues_college" validate constraint "library_book_issues_college_status_check";

alter table "public"."library_book_issues_school" add constraint "check_return_date_school" CHECK (((return_date IS NULL) OR (return_date >= issue_date))) not valid;

alter table "public"."library_book_issues_school" validate constraint "check_return_date_school";

alter table "public"."library_book_issues_school" add constraint "library_book_issues_school_book_id_fkey" FOREIGN KEY (book_id) REFERENCES public.library_books_school(id) ON DELETE CASCADE not valid;

alter table "public"."library_book_issues_school" validate constraint "library_book_issues_school_book_id_fkey";

alter table "public"."library_book_issues_school" add constraint "library_book_issues_school_status_check" CHECK ((status = ANY (ARRAY['issued'::text, 'returned'::text, 'overdue'::text]))) not valid;

alter table "public"."library_book_issues_school" validate constraint "library_book_issues_school_status_check";

alter table "public"."library_books" add constraint "library_books_acquisition_type_check" CHECK ((acquisition_type = ANY (ARRAY['Purchase'::text, 'Donation'::text, 'Exchange'::text, 'Gift'::text]))) not valid;

alter table "public"."library_books" validate constraint "library_books_acquisition_type_check";

alter table "public"."library_books" add constraint "library_books_binding_type_check" CHECK ((binding_type = ANY (ARRAY['Hardcover'::text, 'Paperback'::text, 'Spiral'::text, 'Leather'::text]))) not valid;

alter table "public"."library_books" validate constraint "library_books_binding_type_check";

alter table "public"."library_books" add constraint "library_books_book_id_key" UNIQUE using index "library_books_book_id_key";

alter table "public"."library_books" add constraint "library_books_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."library_books" validate constraint "library_books_college_id_fkey";

alter table "public"."library_books" add constraint "library_books_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."library_books" validate constraint "library_books_created_by_fkey";

alter table "public"."library_books" add constraint "library_books_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) not valid;

alter table "public"."library_books" validate constraint "library_books_department_id_fkey";

alter table "public"."library_books" add constraint "library_books_isbn_key" UNIQUE using index "library_books_isbn_key";

alter table "public"."library_books" add constraint "library_books_status_check" CHECK ((status = ANY (ARRAY['available'::text, 'issued'::text, 'reserved'::text, 'maintenance'::text, 'lost'::text, 'damaged'::text, 'withdrawn'::text]))) not valid;

alter table "public"."library_books" validate constraint "library_books_status_check";

alter table "public"."library_books" add constraint "valid_copies" CHECK (((total_copies >= 0) AND (available_copies >= 0) AND (available_copies <= total_copies) AND (damaged_copies >= 0) AND (lost_copies >= 0))) not valid;

alter table "public"."library_books" validate constraint "valid_copies";

alter table "public"."library_books" add constraint "valid_rating" CHECK (((average_rating >= (0)::numeric) AND (average_rating <= (5)::numeric))) not valid;

alter table "public"."library_books" validate constraint "valid_rating";

alter table "public"."library_books" add constraint "valid_year" CHECK (((publication_year IS NULL) OR ((publication_year)::numeric <= EXTRACT(year FROM CURRENT_DATE)))) not valid;

alter table "public"."library_books" validate constraint "valid_year";

alter table "public"."library_books_college" add constraint "check_available_copies" CHECK (((available_copies >= 0) AND (available_copies <= total_copies))) not valid;

alter table "public"."library_books_college" validate constraint "check_available_copies";

alter table "public"."library_books_college" add constraint "library_books_college_college_id_isbn_key" UNIQUE using index "library_books_college_college_id_isbn_key";

alter table "public"."library_books_college" add constraint "library_books_college_status_check" CHECK ((status = ANY (ARRAY['available'::text, 'all_issued'::text, 'maintenance'::text]))) not valid;

alter table "public"."library_books_college" validate constraint "library_books_college_status_check";

alter table "public"."library_books_school" add constraint "check_available_copies_school" CHECK (((available_copies >= 0) AND (available_copies <= total_copies))) not valid;

alter table "public"."library_books_school" validate constraint "check_available_copies_school";

alter table "public"."library_books_school" add constraint "library_books_school_status_check" CHECK ((status = ANY (ARRAY['available'::text, 'all_issued'::text, 'maintenance'::text]))) not valid;

alter table "public"."library_books_school" validate constraint "library_books_school_status_check";

alter table "public"."library_books_school" add constraint "unique_isbn_per_school" UNIQUE using index "unique_isbn_per_school";

alter table "public"."library_categories" add constraint "library_categories_name_key" UNIQUE using index "library_categories_name_key";

alter table "public"."library_categories_college" add constraint "library_categories_college_college_id_name_key" UNIQUE using index "library_categories_college_college_id_name_key";

alter table "public"."library_categories_school" add constraint "unique_category_per_school" UNIQUE using index "unique_category_per_school";

alter table "public"."library_history" add constraint "library_history_book_id_fkey" FOREIGN KEY (book_id) REFERENCES public.library_books(id) ON DELETE SET NULL not valid;

alter table "public"."library_history" validate constraint "library_history_book_id_fkey";

alter table "public"."library_history" add constraint "library_history_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) not valid;

alter table "public"."library_history" validate constraint "library_history_department_id_fkey";

alter table "public"."library_history" add constraint "library_history_issued_by_fkey" FOREIGN KEY (issued_by) REFERENCES public.users(id) not valid;

alter table "public"."library_history" validate constraint "library_history_issued_by_fkey";

alter table "public"."library_history" add constraint "library_history_returned_to_fkey" FOREIGN KEY (returned_to) REFERENCES public.users(id) not valid;

alter table "public"."library_history" validate constraint "library_history_returned_to_fkey";

alter table "public"."library_history" add constraint "library_history_status_check" CHECK ((status = ANY (ARRAY['returned'::text, 'lost'::text, 'damaged'::text]))) not valid;

alter table "public"."library_history" validate constraint "library_history_status_check";

alter table "public"."library_history" add constraint "library_history_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."library_history" validate constraint "library_history_student_id_fkey";

alter table "public"."library_history" add constraint "library_history_student_record_id_fkey" FOREIGN KEY (student_record_id) REFERENCES public.students(id) ON DELETE SET NULL not valid;

alter table "public"."library_history" validate constraint "library_history_student_record_id_fkey";

alter table "public"."library_history" add constraint "valid_history_dates" CHECK (((return_date IS NULL) OR (return_date >= issue_date))) not valid;

alter table "public"."library_history" validate constraint "valid_history_dates";

alter table "public"."library_issued_books" add constraint "library_issued_books_book_id_fkey" FOREIGN KEY (book_id) REFERENCES public.library_books(id) ON DELETE CASCADE not valid;

alter table "public"."library_issued_books" validate constraint "library_issued_books_book_id_fkey";

alter table "public"."library_issued_books" add constraint "library_issued_books_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) not valid;

alter table "public"."library_issued_books" validate constraint "library_issued_books_department_id_fkey";

alter table "public"."library_issued_books" add constraint "library_issued_books_issue_condition_check" CHECK ((issue_condition = ANY (ARRAY['excellent'::text, 'good'::text, 'fair'::text, 'poor'::text, 'damaged'::text]))) not valid;

alter table "public"."library_issued_books" validate constraint "library_issued_books_issue_condition_check";

alter table "public"."library_issued_books" add constraint "library_issued_books_issued_by_fkey" FOREIGN KEY (issued_by) REFERENCES public.users(id) not valid;

alter table "public"."library_issued_books" validate constraint "library_issued_books_issued_by_fkey";

alter table "public"."library_issued_books" add constraint "library_issued_books_return_condition_check" CHECK ((return_condition = ANY (ARRAY['excellent'::text, 'good'::text, 'fair'::text, 'poor'::text, 'damaged'::text, 'lost'::text]))) not valid;

alter table "public"."library_issued_books" validate constraint "library_issued_books_return_condition_check";

alter table "public"."library_issued_books" add constraint "library_issued_books_returned_to_fkey" FOREIGN KEY (returned_to) REFERENCES public.users(id) not valid;

alter table "public"."library_issued_books" validate constraint "library_issued_books_returned_to_fkey";

alter table "public"."library_issued_books" add constraint "library_issued_books_status_check" CHECK ((status = ANY (ARRAY['issued'::text, 'returned'::text, 'overdue'::text, 'lost'::text, 'renewed'::text]))) not valid;

alter table "public"."library_issued_books" validate constraint "library_issued_books_status_check";

alter table "public"."library_issued_books" add constraint "library_issued_books_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."library_issued_books" validate constraint "library_issued_books_student_id_fkey";

alter table "public"."library_issued_books" add constraint "library_issued_books_student_record_id_fkey" FOREIGN KEY (student_record_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."library_issued_books" validate constraint "library_issued_books_student_record_id_fkey";

alter table "public"."library_issued_books" add constraint "valid_dates" CHECK ((due_date >= issue_date)) not valid;

alter table "public"."library_issued_books" validate constraint "valid_dates";

alter table "public"."library_issued_books" add constraint "valid_fine" CHECK (((fine_paid_amount >= (0)::numeric) AND (fine_paid_amount <= fine_amount))) not valid;

alter table "public"."library_issued_books" validate constraint "valid_fine";

alter table "public"."library_issued_books" add constraint "valid_renewal" CHECK (((renewal_count >= 0) AND (renewal_count <= max_renewals))) not valid;

alter table "public"."library_issued_books" validate constraint "valid_renewal";

alter table "public"."library_issued_books" add constraint "valid_return_date" CHECK (((return_date IS NULL) OR (return_date >= issue_date))) not valid;

alter table "public"."library_issued_books" validate constraint "valid_return_date";

alter table "public"."library_reservations" add constraint "library_reservations_book_id_fkey" FOREIGN KEY (book_id) REFERENCES public.library_books(id) ON DELETE CASCADE not valid;

alter table "public"."library_reservations" validate constraint "library_reservations_book_id_fkey";

alter table "public"."library_reservations" add constraint "library_reservations_issued_book_id_fkey" FOREIGN KEY (issued_book_id) REFERENCES public.library_issued_books(id) not valid;

alter table "public"."library_reservations" validate constraint "library_reservations_issued_book_id_fkey";

alter table "public"."library_reservations" add constraint "library_reservations_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'fulfilled'::text, 'expired'::text, 'cancelled'::text]))) not valid;

alter table "public"."library_reservations" validate constraint "library_reservations_status_check";

alter table "public"."library_reservations" add constraint "library_reservations_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."library_reservations" validate constraint "library_reservations_student_id_fkey";

alter table "public"."library_reservations" add constraint "valid_reservation_dates" CHECK ((expiry_date >= reserved_date)) not valid;

alter table "public"."library_reservations" validate constraint "valid_reservation_dates";

alter table "public"."library_reviews" add constraint "library_reviews_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) not valid;

alter table "public"."library_reviews" validate constraint "library_reviews_approved_by_fkey";

alter table "public"."library_reviews" add constraint "library_reviews_book_id_fkey" FOREIGN KEY (book_id) REFERENCES public.library_books(id) ON DELETE CASCADE not valid;

alter table "public"."library_reviews" validate constraint "library_reviews_book_id_fkey";

alter table "public"."library_reviews" add constraint "library_reviews_book_id_student_id_key" UNIQUE using index "library_reviews_book_id_student_id_key";

alter table "public"."library_reviews" add constraint "library_reviews_rating_check" CHECK (((rating >= 1) AND (rating <= 5))) not valid;

alter table "public"."library_reviews" validate constraint "library_reviews_rating_check";

alter table "public"."library_reviews" add constraint "library_reviews_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."library_reviews" validate constraint "library_reviews_student_id_fkey";

alter table "public"."library_settings" add constraint "library_settings_setting_key_key" UNIQUE using index "library_settings_setting_key_key";

alter table "public"."library_settings_college" add constraint "library_settings_college_college_id_setting_key_key" UNIQUE using index "library_settings_college_college_id_setting_key_key";

alter table "public"."library_settings_school" add constraint "unique_setting_per_school" UNIQUE using index "unique_setting_per_school";

alter table "public"."license_assignments" add constraint "license_assignments_assigned_by_fkey" FOREIGN KEY (assigned_by) REFERENCES public.users(id) not valid;

alter table "public"."license_assignments" validate constraint "license_assignments_assigned_by_fkey";

alter table "public"."license_assignments" add constraint "license_assignments_license_pool_id_fkey" FOREIGN KEY (license_pool_id) REFERENCES public.license_pools(id) ON DELETE CASCADE not valid;

alter table "public"."license_assignments" validate constraint "license_assignments_license_pool_id_fkey";

alter table "public"."license_assignments" add constraint "license_assignments_member_type_check" CHECK (((member_type)::text = ANY ((ARRAY['educator'::character varying, 'student'::character varying])::text[]))) not valid;

alter table "public"."license_assignments" validate constraint "license_assignments_member_type_check";

alter table "public"."license_assignments" add constraint "license_assignments_organization_subscription_id_fkey" FOREIGN KEY (organization_subscription_id) REFERENCES public.organization_subscriptions(id) ON DELETE CASCADE not valid;

alter table "public"."license_assignments" validate constraint "license_assignments_organization_subscription_id_fkey";

alter table "public"."license_assignments" add constraint "license_assignments_revoked_by_fkey" FOREIGN KEY (revoked_by) REFERENCES public.users(id) not valid;

alter table "public"."license_assignments" validate constraint "license_assignments_revoked_by_fkey";

alter table "public"."license_assignments" add constraint "license_assignments_status_check" CHECK (((status)::text = ANY ((ARRAY['active'::character varying, 'suspended'::character varying, 'revoked'::character varying, 'expired'::character varying])::text[]))) not valid;

alter table "public"."license_assignments" validate constraint "license_assignments_status_check";

alter table "public"."license_assignments" add constraint "license_assignments_transferred_from_fkey" FOREIGN KEY (transferred_from) REFERENCES public.license_assignments(id) not valid;

alter table "public"."license_assignments" validate constraint "license_assignments_transferred_from_fkey";

alter table "public"."license_assignments" add constraint "license_assignments_transferred_to_fkey" FOREIGN KEY (transferred_to) REFERENCES public.license_assignments(id) not valid;

alter table "public"."license_assignments" validate constraint "license_assignments_transferred_to_fkey";

alter table "public"."license_assignments" add constraint "license_assignments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."license_assignments" validate constraint "license_assignments_user_id_fkey";

alter table "public"."license_assignments" add constraint "valid_expiration" CHECK (((expires_at IS NULL) OR (expires_at > assigned_at))) not valid;

alter table "public"."license_assignments" validate constraint "valid_expiration";

alter table "public"."license_assignments" add constraint "valid_revocation" CHECK (((((status)::text = 'revoked'::text) AND (revoked_at IS NOT NULL) AND (revoked_by IS NOT NULL)) OR (((status)::text <> 'revoked'::text) AND (revoked_at IS NULL)))) not valid;

alter table "public"."license_assignments" validate constraint "valid_revocation";

alter table "public"."license_pools" add constraint "license_pools_allocated_seats_check" CHECK ((allocated_seats > 0)) not valid;

alter table "public"."license_pools" validate constraint "license_pools_allocated_seats_check";

alter table "public"."license_pools" add constraint "license_pools_assigned_seats_check" CHECK ((assigned_seats >= 0)) not valid;

alter table "public"."license_pools" validate constraint "license_pools_assigned_seats_check";

alter table "public"."license_pools" add constraint "license_pools_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."license_pools" validate constraint "license_pools_created_by_fkey";

alter table "public"."license_pools" add constraint "license_pools_member_type_check" CHECK (((member_type)::text = ANY ((ARRAY['educator'::character varying, 'student'::character varying])::text[]))) not valid;

alter table "public"."license_pools" validate constraint "license_pools_member_type_check";

alter table "public"."license_pools" add constraint "license_pools_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."license_pools" validate constraint "license_pools_organization_id_fkey";

alter table "public"."license_pools" add constraint "license_pools_organization_subscription_id_fkey" FOREIGN KEY (organization_subscription_id) REFERENCES public.organization_subscriptions(id) ON DELETE CASCADE not valid;

alter table "public"."license_pools" validate constraint "license_pools_organization_subscription_id_fkey";

alter table "public"."license_pools" add constraint "license_pools_organization_type_check" CHECK (((organization_type)::text = ANY ((ARRAY['school'::character varying, 'college'::character varying, 'university'::character varying])::text[]))) not valid;

alter table "public"."license_pools" validate constraint "license_pools_organization_type_check";

alter table "public"."license_pools" add constraint "valid_pool_name" CHECK (((pool_name IS NULL) OR (length((pool_name)::text) > 0))) not valid;

alter table "public"."license_pools" validate constraint "valid_pool_name";

alter table "public"."license_pools" add constraint "valid_pool_seats" CHECK ((assigned_seats <= allocated_seats)) not valid;

alter table "public"."license_pools" validate constraint "valid_pool_seats";

alter table "public"."mark_entries" add constraint "absent_or_marks" CHECK ((NOT ((is_absent = true) AND (marks_obtained IS NOT NULL)))) not valid;

alter table "public"."mark_entries" validate constraint "absent_or_marks";

alter table "public"."mark_entries" add constraint "mark_entries_assessment_id_fkey" FOREIGN KEY (assessment_id) REFERENCES public.assessments(id) ON DELETE CASCADE not valid;

alter table "public"."mark_entries" validate constraint "mark_entries_assessment_id_fkey";

alter table "public"."mark_entries" add constraint "mark_entries_assessment_student_subject_key" UNIQUE using index "mark_entries_assessment_student_subject_key";

alter table "public"."mark_entries" add constraint "mark_entries_entered_by_fkey" FOREIGN KEY (entered_by) REFERENCES public.users(id) not valid;

alter table "public"."mark_entries" validate constraint "mark_entries_entered_by_fkey";

alter table "public"."mark_entries" add constraint "mark_entries_locked_by_fkey" FOREIGN KEY (locked_by) REFERENCES public.users(id) not valid;

alter table "public"."mark_entries" validate constraint "mark_entries_locked_by_fkey";

alter table "public"."mark_entries" add constraint "mark_entries_moderated_by_fkey" FOREIGN KEY (moderated_by) REFERENCES public.users(id) not valid;

alter table "public"."mark_entries" validate constraint "mark_entries_moderated_by_fkey";

alter table "public"."mark_entries" add constraint "mark_entries_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."mark_entries" validate constraint "mark_entries_student_id_fkey";

alter table "public"."mark_entries" add constraint "mark_entries_student_record_id_fkey" FOREIGN KEY (student_record_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."mark_entries" validate constraint "mark_entries_student_record_id_fkey";

alter table "public"."mark_entries" add constraint "valid_grade_point" CHECK (((grade_point IS NULL) OR ((grade_point >= (0)::numeric) AND (grade_point <= (10)::numeric)))) not valid;

alter table "public"."mark_entries" validate constraint "valid_grade_point";

alter table "public"."mark_entries" add constraint "valid_marks" CHECK (((marks_obtained IS NULL) OR ((marks_obtained >= (0)::numeric) AND (marks_obtained <= total_marks)))) not valid;

alter table "public"."mark_entries" validate constraint "valid_marks";

alter table "public"."mark_entry_batches" add constraint "mark_entry_batches_assessment_id_fkey" FOREIGN KEY (assessment_id) REFERENCES public.assessments(id) ON DELETE CASCADE not valid;

alter table "public"."mark_entry_batches" validate constraint "mark_entry_batches_assessment_id_fkey";

alter table "public"."mark_entry_batches" add constraint "mark_entry_batches_batch_number_key" UNIQUE using index "mark_entry_batches_batch_number_key";

alter table "public"."mark_entry_batches" add constraint "mark_entry_batches_entered_by_fkey" FOREIGN KEY (entered_by) REFERENCES public.users(id) not valid;

alter table "public"."mark_entry_batches" validate constraint "mark_entry_batches_entered_by_fkey";

alter table "public"."mark_entry_batches" add constraint "mark_entry_batches_locked_by_fkey" FOREIGN KEY (locked_by) REFERENCES public.users(id) not valid;

alter table "public"."mark_entry_batches" validate constraint "mark_entry_batches_locked_by_fkey";

alter table "public"."mark_entry_batches" add constraint "mark_entry_batches_status_check" CHECK ((status = ANY (ARRAY['in_progress'::text, 'completed'::text, 'locked'::text, 'cancelled'::text]))) not valid;

alter table "public"."mark_entry_batches" validate constraint "mark_entry_batches_status_check";

alter table "public"."mark_moderation_log" add constraint "mark_moderation_log_approval_status_check" CHECK ((approval_status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."mark_moderation_log" validate constraint "mark_moderation_log_approval_status_check";

alter table "public"."mark_moderation_log" add constraint "mark_moderation_log_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) not valid;

alter table "public"."mark_moderation_log" validate constraint "mark_moderation_log_approved_by_fkey";

alter table "public"."mark_moderation_log" add constraint "mark_moderation_log_assessment_id_fkey" FOREIGN KEY (assessment_id) REFERENCES public.assessments(id) not valid;

alter table "public"."mark_moderation_log" validate constraint "mark_moderation_log_assessment_id_fkey";

alter table "public"."mark_moderation_log" add constraint "mark_moderation_log_mark_entry_id_fkey" FOREIGN KEY (mark_entry_id) REFERENCES public.mark_entries(id) ON DELETE CASCADE not valid;

alter table "public"."mark_moderation_log" validate constraint "mark_moderation_log_mark_entry_id_fkey";

alter table "public"."mark_moderation_log" add constraint "mark_moderation_log_moderated_by_fkey" FOREIGN KEY (moderated_by) REFERENCES public.users(id) not valid;

alter table "public"."mark_moderation_log" validate constraint "mark_moderation_log_moderated_by_fkey";

alter table "public"."mark_moderation_log" add constraint "mark_moderation_log_moderation_type_check" CHECK ((moderation_type = ANY (ARRAY['correction'::text, 'revaluation'::text, 'grace_marks'::text, 'normalization'::text, 'appeal'::text]))) not valid;

alter table "public"."mark_moderation_log" validate constraint "mark_moderation_log_moderation_type_check";

alter table "public"."mark_moderation_log" add constraint "mark_moderation_log_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) not valid;

alter table "public"."mark_moderation_log" validate constraint "mark_moderation_log_student_id_fkey";

alter table "public"."mentor_notes" add constraint "mentor_notes_college_lecturer_id_fkey" FOREIGN KEY (college_lecturer_id) REFERENCES public.college_lecturers(id) ON DELETE CASCADE not valid;

alter table "public"."mentor_notes" validate constraint "mentor_notes_college_lecturer_id_fkey";

alter table "public"."mentor_notes" add constraint "mentor_notes_mentor_type_check" CHECK ((mentor_type = ANY (ARRAY['school'::text, 'college'::text]))) not valid;

alter table "public"."mentor_notes" validate constraint "mentor_notes_mentor_type_check";

alter table "public"."mentor_notes" add constraint "mentor_notes_school_educator_id_fkey" FOREIGN KEY (school_educator_id) REFERENCES public.school_educators(id) ON DELETE CASCADE not valid;

alter table "public"."mentor_notes" validate constraint "mentor_notes_school_educator_id_fkey";

alter table "public"."mentor_notes" add constraint "mentor_notes_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."mentor_notes" validate constraint "mentor_notes_student_id_fkey";

alter table "public"."messages" add constraint "messages_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.school_classes(id) not valid;

alter table "public"."messages" validate constraint "messages_class_id_fkey";

alter table "public"."messages" add constraint "messages_conversation_id_fkey" FOREIGN KEY (conversation_id) REFERENCES public.conversations(id) ON DELETE CASCADE not valid;

alter table "public"."messages" validate constraint "messages_conversation_id_fkey";

alter table "public"."messages" add constraint "messages_program_section_id_fkey" FOREIGN KEY (program_section_id) REFERENCES public.program_sections(id) ON DELETE SET NULL not valid;

alter table "public"."messages" validate constraint "messages_program_section_id_fkey";

alter table "public"."messages" add constraint "messages_receiver_type_check" CHECK ((receiver_type = ANY (ARRAY['student'::text, 'recruiter'::text, 'educator'::text, 'college_educator'::text, 'school_admin'::text, 'college_admin'::text]))) not valid;

alter table "public"."messages" validate constraint "messages_receiver_type_check";

alter table "public"."messages" add constraint "messages_sender_type_check" CHECK ((sender_type = ANY (ARRAY['student'::text, 'recruiter'::text, 'educator'::text, 'college_educator'::text, 'school_admin'::text, 'college_admin'::text]))) not valid;

alter table "public"."messages" validate constraint "messages_sender_type_check";

alter table "public"."notifications" add constraint "notifications_assessment_id_fkey" FOREIGN KEY (assessment_id) REFERENCES public.personal_assessment_results(id) not valid;

alter table "public"."notifications" validate constraint "notifications_assessment_id_fkey";

alter table "public"."notifications" add constraint "notifications_recipient_id_fkey" FOREIGN KEY (recipient_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."notifications" validate constraint "notifications_recipient_id_fkey";

alter table "public"."notifications" add constraint "notifications_status_check" CHECK (((status)::text = ANY ((ARRAY['scheduled'::character varying, 'sent'::character varying, 'cancelled'::character varying])::text[]))) not valid;

alter table "public"."notifications" validate constraint "notifications_status_check";

alter table "public"."offers" add constraint "offers_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'rejected'::text, 'expired'::text, 'withdrawn'::text]))) not valid;

alter table "public"."offers" validate constraint "offers_status_check";

alter table "public"."opportunities" add constraint "opportunities_id_old_unique" UNIQUE using index "opportunities_id_old_unique";

alter table "public"."opportunities" add constraint "opportunities_recruiter_id_fkey" FOREIGN KEY (recruiter_id) REFERENCES public.recruiters(id) not valid;

alter table "public"."opportunities" validate constraint "opportunities_recruiter_id_fkey";

alter table "public"."opportunities" add constraint "opportunities_requisition_id_fkey" FOREIGN KEY (requisition_id) REFERENCES public.requisitions(id) ON DELETE SET NULL not valid;

alter table "public"."opportunities" validate constraint "opportunities_requisition_id_fkey";

alter table "public"."opportunities_duplicate" add constraint "opportunities_duplicate_recruiter_id_fkey" FOREIGN KEY (recruiter_id) REFERENCES public.recruiters(id) not valid;

alter table "public"."opportunities_duplicate" validate constraint "opportunities_duplicate_recruiter_id_fkey";

alter table "public"."opportunities_duplicate" add constraint "opportunities_duplicate_requisition_id_fkey" FOREIGN KEY (requisition_id) REFERENCES public.requisitions(id) ON DELETE SET NULL not valid;

alter table "public"."opportunities_duplicate" validate constraint "opportunities_duplicate_requisition_id_fkey";

alter table "public"."opportunity_interactions" add constraint "opportunity_interactions_action_check" CHECK ((action = ANY (ARRAY['view'::text, 'apply'::text, 'dismiss'::text, 'save'::text]))) not valid;

alter table "public"."opportunity_interactions" validate constraint "opportunity_interactions_action_check";

alter table "public"."opportunity_interactions" add constraint "opportunity_interactions_opportunity_id_fkey" FOREIGN KEY (opportunity_id) REFERENCES public.opportunities(id) ON DELETE CASCADE not valid;

alter table "public"."opportunity_interactions" validate constraint "opportunity_interactions_opportunity_id_fkey";

alter table "public"."opportunity_interactions" add constraint "opportunity_interactions_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(user_id) not valid;

alter table "public"."opportunity_interactions" validate constraint "opportunity_interactions_student_id_fkey";

alter table "public"."opportunity_interactions" add constraint "opportunity_interactions_student_id_opportunity_id_action_key" UNIQUE using index "opportunity_interactions_student_id_opportunity_id_action_key";

alter table "public"."organization_invitations" add constraint "accepted_requires_user" CHECK ((((status = 'accepted'::text) AND (accepted_at IS NOT NULL) AND (accepted_by_user_id IS NOT NULL)) OR (status <> 'accepted'::text))) not valid;

alter table "public"."organization_invitations" validate constraint "accepted_requires_user";

alter table "public"."organization_invitations" add constraint "cancelled_requires_info" CHECK ((((status = 'cancelled'::text) AND (cancelled_at IS NOT NULL) AND (cancelled_by IS NOT NULL)) OR (status <> 'cancelled'::text))) not valid;

alter table "public"."organization_invitations" validate constraint "cancelled_requires_info";

alter table "public"."organization_invitations" add constraint "organization_invitations_accepted_by_user_id_fkey" FOREIGN KEY (accepted_by_user_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."organization_invitations" validate constraint "organization_invitations_accepted_by_user_id_fkey";

alter table "public"."organization_invitations" add constraint "organization_invitations_cancelled_by_fkey" FOREIGN KEY (cancelled_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."organization_invitations" validate constraint "organization_invitations_cancelled_by_fkey";

alter table "public"."organization_invitations" add constraint "organization_invitations_invitation_token_key" UNIQUE using index "organization_invitations_invitation_token_key";

alter table "public"."organization_invitations" add constraint "organization_invitations_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."organization_invitations" validate constraint "organization_invitations_invited_by_fkey";

alter table "public"."organization_invitations" add constraint "organization_invitations_invited_by_role_check" CHECK ((invited_by_role = ANY (ARRAY['school_admin'::text, 'college_admin'::text, 'university_admin'::text, 'company_admin'::text]))) not valid;

alter table "public"."organization_invitations" validate constraint "organization_invitations_invited_by_role_check";

alter table "public"."organization_invitations" add constraint "organization_invitations_invitee_role_check" CHECK ((invitee_role = ANY (ARRAY['school_student'::text, 'school_educator'::text, 'school_admin'::text, 'college_student'::text, 'college_educator'::text, 'college_admin'::text, 'university_admin'::text, 'recruiter'::text, 'company_admin'::text]))) not valid;

alter table "public"."organization_invitations" validate constraint "organization_invitations_invitee_role_check";

alter table "public"."organization_invitations" add constraint "organization_invitations_license_pool_id_fkey" FOREIGN KEY (license_pool_id) REFERENCES public.license_pools(id) ON DELETE SET NULL not valid;

alter table "public"."organization_invitations" validate constraint "organization_invitations_license_pool_id_fkey";

alter table "public"."organization_invitations" add constraint "organization_invitations_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_invitations" validate constraint "organization_invitations_organization_id_fkey";

alter table "public"."organization_invitations" add constraint "organization_invitations_organization_type_check" CHECK ((organization_type = ANY (ARRAY['school'::text, 'college'::text, 'university'::text, 'company'::text]))) not valid;

alter table "public"."organization_invitations" validate constraint "organization_invitations_organization_type_check";

alter table "public"."organization_invitations" add constraint "organization_invitations_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'expired'::text, 'cancelled'::text]))) not valid;

alter table "public"."organization_invitations" validate constraint "organization_invitations_status_check";

alter table "public"."organization_invitations" add constraint "organization_invitations_subscription_plan_id_fkey" FOREIGN KEY (subscription_plan_id) REFERENCES public.subscription_plans(id) not valid;

alter table "public"."organization_invitations" validate constraint "organization_invitations_subscription_plan_id_fkey";

alter table "public"."organization_invitations" add constraint "valid_expiration" CHECK ((expires_at > created_at)) not valid;

alter table "public"."organization_invitations" validate constraint "valid_expiration";

alter table "public"."organization_subscriptions" add constraint "organization_subscriptions_assigned_seats_check" CHECK ((assigned_seats >= 0)) not valid;

alter table "public"."organization_subscriptions" validate constraint "organization_subscriptions_assigned_seats_check";

alter table "public"."organization_subscriptions" add constraint "organization_subscriptions_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."organization_subscriptions" validate constraint "organization_subscriptions_organization_id_fkey";

alter table "public"."organization_subscriptions" add constraint "organization_subscriptions_organization_type_check" CHECK (((organization_type)::text = ANY ((ARRAY['school'::character varying, 'college'::character varying, 'university'::character varying])::text[]))) not valid;

alter table "public"."organization_subscriptions" validate constraint "organization_subscriptions_organization_type_check";

alter table "public"."organization_subscriptions" add constraint "organization_subscriptions_purchased_by_fkey" FOREIGN KEY (purchased_by) REFERENCES public.users(id) not valid;

alter table "public"."organization_subscriptions" validate constraint "organization_subscriptions_purchased_by_fkey";

alter table "public"."organization_subscriptions" add constraint "organization_subscriptions_status_check" CHECK (((status)::text = ANY ((ARRAY['active'::character varying, 'paused'::character varying, 'cancelled'::character varying, 'expired'::character varying, 'grace_period'::character varying])::text[]))) not valid;

alter table "public"."organization_subscriptions" validate constraint "organization_subscriptions_status_check";

alter table "public"."organization_subscriptions" add constraint "organization_subscriptions_subscription_plan_id_fkey" FOREIGN KEY (subscription_plan_id) REFERENCES public.subscription_plans(id) not valid;

alter table "public"."organization_subscriptions" validate constraint "organization_subscriptions_subscription_plan_id_fkey";

alter table "public"."organization_subscriptions" add constraint "organization_subscriptions_target_member_type_check" CHECK (((target_member_type)::text = ANY ((ARRAY['educator'::character varying, 'student'::character varying, 'both'::character varying])::text[]))) not valid;

alter table "public"."organization_subscriptions" validate constraint "organization_subscriptions_target_member_type_check";

alter table "public"."organization_subscriptions" add constraint "organization_subscriptions_total_seats_check" CHECK ((total_seats > 0)) not valid;

alter table "public"."organization_subscriptions" validate constraint "organization_subscriptions_total_seats_check";

alter table "public"."organization_subscriptions" add constraint "valid_dates" CHECK ((end_date > start_date)) not valid;

alter table "public"."organization_subscriptions" validate constraint "valid_dates";

alter table "public"."organization_subscriptions" add constraint "valid_pricing" CHECK (((final_amount >= (0)::numeric) AND (total_amount >= (0)::numeric) AND (price_per_seat >= (0)::numeric))) not valid;

alter table "public"."organization_subscriptions" validate constraint "valid_pricing";

alter table "public"."organization_subscriptions" add constraint "valid_seat_count" CHECK ((assigned_seats <= total_seats)) not valid;

alter table "public"."organization_subscriptions" validate constraint "valid_seat_count";

alter table "public"."organizations" add constraint "organizations_admin_id_fkey" FOREIGN KEY (admin_id) REFERENCES auth.users(id) not valid;

alter table "public"."organizations" validate constraint "organizations_admin_id_fkey";

alter table "public"."organizations" add constraint "organizations_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) not valid;

alter table "public"."organizations" validate constraint "organizations_approved_by_fkey";

alter table "public"."outcome_assessment_mappings" add constraint "outcome_assessment_mappings_assessment_type_id_fkey" FOREIGN KEY (assessment_type_id) REFERENCES public.assessment_types(id) ON DELETE CASCADE not valid;

alter table "public"."outcome_assessment_mappings" validate constraint "outcome_assessment_mappings_assessment_type_id_fkey";

alter table "public"."outcome_assessment_mappings" add constraint "outcome_assessment_mappings_learning_outcome_id_assessment__key" UNIQUE using index "outcome_assessment_mappings_learning_outcome_id_assessment__key";

alter table "public"."outcome_assessment_mappings" add constraint "outcome_assessment_mappings_learning_outcome_id_fkey" FOREIGN KEY (learning_outcome_id) REFERENCES public.curriculum_learning_outcomes(id) ON DELETE CASCADE not valid;

alter table "public"."outcome_assessment_mappings" validate constraint "outcome_assessment_mappings_learning_outcome_id_fkey";

alter table "public"."outcome_assessment_mappings" add constraint "outcome_assessment_mappings_weightage_check" CHECK (((weightage >= (0)::numeric) AND (weightage <= (100)::numeric))) not valid;

alter table "public"."outcome_assessment_mappings" validate constraint "outcome_assessment_mappings_weightage_check";

alter table "public"."payment_transactions" add constraint "check_bulk_purchase_has_org" CHECK ((((is_bulk_purchase = true) AND (organization_id IS NOT NULL) AND (organization_type IS NOT NULL)) OR (is_bulk_purchase = false))) not valid;

alter table "public"."payment_transactions" validate constraint "check_bulk_purchase_has_org";

alter table "public"."payment_transactions" add constraint "check_bulk_purchase_seat_count" CHECK ((((is_bulk_purchase = true) AND (seat_count > 1)) OR ((is_bulk_purchase = false) AND (seat_count = 1)))) not valid;

alter table "public"."payment_transactions" validate constraint "check_bulk_purchase_seat_count";

alter table "public"."payment_transactions" add constraint "payment_transactions_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."payment_transactions" validate constraint "payment_transactions_organization_id_fkey";

alter table "public"."payment_transactions" add constraint "payment_transactions_organization_type_check" CHECK ((organization_type = ANY (ARRAY['school'::text, 'college'::text, 'university'::text, 'company'::text]))) not valid;

alter table "public"."payment_transactions" validate constraint "payment_transactions_organization_type_check";

alter table "public"."payment_transactions" add constraint "payment_transactions_razorpay_payment_id_key" UNIQUE using index "payment_transactions_razorpay_payment_id_key";

alter table "public"."payment_transactions" add constraint "payment_transactions_seat_count_check" CHECK ((seat_count > 0)) not valid;

alter table "public"."payment_transactions" validate constraint "payment_transactions_seat_count_check";

alter table "public"."payment_transactions" add constraint "payment_transactions_subscription_id_fkey" FOREIGN KEY (subscription_id) REFERENCES public.subscriptions(id) ON DELETE SET NULL not valid;

alter table "public"."payment_transactions" validate constraint "payment_transactions_subscription_id_fkey";

alter table "public"."payment_transactions" add constraint "payment_transactions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."payment_transactions" validate constraint "payment_transactions_user_id_fkey";

alter table "public"."personal_assessment_attempts" add constraint "assessment_attempts_status_check" CHECK (((status)::text = ANY ((ARRAY['in_progress'::character varying, 'completed'::character varying, 'abandoned'::character varying])::text[]))) not valid;

alter table "public"."personal_assessment_attempts" validate constraint "assessment_attempts_status_check";

alter table "public"."personal_assessment_attempts" add constraint "assessment_attempts_stream_id_fkey" FOREIGN KEY (stream_id) REFERENCES public.personal_assessment_streams(id) not valid;

alter table "public"."personal_assessment_attempts" validate constraint "assessment_attempts_stream_id_fkey";

alter table "public"."personal_assessment_attempts" add constraint "assessment_attempts_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."personal_assessment_attempts" validate constraint "assessment_attempts_student_id_fkey";

alter table "public"."personal_assessment_attempts" add constraint "personal_assessment_attempts_adaptive_aptitude_session_id_fkey" FOREIGN KEY (adaptive_aptitude_session_id) REFERENCES public.adaptive_aptitude_sessions(id) ON DELETE SET NULL not valid;

alter table "public"."personal_assessment_attempts" validate constraint "personal_assessment_attempts_adaptive_aptitude_session_id_fkey";

alter table "public"."personal_assessment_attempts" add constraint "personal_assessment_attempts_grade_level_check" CHECK ((grade_level = ANY (ARRAY['middle'::text, 'highschool'::text, 'higher_secondary'::text, 'after10'::text, 'after12'::text, 'college'::text]))) not valid;

alter table "public"."personal_assessment_attempts" validate constraint "personal_assessment_attempts_grade_level_check";

alter table "public"."personal_assessment_questions" add constraint "assessment_questions_question_type_check" CHECK (((question_type)::text = ANY ((ARRAY['likert'::character varying, 'mcq'::character varying, 'sjt'::character varying, 'rating'::character varying, 'multiselect'::character varying, 'singleselect'::character varying, 'text'::character varying])::text[]))) not valid;

alter table "public"."personal_assessment_questions" validate constraint "assessment_questions_question_type_check";

alter table "public"."personal_assessment_questions" add constraint "assessment_questions_section_id_fkey" FOREIGN KEY (section_id) REFERENCES public.personal_assessment_sections(id) ON DELETE CASCADE not valid;

alter table "public"."personal_assessment_questions" validate constraint "assessment_questions_section_id_fkey";

alter table "public"."personal_assessment_questions" add constraint "assessment_questions_stream_id_fkey" FOREIGN KEY (stream_id) REFERENCES public.personal_assessment_streams(id) ON DELETE SET NULL not valid;

alter table "public"."personal_assessment_questions" validate constraint "assessment_questions_stream_id_fkey";

alter table "public"."personal_assessment_response_scales" add constraint "personal_assessment_response_scales_section_id_fkey" FOREIGN KEY (section_id) REFERENCES public.personal_assessment_sections(id) ON DELETE CASCADE not valid;

alter table "public"."personal_assessment_response_scales" validate constraint "personal_assessment_response_scales_section_id_fkey";

alter table "public"."personal_assessment_response_scales" add constraint "personal_assessment_response_scales_section_id_scale_name_key" UNIQUE using index "personal_assessment_response_scales_section_id_scale_name_key";

alter table "public"."personal_assessment_responses" add constraint "assessment_responses_attempt_id_fkey" FOREIGN KEY (attempt_id) REFERENCES public.personal_assessment_attempts(id) ON DELETE CASCADE not valid;

alter table "public"."personal_assessment_responses" validate constraint "assessment_responses_attempt_id_fkey";

alter table "public"."personal_assessment_responses" add constraint "assessment_responses_attempt_id_question_id_key" UNIQUE using index "assessment_responses_attempt_id_question_id_key";

alter table "public"."personal_assessment_restrictions" add constraint "personal_assessment_restrictions_grade_level_check" CHECK ((grade_level = ANY (ARRAY['middle'::text, 'highschool'::text, 'higher_secondary'::text, 'after10'::text, 'after12'::text, 'college'::text]))) not valid;

alter table "public"."personal_assessment_restrictions" validate constraint "personal_assessment_restrictions_grade_level_check";

alter table "public"."personal_assessment_restrictions" add constraint "personal_assessment_restrictions_student_id_grade_level_key" UNIQUE using index "personal_assessment_restrictions_student_id_grade_level_key";

alter table "public"."personal_assessment_results" add constraint "assessment_results_attempt_id_fkey" FOREIGN KEY (attempt_id) REFERENCES public.personal_assessment_attempts(id) ON DELETE CASCADE not valid;

alter table "public"."personal_assessment_results" validate constraint "assessment_results_attempt_id_fkey";

alter table "public"."personal_assessment_results" add constraint "assessment_results_attempt_id_key" UNIQUE using index "assessment_results_attempt_id_key";

alter table "public"."personal_assessment_results" add constraint "assessment_results_stream_id_fkey" FOREIGN KEY (stream_id) REFERENCES public.personal_assessment_streams(id) not valid;

alter table "public"."personal_assessment_results" validate constraint "assessment_results_stream_id_fkey";

alter table "public"."personal_assessment_results" add constraint "assessment_results_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."personal_assessment_results" validate constraint "assessment_results_student_id_fkey";

alter table "public"."personal_assessment_results" add constraint "personal_assessment_results_grade_level_check" CHECK ((grade_level = ANY (ARRAY['middle'::text, 'highschool'::text, 'higher_secondary'::text, 'after10'::text, 'after12'::text, 'college'::text]))) not valid;

alter table "public"."personal_assessment_results" validate constraint "personal_assessment_results_grade_level_check";

alter table "public"."personal_assessment_sections" add constraint "assessment_sections_name_key" UNIQUE using index "assessment_sections_name_key";

alter table "public"."personal_assessment_sections" add constraint "personal_assessment_sections_grade_level_check" CHECK ((grade_level = ANY (ARRAY['middle'::text, 'highschool'::text, 'higher_secondary'::text, 'after10'::text, 'after12'::text, 'college'::text]))) not valid;

alter table "public"."personal_assessment_sections" validate constraint "personal_assessment_sections_grade_level_check";

alter table "public"."personal_assessment_streams" add constraint "personal_assessment_streams_grade_level_check" CHECK ((grade_level = ANY (ARRAY['middle'::text, 'highschool'::text, 'higher_secondary'::text, 'after10'::text, 'after12'::text, 'college'::text]))) not valid;

alter table "public"."personal_assessment_streams" validate constraint "personal_assessment_streams_grade_level_check";

alter table "public"."phone_otps" add constraint "phone_otps_phone_key" UNIQUE using index "phone_otps_phone_key";

alter table "public"."pipeline_activities" add constraint "pipeline_activities_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) not valid;

alter table "public"."pipeline_activities" validate constraint "pipeline_activities_student_id_fkey";

alter table "public"."pipeline_candidates" add constraint "pipeline_candidates_opportunity_id_fkey" FOREIGN KEY (opportunity_id) REFERENCES public.opportunities(id) not valid;

alter table "public"."pipeline_candidates" validate constraint "pipeline_candidates_opportunity_id_fkey";

alter table "public"."pipeline_candidates" add constraint "pipeline_candidates_opportunity_id_student_id_key" UNIQUE using index "pipeline_candidates_opportunity_id_student_id_key";

alter table "public"."pipeline_candidates" add constraint "pipeline_candidates_requisition_id_fkey" FOREIGN KEY (requisition_id) REFERENCES public.recruiters(id) not valid;

alter table "public"."pipeline_candidates" validate constraint "pipeline_candidates_requisition_id_fkey";

alter table "public"."pipeline_candidates" add constraint "pipeline_candidates_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) not valid;

alter table "public"."pipeline_candidates" validate constraint "pipeline_candidates_student_id_fkey";

alter table "public"."placements" add constraint "placements_hiredate_status_check" CHECK (((("hiredDate" IS NULL) AND ("placementStatus" <> ALL (ARRAY['offered'::public.placement_status, 'hired'::public.placement_status]))) OR ("placementStatus" = ANY (ARRAY['offered'::public.placement_status, 'hired'::public.placement_status])))) not valid;

alter table "public"."placements" validate constraint "placements_hiredate_status_check";

alter table "public"."placements" add constraint "placements_recruiterId_fkey" FOREIGN KEY ("recruiterId") REFERENCES public.recruiters(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."placements" validate constraint "placements_recruiterId_fkey";

alter table "public"."placements" add constraint "placements_retentiondate_status_check" CHECK (((("retentionDate" IS NULL) AND ("placementStatus" <> 'hired'::public.placement_status)) OR ("placementStatus" = 'hired'::public.placement_status))) not valid;

alter table "public"."placements" validate constraint "placements_retentiondate_status_check";

alter table "public"."placements" add constraint "placements_studentId_fkey" FOREIGN KEY ("studentId") REFERENCES public.students(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."placements" validate constraint "placements_studentId_fkey";

alter table "public"."placements" add constraint "placements_studentid_fkey" FOREIGN KEY ("studentId") REFERENCES public.students(user_id) not valid;

alter table "public"."placements" validate constraint "placements_studentid_fkey";

alter table "public"."pre_registration_email_tracking" add constraint "pre_registration_email_tracking_email_status_check" CHECK ((email_status = ANY (ARRAY['pending'::text, 'queued'::text, 'sending'::text, 'sent'::text, 'delivered'::text, 'failed'::text, 'bounced'::text, 'rejected'::text, 'deferred'::text]))) not valid;

alter table "public"."pre_registration_email_tracking" validate constraint "pre_registration_email_tracking_email_status_check";

alter table "public"."pre_registration_email_tracking" add constraint "pre_registration_email_tracking_pre_registration_id_fkey" FOREIGN KEY (pre_registration_id) REFERENCES public.pre_registrations(id) ON DELETE CASCADE not valid;

alter table "public"."pre_registration_email_tracking" validate constraint "pre_registration_email_tracking_pre_registration_id_fkey";

alter table "public"."profile_views" add constraint "fk_profile_views_student" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."profile_views" validate constraint "fk_profile_views_student";

alter table "public"."profile_views" add constraint "fk_profile_views_viewer" FOREIGN KEY (viewer_id) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."profile_views" validate constraint "fk_profile_views_viewer";

alter table "public"."profile_views" add constraint "profile_views_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(user_id) not valid;

alter table "public"."profile_views" validate constraint "profile_views_student_id_fkey";

alter table "public"."program_sections" add constraint "program_sections_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."program_sections" validate constraint "program_sections_created_by_fkey";

alter table "public"."program_sections" add constraint "program_sections_current_students_check" CHECK ((current_students >= 0)) not valid;

alter table "public"."program_sections" validate constraint "program_sections_current_students_check";

alter table "public"."program_sections" add constraint "program_sections_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) ON DELETE CASCADE not valid;

alter table "public"."program_sections" validate constraint "program_sections_department_id_fkey";

alter table "public"."program_sections" add constraint "program_sections_faculty_id_fkey" FOREIGN KEY (faculty_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."program_sections" validate constraint "program_sections_faculty_id_fkey";

alter table "public"."program_sections" add constraint "program_sections_max_students_check" CHECK ((max_students > 0)) not valid;

alter table "public"."program_sections" validate constraint "program_sections_max_students_check";

alter table "public"."program_sections" add constraint "program_sections_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) ON DELETE CASCADE not valid;

alter table "public"."program_sections" validate constraint "program_sections_program_id_fkey";

alter table "public"."program_sections" add constraint "program_sections_program_id_semester_section_academic_year_key" UNIQUE using index "program_sections_program_id_semester_section_academic_year_key";

alter table "public"."program_sections" add constraint "program_sections_semester_check" CHECK (((semester >= 1) AND (semester <= 12))) not valid;

alter table "public"."program_sections" validate constraint "program_sections_semester_check";

alter table "public"."program_sections" add constraint "program_sections_status_check" CHECK (((status)::text = ANY ((ARRAY['active'::character varying, 'inactive'::character varying])::text[]))) not valid;

alter table "public"."program_sections" validate constraint "program_sections_status_check";

alter table "public"."program_sections" add constraint "program_sections_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) not valid;

alter table "public"."program_sections" validate constraint "program_sections_updated_by_fkey";

alter table "public"."programs" add constraint "programs_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."programs" validate constraint "programs_created_by_fkey";

alter table "public"."programs" add constraint "programs_department_id_code_key" UNIQUE using index "programs_department_id_code_key";

alter table "public"."programs" add constraint "programs_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) ON DELETE CASCADE not valid;

alter table "public"."programs" validate constraint "programs_department_id_fkey";

alter table "public"."programs" add constraint "programs_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) not valid;

alter table "public"."programs" validate constraint "programs_updated_by_fkey";

alter table "public"."projects" add constraint "projects_approval_authority_check" CHECK (((approval_authority)::text = ANY ((ARRAY['school_admin'::character varying, 'college_admin'::character varying, 'rareminds_admin'::character varying])::text[]))) not valid;

alter table "public"."projects" validate constraint "projects_approval_authority_check";

alter table "public"."projects" add constraint "projects_approval_status_check" CHECK (((approval_status)::text = ANY ((ARRAY['pending'::character varying, 'approved'::character varying, 'rejected'::character varying, 'verified'::character varying])::text[]))) not valid;

alter table "public"."projects" validate constraint "projects_approval_status_check";

alter table "public"."projects" add constraint "projects_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."projects" validate constraint "projects_student_id_fkey";

alter table "public"."promotional_events" add constraint "promotional_events_discount_type_check" CHECK ((discount_type = ANY (ARRAY['percentage'::text, 'fixed'::text]))) not valid;

alter table "public"."promotional_events" validate constraint "promotional_events_discount_type_check";

alter table "public"."promotional_events" add constraint "promotional_events_event_code_key" UNIQUE using index "promotional_events_event_code_key";

alter table "public"."quizzes" add constraint "quizzes_lesson_id_fkey" FOREIGN KEY (lesson_id) REFERENCES public.lessons(lesson_id) ON DELETE CASCADE not valid;

alter table "public"."quizzes" validate constraint "quizzes_lesson_id_fkey";

alter table "public"."razorpay_orders" add constraint "razorpay_orders_order_id_key" UNIQUE using index "razorpay_orders_order_id_key";

alter table "public"."razorpay_orders" add constraint "razorpay_orders_subscription_id_fkey" FOREIGN KEY (subscription_id) REFERENCES public.subscriptions(id) not valid;

alter table "public"."razorpay_orders" validate constraint "razorpay_orders_subscription_id_fkey";

alter table "public"."razorpay_orders" add constraint "razorpay_orders_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."razorpay_orders" validate constraint "razorpay_orders_user_id_fkey";

alter table "public"."recent_updates" add constraint "recent_updates_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(user_id) not valid;

alter table "public"."recent_updates" validate constraint "recent_updates_student_id_fkey";

alter table "public"."recent_updates" add constraint "unique_student_id" UNIQUE using index "unique_student_id";

alter table "public"."recruiter_activities" add constraint "recruiter_activities_activityType_check" CHECK (("activityType" = ANY (ARRAY['search'::text, 'profile_view'::text, 'contact'::text, 'shortlist'::text, 'hire_intent'::text]))) not valid;

alter table "public"."recruiter_activities" validate constraint "recruiter_activities_activityType_check";

alter table "public"."recruiter_activities" add constraint "recruiter_activities_targetStudentId_fkey" FOREIGN KEY ("targetStudentId") REFERENCES public.students(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."recruiter_activities" validate constraint "recruiter_activities_targetStudentId_fkey";

alter table "public"."recruiter_activities" add constraint "recruiter_activities_targetstudentid_fkey" FOREIGN KEY ("targetStudentId") REFERENCES public.students(user_id) not valid;

alter table "public"."recruiter_activities" validate constraint "recruiter_activities_targetstudentid_fkey";

alter table "public"."recruiters" add constraint "recruiters_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) not valid;

alter table "public"."recruiters" validate constraint "recruiters_approved_by_fkey";

alter table "public"."recruiters" add constraint "recruiters_company_id_fkey" FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE SET NULL not valid;

alter table "public"."recruiters" validate constraint "recruiters_company_id_fkey";

alter table "public"."recruiters" add constraint "recruiters_email_key" UNIQUE using index "recruiters_email_key";

alter table "public"."recruiters" add constraint "recruiters_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."recruiters" validate constraint "recruiters_user_id_fkey";

alter table "public"."role_permissions" add constraint "role_permissions_permission_name_fkey" FOREIGN KEY (permission_name) REFERENCES public.permissions(name) ON DELETE CASCADE not valid;

alter table "public"."role_permissions" validate constraint "role_permissions_permission_name_fkey";

alter table "public"."role_permissions" add constraint "role_permissions_role_fkey" FOREIGN KEY (role) REFERENCES public.roles(name) ON DELETE CASCADE not valid;

alter table "public"."role_permissions" validate constraint "role_permissions_role_fkey";

alter table "public"."saved_jobs" add constraint "fk_saved_jobs_opportunity" FOREIGN KEY (opportunity_id) REFERENCES public.opportunities(id) not valid;

alter table "public"."saved_jobs" validate constraint "fk_saved_jobs_opportunity";

alter table "public"."saved_jobs" add constraint "fk_saved_jobs_student" FOREIGN KEY (student_id) REFERENCES public.students(id) not valid;

alter table "public"."saved_jobs" validate constraint "fk_saved_jobs_student";

alter table "public"."saved_jobs" add constraint "unique_saved_job" UNIQUE using index "unique_saved_job";

alter table "public"."school_classes" add constraint "school_classes_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."school_classes" validate constraint "school_classes_school_id_fkey";

alter table "public"."school_classes" add constraint "school_classes_school_id_name_academic_year_key" UNIQUE using index "school_classes_school_id_name_academic_year_key";

alter table "public"."school_educator_class_assignments" add constraint "school_educator_class_assignm_educator_id_class_id_subject__key" UNIQUE using index "school_educator_class_assignm_educator_id_class_id_subject__key";

alter table "public"."school_educator_class_assignments" add constraint "school_educator_class_assignments_assigned_by_fkey" FOREIGN KEY (assigned_by) REFERENCES public.users(id) not valid;

alter table "public"."school_educator_class_assignments" validate constraint "school_educator_class_assignments_assigned_by_fkey";

alter table "public"."school_educator_class_assignments" add constraint "school_educator_class_assignments_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.school_classes(id) ON DELETE CASCADE not valid;

alter table "public"."school_educator_class_assignments" validate constraint "school_educator_class_assignments_class_id_fkey";

alter table "public"."school_educator_class_assignments" add constraint "school_educator_class_assignments_educator_id_fkey" FOREIGN KEY (educator_id) REFERENCES public.school_educators(id) ON DELETE CASCADE not valid;

alter table "public"."school_educator_class_assignments" validate constraint "school_educator_class_assignments_educator_id_fkey";

alter table "public"."school_educators" add constraint "school_educators_onboarding_status_check" CHECK (((onboarding_status)::text = ANY ((ARRAY['pending'::character varying, 'documents_uploaded'::character varying, 'verified'::character varying, 'active'::character varying, 'inactive'::character varying])::text[]))) not valid;

alter table "public"."school_educators" validate constraint "school_educators_onboarding_status_check";

alter table "public"."school_educators" add constraint "school_educators_role_check" CHECK (((role)::text = ANY ((ARRAY['school_admin'::character varying, 'principal'::character varying, 'it_admin'::character varying, 'class_teacher'::character varying, 'subject_teacher'::character varying])::text[]))) not valid;

alter table "public"."school_educators" validate constraint "school_educators_role_check";

alter table "public"."school_educators" add constraint "school_educators_school_id_employee_id_key" UNIQUE using index "school_educators_school_id_employee_id_key";

alter table "public"."school_educators" add constraint "school_educators_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."school_educators" validate constraint "school_educators_school_id_fkey";

alter table "public"."school_educators" add constraint "school_educators_teacher_id_key" UNIQUE using index "school_educators_teacher_id_key";

alter table "public"."school_educators" add constraint "school_educators_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."school_educators" validate constraint "school_educators_user_id_fkey";

alter table "public"."school_educators" add constraint "school_educators_user_key" UNIQUE using index "school_educators_user_key";

alter table "public"."search_history" add constraint "search_history_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(user_id) not valid;

alter table "public"."search_history" validate constraint "search_history_student_id_fkey";

alter table "public"."search_history" add constraint "search_history_student_id_search_term_key" UNIQUE using index "search_history_student_id_search_term_key";

alter table "public"."shortlist_candidates" add constraint "shortlist_candidates_shortlist_id_fkey" FOREIGN KEY (shortlist_id) REFERENCES public.shortlists(id) ON DELETE CASCADE not valid;

alter table "public"."shortlist_candidates" validate constraint "shortlist_candidates_shortlist_id_fkey";

alter table "public"."shortlist_candidates" add constraint "shortlist_candidates_shortlist_id_student_id_key" UNIQUE using index "shortlist_candidates_shortlist_id_student_id_key";

alter table "public"."shortlist_candidates" add constraint "shortlist_candidates_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."shortlist_candidates" validate constraint "shortlist_candidates_student_id_fkey";

alter table "public"."skill_assessments" add constraint "skill_assessments_assessed_by_fkey" FOREIGN KEY (assessed_by) REFERENCES auth.users(id) not valid;

alter table "public"."skill_assessments" validate constraint "skill_assessments_assessed_by_fkey";

alter table "public"."skill_assessments" add constraint "skill_assessments_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."skill_assessments" validate constraint "skill_assessments_school_id_fkey";

alter table "public"."skill_assessments" add constraint "skill_assessments_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."skill_assessments" validate constraint "skill_assessments_student_id_fkey";

alter table "public"."skill_badges" add constraint "check_single_badge_creator" CHECK ((((created_by_educator_id IS NOT NULL) AND (created_by_admin_id IS NULL) AND ((created_by_type)::text = 'educator'::text)) OR ((created_by_educator_id IS NULL) AND (created_by_admin_id IS NOT NULL) AND ((created_by_type)::text = 'admin'::text)))) not valid;

alter table "public"."skill_badges" validate constraint "check_single_badge_creator";

alter table "public"."skill_badges" add constraint "skill_badges_created_by_educator_id_fkey" FOREIGN KEY (created_by_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."skill_badges" validate constraint "skill_badges_created_by_educator_id_fkey";

alter table "public"."skill_badges" add constraint "skill_badges_created_by_type_check" CHECK (((created_by_type)::text = ANY ((ARRAY['educator'::character varying, 'admin'::character varying])::text[]))) not valid;

alter table "public"."skill_badges" validate constraint "skill_badges_created_by_type_check";

alter table "public"."skill_badges" add constraint "skill_badges_level_check" CHECK (((level)::text = ANY ((ARRAY['bronze'::character varying, 'silver'::character varying, 'gold'::character varying, 'platinum'::character varying])::text[]))) not valid;

alter table "public"."skill_badges" validate constraint "skill_badges_level_check";

alter table "public"."skill_badges" add constraint "skill_badges_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."skill_badges" validate constraint "skill_badges_school_id_fkey";

alter table "public"."skill_badges" add constraint "unique_badge_name" UNIQUE using index "unique_badge_name";

alter table "public"."skill_passports" add constraint "skill_passports_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'verified'::text, 'rejected'::text, 'suspended'::text]))) not valid;

alter table "public"."skill_passports" validate constraint "skill_passports_status_check";

alter table "public"."skill_passports" add constraint "skill_passports_studentId_key" UNIQUE using index "skill_passports_studentId_key";

alter table "public"."skill_passports" add constraint "skill_passports_studentid_fkey1" FOREIGN KEY ("studentId") REFERENCES public.students(user_id) not valid;

alter table "public"."skill_passports" validate constraint "skill_passports_studentid_fkey1";

alter table "public"."skill_trends" add constraint "skill_trends_trendDirection_check" CHECK (("trendDirection" = ANY (ARRAY['rising'::text, 'stable'::text, 'declining'::text]))) not valid;

alter table "public"."skill_trends" validate constraint "skill_trends_trendDirection_check";

alter table "public"."skill_verification_requests" add constraint "skill_verification_requests_institution_admin_status_check" CHECK ((institution_admin_status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."skill_verification_requests" validate constraint "skill_verification_requests_institution_admin_status_check";

alter table "public"."skill_verification_requests" add constraint "skill_verification_requests_rareminds_admin_status_check" CHECK ((rareminds_admin_status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text]))) not valid;

alter table "public"."skill_verification_requests" validate constraint "skill_verification_requests_rareminds_admin_status_check";

alter table "public"."skill_verification_requests" add constraint "skill_verification_requests_skill_level_check" CHECK (((skill_level >= 1) AND (skill_level <= 5))) not valid;

alter table "public"."skill_verification_requests" validate constraint "skill_verification_requests_skill_level_check";

alter table "public"."skill_verification_requests" add constraint "skill_verification_requests_skill_type_check" CHECK ((skill_type = ANY (ARRAY['technical'::text, 'soft'::text]))) not valid;

alter table "public"."skill_verification_requests" validate constraint "skill_verification_requests_skill_type_check";

alter table "public"."skill_verification_requests" add constraint "skill_verification_requests_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."skill_verification_requests" validate constraint "skill_verification_requests_student_id_fkey";

alter table "public"."skills" add constraint "skills_level_check" CHECK (((level >= 1) AND (level <= 5))) not valid;

alter table "public"."skills" validate constraint "skills_level_check";

alter table "public"."skills" add constraint "skills_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."skills" validate constraint "skills_student_id_fkey";

alter table "public"."skills" add constraint "skills_training_id_fkey" FOREIGN KEY (training_id) REFERENCES public.trainings(id) ON DELETE CASCADE not valid;

alter table "public"."skills" validate constraint "skills_training_id_fkey";

alter table "public"."skills" add constraint "skills_type_check" CHECK (((type)::text = ANY (ARRAY[('technical'::character varying)::text, ('soft'::character varying)::text]))) not valid;

alter table "public"."skills" validate constraint "skills_type_check";

alter table "public"."streak_notification_log" add constraint "streak_notification_log_email_template_number_check" CHECK (((email_template_number >= 1) AND (email_template_number <= 4))) not valid;

alter table "public"."streak_notification_log" validate constraint "streak_notification_log_email_template_number_check";

alter table "public"."streak_notification_log" add constraint "streak_notification_log_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."streak_notification_log" validate constraint "streak_notification_log_student_id_fkey";

alter table "public"."stream_recommendation_reports" add constraint "stream_recommendation_reports_reviewed_by_fkey" FOREIGN KEY (reviewed_by) REFERENCES public.school_educators(id) not valid;

alter table "public"."stream_recommendation_reports" validate constraint "stream_recommendation_reports_reviewed_by_fkey";

alter table "public"."stream_recommendation_reports" add constraint "stream_recommendation_reports_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."stream_recommendation_reports" validate constraint "stream_recommendation_reports_student_id_fkey";

alter table "public"."student_assignments" add constraint "chk_grade_percentage_range" CHECK (((grade_percentage IS NULL) OR ((grade_percentage >= (0)::numeric) AND (grade_percentage <= (100)::numeric)))) not valid;

alter table "public"."student_assignments" validate constraint "chk_grade_percentage_range";

alter table "public"."student_assignments" add constraint "chk_status_dates" CHECK ((((status <> 'submitted'::text) OR (completed_date IS NOT NULL)) AND ((status <> 'graded'::text) OR (graded_date IS NOT NULL)))) not valid;

alter table "public"."student_assignments" validate constraint "chk_status_dates";

alter table "public"."student_assignments" add constraint "fk_student_assignment_assignment" FOREIGN KEY (assignment_id) REFERENCES public.assignments(assignment_id) ON DELETE CASCADE not valid;

alter table "public"."student_assignments" validate constraint "fk_student_assignment_assignment";

alter table "public"."student_assignments" add constraint "student_assignments_priority_check" CHECK ((priority = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text]))) not valid;

alter table "public"."student_assignments" validate constraint "student_assignments_priority_check";

alter table "public"."student_assignments" add constraint "student_assignments_status_check" CHECK ((status = ANY (ARRAY['todo'::text, 'in-progress'::text, 'submitted'::text, 'graded'::text]))) not valid;

alter table "public"."student_assignments" validate constraint "student_assignments_status_check";

alter table "public"."student_assignments" add constraint "student_assignments_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(user_id) ON DELETE CASCADE not valid;

alter table "public"."student_assignments" validate constraint "student_assignments_student_id_fkey";

alter table "public"."student_assignments" add constraint "student_assignments_submission_type_check" CHECK ((submission_type = ANY (ARRAY['file'::text, 'text'::text, 'url'::text, 'code'::text, 'other'::text]))) not valid;

alter table "public"."student_assignments" validate constraint "student_assignments_submission_type_check";

alter table "public"."student_assignments" add constraint "uq_student_assignment" UNIQUE using index "uq_student_assignment";

alter table "public"."student_course_progress" add constraint "student_course_progress_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.courses(course_id) ON DELETE CASCADE not valid;

alter table "public"."student_course_progress" validate constraint "student_course_progress_course_id_fkey";

alter table "public"."student_course_progress" add constraint "student_course_progress_lesson_id_fkey" FOREIGN KEY (lesson_id) REFERENCES public.lessons(lesson_id) ON DELETE CASCADE not valid;

alter table "public"."student_course_progress" validate constraint "student_course_progress_lesson_id_fkey";

alter table "public"."student_course_progress" add constraint "student_course_progress_status_check" CHECK (((status)::text = ANY ((ARRAY['not_started'::character varying, 'in_progress'::character varying, 'completed'::character varying])::text[]))) not valid;

alter table "public"."student_course_progress" validate constraint "student_course_progress_status_check";

alter table "public"."student_course_progress" add constraint "student_course_progress_student_id_course_id_lesson_id_key" UNIQUE using index "student_course_progress_student_id_course_id_lesson_id_key";

alter table "public"."student_course_progress" add constraint "student_course_progress_student_id_fkey" FOREIGN KEY (student_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."student_course_progress" validate constraint "student_course_progress_student_id_fkey";

alter table "public"."student_course_recommendations" add constraint "student_course_recommendation_student_id_course_id_assessme_key" UNIQUE using index "student_course_recommendation_student_id_course_id_assessme_key";

alter table "public"."student_course_recommendations" add constraint "student_course_recommendations_assessment_result_id_fkey" FOREIGN KEY (assessment_result_id) REFERENCES public.personal_assessment_results(id) ON DELETE SET NULL not valid;

alter table "public"."student_course_recommendations" validate constraint "student_course_recommendations_assessment_result_id_fkey";

alter table "public"."student_course_recommendations" add constraint "student_course_recommendations_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.courses(course_id) ON DELETE CASCADE not valid;

alter table "public"."student_course_recommendations" validate constraint "student_course_recommendations_course_id_fkey";

alter table "public"."student_course_recommendations" add constraint "student_course_recommendations_recommendation_type_check" CHECK (((recommendation_type)::text = ANY ((ARRAY['assessment'::character varying, 'skill_gap'::character varying, 'career_path'::character varying, 'manual'::character varying])::text[]))) not valid;

alter table "public"."student_course_recommendations" validate constraint "student_course_recommendations_recommendation_type_check";

alter table "public"."student_course_recommendations" add constraint "student_course_recommendations_relevance_score_check" CHECK (((relevance_score >= 0) AND (relevance_score <= 100))) not valid;

alter table "public"."student_course_recommendations" validate constraint "student_course_recommendations_relevance_score_check";

alter table "public"."student_course_recommendations" add constraint "student_course_recommendations_status_check" CHECK (((status)::text = ANY ((ARRAY['active'::character varying, 'enrolled'::character varying, 'dismissed'::character varying, 'completed'::character varying])::text[]))) not valid;

alter table "public"."student_course_recommendations" validate constraint "student_course_recommendations_status_check";

alter table "public"."student_course_recommendations" add constraint "student_course_recommendations_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(user_id) ON DELETE CASCADE not valid;

alter table "public"."student_course_recommendations" validate constraint "student_course_recommendations_student_id_fkey";

alter table "public"."student_enrollments" add constraint "student_enrollments_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."student_enrollments" validate constraint "student_enrollments_created_by_fkey";

alter table "public"."student_enrollments" add constraint "student_enrollments_enrollment_status_check" CHECK (((enrollment_status)::text = ANY ((ARRAY['active'::character varying, 'inactive'::character varying, 'graduated'::character varying, 'transferred'::character varying, 'withdrawn'::character varying])::text[]))) not valid;

alter table "public"."student_enrollments" validate constraint "student_enrollments_enrollment_status_check";

alter table "public"."student_enrollments" add constraint "student_enrollments_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) not valid;

alter table "public"."student_enrollments" validate constraint "student_enrollments_program_id_fkey";

alter table "public"."student_enrollments" add constraint "student_enrollments_section_id_fkey" FOREIGN KEY (section_id) REFERENCES public.program_sections(id) not valid;

alter table "public"."student_enrollments" validate constraint "student_enrollments_section_id_fkey";

alter table "public"."student_enrollments" add constraint "student_enrollments_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_enrollments" validate constraint "student_enrollments_student_id_fkey";

alter table "public"."student_enrollments" add constraint "student_enrollments_student_id_program_id_academic_year_key" UNIQUE using index "student_enrollments_student_id_program_id_academic_year_key";

alter table "public"."student_enrollments" add constraint "student_enrollments_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES public.users(id) not valid;

alter table "public"."student_enrollments" validate constraint "student_enrollments_updated_by_fkey";

alter table "public"."student_job_matches" add constraint "student_job_matches_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_job_matches" validate constraint "student_job_matches_student_id_fkey";

alter table "public"."student_job_matches" add constraint "unique_student_job_matches" UNIQUE using index "unique_student_job_matches";

alter table "public"."student_ledgers" add constraint "student_ledgers_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."student_ledgers" validate constraint "student_ledgers_college_id_fkey";

alter table "public"."student_ledgers" add constraint "student_ledgers_fee_structure_id_fkey" FOREIGN KEY (fee_structure_id) REFERENCES public.fee_structures(id) ON DELETE CASCADE not valid;

alter table "public"."student_ledgers" validate constraint "student_ledgers_fee_structure_id_fkey";

alter table "public"."student_ledgers" add constraint "student_ledgers_payment_status_check" CHECK ((payment_status = ANY (ARRAY['pending'::text, 'partial'::text, 'paid'::text, 'overdue'::text, 'waived'::text]))) not valid;

alter table "public"."student_ledgers" validate constraint "student_ledgers_payment_status_check";

alter table "public"."student_ledgers" add constraint "student_ledgers_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."student_ledgers" validate constraint "student_ledgers_student_id_fkey";

alter table "public"."student_ledgers" add constraint "student_ledgers_student_record_id_fkey" FOREIGN KEY (student_record_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_ledgers" validate constraint "student_ledgers_student_record_id_fkey";

alter table "public"."student_ledgers" add constraint "student_ledgers_waived_by_fkey" FOREIGN KEY (waived_by) REFERENCES public.users(id) not valid;

alter table "public"."student_ledgers" validate constraint "student_ledgers_waived_by_fkey";

alter table "public"."student_ledgers" add constraint "valid_amounts" CHECK (((due_amount >= (0)::numeric) AND (paid_amount >= (0)::numeric) AND (paid_amount <= due_amount) AND (late_fee_amount >= (0)::numeric) AND (waiver_amount >= (0)::numeric) AND (waiver_amount <= due_amount))) not valid;

alter table "public"."student_ledgers" validate constraint "valid_amounts";

alter table "public"."student_management_records" add constraint "student_management_records_enrollment_number_key" UNIQUE using index "student_management_records_enrollment_number_key";

alter table "public"."student_management_records" add constraint "student_management_records_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."student_management_records" validate constraint "student_management_records_school_id_fkey";

alter table "public"."student_management_records" add constraint "student_management_records_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'inactive'::text, 'transferred'::text, 'graduated'::text]))) not valid;

alter table "public"."student_management_records" validate constraint "student_management_records_status_check";

alter table "public"."student_management_records" add constraint "student_management_records_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_management_records" validate constraint "student_management_records_student_id_fkey";

alter table "public"."student_management_records" add constraint "student_management_records_student_id_school_id_key" UNIQUE using index "student_management_records_student_id_school_id_key";

alter table "public"."student_promotions" add constraint "student_promotions_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."student_promotions" validate constraint "student_promotions_college_id_fkey";

alter table "public"."student_promotions" add constraint "student_promotions_promoted_by_fkey" FOREIGN KEY (promoted_by) REFERENCES public.school_educators(id) not valid;

alter table "public"."student_promotions" validate constraint "student_promotions_promoted_by_fkey";

alter table "public"."student_promotions" add constraint "student_promotions_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."student_promotions" validate constraint "student_promotions_school_id_fkey";

alter table "public"."student_promotions" add constraint "student_promotions_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_promotions" validate constraint "student_promotions_student_id_fkey";

alter table "public"."student_promotions" add constraint "unique_student_academic_year" UNIQUE using index "unique_student_academic_year";

alter table "public"."student_quiz_progress" add constraint "student_quiz_progress_status_check" CHECK (((status)::text = ANY ((ARRAY['not_started'::character varying, 'in_progress'::character varying, 'completed'::character varying, 'abandoned'::character varying, 'timed_out'::character varying])::text[]))) not valid;

alter table "public"."student_quiz_progress" validate constraint "student_quiz_progress_status_check";

alter table "public"."student_quiz_progress" add constraint "student_quiz_progress_student_id_course_id_lesson_id_quiz_i_key" UNIQUE using index "student_quiz_progress_student_id_course_id_lesson_id_quiz_i_key";

alter table "public"."student_reports" add constraint "student_reports_generated_by_fkey" FOREIGN KEY (generated_by) REFERENCES auth.users(id) not valid;

alter table "public"."student_reports" validate constraint "student_reports_generated_by_fkey";

alter table "public"."student_reports" add constraint "student_reports_report_type_check" CHECK ((report_type = ANY (ARRAY['attendance'::text, 'academic'::text, 'behavioral'::text, 'skill_assessment'::text, 'career_readiness'::text]))) not valid;

alter table "public"."student_reports" validate constraint "student_reports_report_type_check";

alter table "public"."student_reports" add constraint "student_reports_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."student_reports" validate constraint "student_reports_school_id_fkey";

alter table "public"."student_reports" add constraint "student_reports_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_reports" validate constraint "student_reports_student_id_fkey";

alter table "public"."student_skill_badges" add constraint "check_single_badge_awarder" CHECK ((((awarded_by_educator_id IS NOT NULL) AND (awarded_by_admin_id IS NULL) AND ((awarded_by_type)::text = 'educator'::text)) OR ((awarded_by_educator_id IS NULL) AND (awarded_by_admin_id IS NOT NULL) AND ((awarded_by_type)::text = 'admin'::text)) OR ((awarded_by_educator_id IS NULL) AND (awarded_by_admin_id IS NULL) AND ((awarded_by_type)::text = 'auto'::text)))) not valid;

alter table "public"."student_skill_badges" validate constraint "check_single_badge_awarder";

alter table "public"."student_skill_badges" add constraint "fk_student_email" FOREIGN KEY (student_email) REFERENCES public.students(email) ON DELETE CASCADE not valid;

alter table "public"."student_skill_badges" validate constraint "fk_student_email";

alter table "public"."student_skill_badges" add constraint "student_skill_badges_awarded_by_educator_id_fkey" FOREIGN KEY (awarded_by_educator_id) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."student_skill_badges" validate constraint "student_skill_badges_awarded_by_educator_id_fkey";

alter table "public"."student_skill_badges" add constraint "student_skill_badges_awarded_by_type_check" CHECK (((awarded_by_type)::text = ANY ((ARRAY['educator'::character varying, 'admin'::character varying, 'auto'::character varying])::text[]))) not valid;

alter table "public"."student_skill_badges" validate constraint "student_skill_badges_awarded_by_type_check";

alter table "public"."student_skill_badges" add constraint "student_skill_badges_badge_id_fkey" FOREIGN KEY (badge_id) REFERENCES public.skill_badges(badge_id) ON DELETE CASCADE not valid;

alter table "public"."student_skill_badges" validate constraint "student_skill_badges_badge_id_fkey";

alter table "public"."student_skill_badges" add constraint "student_skill_badges_status_check" CHECK (((status)::text = ANY ((ARRAY['in_progress'::character varying, 'earned'::character varying, 'expired'::character varying])::text[]))) not valid;

alter table "public"."student_skill_badges" validate constraint "student_skill_badges_status_check";

alter table "public"."student_skill_badges" add constraint "unique_student_badge" UNIQUE using index "unique_student_badge";

alter table "public"."student_streaks" add constraint "student_streaks_current_streak_check" CHECK ((current_streak >= 0)) not valid;

alter table "public"."student_streaks" validate constraint "student_streaks_current_streak_check";

alter table "public"."student_streaks" add constraint "student_streaks_longest_streak_check" CHECK ((longest_streak >= 0)) not valid;

alter table "public"."student_streaks" validate constraint "student_streaks_longest_streak_check";

alter table "public"."student_streaks" add constraint "student_streaks_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."student_streaks" validate constraint "student_streaks_student_id_fkey";

alter table "public"."student_streaks" add constraint "student_streaks_student_id_key" UNIQUE using index "student_streaks_student_id_key";

alter table "public"."students" add constraint "chk_aadhar_format" CHECK (((aadhar_number IS NULL) OR ((aadhar_number)::text ~ '^[0-9]{12}$'::text))) not valid;

alter table "public"."students" validate constraint "chk_aadhar_format";

alter table "public"."students" add constraint "chk_current_backlogs_positive" CHECK ((current_backlogs >= 0)) not valid;

alter table "public"."students" validate constraint "chk_current_backlogs_positive";

alter table "public"."students" add constraint "chk_gap_consistency" CHECK (((NOT gap_in_studies) OR (gap_years > 0))) not valid;

alter table "public"."students" validate constraint "chk_gap_consistency";

alter table "public"."students" add constraint "chk_gap_years_positive" CHECK ((gap_years >= 0)) not valid;

alter table "public"."students" validate constraint "chk_gap_years_positive";

alter table "public"."students" add constraint "chk_only_one_class" CHECK ((((school_class_id IS NOT NULL) AND (college_class_id IS NULL)) OR ((school_class_id IS NULL) AND (college_id IS NOT NULL)) OR ((school_class_id IS NULL) AND (college_id IS NULL) AND (university_college_id IS NOT NULL) AND (college_class_id IS NULL)) OR ((school_class_id IS NULL) AND (university_college_id IS NULL) AND (college_class_id IS NULL)))) not valid;

alter table "public"."students" validate constraint "chk_only_one_class";

alter table "public"."students" add constraint "fk_students_user" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."students" validate constraint "fk_students_user";

alter table "public"."students" add constraint "students_college_class_id_fkey" FOREIGN KEY (college_class_id) REFERENCES public.college_classes(id) ON DELETE SET NULL not valid;

alter table "public"."students" validate constraint "students_college_class_id_fkey";

alter table "public"."students" add constraint "students_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."students" validate constraint "students_college_id_fkey";

alter table "public"."students" add constraint "students_deleted_by_fkey" FOREIGN KEY (deleted_by) REFERENCES public.school_educators(id) ON DELETE SET NULL not valid;

alter table "public"."students" validate constraint "students_deleted_by_fkey";

alter table "public"."students" add constraint "students_email_key" UNIQUE using index "students_email_key";

alter table "public"."students" add constraint "students_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) not valid;

alter table "public"."students" validate constraint "students_program_id_fkey";

alter table "public"."students" add constraint "students_program_section_id_fkey" FOREIGN KEY (program_section_id) REFERENCES public.program_sections(id) not valid;

alter table "public"."students" validate constraint "students_program_section_id_fkey";

alter table "public"."students" add constraint "students_school_class_id_fkey" FOREIGN KEY (school_class_id) REFERENCES public.school_classes(id) ON DELETE SET NULL not valid;

alter table "public"."students" validate constraint "students_school_class_id_fkey";

alter table "public"."students" add constraint "students_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."students" validate constraint "students_school_id_fkey";

alter table "public"."students" add constraint "students_student_id_key" UNIQUE using index "students_student_id_key";

alter table "public"."students" add constraint "students_university_college_id_fkey" FOREIGN KEY (university_college_id) REFERENCES public.university_colleges(id) ON DELETE SET NULL not valid;

alter table "public"."students" validate constraint "students_university_college_id_fkey";

alter table "public"."students" add constraint "students_universityid_fkey" FOREIGN KEY ("universityId") REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."students" validate constraint "students_universityid_fkey";

alter table "public"."students" add constraint "students_user_id_key" UNIQUE using index "students_user_id_key";

alter table "public"."subscription_cancellations" add constraint "subscription_cancellations_subscription_id_fkey" FOREIGN KEY (subscription_id) REFERENCES public.subscriptions(id) ON DELETE CASCADE not valid;

alter table "public"."subscription_cancellations" validate constraint "subscription_cancellations_subscription_id_fkey";

alter table "public"."subscription_cancellations" add constraint "subscription_cancellations_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."subscription_cancellations" validate constraint "subscription_cancellations_user_id_fkey";

alter table "public"."subscription_migrations" add constraint "subscription_migrations_migration_status_check" CHECK (((migration_status)::text = ANY ((ARRAY['pending'::character varying, 'notified'::character varying, 'completed'::character varying, 'opted_out'::character varying])::text[]))) not valid;

alter table "public"."subscription_migrations" validate constraint "subscription_migrations_migration_status_check";

alter table "public"."subscription_migrations" add constraint "subscription_migrations_old_subscription_id_fkey" FOREIGN KEY (old_subscription_id) REFERENCES public.subscriptions(id) not valid;

alter table "public"."subscription_migrations" validate constraint "subscription_migrations_old_subscription_id_fkey";

alter table "public"."subscription_migrations" add constraint "subscription_migrations_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."subscription_migrations" validate constraint "subscription_migrations_user_id_fkey";

alter table "public"."subscription_plan_features" add constraint "subscription_plan_features_category_check" CHECK ((category = ANY (ARRAY['capacity'::text, 'branding'::text, 'content'::text, 'learning'::text, 'assessments'::text, 'certificates'::text, 'analytics'::text, 'integrations'::text, 'security'::text, 'support'::text]))) not valid;

alter table "public"."subscription_plan_features" validate constraint "subscription_plan_features_category_check";

alter table "public"."subscription_plan_features" add constraint "subscription_plan_features_plan_id_fkey" FOREIGN KEY (plan_id) REFERENCES public.subscription_plans(id) ON DELETE CASCADE not valid;

alter table "public"."subscription_plan_features" validate constraint "subscription_plan_features_plan_id_fkey";

alter table "public"."subscription_plan_features" add constraint "subscription_plan_features_unique" UNIQUE using index "subscription_plan_features_unique";

alter table "public"."subscription_plans" add constraint "subscription_plans_business_type_check" CHECK ((business_type = ANY (ARRAY['b2b'::text, 'b2c'::text]))) not valid;

alter table "public"."subscription_plans" validate constraint "subscription_plans_business_type_check";

alter table "public"."subscription_plans" add constraint "subscription_plans_entity_type_check" CHECK ((entity_type = ANY (ARRAY['school'::text, 'college'::text, 'university'::text, 'recruitment'::text, 'all'::text]))) not valid;

alter table "public"."subscription_plans" validate constraint "subscription_plans_entity_type_check";

alter table "public"."subscription_plans" add constraint "subscription_plans_plan_code_business_type_entity_type_role_key" UNIQUE using index "subscription_plans_plan_code_business_type_entity_type_role_key";

alter table "public"."subscription_plans" add constraint "subscription_plans_role_type_check" CHECK ((role_type = ANY (ARRAY['student'::text, 'educator'::text, 'admin'::text, 'recruiter'::text, 'all'::text]))) not valid;

alter table "public"."subscription_plans" validate constraint "subscription_plans_role_type_check";

alter table "public"."subscriptions" add constraint "check_end_after_start" CHECK (((subscription_end_date IS NULL) OR (subscription_start_date IS NULL) OR (subscription_end_date > subscription_start_date))) not valid;

alter table "public"."subscriptions" validate constraint "check_end_after_start";

alter table "public"."subscriptions" add constraint "check_org_subscription_has_org_id" CHECK ((((is_organization_subscription = true) AND (organization_id IS NOT NULL) AND (organization_type IS NOT NULL)) OR (is_organization_subscription = false))) not valid;

alter table "public"."subscriptions" validate constraint "check_org_subscription_has_org_id";

alter table "public"."subscriptions" add constraint "check_org_subscription_seat_count" CHECK ((((is_organization_subscription = true) AND (seat_count > 1)) OR ((is_organization_subscription = false) AND (seat_count = 1)))) not valid;

alter table "public"."subscriptions" validate constraint "check_org_subscription_seat_count";

alter table "public"."subscriptions" add constraint "check_paused_fields_together" CHECK ((((paused_at IS NULL) AND (paused_until IS NULL)) OR ((paused_at IS NOT NULL) AND (paused_until IS NOT NULL)))) not valid;

alter table "public"."subscriptions" validate constraint "check_paused_fields_together";

alter table "public"."subscriptions" add constraint "check_paused_until_valid" CHECK (((paused_until IS NULL) OR (paused_at IS NULL) OR (paused_until > paused_at))) not valid;

alter table "public"."subscriptions" validate constraint "check_paused_until_valid";

alter table "public"."subscriptions" add constraint "check_plan_amount_positive" CHECK ((plan_amount > (0)::numeric)) not valid;

alter table "public"."subscriptions" validate constraint "check_plan_amount_positive";

alter table "public"."subscriptions" add constraint "fk_subscriptions_plan_id" FOREIGN KEY (plan_id) REFERENCES public.subscription_plans(id) ON DELETE SET NULL not valid;

alter table "public"."subscriptions" validate constraint "fk_subscriptions_plan_id";

alter table "public"."subscriptions" add constraint "fk_subscriptions_public_users" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."subscriptions" validate constraint "fk_subscriptions_public_users";

alter table "public"."subscriptions" add constraint "fk_subscriptions_user_id" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."subscriptions" validate constraint "fk_subscriptions_user_id";

alter table "public"."subscriptions" add constraint "subscriptions_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_organization_id_fkey";

alter table "public"."subscriptions" add constraint "subscriptions_organization_type_check" CHECK ((organization_type = ANY (ARRAY['school'::text, 'college'::text, 'university'::text, 'company'::text]))) not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_organization_type_check";

alter table "public"."subscriptions" add constraint "subscriptions_purchased_by_fkey" FOREIGN KEY (purchased_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_purchased_by_fkey";

alter table "public"."subscriptions" add constraint "subscriptions_razorpay_subscription_id_key" UNIQUE using index "subscriptions_razorpay_subscription_id_key";

alter table "public"."subscriptions" add constraint "subscriptions_seat_count_check" CHECK ((seat_count > 0)) not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_seat_count_check";

alter table "public"."subscriptions" add constraint "subscriptions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."subscriptions" validate constraint "subscriptions_user_id_fkey";

alter table "public"."teacher_journal" add constraint "teacher_journal_educator_id_fkey" FOREIGN KEY (educator_id) REFERENCES public.school_educators(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_journal" validate constraint "teacher_journal_educator_id_fkey";

alter table "public"."teacher_journal" add constraint "teacher_journal_educator_id_lesson_plan_id_date_key" UNIQUE using index "teacher_journal_educator_id_lesson_plan_id_date_key";

alter table "public"."teacher_journal" add constraint "teacher_journal_lesson_plan_id_fkey" FOREIGN KEY (lesson_plan_id) REFERENCES public.lesson_plans(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_journal" validate constraint "teacher_journal_lesson_plan_id_fkey";

alter table "public"."teacher_journal" add constraint "teacher_journal_student_engagement_check" CHECK (((student_engagement)::text = ANY ((ARRAY['low'::character varying, 'medium'::character varying, 'high'::character varying])::text[]))) not valid;

alter table "public"."teacher_journal" validate constraint "teacher_journal_student_engagement_check";

alter table "public"."teacher_workload" add constraint "teacher_workload_educator_id_fkey" FOREIGN KEY (educator_id) REFERENCES public.school_educators(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_workload" validate constraint "teacher_workload_educator_id_fkey";

alter table "public"."teacher_workload" add constraint "teacher_workload_educator_id_timetable_id_key" UNIQUE using index "teacher_workload_educator_id_timetable_id_key";

alter table "public"."teacher_workload" add constraint "teacher_workload_timetable_id_fkey" FOREIGN KEY (timetable_id) REFERENCES public.timetables(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_workload" validate constraint "teacher_workload_timetable_id_fkey";

alter table "public"."timetable_conflicts" add constraint "timetable_conflicts_educator_id_fkey" FOREIGN KEY (educator_id) REFERENCES public.school_educators(id) not valid;

alter table "public"."timetable_conflicts" validate constraint "timetable_conflicts_educator_id_fkey";

alter table "public"."timetable_conflicts" add constraint "timetable_conflicts_slot_id_fkey" FOREIGN KEY (slot_id) REFERENCES public.timetable_slots(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."timetable_conflicts" validate constraint "timetable_conflicts_slot_id_fkey";

alter table "public"."timetable_conflicts" add constraint "timetable_conflicts_timetable_id_fkey" FOREIGN KEY (timetable_id) REFERENCES public.timetables(id) ON DELETE CASCADE not valid;

alter table "public"."timetable_conflicts" validate constraint "timetable_conflicts_timetable_id_fkey";

alter table "public"."timetable_slots" add constraint "timetable_slots_class_id_fkey" FOREIGN KEY (class_id) REFERENCES public.school_classes(id) ON DELETE SET NULL not valid;

alter table "public"."timetable_slots" validate constraint "timetable_slots_class_id_fkey";

alter table "public"."timetable_slots" add constraint "timetable_slots_day_of_week_check" CHECK (((day_of_week >= 1) AND (day_of_week <= 7))) not valid;

alter table "public"."timetable_slots" validate constraint "timetable_slots_day_of_week_check";

alter table "public"."timetable_slots" add constraint "timetable_slots_educator_id_fkey" FOREIGN KEY (educator_id) REFERENCES public.school_educators(id) ON DELETE CASCADE not valid;

alter table "public"."timetable_slots" validate constraint "timetable_slots_educator_id_fkey";

alter table "public"."timetable_slots" add constraint "timetable_slots_period_number_check" CHECK (((period_number >= 1) AND (period_number <= 10))) not valid;

alter table "public"."timetable_slots" validate constraint "timetable_slots_period_number_check";

alter table "public"."timetable_slots" add constraint "timetable_slots_timetable_id_day_of_week_period_number_educ_key" UNIQUE using index "timetable_slots_timetable_id_day_of_week_period_number_educ_key";

alter table "public"."timetable_slots" add constraint "timetable_slots_timetable_id_fkey" FOREIGN KEY (timetable_id) REFERENCES public.timetables(id) ON DELETE CASCADE not valid;

alter table "public"."timetable_slots" validate constraint "timetable_slots_timetable_id_fkey";

alter table "public"."timetables" add constraint "timetables_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."timetables" validate constraint "timetables_created_by_fkey";

alter table "public"."timetables" add constraint "timetables_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."timetables" validate constraint "timetables_school_id_fkey";

alter table "public"."timetables" add constraint "timetables_status_check" CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'published'::character varying, 'archived'::character varying])::text[]))) not valid;

alter table "public"."timetables" validate constraint "timetables_status_check";

alter table "public"."training_notifications" add constraint "training_notifications_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."training_notifications" validate constraint "training_notifications_college_id_fkey";

alter table "public"."training_notifications" add constraint "training_notifications_experience_id_fkey" FOREIGN KEY (experience_id) REFERENCES public.experience(id) ON DELETE CASCADE not valid;

alter table "public"."training_notifications" validate constraint "training_notifications_experience_id_fkey";

alter table "public"."training_notifications" add constraint "training_notifications_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE not valid;

alter table "public"."training_notifications" validate constraint "training_notifications_project_id_fkey";

alter table "public"."training_notifications" add constraint "training_notifications_recipient_type_check" CHECK (((recipient_type)::text = ANY (ARRAY[('school_admin'::character varying)::text, ('college_admin'::character varying)::text, ('rareminds_admin'::character varying)::text]))) not valid;

alter table "public"."training_notifications" validate constraint "training_notifications_recipient_type_check";

alter table "public"."training_notifications" add constraint "training_notifications_reference_check" CHECK ((((training_id IS NOT NULL) AND (experience_id IS NULL) AND (project_id IS NULL)) OR ((training_id IS NULL) AND (experience_id IS NOT NULL) AND (project_id IS NULL)) OR ((training_id IS NULL) AND (experience_id IS NULL) AND (project_id IS NOT NULL)))) not valid;

alter table "public"."training_notifications" validate constraint "training_notifications_reference_check";

alter table "public"."training_notifications" add constraint "training_notifications_school_id_fkey" FOREIGN KEY (school_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."training_notifications" validate constraint "training_notifications_school_id_fkey";

alter table "public"."training_notifications" add constraint "training_notifications_training_id_fkey" FOREIGN KEY (training_id) REFERENCES public.trainings(id) ON DELETE CASCADE not valid;

alter table "public"."training_notifications" validate constraint "training_notifications_training_id_fkey";

alter table "public"."trainings" add constraint "trainings_approval_authority_check" CHECK (((approval_authority)::text = ANY ((ARRAY['school_admin'::character varying, 'college_admin'::character varying, 'rareminds_admin'::character varying])::text[]))) not valid;

alter table "public"."trainings" validate constraint "trainings_approval_authority_check";

alter table "public"."trainings" add constraint "trainings_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES auth.users(id) not valid;

alter table "public"."trainings" validate constraint "trainings_approved_by_fkey";

alter table "public"."trainings" add constraint "trainings_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.courses(course_id) ON DELETE SET NULL not valid;

alter table "public"."trainings" validate constraint "trainings_course_id_fkey";

alter table "public"."trainings" add constraint "trainings_rejected_by_fkey" FOREIGN KEY (rejected_by) REFERENCES auth.users(id) not valid;

alter table "public"."trainings" validate constraint "trainings_rejected_by_fkey";

alter table "public"."trainings" add constraint "trainings_source_check" CHECK (((source)::text = ANY ((ARRAY['manual'::character varying, 'internal_course'::character varying, 'external_course'::character varying, 'certification'::character varying, 'mooc'::character varying])::text[]))) not valid;

alter table "public"."trainings" validate constraint "trainings_source_check";

alter table "public"."trainings" add constraint "trainings_status_check" CHECK ((status = ANY (ARRAY['ongoing'::text, 'completed'::text]))) not valid;

alter table "public"."trainings" validate constraint "trainings_status_check";

alter table "public"."trainings" add constraint "trainings_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."trainings" validate constraint "trainings_student_id_fkey";

alter table "public"."transcript_requests" add constraint "transcript_requests_delivery_method_check" CHECK ((delivery_method = ANY (ARRAY['collect'::text, 'post'::text, 'email'::text, 'courier'::text]))) not valid;

alter table "public"."transcript_requests" validate constraint "transcript_requests_delivery_method_check";

alter table "public"."transcript_requests" add constraint "transcript_requests_processed_by_fkey" FOREIGN KEY (processed_by) REFERENCES public.users(id) not valid;

alter table "public"."transcript_requests" validate constraint "transcript_requests_processed_by_fkey";

alter table "public"."transcript_requests" add constraint "transcript_requests_purpose_check" CHECK ((purpose = ANY (ARRAY['higher_studies'::text, 'employment'::text, 'visa'::text, 'personal'::text, 'other'::text]))) not valid;

alter table "public"."transcript_requests" validate constraint "transcript_requests_purpose_check";

alter table "public"."transcript_requests" add constraint "transcript_requests_request_number_key" UNIQUE using index "transcript_requests_request_number_key";

alter table "public"."transcript_requests" add constraint "transcript_requests_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'processing'::text, 'ready'::text, 'dispatched'::text, 'delivered'::text, 'rejected'::text]))) not valid;

alter table "public"."transcript_requests" validate constraint "transcript_requests_status_check";

alter table "public"."transcript_requests" add constraint "transcript_requests_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."transcript_requests" validate constraint "transcript_requests_student_id_fkey";

alter table "public"."transcript_requests" add constraint "transcript_requests_transcript_id_fkey" FOREIGN KEY (transcript_id) REFERENCES public.transcripts(id) not valid;

alter table "public"."transcript_requests" validate constraint "transcript_requests_transcript_id_fkey";

alter table "public"."transcript_requests" add constraint "transcript_requests_transcript_type_check" CHECK ((transcript_type = ANY (ARRAY['provisional'::text, 'final'::text, 'consolidated'::text, 'semester'::text, 'degree'::text]))) not valid;

alter table "public"."transcript_requests" validate constraint "transcript_requests_transcript_type_check";

alter table "public"."transcript_requests" add constraint "valid_copies" CHECK ((number_of_copies > 0)) not valid;

alter table "public"."transcript_requests" validate constraint "valid_copies";

alter table "public"."transcripts" add constraint "transcripts_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) not valid;

alter table "public"."transcripts" validate constraint "transcripts_approved_by_fkey";

alter table "public"."transcripts" add constraint "transcripts_check" CHECK ((semester_to >= semester_from)) not valid;

alter table "public"."transcripts" validate constraint "transcripts_check";

alter table "public"."transcripts" add constraint "transcripts_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."transcripts" validate constraint "transcripts_created_by_fkey";

alter table "public"."transcripts" add constraint "transcripts_department_id_fkey" FOREIGN KEY (department_id) REFERENCES public.departments(id) not valid;

alter table "public"."transcripts" validate constraint "transcripts_department_id_fkey";

alter table "public"."transcripts" add constraint "transcripts_program_id_fkey" FOREIGN KEY (program_id) REFERENCES public.programs(id) not valid;

alter table "public"."transcripts" validate constraint "transcripts_program_id_fkey";

alter table "public"."transcripts" add constraint "transcripts_semester_from_check" CHECK ((semester_from >= 1)) not valid;

alter table "public"."transcripts" validate constraint "transcripts_semester_from_check";

alter table "public"."transcripts" add constraint "transcripts_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'pending_approval'::text, 'approved'::text, 'issued'::text, 'cancelled'::text]))) not valid;

alter table "public"."transcripts" validate constraint "transcripts_status_check";

alter table "public"."transcripts" add constraint "transcripts_student_id_fkey" FOREIGN KEY (student_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."transcripts" validate constraint "transcripts_student_id_fkey";

alter table "public"."transcripts" add constraint "transcripts_student_record_id_fkey" FOREIGN KEY (student_record_id) REFERENCES public.students(id) ON DELETE CASCADE not valid;

alter table "public"."transcripts" validate constraint "transcripts_student_record_id_fkey";

alter table "public"."transcripts" add constraint "transcripts_type_check" CHECK ((type = ANY (ARRAY['provisional'::text, 'final'::text, 'consolidated'::text, 'semester'::text]))) not valid;

alter table "public"."transcripts" validate constraint "transcripts_type_check";

alter table "public"."transcripts" add constraint "transcripts_verification_id_key" UNIQUE using index "transcripts_verification_id_key";

alter table "public"."transcripts" add constraint "valid_cgpa" CHECK (((cgpa IS NULL) OR ((cgpa >= (0)::numeric) AND (cgpa <= (10)::numeric)))) not valid;

alter table "public"."transcripts" validate constraint "valid_cgpa";

alter table "public"."transcripts" add constraint "valid_credits" CHECK (((total_credits_earned IS NULL) OR (total_credits_required IS NULL) OR (total_credits_earned <= total_credits_required))) not valid;

alter table "public"."transcripts" validate constraint "valid_credits";

alter table "public"."tutor_conversations" add constraint "tutor_conversations_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.courses(course_id) ON DELETE CASCADE not valid;

alter table "public"."tutor_conversations" validate constraint "tutor_conversations_course_id_fkey";

alter table "public"."tutor_conversations" add constraint "tutor_conversations_lesson_id_fkey" FOREIGN KEY (lesson_id) REFERENCES public.lessons(lesson_id) ON DELETE SET NULL not valid;

alter table "public"."tutor_conversations" validate constraint "tutor_conversations_lesson_id_fkey";

alter table "public"."tutor_conversations" add constraint "tutor_conversations_student_id_fkey1" FOREIGN KEY (student_id) REFERENCES public.students(id) not valid;

alter table "public"."tutor_conversations" validate constraint "tutor_conversations_student_id_fkey1";

alter table "public"."tutor_feedback" add constraint "tutor_feedback_conversation_id_fkey" FOREIGN KEY (conversation_id) REFERENCES public.tutor_conversations(id) ON DELETE CASCADE not valid;

alter table "public"."tutor_feedback" validate constraint "tutor_feedback_conversation_id_fkey";

alter table "public"."tutor_feedback" add constraint "tutor_feedback_rating_check" CHECK ((rating = ANY (ARRAY['-1'::integer, 1]))) not valid;

alter table "public"."tutor_feedback" validate constraint "tutor_feedback_rating_check";

alter table "public"."university_colleges" add constraint "university_colleges_college_id_fkey" FOREIGN KEY (college_id) REFERENCES public.organizations(id) not valid;

alter table "public"."university_colleges" validate constraint "university_colleges_college_id_fkey";

alter table "public"."university_colleges" add constraint "university_colleges_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) not valid;

alter table "public"."university_colleges" validate constraint "university_colleges_created_by_fkey";

alter table "public"."university_colleges" add constraint "university_colleges_university_id_code_key" UNIQUE using index "university_colleges_university_id_code_key";

alter table "public"."university_colleges" add constraint "university_colleges_university_id_fkey" FOREIGN KEY (university_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."university_colleges" validate constraint "university_colleges_university_id_fkey";

alter table "public"."university_courses" add constraint "university_courses_approved_by_fkey" FOREIGN KEY (approved_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."university_courses" validate constraint "university_courses_approved_by_fkey";

alter table "public"."university_courses" add constraint "university_courses_university_id_fkey" FOREIGN KEY (university_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."university_courses" validate constraint "university_courses_university_id_fkey";

alter table "public"."university_performance" add constraint "university_performance_universityid_fkey" FOREIGN KEY ("universityId") REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."university_performance" validate constraint "university_performance_universityid_fkey";

alter table "public"."user_categories" add constraint "user_categories_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."user_categories" validate constraint "user_categories_created_by_fkey";

alter table "public"."user_categories" add constraint "user_categories_name_key" UNIQUE using index "user_categories_name_key";

alter table "public"."user_categories" add constraint "user_categories_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."user_categories" validate constraint "user_categories_updated_by_fkey";

alter table "public"."user_entitlements" add constraint "check_org_entitlement_has_subscription" CHECK ((((granted_by_organization = true) AND (organization_subscription_id IS NOT NULL)) OR (granted_by_organization = false))) not valid;

alter table "public"."user_entitlements" validate constraint "check_org_entitlement_has_subscription";

alter table "public"."user_entitlements" add constraint "fk_user_entitlements_bundle" FOREIGN KEY (bundle_id) REFERENCES public.bundles(id) ON DELETE SET NULL not valid;

alter table "public"."user_entitlements" validate constraint "fk_user_entitlements_bundle";

alter table "public"."user_entitlements" add constraint "user_entitlements_billing_period_check" CHECK (((billing_period)::text = ANY ((ARRAY['monthly'::character varying, 'annual'::character varying])::text[]))) not valid;

alter table "public"."user_entitlements" validate constraint "user_entitlements_billing_period_check";

alter table "public"."user_entitlements" add constraint "user_entitlements_granted_by_fkey" FOREIGN KEY (granted_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."user_entitlements" validate constraint "user_entitlements_granted_by_fkey";

alter table "public"."user_entitlements" add constraint "user_entitlements_organization_subscription_id_fkey" FOREIGN KEY (organization_subscription_id) REFERENCES public.organization_subscriptions(id) ON DELETE CASCADE not valid;

alter table "public"."user_entitlements" validate constraint "user_entitlements_organization_subscription_id_fkey";

alter table "public"."user_entitlements" add constraint "user_entitlements_status_check" CHECK (((status)::text = ANY ((ARRAY['active'::character varying, 'cancelled'::character varying, 'expired'::character varying, 'grace_period'::character varying])::text[]))) not valid;

alter table "public"."user_entitlements" validate constraint "user_entitlements_status_check";

alter table "public"."user_entitlements" add constraint "user_entitlements_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_entitlements" validate constraint "user_entitlements_user_id_fkey";

alter table "public"."user_login_history" add constraint "user_login_history_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_login_history" validate constraint "user_login_history_user_id_fkey";

alter table "public"."user_profiles" add constraint "user_profiles_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."user_profiles" validate constraint "user_profiles_created_by_fkey";

alter table "public"."user_profiles" add constraint "user_profiles_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."user_profiles" validate constraint "user_profiles_updated_by_fkey";

alter table "public"."user_profiles" add constraint "user_profiles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_profiles" validate constraint "user_profiles_user_id_fkey";

alter table "public"."user_profiles" add constraint "user_profiles_user_id_key" UNIQUE using index "user_profiles_user_id_key";

alter table "public"."user_sessions" add constraint "user_sessions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_sessions" validate constraint "user_sessions_user_id_fkey";

alter table "public"."user_settings" add constraint "user_settings_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."user_settings" validate constraint "user_settings_updated_by_fkey";

alter table "public"."user_settings" add constraint "user_settings_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_settings" validate constraint "user_settings_user_id_fkey";

alter table "public"."user_settings" add constraint "user_settings_user_id_key" UNIQUE using index "user_settings_user_id_key";

alter table "public"."user_state_history" add constraint "user_state_history_changed_by_fkey" FOREIGN KEY (changed_by) REFERENCES public.users(id) ON DELETE SET NULL not valid;

alter table "public"."user_state_history" validate constraint "user_state_history_changed_by_fkey";

alter table "public"."user_state_history" add constraint "user_state_history_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_state_history" validate constraint "user_state_history_user_id_fkey";

alter table "public"."users" add constraint "users_email_fkey" FOREIGN KEY (email) REFERENCES public.users(email) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."users" validate constraint "users_email_fkey";

alter table "public"."users" add constraint "users_email_key" UNIQUE using index "users_email_key";

alter table "public"."users" add constraint "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."users" validate constraint "users_id_fkey";

alter table "public"."users" add constraint "users_organizationid_fkey" FOREIGN KEY ("organizationId") REFERENCES public.organizations(id) ON DELETE SET NULL not valid;

alter table "public"."users" validate constraint "users_organizationid_fkey";

alter table "public"."verifications" add constraint "verifications_performedby_fkey" FOREIGN KEY ("performedBy") REFERENCES public.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."verifications" validate constraint "verifications_performedby_fkey";

alter table "public"."video_summaries" add constraint "video_summaries_course_id_fkey" FOREIGN KEY (course_id) REFERENCES public.courses(course_id) ON DELETE CASCADE not valid;

alter table "public"."video_summaries" validate constraint "video_summaries_course_id_fkey";

alter table "public"."video_summaries" add constraint "video_summaries_lesson_id_fkey" FOREIGN KEY (lesson_id) REFERENCES public.lessons(lesson_id) ON DELETE CASCADE not valid;

alter table "public"."video_summaries" validate constraint "video_summaries_lesson_id_fkey";

alter table "public"."video_summaries" add constraint "video_summaries_processing_status_check" CHECK (((processing_status)::text = ANY ((ARRAY['pending'::character varying, 'processing'::character varying, 'completed'::character varying, 'failed'::character varying])::text[]))) not valid;

alter table "public"."video_summaries" validate constraint "video_summaries_processing_status_check";

alter table "public"."video_summaries" add constraint "video_summaries_video_type_check" CHECK (((video_type)::text = ANY ((ARRAY['youtube'::character varying, 'uploaded'::character varying, 'vimeo'::character varying])::text[]))) not valid;

alter table "public"."video_summaries" validate constraint "video_summaries_video_type_check";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.add_achievement_update(p_student_id uuid, p_achievement text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  PERFORM add_recent_update(
    p_student_id,
    p_achievement,
    'achievement'
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_column_if_not_exists(p_table_name text, p_column_name text, p_column_definition text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_schema = 'public'
        AND table_name = p_table_name
        AND column_name = p_column_name
    ) THEN
        EXECUTE format('ALTER TABLE %I.%I ADD COLUMN %I %s',
            'public',
            p_table_name,
            p_column_name,
            p_column_definition
        );
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_constraint_if_not_exists(p_table_name text, p_constraint_name text, p_constraint_definition text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    constraint_exists boolean;
BEGIN
    SELECT EXISTS (
        SELECT 1 
        FROM information_schema.table_constraints 
        WHERE constraint_schema = 'public' 
        AND table_name = p_table_name 
        AND constraint_name = p_constraint_name
    ) INTO constraint_exists;
    
    IF NOT constraint_exists THEN
        EXECUTE format('ALTER TABLE %I ADD CONSTRAINT %I %s', 
            p_table_name, p_constraint_name, p_constraint_definition);
        RAISE NOTICE 'Added constraint % to %', p_constraint_name, p_table_name;
    ELSE
        RAISE NOTICE 'Constraint % already exists on %, skipping', p_constraint_name, p_table_name;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_jsonb_recent_update(student_email text, update_title text, update_type text DEFAULT 'system'::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  student_uuid UUID;
  update_json JSONB;
BEGIN
  -- Get the student_id dynamically
  SELECT id INTO student_uuid
  FROM public.students
  WHERE profile->>'email' = student_email;

  IF student_uuid IS NULL THEN
    RAISE EXCEPTION 'No student found with email: %', student_email;
  END IF;

  -- Create new update object
  update_json := jsonb_build_object(
    'title', update_title,
    'type', update_type,
    'created_at', NOW()
  );

  -- Insert or update JSONB array
  INSERT INTO public.recent_updates (student_id, updates)
  VALUES (student_uuid, jsonb_build_object('updates', jsonb_build_array(update_json)))
  ON CONFLICT (student_id)
  DO UPDATE
  SET updates = jsonb_set(
    recent_updates.updates,
    '{updates}',
    (recent_updates.updates->'updates') || jsonb_build_array(update_json)
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_jsonb_recent_update(student_uuid uuid, update_title text, update_description text DEFAULT NULL::text, update_type text DEFAULT 'system'::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  update_json JSONB;
BEGIN
  -- Build JSON for the new update
  update_json := jsonb_build_object(
    'title', update_title,
    'description', update_description,
    'type', update_type,
    'created_at', now()
  );

  -- Insert or update dynamically
  INSERT INTO public.recent_updates (student_id, updates)
  VALUES (
    student_uuid,
    jsonb_build_object('updates', jsonb_build_array(update_json))
  )
  ON CONFLICT (student_id)
  DO UPDATE
  SET updates = jsonb_set(
    COALESCE(recent_updates.updates, '{"updates":[]}'::jsonb),
    '{updates}',
    (COALESCE(recent_updates.updates->'updates', '[]'::jsonb) || jsonb_build_array(update_json))
  ),
  created_at = now();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_opportunity_match_update(p_student_id uuid, p_opportunity_title text, p_company_name text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  PERFORM add_recent_update(
    p_student_id,
    'New opportunity match: ' || p_opportunity_title || ' at ' || p_company_name,
    'opportunity_match'
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_recent_update(p_student_id uuid, p_message text, p_type text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_new_update jsonb;
  v_current_updates jsonb;
  v_updates_array jsonb;
BEGIN
  v_new_update := jsonb_build_object(
    'id', gen_random_uuid()::text,
    'message', p_message,
    'timestamp', 'Just now',
    'type', p_type,
    'created_at', now()
  );

  SELECT updates INTO v_current_updates
  FROM public.recent_updates
  WHERE student_id = p_student_id;

  IF v_current_updates IS NULL THEN
    v_updates_array := jsonb_build_array();
  ELSIF v_current_updates ? 'updates' THEN
    v_updates_array := v_current_updates->'updates';
  ELSE
    v_updates_array := jsonb_build_array();
  END IF;

  v_updates_array := jsonb_build_array(v_new_update) || v_updates_array;

  IF jsonb_array_length(v_updates_array) > 20 THEN
    v_updates_array := v_updates_array #> ARRAY['0:19'];
  END IF;

  INSERT INTO public.recent_updates (student_id, updates, updated_at)
  VALUES (
    p_student_id,
    jsonb_build_object('updates', v_updates_array),
    now()
  )
  ON CONFLICT (student_id) 
  DO UPDATE SET
    updates = jsonb_build_object('updates', v_updates_array),
    updated_at = now();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_recent_update(student_email text, update_title text, update_description text DEFAULT NULL::text, update_type text DEFAULT 'system'::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    student_uuid UUID;
BEGIN
    -- Get student_id dynamically using email inside JSONB "profile"
    SELECT id INTO student_uuid
    FROM public.students
    WHERE profile->>'email' = student_email;

    -- Handle missing student
    IF student_uuid IS NULL THEN
        RAISE EXCEPTION ' No student found with email: %', student_email;
    END IF;

    -- Insert recent update
    INSERT INTO public.recent_updates (student_id, title, description, type)
    VALUES (student_uuid, update_title, update_description, update_type);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_recent_update_by_email(student_email text, update_title text, update_description text DEFAULT NULL::text, update_type text DEFAULT 'system'::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  student_uuid UUID;
  update_json JSONB;
BEGIN
  -- Find student_id from students.profile->>'email'
  SELECT id INTO student_uuid
  FROM public.students
  WHERE profile->>'email' = student_email
  LIMIT 1;

  -- If no student found, exit
  IF student_uuid IS NULL THEN
    RAISE NOTICE 'No student found with email: %', student_email;
    RETURN;
  END IF;

  -- Build the update JSON object
  update_json := jsonb_build_object(
    'title', update_title,
    'description', update_description,
    'type', update_type,
    'created_at', now()
  );

  -- Insert or update dynamically (upsert)
  INSERT INTO public.recent_updates (student_id, updates)
  VALUES (
    student_uuid,
    jsonb_build_object('updates', jsonb_build_array(update_json))
  )
  ON CONFLICT (student_id)
  DO UPDATE
  SET updates = jsonb_set(
        COALESCE(recent_updates.updates, '{"updates":[]}'::jsonb),
        '{updates}',
        (COALESCE(recent_updates.updates->'updates', '[]'::jsonb) || jsonb_build_array(update_json))
      ),
      created_at = now();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_to_profile_array(p_student_id uuid, p_array_name text, p_new_item jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_profile JSONB;
  v_array JSONB;
  v_new_id INTEGER;
BEGIN
  -- Get current profile
  SELECT profile INTO v_profile
  FROM students
  WHERE id = p_student_id;
  
  -- Get current array or initialize empty
  v_array := COALESCE(v_profile -> p_array_name, '[]'::jsonb);
  
  -- Generate new ID
  v_new_id := COALESCE(
    (SELECT MAX((elem->>'id')::int) FROM jsonb_array_elements(v_array) elem),
    0
  ) + 1;
  
  -- Add id to new item
  p_new_item := jsonb_set(p_new_item, '{id}', to_jsonb(v_new_id));
  
  -- Append to array
  v_array := v_array || p_new_item;
  
  -- Update profile
  v_profile := jsonb_set(v_profile, ARRAY[p_array_name], v_array);
  
  -- Save and return
  UPDATE students SET profile = v_profile WHERE id = p_student_id;
  
  RETURN v_profile;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.add_to_teacher_journal()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.status = 'approved' AND (OLD.status IS NULL OR OLD.status != 'approved') THEN
    INSERT INTO teacher_journal (educator_id, lesson_plan_id, date)
    VALUES (NEW.educator_id, NEW.id, NEW.date)
    ON CONFLICT (educator_id, lesson_plan_id, date) DO NOTHING;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.analyze_skills_demand()
 RETURNS TABLE(skill text, total_mentions bigint)
 LANGUAGE sql
 STABLE
AS $function$

WITH wanted(skill) AS (
  VALUES
    ('html'),('css'),('sass'),('scss'),('tailwind'),('bootstrap'),
    ('javascript'),('js'),('typescript'),('ts'),
    ('react'),('reactjs'),('react.js'),('nextjs'),('next.js'),('gatsby'),
    ('angular'),('vue'),('vuejs'),('vue.js'),('svelte'),
    ('nodejs'),('node'),('express'),('nest'),
    ('python'),('swift'),
    ('django'),('flask'),('fastapi'),
    ('c'),('c++'),('csharp'),('c#'),('.net'),
    ('java'),('spring'),('kotlin'),('scala'),
    ('php'),('laravel'),('symfony'),
    ('ruby'),('rails'),('go'),('golang'),
    ('rust'),('dart'),('flutter'),
    ('sql'),('mysql'),('postgresql'),('sqlite'),
    ('mongodb'),('redis'),('elasticsearch'),
    ('docker'),('kubernetes'),('k8s'),
    ('aws'),('azure'),('gcp'),('googlecloud'),
    ('github'),('gitlab'),('bitbucket'),('git'),
    ('jenkins'),('githubactions'),('gitlabci'),('circleci'),('cicd'),('ci/cd'),
    ('rest'),('restful'),('graphql'),('grpc'),
    ('jest'),('mocha'),('jasmine'),('cypress'),('selenium'),
    ('webpack'),('vite'),('parcel'),('babel'),('eslint'),('prettier'),
    ('npm'),('yarn'),('pnpm'),
    ('microservices'),('serverless'),('lambda'),
    ('oauth'),('jwt'),('auth'),
    ('figma'),('sketch'),('adobe'),
    ('framer'),('framer motion'),('framermotion'),
    ('responsive'),('mobilefirst'),('crossbrowser'),
    ('agile'),('scrum'),('kanban')
),

/* explode responsibilities -> one text row per array element */
raw_lines AS (
  SELECT  
    o.id,
    lower(regexp_replace(jsonb_array_elements_text(o.requirements), '[^\w+#/]',' ','g')) AS line
  FROM opportunities o
  WHERE o.requirements IS NOT NULL
),

/* count occurrences per line */
per_line AS (
  SELECT 
    w.skill,
    r.id,
    CASE 
      /* use regex boundaries for longer words to avoid partial matches */
      WHEN length(w.skill) > 3 THEN 
        CASE WHEN r.line ~ ('\m' || w.skill || '\M') THEN 1 ELSE 0 END
      /* use simple regex for short keywords that may terminate a line */
      ELSE 
        CASE WHEN r.line ~ ('\m' || w.skill) THEN 1 ELSE 0 END
    END as found
  FROM wanted w
  CROSS JOIN raw_lines r
)

/* aggregate totals across all listings */
SELECT 
  w.skill,
  sum(p.found)::bigint as total_mentions
FROM wanted w
LEFT JOIN per_line p ON w.skill = p.skill  
GROUP BY w.skill
HAVING sum(p.found) > 0
ORDER BY total_mentions DESC

$function$
;

CREATE OR REPLACE FUNCTION public.apply_change_to_tables(p_curriculum_id uuid, p_change_type character varying, p_entity_id uuid, p_change_data jsonb, p_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_unit_id UUID;
BEGIN
  CASE p_change_type
    
    WHEN 'unit_add' THEN
      INSERT INTO college_curriculum_units (
        id, curriculum_id, name, code, description, order_index,
        estimated_duration, duration_unit, credits, created_by, updated_by
      ) VALUES (
        p_entity_id, p_curriculum_id,
        p_change_data->>'name',
        p_change_data->>'code',
        p_change_data->>'description',
        (p_change_data->>'order_index')::INTEGER,
        (p_change_data->>'estimatedDuration')::INTEGER,
        p_change_data->>'durationUnit',
        (p_change_data->>'credits')::DECIMAL,
        p_user_id, p_user_id
      )
      ON CONFLICT (id) DO UPDATE SET
        name = EXCLUDED.name, updated_by = p_user_id, updated_at = NOW();
      
      RAISE NOTICE 'Applied unit: %', p_change_data->>'name';
    
    WHEN 'unit_edit' THEN
      UPDATE college_curriculum_units
      SET 
        name = COALESCE(p_change_data->>'new_name', p_change_data->>'name', name),
        code = COALESCE(p_change_data->>'new_code', p_change_data->>'code', code),
        description = COALESCE(p_change_data->>'new_description', p_change_data->>'description', description),
        order_index = COALESCE((p_change_data->>'new_order_index')::INTEGER, (p_change_data->>'order_index')::INTEGER, order_index),
        estimated_duration = COALESCE((p_change_data->>'new_estimatedDuration')::INTEGER, (p_change_data->>'estimatedDuration')::INTEGER, estimated_duration),
        duration_unit = COALESCE(p_change_data->>'new_durationUnit', p_change_data->>'durationUnit', duration_unit),
        credits = COALESCE((p_change_data->>'new_credits')::DECIMAL, (p_change_data->>'credits')::DECIMAL, credits),
        updated_by = p_user_id, updated_at = NOW()
      WHERE id = p_entity_id;
      
      RAISE NOTICE 'Updated unit: %', p_entity_id;
    
    WHEN 'unit_delete' THEN
      DELETE FROM college_curriculum_units WHERE id = p_entity_id;
      RAISE NOTICE 'Deleted unit: %', p_entity_id;
    
    WHEN 'outcome_add' THEN
      INSERT INTO college_curriculum_outcomes (
        id, curriculum_id, unit_id, outcome_text, bloom_level,
        assessment_mappings, created_by, updated_by
      ) VALUES (
        p_entity_id, p_curriculum_id,
        (p_change_data->>'unitId')::UUID,
        p_change_data->>'outcome',
        p_change_data->>'bloomLevel',
        COALESCE(p_change_data->'assessmentMappings', '[]'::jsonb),
        p_user_id, p_user_id
      )
      ON CONFLICT (id) DO UPDATE SET
        outcome_text = EXCLUDED.outcome_text, updated_by = p_user_id, updated_at = NOW();
      
      RAISE NOTICE 'Applied outcome for unit: %', p_change_data->>'unitId';
    
    WHEN 'outcome_edit' THEN
      UPDATE college_curriculum_outcomes
      SET 
        outcome_text = COALESCE(p_change_data->>'new_outcome', p_change_data->>'outcome', outcome_text),
        bloom_level = COALESCE(p_change_data->>'new_bloomLevel', p_change_data->>'bloomLevel', bloom_level),
        assessment_mappings = COALESCE(p_change_data->'new_assessmentMappings', p_change_data->'assessmentMappings', assessment_mappings),
        unit_id = COALESCE((p_change_data->>'new_unitId')::UUID, (p_change_data->>'unitId')::UUID, unit_id),
        updated_by = p_user_id, updated_at = NOW()
      WHERE id = p_entity_id;
      
      RAISE NOTICE 'Updated outcome: %', p_entity_id;
    
    WHEN 'outcome_delete' THEN
      DELETE FROM college_curriculum_outcomes WHERE id = p_entity_id;
      RAISE NOTICE 'Deleted outcome: %', p_entity_id;
    
    ELSE
      RAISE NOTICE 'Unknown change type: %', p_change_type;
      RETURN FALSE;
  END CASE;
  
  RETURN TRUE;
  
EXCEPTION
  WHEN OTHERS THEN
    RAISE WARNING 'Error applying change: % - %', SQLERRM, SQLSTATE;
    RETURN FALSE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.apply_to_job(p_student_id uuid, p_opportunity_id integer)
 RETURNS TABLE(success boolean, message text, application_id integer)
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_application_id INTEGER;
  v_already_applied BOOLEAN;
  v_opportunity_active BOOLEAN;
BEGIN
  -- Check if opportunity exists and is active
  SELECT is_active INTO v_opportunity_active
  FROM public.opportunities
  WHERE id = p_opportunity_id;
  
  IF NOT FOUND THEN
    RETURN QUERY SELECT FALSE, 'Opportunity not found', NULL::INTEGER;
    RETURN;
  END IF;
  
  IF NOT v_opportunity_active THEN
    RETURN QUERY SELECT FALSE, 'This opportunity is no longer active', NULL::INTEGER;
    RETURN;
  END IF;

  -- Check if already applied
  SELECT EXISTS (
    SELECT 1 
    FROM public.applications 
    WHERE student_id = p_student_id 
    AND opportunity_id = p_opportunity_id
  ) INTO v_already_applied;
  
  IF v_already_applied THEN
    RETURN QUERY SELECT FALSE, 'You have already applied to this opportunity', NULL::INTEGER;
    RETURN;
  END IF;
  
  -- Create application
  INSERT INTO public.applications (
    student_id,
    opportunity_id,
    application_date,
    status
  ) 
  VALUES (
    p_student_id,
    p_opportunity_id,
    NOW(),
    'pending'::public.approval_status
  )
  RETURNING id INTO v_application_id;
  
  -- Add recent update
  PERFORM public.add_recent_update(
    p_student_id, 
    'Applied to job opportunity',
    'application'
  );
  
  RETURN QUERY SELECT TRUE, 'Application submitted successfully', v_application_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.auto_add_applicant_to_pipeline()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_opportunity RECORD;
  v_student RECORD;
  v_existing_candidate INTEGER;
BEGIN
  -- Get opportunity details including requisition_id
  SELECT 
    o.requisition_id, 
    COALESCE(o.job_title, o.title) as job_title
  INTO v_opportunity
  FROM opportunities o
  WHERE o.id = NEW.opportunity_id;
  
  -- Only proceed if opportunity has a linked requisition
  IF v_opportunity.requisition_id IS NULL THEN
    RAISE NOTICE 'Opportunity % has no linked requisition, skipping pipeline addition', NEW.opportunity_id;
    RETURN NEW;
  END IF;
  
  -- Get student details from the students table (CORRECTED: use direct columns)
  SELECT 
    s.id,
    COALESCE(s.name, 'Unknown Student') as name,
    COALESCE(s.email, '') as email,
    COALESCE(s.contact_number::TEXT, '') as phone
  INTO v_student
  FROM students s
  WHERE s.id = NEW.student_id;
  
  -- If student not found, try to get basic info
  IF v_student.id IS NULL THEN
    RAISE NOTICE 'Student % not found in students table, skipping pipeline addition', NEW.student_id;
    RETURN NEW;
  END IF;
  
  -- Check if candidate already exists in this pipeline
  SELECT id INTO v_existing_candidate
  FROM pipeline_candidates
  WHERE requisition_id = v_opportunity.requisition_id
    AND student_id = NEW.student_id
  LIMIT 1;
  
  -- If candidate doesn't exist, add them to the pipeline
  IF v_existing_candidate IS NULL THEN
    BEGIN
      INSERT INTO pipeline_candidates (
        requisition_id,
        student_id,
        candidate_name,
        candidate_email,
        candidate_phone,
        stage,
        source,
        status,
        added_at,
        stage_changed_at,
        created_at,
        updated_at
      ) VALUES (
        v_opportunity.requisition_id,
        v_student.id,
        v_student.name,
        v_student.email,
        v_student.phone,
        'sourced', -- Start at sourced stage
        'direct_application', -- Mark as direct application
        'active',
        NOW(),
        NOW(),
        NOW(),
        NOW()
      );
      
      RAISE NOTICE 'Successfully added student % (%) to pipeline for requisition %', 
        v_student.name, NEW.student_id, v_opportunity.requisition_id;
    EXCEPTION WHEN OTHERS THEN
      RAISE WARNING 'Failed to add student to pipeline: %', SQLERRM;
    END;
  ELSE
    RAISE NOTICE 'Student % already exists in pipeline for requisition % (pipeline_candidate_id: %)', 
      NEW.student_id, v_opportunity.requisition_id, v_existing_candidate;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.auto_assign_license_to_member()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_organization_id UUID;
    v_organization_type VARCHAR;
    v_member_type VARCHAR;
    v_user_id UUID;
    v_pool RECORD;
BEGIN
    -- Determine organization ID, type, and member type based on the table
    IF TG_TABLE_NAME = 'students' THEN
        IF NEW.school_id IS NOT NULL THEN
            v_organization_id := NEW.school_id;
            v_organization_type := 'school';
        ELSIF NEW.college_id IS NOT NULL THEN
            v_organization_id := NEW.college_id;
            v_organization_type := 'college';
        ELSE
            RETURN NEW;
        END IF;
        v_member_type := 'student';
        v_user_id := NEW.user_id;
        
    ELSIF TG_TABLE_NAME = 'school_educators' THEN
        v_organization_id := NEW.school_id;
        v_organization_type := 'school';
        v_member_type := 'educator';
        v_user_id := NEW.user_id;
        
    ELSIF TG_TABLE_NAME = 'college_lecturers' THEN
        v_organization_id := NEW."collegeId";
        v_organization_type := 'college';
        v_member_type := 'educator';
        v_user_id := NEW.user_id;
        
    ELSE
        RETURN NEW;
    END IF;
    
    IF v_user_id IS NULL OR v_organization_id IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Check if user already has an active license assignment
    IF EXISTS (
        SELECT 1 FROM license_assignments la
        JOIN license_pools lp ON la.license_pool_id = lp.id
        WHERE la.user_id = v_user_id
        AND la.status = 'active'
        AND lp.organization_id = v_organization_id
    ) THEN
        RETURN NEW;
    END IF;
    
    -- Find an eligible pool with auto-assign enabled
    FOR v_pool IN
        SELECT 
            lp.id AS pool_id,
            lp.organization_subscription_id,
            lp.allocated_seats,
            lp.created_by,
            COALESCE(lp.assigned_seats, 0) AS current_assigned
        FROM license_pools lp
        WHERE lp.organization_id = v_organization_id
        AND lp.organization_type = v_organization_type
        AND lp.member_type = v_member_type
        AND lp.auto_assign_new_members = true
        AND lp.is_active = true
        ORDER BY lp.created_at ASC
        LIMIT 1
    LOOP
        IF v_pool.current_assigned < v_pool.allocated_seats THEN
            -- Create the license assignment
            -- The trigger_sync_pool_seats will handle updating the counts
            INSERT INTO license_assignments (
                license_pool_id,
                organization_subscription_id,
                user_id,
                member_type,
                status,
                assigned_at,
                assigned_by
            ) VALUES (
                v_pool.pool_id,
                v_pool.organization_subscription_id,
                v_user_id,
                v_member_type,
                'active',
                NOW(),
                COALESCE(v_pool.created_by, v_user_id)
            );
            
            EXIT;
        END IF;
    END LOOP;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.auto_create_assessment_result()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Only proceed if status changed to 'completed' and no result exists yet
    IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
        -- Check if result already exists
        IF NOT EXISTS (
            SELECT 1 FROM personal_assessment_results 
            WHERE attempt_id = NEW.id
        ) THEN
            -- Create the result
            INSERT INTO personal_assessment_results (
                attempt_id,
                student_id,
                stream_id,
                grade_level,
                status,
                gemini_results,
                overall_summary,
                created_at,
                updated_at
            ) VALUES (
                NEW.id,
                NEW.student_id,
                NEW.stream_id,
                COALESCE(NEW.grade_level, 'highschool'),
                'completed',
                '{}'::jsonb,
                'Assessment completed - AI analysis will be generated when viewing report',
                COALESCE(NEW.completed_at, NOW()),
                COALESCE(NEW.completed_at, NOW())
            );
            
            RAISE NOTICE 'Auto-created assessment result for attempt %', NEW.id;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.auto_set_cancelled_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- If status changed to cancelled and cancelled_at is not set
  IF NEW.status = 'cancelled' AND OLD.status != 'cancelled' AND NEW.cancelled_at IS NULL THEN
    NEW.cancelled_at := NOW();
  END IF;
  
  -- If status changed away from cancelled, clear cancelled_at
  IF NEW.status != 'cancelled' AND OLD.status = 'cancelled' THEN
    NEW.cancelled_at := NULL;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.auto_set_university_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_university_id UUID;
BEGIN
    -- Get university_id for the college
    SELECT uc.university_id INTO v_university_id
    FROM university_colleges uc
    WHERE uc.college_id = NEW.college_id
    AND uc.account_status = 'active'
    LIMIT 1;
    
    -- Set university_id if college is affiliated
    IF v_university_id IS NOT NULL THEN
        NEW.university_id := v_university_id;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.backfill_assessment_reminders()
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
    assessment_record RECORD;
    reminders_created INTEGER := 0;
BEGIN
    -- Process existing assessments that don't have scheduled reminders
    FOR assessment_record IN 
        SELECT par.* 
        FROM personal_assessment_results par
        WHERE par.status = 'completed'
        AND par.created_at >= NOW() - INTERVAL '6 months' -- Only recent assessments
        AND NOT EXISTS (
            SELECT 1 FROM notifications n 
            WHERE n.assessment_id = par.id 
            AND n.type = 'assessment_6month_reminder'
        )
    LOOP
        -- Use the trigger function logic
        PERFORM schedule_assessment_reminder() FROM (SELECT assessment_record.*) AS NEW;
        reminders_created := reminders_created + 1;
    END LOOP;

    RETURN reminders_created;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.build_certificate_text(cert_record public.certificates)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
  result_text TEXT;
BEGIN
  result_text := '';
  
  -- Title is the primary identifier
  IF cert_record.title IS NOT NULL AND cert_record.title != '' THEN
    result_text := 'Certificate: ' || cert_record.title;
  END IF;
  
  -- Issuer adds credibility context
  IF cert_record.issuer IS NOT NULL AND cert_record.issuer != '' THEN
    result_text := result_text || ' issued by ' || cert_record.issuer;
  END IF;
  
  -- Platform indicates the learning source
  IF cert_record.platform IS NOT NULL AND cert_record.platform != '' THEN
    result_text := result_text || ' on ' || cert_record.platform;
  END IF;
  
  -- Level indicates expertise depth
  IF cert_record.level IS NOT NULL AND cert_record.level != '' THEN
    result_text := result_text || '. Level: ' || cert_record.level;
  END IF;
  
  -- Category for domain classification
  IF cert_record.category IS NOT NULL AND cert_record.category != '' THEN
    result_text := result_text || '. Category: ' || cert_record.category;
  END IF;
  
  -- Description for full context
  IF cert_record.description IS NOT NULL AND cert_record.description != '' THEN
    result_text := result_text || '. ' || cert_record.description;
  END IF;
  
  RETURN result_text;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.build_course_enrollment_text(p_enrollment public.course_enrollments)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
  result TEXT := '';
  skills_text TEXT;
BEGIN
  IF p_enrollment.course_title IS NOT NULL THEN
    result := 'Course: ' || p_enrollment.course_title;
  END IF;
  
  IF p_enrollment.status IS NOT NULL THEN
    result := result || ' (Status: ' || p_enrollment.status || ')';
  END IF;
  
  IF p_enrollment.progress IS NOT NULL AND p_enrollment.progress > 0 THEN
    result := result || '. Progress: ' || p_enrollment.progress || '%';
  END IF;
  
  IF p_enrollment.grade IS NOT NULL THEN
    result := result || '. Grade: ' || p_enrollment.grade;
  END IF;
  
  -- Extract skills from JSONB array
  IF p_enrollment.skills_acquired IS NOT NULL AND jsonb_array_length(p_enrollment.skills_acquired) > 0 THEN
    SELECT string_agg(skill::text, ', ') INTO skills_text
    FROM jsonb_array_elements_text(p_enrollment.skills_acquired) AS skill;
    IF skills_text IS NOT NULL THEN
      result := result || '. Skills learned: ' || skills_text;
    END IF;
  END IF;
  
  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.build_project_text(proj_record public.projects)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
  result_text TEXT;
  tech_stack_text TEXT;
BEGIN
  result_text := '';
  
  -- Title is the primary identifier
  IF proj_record.title IS NOT NULL AND proj_record.title != '' THEN
    result_text := 'Project: ' || proj_record.title;
  END IF;
  
  -- Role in the project
  IF proj_record.role IS NOT NULL AND proj_record.role != '' THEN
    result_text := result_text || '. Role: ' || proj_record.role;
  END IF;
  
  -- Organization context
  IF proj_record.organization IS NOT NULL AND proj_record.organization != '' THEN
    result_text := result_text || ' at ' || proj_record.organization;
  END IF;
  
  -- Tech stack is crucial for technical matching
  IF proj_record.tech_stack IS NOT NULL AND array_length(proj_record.tech_stack, 1) > 0 THEN
    tech_stack_text := array_to_string(proj_record.tech_stack, ', ');
    result_text := result_text || '. Technologies: ' || tech_stack_text;
  END IF;
  
  -- Description for full context
  IF proj_record.description IS NOT NULL AND proj_record.description != '' THEN
    result_text := result_text || '. ' || proj_record.description;
  END IF;
  
  RETURN result_text;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.build_skill_text(p_skill public.skills)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
  result TEXT := '';
BEGIN
  IF p_skill.name IS NOT NULL THEN
    result := p_skill.name;
  END IF;
  
  IF p_skill.type IS NOT NULL THEN
    result := result || ' (' || p_skill.type || ' skill)';
  END IF;
  
  IF p_skill.proficiency_level IS NOT NULL THEN
    result := result || '. Proficiency: ' || p_skill.proficiency_level;
  ELSIF p_skill.level IS NOT NULL THEN
    result := result || '. Level: ' || p_skill.level || '/5';
  END IF;
  
  IF p_skill.description IS NOT NULL THEN
    result := result || '. ' || p_skill.description;
  END IF;
  
  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.build_training_text(training_record public.trainings)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
  result_text TEXT;
BEGIN
  result_text := '';
  
  -- Title is the primary identifier
  IF training_record.title IS NOT NULL AND training_record.title != '' THEN
    result_text := 'Training: ' || training_record.title;
  END IF;
  
  -- Organization adds credibility
  IF training_record.organization IS NOT NULL AND training_record.organization != '' THEN
    result_text := result_text || ' by ' || training_record.organization;
  END IF;
  
  -- Source indicates the platform
  IF training_record.source IS NOT NULL AND training_record.source != '' THEN
    result_text := result_text || ' via ' || training_record.source;
  END IF;
  
  -- Duration indicates depth
  IF training_record.duration IS NOT NULL AND training_record.duration != '' THEN
    result_text := result_text || '. Duration: ' || training_record.duration;
  END IF;
  
  -- Description for full context
  IF training_record.description IS NOT NULL AND training_record.description != '' THEN
    result_text := result_text || '. ' || training_record.description;
  END IF;
  
  RETURN result_text;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_assessment_scores()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  attempt_record RECORD;
  aptitude_questions JSONB;
  knowledge_questions JSONB;
  all_responses JSONB;
  
  -- Score counters
  verbal_correct INT := 0;
  verbal_total INT := 0;
  numerical_correct INT := 0;
  numerical_total INT := 0;
  abstract_correct INT := 0;
  abstract_total INT := 0;
  spatial_correct INT := 0;
  spatial_total INT := 0;
  clerical_correct INT := 0;
  clerical_total INT := 0;
  
  knowledge_correct INT := 0;
  knowledge_total INT := 0;
  
  -- Loop variables
  answer_key TEXT;
  answer_value TEXT;
  question_id TEXT;
  question JSONB;
  correct_answer TEXT;
  subtype TEXT;
  
  -- Final scores
  total_aptitude_correct INT;
  total_aptitude_questions INT;
  aptitude_percentage NUMERIC;
  knowledge_percentage NUMERIC;
  
  -- Updated scores JSONB
  new_aptitude_scores JSONB;
  new_knowledge_details JSONB;
BEGIN
  -- Get the attempt record with all_responses
  SELECT * INTO attempt_record
  FROM personal_assessment_attempts
  WHERE id = NEW.attempt_id;
  
  IF attempt_record IS NULL THEN
    RAISE NOTICE 'No attempt found for attempt_id: %', NEW.attempt_id;
    RETURN NEW;
  END IF;
  
  all_responses := attempt_record.all_responses;
  
  IF all_responses IS NULL THEN
    RAISE NOTICE 'No all_responses found for attempt_id: %', NEW.attempt_id;
    RETURN NEW;
  END IF;
  
  -- Get aptitude questions for this student
  SELECT questions INTO aptitude_questions
  FROM career_assessment_ai_questions
  WHERE student_id = NEW.student_id
    AND question_type = 'aptitude'
    AND is_active = true
  ORDER BY created_at DESC
  LIMIT 1;
  
  -- Get knowledge questions for this student
  SELECT questions INTO knowledge_questions
  FROM career_assessment_ai_questions
  WHERE student_id = NEW.student_id
    AND question_type = 'knowledge'
    AND is_active = true
  ORDER BY created_at DESC
  LIMIT 1;
  
  -- Calculate aptitude scores
  IF aptitude_questions IS NOT NULL THEN
    FOR answer_key, answer_value IN SELECT * FROM jsonb_each_text(all_responses)
    LOOP
      IF answer_key LIKE 'aptitude_%' THEN
        question_id := REPLACE(answer_key, 'aptitude_', '');
        
        -- Find the question in the questions array
        SELECT q INTO question
        FROM jsonb_array_elements(aptitude_questions) AS q
        WHERE q->>'id' = question_id;
        
        IF question IS NOT NULL THEN
          correct_answer := TRIM(question->>'correct_answer');
          subtype := LOWER(COALESCE(question->>'subtype', question->>'category', 'verbal'));
          
          -- Map subtypes to categories
          IF subtype IN ('mathematics', 'math', 'numerical_reasoning', 'numerical', 'data_interpretation', 'economics') THEN
            numerical_total := numerical_total + 1;
            IF TRIM(answer_value) = correct_answer THEN
              numerical_correct := numerical_correct + 1;
            END IF;
          ELSIF subtype IN ('english', 'verbal_reasoning', 'verbal', 'social_studies', 'history', 'civics', 'general_knowledge') THEN
            verbal_total := verbal_total + 1;
            IF TRIM(answer_value) = correct_answer THEN
              verbal_correct := verbal_correct + 1;
            END IF;
          ELSIF subtype IN ('science', 'logical_reasoning', 'logical', 'abstract', 'reasoning', 'pattern_recognition') THEN
            abstract_total := abstract_total + 1;
            IF TRIM(answer_value) = correct_answer THEN
              abstract_correct := abstract_correct + 1;
            END IF;
          ELSIF subtype IN ('geography', 'spatial_reasoning', 'spatial') THEN
            spatial_total := spatial_total + 1;
            IF TRIM(answer_value) = correct_answer THEN
              spatial_correct := spatial_correct + 1;
            END IF;
          ELSE
            -- Default to clerical for unknown types
            clerical_total := clerical_total + 1;
            IF TRIM(answer_value) = correct_answer THEN
              clerical_correct := clerical_correct + 1;
            END IF;
          END IF;
        END IF;
      END IF;
    END LOOP;
  END IF;
  
  -- Calculate knowledge scores
  IF knowledge_questions IS NOT NULL THEN
    FOR answer_key, answer_value IN SELECT * FROM jsonb_each_text(all_responses)
    LOOP
      IF answer_key LIKE 'knowledge_%' THEN
        question_id := REPLACE(answer_key, 'knowledge_', '');
        
        -- Find the question in the questions array
        SELECT q INTO question
        FROM jsonb_array_elements(knowledge_questions) AS q
        WHERE q->>'id' = question_id;
        
        IF question IS NOT NULL THEN
          correct_answer := TRIM(question->>'correct_answer');
          knowledge_total := knowledge_total + 1;
          IF TRIM(answer_value) = correct_answer THEN
            knowledge_correct := knowledge_correct + 1;
          END IF;
        END IF;
      END IF;
    END LOOP;
  END IF;
  
  -- Calculate totals and percentages
  total_aptitude_correct := verbal_correct + numerical_correct + abstract_correct + spatial_correct + clerical_correct;
  total_aptitude_questions := verbal_total + numerical_total + abstract_total + spatial_total + clerical_total;
  
  IF total_aptitude_questions > 0 THEN
    aptitude_percentage := ROUND((total_aptitude_correct::NUMERIC / total_aptitude_questions) * 100, 2);
  ELSE
    aptitude_percentage := 0;
  END IF;
  
  IF knowledge_total > 0 THEN
    knowledge_percentage := ROUND((knowledge_correct::NUMERIC / knowledge_total) * 100, 2);
  ELSE
    knowledge_percentage := 0;
  END IF;
  
  -- Build new aptitude_scores JSONB
  new_aptitude_scores := jsonb_build_object(
    'verbal', jsonb_build_object('correct', verbal_correct, 'total', verbal_total, 'percentage', CASE WHEN verbal_total > 0 THEN ROUND((verbal_correct::NUMERIC / verbal_total) * 100) ELSE 0 END),
    'numerical', jsonb_build_object('correct', numerical_correct, 'total', numerical_total, 'percentage', CASE WHEN numerical_total > 0 THEN ROUND((numerical_correct::NUMERIC / numerical_total) * 100) ELSE 0 END),
    'abstract', jsonb_build_object('correct', abstract_correct, 'total', abstract_total, 'percentage', CASE WHEN abstract_total > 0 THEN ROUND((abstract_correct::NUMERIC / abstract_total) * 100) ELSE 0 END),
    'spatial', jsonb_build_object('correct', spatial_correct, 'total', spatial_total, 'percentage', CASE WHEN spatial_total > 0 THEN ROUND((spatial_correct::NUMERIC / spatial_total) * 100) ELSE 0 END),
    'clerical', jsonb_build_object('correct', clerical_correct, 'total', clerical_total, 'percentage', CASE WHEN clerical_total > 0 THEN ROUND((clerical_correct::NUMERIC / clerical_total) * 100) ELSE 0 END)
  );
  
  -- Build new knowledge_details JSONB
  new_knowledge_details := jsonb_build_object(
    'score', knowledge_percentage,
    'correctCount', knowledge_correct,
    'totalQuestions', knowledge_total,
    'strongTopics', CASE WHEN knowledge_correct > 0 THEN '["Calculated from answers"]'::jsonb ELSE '["No data"]'::jsonb END,
    'weakTopics', CASE WHEN knowledge_total - knowledge_correct > 0 THEN '["Calculated from answers"]'::jsonb ELSE '["No data"]'::jsonb END,
    'recommendation', CASE 
      WHEN knowledge_percentage >= 70 THEN 'Strong knowledge foundation. Continue building expertise.'
      WHEN knowledge_percentage >= 50 THEN 'Good knowledge base. Focus on weak areas for improvement.'
      ELSE 'Focus on building domain expertise through projects and certifications.'
    END
  );
  
  -- Update the NEW record with calculated scores
  NEW.aptitude_scores := new_aptitude_scores;
  NEW.aptitude_overall := aptitude_percentage;
  NEW.knowledge_score := knowledge_percentage;
  NEW.knowledge_details := new_knowledge_details;
  
  -- Also update gemini_results if it exists
  IF NEW.gemini_results IS NOT NULL THEN
    NEW.gemini_results := NEW.gemini_results || jsonb_build_object(
      'aptitude', jsonb_build_object(
        'scores', new_aptitude_scores,
        'overallScore', aptitude_percentage,
        'topStrengths', CASE 
          WHEN numerical_correct >= verbal_correct AND numerical_correct >= abstract_correct THEN '["Numerical Reasoning"]'::jsonb
          WHEN verbal_correct >= numerical_correct AND verbal_correct >= abstract_correct THEN '["Verbal Reasoning"]'::jsonb
          ELSE '["Abstract Reasoning"]'::jsonb
        END,
        'areasToImprove', '["Continue practicing"]'::jsonb,
        'cognitiveProfile', 'Calculated from actual assessment answers.',
        'careerImplications', 'Scores reflect actual performance on aptitude questions.'
      ),
      'knowledge', new_knowledge_details
    );
  END IF;
  
  RAISE NOTICE 'Calculated scores - Aptitude: %/% (%), Knowledge: %/% (%)', 
    total_aptitude_correct, total_aptitude_questions, aptitude_percentage,
    knowledge_correct, knowledge_total, knowledge_percentage;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_batch_statistics()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.entries_pending := NEW.total_students - NEW.entries_completed;
  
  IF NEW.total_students > 0 THEN
    NEW.completion_percentage := (NEW.entries_completed::DECIMAL / NEW.total_students * 100);
  ELSE
    NEW.completion_percentage := 0;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_days_borrowed()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Calculate days borrowed
  IF NEW.return_date IS NOT NULL THEN
    NEW.days_borrowed := NEW.return_date - NEW.issue_date;
  ELSE
    NEW.days_borrowed := CURRENT_DATE - NEW.issue_date;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_exam_registration_fee()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.total_fee := NEW.registration_fee + NEW.late_fee;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_fine(issue_date date, return_date date DEFAULT CURRENT_DATE)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
DECLARE
    loan_period INTEGER;
    fine_per_day DECIMAL(10,2);
    due_date DATE;
    overdue_days INTEGER;
BEGIN
    -- Get library settings
    SELECT setting_value::INTEGER INTO loan_period 
    FROM library_settings WHERE setting_key = 'default_loan_period_days';
    
    SELECT setting_value::DECIMAL INTO fine_per_day 
    FROM library_settings WHERE setting_key = 'fine_per_day';
    
    -- Calculate due date
    due_date := issue_date + (loan_period || ' days')::INTERVAL;
    
    -- Calculate overdue days
    overdue_days := GREATEST(0, return_date - due_date);
    
    -- Return fine amount
    RETURN overdue_days * fine_per_day;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_fine_college(p_college_id uuid, issue_date date, return_date date DEFAULT CURRENT_DATE)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
DECLARE
    loan_period INTEGER;
    fine_per_day DECIMAL(10,2);
    due_date DATE;
    overdue_days INTEGER;
BEGIN
    -- Get library settings for specific college
    SELECT setting_value::INTEGER INTO loan_period 
    FROM library_settings_college 
    WHERE college_id = p_college_id AND setting_key = 'default_loan_period_days';
    
    SELECT setting_value::DECIMAL INTO fine_per_day 
    FROM library_settings_college 
    WHERE college_id = p_college_id AND setting_key = 'fine_per_day';
    
    -- Use default values if settings not found
    loan_period := COALESCE(loan_period, 14);
    fine_per_day := COALESCE(fine_per_day, 10);
    
    -- Calculate due date
    due_date := issue_date + (loan_period || ' days')::INTERVAL;
    
    -- Calculate overdue days
    overdue_days := GREATEST(0, return_date - due_date);
    
    -- Return fine amount
    RETURN overdue_days * fine_per_day;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_fine_school(p_school_id uuid, issue_date date, return_date date DEFAULT CURRENT_DATE)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
DECLARE
    loan_period INTEGER;
    fine_per_day DECIMAL(10,2);
    due_date DATE;
    overdue_days INTEGER;
BEGIN
    -- Get library settings for this school
    SELECT setting_value::INTEGER INTO loan_period 
    FROM library_settings_school 
    WHERE school_id = p_school_id AND setting_key = 'default_loan_period_days';
    
    SELECT setting_value::DECIMAL INTO fine_per_day 
    FROM library_settings_school 
    WHERE school_id = p_school_id AND setting_key = 'fine_per_day';
    
    -- Use defaults if settings not found
    loan_period := COALESCE(loan_period, 14);
    fine_per_day := COALESCE(fine_per_day, 10);
    
    -- Calculate due date
    due_date := issue_date + (loan_period || ' days')::INTERVAL;
    
    -- Calculate overdue days
    overdue_days := GREATEST(0, return_date - due_date);
    
    -- Return fine amount
    RETURN overdue_days * fine_per_day;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_internship_duration(start_date date, end_date date)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
  diff_days INTEGER;
  diff_months INTEGER;
  diff_weeks INTEGER;
  duration_text TEXT;
BEGIN
  IF start_date IS NULL OR end_date IS NULL THEN
    RETURN NULL;
  END IF;

  diff_days := end_date - start_date;

  IF diff_days >= 30 THEN
    diff_months := FLOOR(diff_days / 30);
    duration_text := diff_months || ' month';
    IF diff_months > 1 THEN
      duration_text := duration_text || 's';
    END IF;
  ELSIF diff_days >= 14 THEN
    diff_weeks := FLOOR(diff_days / 7);
    duration_text := diff_weeks || ' week';
    IF diff_weeks > 1 THEN
      duration_text := duration_text || 's';
    END IF;
  ELSIF diff_days > 1 THEN
    duration_text := diff_days || ' days';
  ELSE
    duration_text := '1 day';
  END IF;

  RETURN TO_CHAR(start_date, 'Mon YYYY') || '  ' ||
         TO_CHAR(end_date, 'Mon YYYY') || ' (' || duration_text || ')';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_library_fine()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Calculate days overdue
  IF NEW.return_date IS NULL AND CURRENT_DATE > NEW.due_date THEN
    NEW.days_overdue := CURRENT_DATE - NEW.due_date;
  ELSIF NEW.return_date IS NOT NULL AND NEW.return_date > NEW.due_date THEN
    NEW.days_overdue := NEW.return_date - NEW.due_date;
  ELSE
    NEW.days_overdue := 0;
  END IF;
  
  -- Calculate fine amount
  NEW.fine_amount := NEW.days_overdue * NEW.fine_per_day;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_moderation_difference()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.difference := NEW.moderated_marks - NEW.original_marks;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_session_stats(p_session_id uuid)
 RETURNS TABLE(total_questions integer, total_correct integer, overall_accuracy numeric, avg_response_time_ms integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*)::INTEGER as total_questions,
    COUNT(*) FILTER (WHERE is_correct)::INTEGER as total_correct,
    ROUND((COUNT(*) FILTER (WHERE is_correct)::DECIMAL / NULLIF(COUNT(*), 0)) * 100, 2) as overall_accuracy,
    ROUND(AVG(response_time_ms))::INTEGER as avg_response_time_ms
  FROM adaptive_aptitude_responses
  WHERE session_id = p_session_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_teacher_workload(p_educator_id uuid, p_timetable_id uuid)
 RETURNS TABLE(total_periods integer, max_consecutive integer, exceeds_limit boolean, consecutive_violation boolean)
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_total_periods INTEGER;
  v_max_consecutive INTEGER;
BEGIN
  -- Count total periods per week
  SELECT COUNT(*)
  INTO v_total_periods
  FROM timetable_slots
  WHERE educator_id = p_educator_id AND timetable_id = p_timetable_id;
  
  -- Calculate max consecutive classes
  WITH consecutive_periods AS (
    SELECT 
      day_of_week,
      period_number,
      period_number - ROW_NUMBER() OVER (PARTITION BY day_of_week ORDER BY period_number) AS grp
    FROM timetable_slots
    WHERE educator_id = p_educator_id AND timetable_id = p_timetable_id
  ),
  consecutive_counts AS (
    SELECT 
      day_of_week,
      grp,
      COUNT(*) AS consecutive_count
    FROM consecutive_periods
    GROUP BY day_of_week, grp
  )
  SELECT COALESCE(MAX(consecutive_count), 0)
  INTO v_max_consecutive
  FROM consecutive_counts;
  
  -- Update workload table
  INSERT INTO teacher_workload (educator_id, timetable_id, total_periods_per_week, max_consecutive_classes, last_calculated)
  VALUES (p_educator_id, p_timetable_id, v_total_periods, v_max_consecutive, NOW())
  ON CONFLICT (educator_id, timetable_id)
  DO UPDATE SET 
    total_periods_per_week = v_total_periods,
    max_consecutive_classes = v_max_consecutive,
    last_calculated = NOW();
  
  RETURN QUERY SELECT 
    v_total_periods,
    v_max_consecutive,
    v_total_periods > 30 AS exceeds_limit,
    v_max_consecutive > 3 AS consecutive_violation;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.calculate_transcript_request_fee()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.total_fee := NEW.processing_fee + NEW.courier_charges;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_student_join_club(p_student_email character varying, p_club_id uuid)
 RETURNS TABLE(can_join boolean, reason text)
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_club_capacity INTEGER;
    v_current_members INTEGER;
    v_student_clubs INTEGER;
    v_max_clubs INTEGER := 5;
    v_club_school UUID;
    v_student_school UUID;
    v_already_member BOOLEAN;
BEGIN
    -- Check if already a member
    SELECT EXISTS(
        SELECT 1 FROM public.club_memberships 
        WHERE club_id = p_club_id 
        AND student_email = p_student_email 
        AND status = 'active'
    ) INTO v_already_member;
    
    IF v_already_member THEN
        RETURN QUERY SELECT FALSE, 'Already a member of this club';
        RETURN;
    END IF;
    
    -- Check school match
    SELECT school_id INTO v_club_school FROM public.clubs WHERE club_id = p_club_id;
    SELECT school_id INTO v_student_school FROM public.students WHERE email = p_student_email;
    
    IF v_club_school != v_student_school THEN
        RETURN QUERY SELECT FALSE, 'Student and club belong to different schools';
        RETURN;
    END IF;
    
    -- Check club capacity
    SELECT capacity INTO v_club_capacity FROM public.clubs WHERE club_id = p_club_id;
    SELECT COUNT(*) INTO v_current_members 
    FROM public.club_memberships 
    WHERE club_id = p_club_id AND status = 'active';
    
    IF v_current_members >= v_club_capacity THEN
        RETURN QUERY SELECT FALSE, 'Club is at full capacity';
        RETURN;
    END IF;
    
    -- Check student's club count
    SELECT COUNT(*) INTO v_student_clubs
    FROM public.club_memberships
    WHERE student_email = p_student_email AND status = 'active';
    
    IF v_student_clubs >= v_max_clubs THEN
        RETURN QUERY SELECT FALSE, 'Student has reached maximum club limit';
        RETURN;
    END IF;
    
    -- All checks passed
    RETURN QUERY SELECT TRUE, 'Can join club'::TEXT;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.can_take_assessment(p_student_id text, p_grade_level text)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_last_restriction RECORD;
BEGIN
  SELECT * INTO v_last_restriction
  FROM public.personal_assessment_restrictions
  WHERE student_id = p_student_id AND grade_level = p_grade_level
  ORDER BY last_attempt_date DESC LIMIT 1;

  IF v_last_restriction IS NULL THEN
    RETURN true;
  END IF;

  IF NOW() >= v_last_restriction.next_allowed_date THEN
    RETURN true;
  END IF;

  RETURN false;
END;
$function$
;

create or replace view "public"."chapter_details" as  SELECT cc.id,
    cc.curriculum_id,
    cc.name,
    cc.code,
    cc.description,
    cc.order_number,
    cc.estimated_duration,
    cc.duration_unit,
    cc.created_at,
    count(clo.id) AS outcome_count
   FROM (public.curriculum_chapters cc
     LEFT JOIN public.curriculum_learning_outcomes clo ON ((cc.id = clo.chapter_id)))
  GROUP BY cc.id;


CREATE OR REPLACE FUNCTION public.check_attendance_alerts()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_student RECORD;
  v_total_days INTEGER;
  v_present_days INTEGER;
  v_absent_days INTEGER;
  v_percentage DECIMAL(5,2);
  v_consecutive_absent INTEGER;
BEGIN
  -- Loop through all active students
  FOR v_student IN 
    SELECT DISTINCT s.id, s.school_id
    FROM students s
    INNER JOIN student_management_records spe ON s.id = spe.student_id
    WHERE spe.status = 'active'
  LOOP
    -- Calculate attendance for last 30 days
    SELECT 
      COUNT(*) as total,
      COUNT(*) FILTER (WHERE status = 'present') as present,
      COUNT(*) FILTER (WHERE status = 'absent') as absent
    INTO v_total_days, v_present_days, v_absent_days
    FROM attendance_records
    WHERE student_id = v_student.id
      AND date >= CURRENT_DATE - INTERVAL '30 days';
    
    -- Calculate percentage
    IF v_total_days > 0 THEN
      v_percentage := (v_present_days::DECIMAL / v_total_days) * 100;
      
      -- Check if below 75%
      IF v_percentage < 75 THEN
        INSERT INTO attendance_alerts (student_id, school_id, alert_type, message, attendance_percentage)
        VALUES (
          v_student.id,
          v_student.school_id,
          'below_75',
          'Attendance has fallen below 75%',
          v_percentage
        )
        ON CONFLICT DO NOTHING;
      END IF;
    END IF;
    
    -- Check consecutive absences
    SELECT COUNT(*) INTO v_consecutive_absent
    FROM (
      SELECT date, status,
             date - ROW_NUMBER() OVER (ORDER BY date)::INTEGER * INTERVAL '1 day' as grp
      FROM attendance_records
      WHERE student_id = v_student.id
        AND status = 'absent'
        AND date >= CURRENT_DATE - INTERVAL '7 days'
    ) sub
    GROUP BY grp
    ORDER BY COUNT(*) DESC
    LIMIT 1;
    
    -- Alert if 3+ consecutive absences
    IF v_consecutive_absent >= 3 THEN
      INSERT INTO attendance_alerts (student_id, school_id, alert_type, message, days_absent)
      VALUES (
        v_student.id,
        v_student.school_id,
        'consecutive_absent',
        'Student has been absent for ' || v_consecutive_absent || ' consecutive days',
        v_consecutive_absent
      )
      ON CONFLICT DO NOTHING;
    END IF;
  END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_attendance_slot_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Log a warning if slot_id is null (for debugging)
    IF NEW.slot_id IS NULL THEN
        RAISE WARNING 'Attendance record created without slot_id for student_id: %, date: %', NEW.student_id, NEW.date;
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_break_date_overlap()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  existing_break RECORD;
BEGIN
  -- Check for overlapping date ranges for the same college
  SELECT id, name, break_type, start_date, end_date INTO existing_break
  FROM college_breaks
  WHERE college_id = NEW.college_id
    AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
    AND start_date IS NOT NULL
    AND end_date IS NOT NULL
    AND NEW.start_date IS NOT NULL
    AND NEW.end_date IS NOT NULL
    AND NEW.start_date <= end_date
    AND NEW.end_date >= start_date
  LIMIT 1;

  IF FOUND THEN
    RAISE EXCEPTION 'Date range overlaps with existing break: "%" (% to %)', 
      existing_break.name, existing_break.start_date, existing_break.end_date;
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_budget_alerts(p_budget_id uuid, p_budget_head_name text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_budget RECORD;
  v_utilization DECIMAL(5,2);
  v_alert_threshold DECIMAL(5,2);
BEGIN
  -- Get budget details
  SELECT * INTO v_budget
  FROM department_budgets
  WHERE id = p_budget_id;
  
  -- Check overall utilization
  v_utilization := v_budget.utilization_percentage;
  v_alert_threshold := v_budget.alert_threshold_percentage;
  
  -- Create alert if threshold reached
  IF v_utilization >= v_alert_threshold AND NOT v_budget.alert_sent THEN
    INSERT INTO budget_alerts (
      budget_id,
      department_id,
      alert_type,
      alert_level,
      allocated_amount,
      spent_amount,
      remaining_amount,
      utilization_percentage,
      alert_message
    ) VALUES (
      p_budget_id,
      v_budget.department_id,
      'threshold_reached',
      CASE 
        WHEN v_utilization >= 95 THEN 'critical'
        WHEN v_utilization >= v_alert_threshold THEN 'warning'
        ELSE 'info'
      END,
      v_budget.total_allocated,
      v_budget.total_spent,
      v_budget.total_remaining,
      v_utilization,
      format('Budget utilization has reached %s%%. Allocated: %s, Spent: %s, Remaining: %s',
        v_utilization, v_budget.total_allocated, v_budget.total_spent, v_budget.total_remaining)
    );
    
    -- Mark alert as sent
    UPDATE department_budgets
    SET alert_sent = TRUE
    WHERE id = p_budget_id;
  END IF;
  
  -- Check for overspending
  IF v_budget.total_spent > v_budget.total_allocated THEN
    INSERT INTO budget_alerts (
      budget_id,
      department_id,
      alert_type,
      alert_level,
      allocated_amount,
      spent_amount,
      remaining_amount,
      utilization_percentage,
      alert_message
    ) VALUES (
      p_budget_id,
      v_budget.department_id,
      'budget_exceeded',
      'critical',
      v_budget.total_allocated,
      v_budget.total_spent,
      v_budget.total_remaining,
      v_utilization,
      format('Budget exceeded! Allocated: %s, Spent: %s, Overspent: %s',
        v_budget.total_allocated, v_budget.total_spent, 
        v_budget.total_spent - v_budget.total_allocated)
    );
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_club_capacity()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    current_members INTEGER;
    club_capacity INTEGER;
BEGIN
    -- Only check for active memberships
    IF NEW.status = 'active' THEN
        SELECT capacity INTO club_capacity
        FROM public.clubs 
        WHERE club_id = NEW.club_id;
        
        SELECT COUNT(*) INTO current_members
        FROM public.club_memberships
        WHERE club_id = NEW.club_id 
        AND status = 'active'
        AND membership_id != COALESCE(NEW.membership_id, '00000000-0000-0000-0000-000000000000'::UUID);
        
        IF current_members >= club_capacity THEN
            RAISE EXCEPTION 'Club is full (capacity: %). Cannot enroll more students.', club_capacity;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_college_affiliation()
 RETURNS TABLE(is_affiliated boolean, college_id uuid, university_id uuid, university_name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_user_id UUID;
    v_college_id UUID;
    v_university_id UUID;
    v_university_name TEXT;
    v_is_affiliated BOOLEAN := FALSE;
BEGIN
    -- Get current user ID
    v_user_id := auth.uid();
    
    -- Get college_id from user
    SELECT u."organizationId" INTO v_college_id
    FROM users u
    WHERE u.id = v_user_id;
    
    IF v_college_id IS NULL THEN
        RETURN QUERY SELECT FALSE, NULL::UUID, NULL::UUID, NULL::TEXT;
        RETURN;
    END IF;
    
    -- Check if college is affiliated with a university
    SELECT uc.university_id, o.name INTO v_university_id, v_university_name
    FROM university_colleges uc
    JOIN organizations o ON o.id = uc.university_id
    WHERE uc.college_id = v_college_id
    AND uc.account_status = 'active'
    LIMIT 1;
    
    v_is_affiliated := (v_university_id IS NOT NULL);
    
    RETURN QUERY SELECT v_is_affiliated, v_college_id, v_university_id, v_university_name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_college_affiliation_status(p_college_id uuid, p_university_id uuid DEFAULT NULL::uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- If university_id is provided, check specific affiliation
    IF p_university_id IS NOT NULL THEN
        RETURN EXISTS (
            SELECT 1 FROM university_colleges 
            WHERE college_id = p_college_id 
            AND university_id = p_university_id
            AND account_status = 'active'
        );
    END IF;
    
    -- Otherwise, check if college is affiliated with any university
    RETURN EXISTS (
        SELECT 1 FROM university_colleges 
        WHERE college_id = p_college_id 
        AND account_status = 'active'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_duplicate_active_subscription()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only check on INSERT operations, not UPDATE
  -- This allows renewals (updating existing subscription) to work
  IF TG_OP = 'INSERT' AND NEW.status = 'active' THEN
    -- Check if there's already an active subscription for this user and plan
    IF EXISTS (
      SELECT 1 FROM public.subscriptions
      WHERE user_id = NEW.user_id
        AND plan_type = NEW.plan_type
        AND status = 'active'
        AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
    ) THEN
      RAISE EXCEPTION 'User already has an active % subscription. Please cancel the existing subscription before purchasing again.', NEW.plan_type
        USING HINT = 'Cancel existing subscription first or manage your current subscription',
              ERRCODE = '23505'; -- unique_violation error code
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_max_clubs_per_student()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    club_count INTEGER;
    max_clubs INTEGER := 5; -- Configure this value as needed
BEGIN
    -- Only check for active memberships
    IF NEW.status = 'active' THEN
        SELECT COUNT(*) INTO club_count
        FROM public.club_memberships
        WHERE student_email = NEW.student_email
        AND status = 'active'
        AND membership_id != COALESCE(NEW.membership_id, '00000000-0000-0000-0000-000000000000'::UUID);
        
        IF club_count >= max_clubs THEN
            RAISE EXCEPTION 'Student cannot join more than % clubs', max_clubs;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_swap_conflicts(p_requester_slot_id uuid, p_target_slot_id uuid, p_swap_date date DEFAULT NULL::date)
 RETURNS TABLE(has_conflict boolean, conflict_reason text)
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_requester_slot RECORD;
  v_target_slot RECORD;
BEGIN
  -- Try to get slot from school timetable_slots first
  SELECT 
    id, timetable_id, day_of_week, period_number, start_time, end_time
  INTO v_requester_slot 
  FROM timetable_slots 
  WHERE id = p_requester_slot_id;
  
  -- If not found, try college_timetable_slots
  IF v_requester_slot IS NULL THEN
    SELECT 
      id, timetable_id, day_of_week, period_number, start_time, end_time
    INTO v_requester_slot 
    FROM college_timetable_slots 
    WHERE id = p_requester_slot_id;
  END IF;
  
  -- Try to get target slot from school timetable_slots first
  SELECT 
    id, timetable_id, day_of_week, period_number, start_time, end_time
  INTO v_target_slot 
  FROM timetable_slots 
  WHERE id = p_target_slot_id;
  
  -- If not found, try college_timetable_slots
  IF v_target_slot IS NULL THEN
    SELECT 
      id, timetable_id, day_of_week, period_number, start_time, end_time
    INTO v_target_slot 
    FROM college_timetable_slots 
    WHERE id = p_target_slot_id;
  END IF;
  
  -- Check if slots exist
  IF v_requester_slot IS NULL OR v_target_slot IS NULL THEN
    RETURN QUERY SELECT true, 'One or both slots not found'::TEXT;
    RETURN;
  END IF;
  
  -- Check if slots are from the same timetable
  IF v_requester_slot.timetable_id != v_target_slot.timetable_id THEN
    RETURN QUERY SELECT true, 'Slots must be from the same timetable'::TEXT;
    RETURN;
  END IF;
  
  -- Check if time slots overlap (for permanent swaps)
  IF p_swap_date IS NULL THEN
    IF v_requester_slot.day_of_week = v_target_slot.day_of_week AND
       v_requester_slot.period_number = v_target_slot.period_number THEN
      RETURN QUERY SELECT true, 'Cannot swap slots at the same time'::TEXT;
      RETURN;
    END IF;
  END IF;
  
  -- No conflicts found
  RETURN QUERY SELECT false, 'No conflicts detected'::TEXT;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_timetable_slot_conflicts()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  conflict_faculty RECORD;
  conflict_room RECORD;
BEGIN
  -- Check faculty conflict (same educator at same day/period in different class)
  SELECT 
    cts.id,
    cc.name as class_name,
    cc.grade,
    cc.section
  INTO conflict_faculty
  FROM college_timetable_slots cts
  JOIN college_classes cc ON cc.id = cts.class_id
  WHERE cts.timetable_id = NEW.timetable_id
    AND cts.educator_id = NEW.educator_id
    AND cts.day_of_week = NEW.day_of_week
    AND cts.period_number = NEW.period_number
    AND cts.class_id != NEW.class_id
    AND cts.id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
    AND (
      -- Both are recurring
      (NEW.is_recurring = true AND cts.is_recurring = true)
      -- Or both are on same specific date
      OR (NEW.schedule_date IS NOT NULL AND cts.schedule_date = NEW.schedule_date)
      -- Or new is specific date and existing is recurring (conflict on that day)
      OR (NEW.schedule_date IS NOT NULL AND cts.is_recurring = true)
      -- Or new is recurring and existing is specific date (would conflict)
      OR (NEW.is_recurring = true AND cts.schedule_date IS NOT NULL)
    )
  LIMIT 1;

  IF FOUND THEN
    RAISE EXCEPTION 'Faculty conflict: This faculty is already scheduled for % (%-%) at this time slot', 
      conflict_faculty.class_name, 
      conflict_faculty.grade, 
      conflict_faculty.section;
  END IF;

  -- Check room conflict (same room at same day/period) - only if room is specified
  IF NEW.room_number IS NOT NULL AND NEW.room_number != '' THEN
    SELECT 
      cts.id,
      cc.name as class_name,
      cc.grade,
      cc.section,
      cl.first_name,
      cl.last_name
    INTO conflict_room
    FROM college_timetable_slots cts
    JOIN college_classes cc ON cc.id = cts.class_id
    LEFT JOIN college_lecturers cl ON cl.id = cts.educator_id
    WHERE cts.timetable_id = NEW.timetable_id
      AND LOWER(cts.room_number) = LOWER(NEW.room_number)
      AND cts.day_of_week = NEW.day_of_week
      AND cts.period_number = NEW.period_number
      AND cts.id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::uuid)
      AND (
        (NEW.is_recurring = true AND cts.is_recurring = true)
        OR (NEW.schedule_date IS NOT NULL AND cts.schedule_date = NEW.schedule_date)
        OR (NEW.schedule_date IS NOT NULL AND cts.is_recurring = true)
        OR (NEW.is_recurring = true AND cts.schedule_date IS NOT NULL)
      )
    LIMIT 1;

    IF FOUND THEN
      RAISE EXCEPTION 'Room conflict: Room % is already booked by % (%-%) with %', 
        NEW.room_number,
        conflict_room.class_name, 
        conflict_room.grade, 
        conflict_room.section,
        COALESCE(conflict_room.first_name || ' ' || conflict_room.last_name, 'Unknown');
    END IF;
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_embedding_queue(days_old integer DEFAULT 7)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM embedding_queue
  WHERE status IN ('completed', 'failed')
    AND completed_at < NOW() - (days_old || ' days')::INTERVAL;
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_expired_job_matches_cache()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_deleted_count INTEGER;
BEGIN
    DELETE FROM student_job_matches
    WHERE expires_at < NOW() - INTERVAL '7 days'
    OR (is_valid = false AND updated_at < NOW() - INTERVAL '1 day');
    
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
    RETURN v_deleted_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_expired_otps()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  DELETE FROM phone_otps WHERE expires_at < NOW();
  DELETE FROM otp_requests_log WHERE created_at < NOW() - INTERVAL '24 hours';
END;
$function$
;

create or replace view "public"."club_participation_report" as  SELECT c.club_id,
    c.school_id,
    c.name AS club_name,
    c.category,
    count(DISTINCT cm.student_email) AS student_count,
    round(avg(cm.attendance_percentage), 2) AS avg_attendance,
    round(avg(cm.performance_score), 2) AS avg_performance_score,
    round((((count(DISTINCT cm.student_email))::numeric / (NULLIF(c.capacity, 0))::numeric) * (100)::numeric), 2) AS participation_score,
    ( SELECT string_agg(((((s.name)::text || ' ('::text) || round(((cm2.attendance_percentage * 0.6) + (COALESCE(cm2.performance_score, (0)::numeric) * 0.4)), 1)) || '% score)'::text), ', '::text) AS string_agg
           FROM (( SELECT cm_inner.student_email,
                    cm_inner.attendance_percentage,
                    cm_inner.performance_score,
                    ((cm_inner.attendance_percentage * 0.6) + (COALESCE(cm_inner.performance_score, (0)::numeric) * 0.4)) AS composite_score
                   FROM public.club_memberships cm_inner
                  WHERE ((cm_inner.club_id = c.club_id) AND ((cm_inner.status)::text = 'active'::text) AND (cm_inner.attendance_percentage >= (70)::numeric))
                  ORDER BY ((cm_inner.attendance_percentage * 0.6) + (COALESCE(cm_inner.performance_score, (0)::numeric) * 0.4)) DESC
                 LIMIT 5) cm2
             JOIN public.students s ON (((cm2.student_email)::text = s.email)))) AS top_performers,
    c.capacity,
    c.meeting_day,
    c.meeting_time,
    c.location,
    c.is_active
   FROM (public.clubs c
     LEFT JOIN public.club_memberships cm ON (((c.club_id = cm.club_id) AND ((cm.status)::text = 'active'::text))))
  GROUP BY c.club_id, c.school_id, c.name, c.category, c.capacity, c.meeting_day, c.meeting_time, c.location, c.is_active;


create or replace view "public"."college_assignments_view" as  SELECT ca.assignment_id,
    ca.title,
    ca.description,
    ca.instructions,
    ca.course_name,
    ca.course_code,
    ca.college_id,
    ca.college_educator_id,
    ca.program_section_id,
    ca.department_id,
    ca.program_id,
    ca.educator_name,
    ca.total_points,
    ca.assignment_type,
    ca.skill_outcomes,
    ca.document_pdf,
    ca.due_date,
    ca.available_from,
    ca.created_date,
    ca.updated_date,
    ca.allow_late_submission,
    ca.is_deleted,
    ps.semester,
    ps.section,
    ps.academic_year,
    ps.current_students,
    p.name AS program_name,
    p.code AS program_code,
    d.name AS department_name,
    d.code AS department_code,
    (((cl.first_name)::text || ' '::text) || (cl.last_name)::text) AS educator_full_name,
    cl.email AS educator_email,
    o.name AS college_name,
    count(DISTINCT csa.student_assignment_id) AS total_assigned,
    count(DISTINCT
        CASE
            WHEN (csa.status = 'submitted'::text) THEN csa.student_assignment_id
            ELSE NULL::uuid
        END) AS total_submitted,
    count(DISTINCT
        CASE
            WHEN (csa.status = 'graded'::text) THEN csa.student_assignment_id
            ELSE NULL::uuid
        END) AS total_graded
   FROM ((((((public.college_assignments ca
     LEFT JOIN public.program_sections ps ON ((ca.program_section_id = ps.id)))
     LEFT JOIN public.programs p ON ((ca.program_id = p.id)))
     LEFT JOIN public.departments d ON ((ca.department_id = d.id)))
     LEFT JOIN public.college_lecturers cl ON ((ca.college_educator_id = cl.user_id)))
     LEFT JOIN public.organizations o ON ((ca.college_id = o.id)))
     LEFT JOIN public.college_student_assignments csa ON (((ca.assignment_id = csa.assignment_id) AND (csa.is_deleted = false))))
  WHERE (ca.is_deleted = false)
  GROUP BY ca.assignment_id, ps.semester, ps.section, ps.academic_year, ps.current_students, p.name, p.code, d.name, d.code, cl.first_name, cl.last_name, cl.email, o.name;


create or replace view "public"."college_curriculum_status" as  SELECT c.id AS curriculum_id,
    c.academic_year,
    c.status,
    c.request_date,
    c.request_message,
    c.review_date,
    c.review_notes,
    c.published_date,
    cc.course_name,
    cc.course_code,
    cm.semester,
        CASE
            WHEN (uc.university_id IS NOT NULL) THEN true
            ELSE false
        END AS is_affiliated,
    uc.university_id,
    univ_org.name AS university_name,
    dept.name AS department_name,
    prog.name AS program_name
   FROM ((((((public.college_curriculums c
     LEFT JOIN public.college_course_mappings cm ON ((cm.id = c.course_id)))
     LEFT JOIN public.college_courses cc ON ((cc.id = cm.course_id)))
     LEFT JOIN public.university_colleges uc ON (((uc.college_id = c.college_id) AND ((uc.account_status)::text = 'active'::text))))
     LEFT JOIN public.organizations univ_org ON ((univ_org.id = uc.university_id)))
     LEFT JOIN public.departments dept ON ((dept.id = c.department_id)))
     LEFT JOIN public.programs prog ON ((prog.id = c.program_id)));


create or replace view "public"."college_daily_attendance_summary" as  SELECT date,
    department_name AS department,
    program_name AS course,
    semester,
    section,
    count(DISTINCT session_id) AS total_sessions,
    count(*) AS total_records,
    count(
        CASE
            WHEN ((status)::text = 'present'::text) THEN 1
            ELSE NULL::integer
        END) AS present_count,
    count(
        CASE
            WHEN ((status)::text = 'absent'::text) THEN 1
            ELSE NULL::integer
        END) AS absent_count,
    count(
        CASE
            WHEN ((status)::text = 'late'::text) THEN 1
            ELSE NULL::integer
        END) AS late_count,
    count(
        CASE
            WHEN ((status)::text = 'excused'::text) THEN 1
            ELSE NULL::integer
        END) AS excused_count,
    round((((count(
        CASE
            WHEN ((status)::text = ANY ((ARRAY['present'::character varying, 'late'::character varying, 'excused'::character varying])::text[])) THEN 1
            ELSE NULL::integer
        END))::numeric * 100.0) / (count(*))::numeric), 2) AS daily_attendance_percentage,
    college_id
   FROM public.college_attendance_records
  GROUP BY date, department_name, program_name, semester, section, college_id
  ORDER BY date DESC;


create or replace view "public"."college_student_attendance_stats" as  SELECT student_id,
    student_name,
    roll_number,
    subject_name AS subject,
    subject_code,
    department_name AS department,
    program_name AS course,
    semester,
    section,
    count(*) AS total_classes,
    count(
        CASE
            WHEN ((status)::text = 'present'::text) THEN 1
            ELSE NULL::integer
        END) AS present_count,
    count(
        CASE
            WHEN ((status)::text = 'absent'::text) THEN 1
            ELSE NULL::integer
        END) AS absent_count,
    count(
        CASE
            WHEN ((status)::text = 'late'::text) THEN 1
            ELSE NULL::integer
        END) AS late_count,
    count(
        CASE
            WHEN ((status)::text = 'excused'::text) THEN 1
            ELSE NULL::integer
        END) AS excused_count,
    round((((count(
        CASE
            WHEN ((status)::text = ANY ((ARRAY['present'::character varying, 'late'::character varying, 'excused'::character varying])::text[])) THEN 1
            ELSE NULL::integer
        END))::numeric * 100.0) / (count(*))::numeric), 2) AS attendance_percentage,
    college_id
   FROM public.college_attendance_records ar
  GROUP BY student_id, student_name, roll_number, subject_name, subject_code, department_name, program_name, semester, section, college_id;


create or replace view "public"."college_subject_attendance_summary" as  SELECT subject_name AS subject,
    subject_code,
    department_name AS department,
    program_name AS course,
    program_code,
    semester,
    section,
    faculty_name AS faculty,
    faculty_id,
    count(DISTINCT id) AS total_sessions,
    COALESCE(avg(attendance_percentage), (0)::numeric) AS avg_attendance_percentage,
    COALESCE(sum(present_count), (0)::bigint) AS total_present_count,
    COALESCE(sum(absent_count), (0)::bigint) AS total_absent_count,
    COALESCE(sum(late_count), (0)::bigint) AS total_late_count,
    COALESCE(sum(excused_count), (0)::bigint) AS total_excused_count,
    min(date) AS first_date,
    max(date) AS last_date,
    COALESCE(( SELECT college_attendance_sessions.status
           FROM public.college_attendance_sessions
          WHERE (((college_attendance_sessions.subject_name)::text = (ats.subject_name)::text) AND ((college_attendance_sessions.department_name)::text = (ats.department_name)::text) AND ((college_attendance_sessions.program_name)::text = (ats.program_name)::text) AND (college_attendance_sessions.semester = ats.semester) AND ((college_attendance_sessions.section)::text = (ats.section)::text) AND (college_attendance_sessions.college_id = ats.college_id))
          ORDER BY college_attendance_sessions.date DESC, college_attendance_sessions.start_time DESC
         LIMIT 1), 'scheduled'::character varying) AS latest_status,
    COALESCE(max(total_students), 0) AS total_students,
    college_id,
    course_type
   FROM public.college_attendance_sessions ats
  GROUP BY subject_name, subject_code, department_name, program_name, program_code, semester, section, faculty_name, faculty_id, college_id, course_type;


create or replace view "public"."competition_performance_report" as  SELECT comp.comp_id,
    comp.school_id,
    comp.name AS competition_name,
    comp.level,
    comp.category,
    comp.competition_date,
    count(DISTINCT cr.student_email) AS total_participants,
    count(DISTINCT
        CASE
            WHEN (cr.award IS NOT NULL) THEN cr.student_email
            ELSE NULL::character varying
        END) AS award_winners,
    string_agg(DISTINCT (cr.award)::text, ', '::text) AS awards_won,
    round(avg(cr.score), 2) AS avg_score,
    ( SELECT string_agg(ranked_results.student_result, ', '::text) AS string_agg
           FROM ( SELECT ((((s.name)::text || ' (Rank: '::text) || COALESCE((cr2.rank)::text, 'N/A'::text)) || ')'::text) AS student_result
                   FROM (public.competition_results cr2
                     JOIN public.students s ON (((cr2.student_email)::text = s.email)))
                  WHERE (cr2.comp_id = comp.comp_id)
                  ORDER BY cr2.rank
                 LIMIT 10) ranked_results) AS student_results
   FROM (public.competitions comp
     LEFT JOIN public.competition_results cr ON ((comp.comp_id = cr.comp_id)))
  GROUP BY comp.comp_id, comp.school_id, comp.name, comp.level, comp.category, comp.competition_date;


create or replace view "public"."competition_results_with_students" as  SELECT cr.result_id,
    cr.comp_id,
    comp.name AS competition_name,
    comp.level,
    comp.category,
    cr.student_email,
    s.name AS student_name,
    s.grade,
    s.section,
    cr.rank,
    cr.score,
    cr.award,
    cr.certificate_issued,
    cr.recorded_at
   FROM ((public.competition_results cr
     JOIN public.competitions comp ON ((cr.comp_id = comp.comp_id)))
     JOIN public.students s ON (((cr.student_email)::text = s.email)));


CREATE OR REPLACE FUNCTION public.complete_embedding_queue_item(queue_id uuid, success boolean, error_msg text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE embedding_queue
  SET 
    status = CASE WHEN success THEN 'completed' ELSE 'failed' END,
    processed_at = NOW(),
    error_message = error_msg
  WHERE id = queue_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.compute_student_profile_hash(p_student_id uuid)
 RETURNS character varying
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_hash_input TEXT;
    v_student RECORD;
    v_courses TEXT;
    v_trainings TEXT;
BEGIN
    -- Get student data (using actual column names from students table)
    SELECT 
        s.id,
        s.name,
        s.email,
        s.branch_field,
        s.semester,
        s."currentCgpa",
        s.skill_summary,
        s.interests,
        s.hobbies,
        s.metadata
    INTO v_student
    FROM students s
    WHERE s.id = p_student_id;
    
    IF NOT FOUND THEN
        RETURN NULL;
    END IF;
    
    -- Get course enrollments
    SELECT COALESCE(string_agg(ce.course_id::text || ':' || ce.status || ':' || COALESCE(ce.progress::text, '0'), '|' ORDER BY ce.course_id), '')
    INTO v_courses
    FROM course_enrollments ce
    WHERE ce.student_id = p_student_id;
    
    -- Get trainings
    SELECT COALESCE(string_agg(t.id::text || ':' || t.status, '|' ORDER BY t.id), '')
    INTO v_trainings
    FROM trainings t
    WHERE t.student_id = p_student_id;
    
    -- Build hash input from all relevant fields
    v_hash_input := COALESCE(v_student.name, '') || '|' ||
                    COALESCE(v_student.branch_field, '') || '|' ||
                    COALESCE(v_student.semester::text, '') || '|' ||
                    COALESCE(v_student."currentCgpa"::text, '') || '|' ||
                    COALESCE(v_student.skill_summary, '') || '|' ||
                    COALESCE(v_student.interests::text, '') || '|' ||
                    COALESCE(v_student.hobbies::text, '') || '|' ||
                    COALESCE(v_student.metadata::text, '') || '|' ||
                    v_courses || '|' ||
                    v_trainings;
    
    -- Return MD5 hash
    RETURN md5(v_hash_input);
END;
$function$
;

create or replace view "public"."conversations_detailed" as  SELECT c.id,
    c.student_id,
    c.recruiter_id,
    c.application_id,
    c.opportunity_id,
    c.subject,
    c.status,
    c.last_message_at,
    c.last_message_preview,
    c.last_message_sender,
    c.student_unread_count,
    c.recruiter_unread_count,
    c.created_at,
    c.updated_at,
    s.name AS student_name,
    s.email AS student_email,
    COALESCE(s.university_main, s.university) AS student_university,
    s.course_name AS student_course,
    s.branch_field AS student_department,
    r.name AS recruiter_name,
    r.email AS recruiter_email,
    r.phone AS recruiter_phone,
    r.website AS recruiter_website,
    aj.application_status,
    o.job_title,
    o.company_name
   FROM ((((public.conversations c
     LEFT JOIN public.students s ON ((c.student_id = s.id)))
     LEFT JOIN public.recruiters r ON ((c.recruiter_id = r.id)))
     LEFT JOIN public.applied_jobs aj ON ((c.application_id = aj.id_old)))
     LEFT JOIN public.opportunities o ON ((c.opportunity_id = o.id_old)))
  WHERE (c.status = 'active'::text);


CREATE OR REPLACE FUNCTION public.copy_curriculum_template(p_source_curriculum_id uuid, p_target_school_id uuid, p_target_subject character varying, p_target_class character varying, p_target_academic_year character varying, p_created_by uuid)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_new_curriculum_id UUID;
  v_chapter_record RECORD;
  v_new_chapter_id UUID;
  v_outcome_record RECORD;
  v_new_outcome_id UUID;
  v_mapping_record RECORD;
BEGIN
  -- Create new curriculum
  INSERT INTO curriculums (
    school_id, subject, class, academic_year, status, created_by
  ) VALUES (
    p_target_school_id, p_target_subject, p_target_class, p_target_academic_year, 'draft', p_created_by
  ) RETURNING id INTO v_new_curriculum_id;
  
  -- Copy chapters
  FOR v_chapter_record IN 
    SELECT * FROM curriculum_chapters 
    WHERE curriculum_id = p_source_curriculum_id 
    ORDER BY order_number
  LOOP
    INSERT INTO curriculum_chapters (
      curriculum_id, name, code, description, order_number, 
      estimated_duration, duration_unit
    ) VALUES (
      v_new_curriculum_id, v_chapter_record.name, v_chapter_record.code, 
      v_chapter_record.description, v_chapter_record.order_number,
      v_chapter_record.estimated_duration, v_chapter_record.duration_unit
    ) RETURNING id INTO v_new_chapter_id;
    
    -- Copy learning outcomes for this chapter
    FOR v_outcome_record IN 
      SELECT * FROM curriculum_learning_outcomes 
      WHERE chapter_id = v_chapter_record.id
    LOOP
      INSERT INTO curriculum_learning_outcomes (
        chapter_id, outcome, bloom_level
      ) VALUES (
        v_new_chapter_id, v_outcome_record.outcome, v_outcome_record.bloom_level
      ) RETURNING id INTO v_new_outcome_id;
      
      -- Copy assessment mappings for this outcome
      FOR v_mapping_record IN 
        SELECT * FROM outcome_assessment_mappings 
        WHERE learning_outcome_id = v_outcome_record.id
      LOOP
        INSERT INTO outcome_assessment_mappings (
          learning_outcome_id, assessment_type_id, weightage
        ) VALUES (
          v_new_outcome_id, v_mapping_record.assessment_type_id, v_mapping_record.weightage
        );
      END LOOP;
    END LOOP;
  END LOOP;
  
  RETURN v_new_curriculum_id;
END;
$function$
;

create or replace view "public"."course_summary" as  SELECT c.course_id,
    c.title,
    c.code,
    c.description,
    c.status,
    c.duration,
    c.educator_id,
    COALESCE(concat(u."firstName", ' ', u."lastName"), 'Unknown'::text) AS educator_name,
    c.enrollment_count,
    c.completion_rate,
    c.evidence_pending,
    c.created_at,
    c.updated_at,
    count(DISTINCT cm.module_id) AS module_count,
    count(DISTINCT l.lesson_id) AS lesson_count,
    count(DISTINCT lr.resource_id) AS resource_count,
    COALESCE(json_agg(DISTINCT cs.skill_name) FILTER (WHERE (cs.skill_name IS NOT NULL)), '[]'::json) AS skills,
    COALESCE(json_agg(DISTINCT cc.class_name) FILTER (WHERE (cc.class_name IS NOT NULL)), '[]'::json) AS classes
   FROM (((((((public.courses c
     LEFT JOIN public.admin_users au ON ((c.educator_id = au.id)))
     LEFT JOIN public.users u ON ((au.id = u.id)))
     LEFT JOIN public.course_modules cm ON ((c.course_id = cm.course_id)))
     LEFT JOIN public.lessons l ON ((cm.module_id = l.module_id)))
     LEFT JOIN public.lesson_resources lr ON ((l.lesson_id = lr.lesson_id)))
     LEFT JOIN public.course_skills cs ON ((c.course_id = cs.course_id)))
     LEFT JOIN public.course_classes cc ON ((c.course_id = cc.course_id)))
  GROUP BY c.course_id, u."firstName", u."lastName";


CREATE OR REPLACE FUNCTION public.create_assessment_restriction()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
    INSERT INTO public.personal_assessment_restrictions (student_id, last_attempt_date, next_allowed_date, grade_level)
    VALUES (NEW.student_id, NEW.completed_at, NEW.completed_at + INTERVAL '90 days', NEW.grade_level)
    ON CONFLICT (student_id, grade_level)
    DO UPDATE SET
      last_attempt_date = EXCLUDED.last_attempt_date,
      next_allowed_date = EXCLUDED.next_allowed_date;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_faculty_leave_balances()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Insert leave balance records for all active leave types of the college
  INSERT INTO college_faculty_leave_balances (college_id, faculty_id, leave_type_id, academic_year, total_days, used_days)
  SELECT 
    NEW."collegeId",
    NEW.id,
    lt.id,
    '2025-2026',  -- Current academic year
    COALESCE(lt.max_days_per_year, 0),
    0
  FROM college_leave_types lt
  WHERE lt.college_id = NEW."collegeId" 
    AND lt.is_active = true;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_index_if_not_exists(p_index_name text, p_table_name text, p_definition text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_indexes 
        WHERE schemaname = 'public' 
        AND indexname = p_index_name
    ) THEN
        EXECUTE format('CREATE INDEX %I ON %I %s', 
            p_index_name, p_table_name, p_definition);
        RAISE NOTICE 'Created index %', p_index_name;
    ELSE
        RAISE NOTICE 'Index % already exists, skipping', p_index_name;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_message_notification()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  v_sender_name text;
  v_notification_title text;
  v_notification_message text;
begin
  -- Only create notification if receiver is a student
  if new.receiver_type = 'student' then
    -- Get sender name based on sender_type
    if new.sender_type = 'recruiter' then
      -- Fix: Use correct column names for recruiters table
      select coalesce(name, email) into v_sender_name
      from recruiters
      where id = new.sender_id;
    elsif new.sender_type = 'educator' then
      select coalesce(first_name || ' ' || last_name, email) into v_sender_name
      from school_educators
      where id = new.sender_id;
    elsif new.sender_type = 'school_admin' then
      select coalesce("firstName" || ' ' || "lastName", email) into v_sender_name
      from users
      where id = new.sender_id;
    elsif new.sender_type = 'college_admin' then
      select coalesce("firstName" || ' ' || "lastName", email) into v_sender_name
      from users
      where id = new.sender_id;
    elsif new.sender_type = 'student' then
      select coalesce(profile->>'name', email) into v_sender_name
      from students
      where id = new.sender_id;
    end if;

    v_sender_name := coalesce(v_sender_name, 'Someone');
    v_notification_title := 'New message from ' || v_sender_name;
    v_notification_message := substring(new.message_text from 1 for 100);

    -- Create notification for the student
    insert into notifications (
      recipient_id,
      type,
      title,
      message,
      read
    ) values (
      new.receiver_id,
      'new_message',
      v_notification_title,
      v_notification_message,
      false
    );
  end if;

  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.create_notification_from_pipeline_activity()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_student_id UUID;
  v_candidate_name TEXT;
  v_opportunity_title TEXT;
  v_notification_type TEXT;
  v_notification_title TEXT;
  v_notification_message TEXT;
BEGIN
  -- Get student ID from pipeline_candidates
  SELECT student_id INTO v_student_id
  FROM pipeline_candidates
  WHERE id = NEW.pipeline_candidate_id
  LIMIT 1;

  -- Get candidate name and opportunity title
  SELECT 
    pc.candidate_name,
    o.title
  INTO 
    v_candidate_name,
    v_opportunity_title
  FROM pipeline_candidates pc
  LEFT JOIN opportunities o ON pc.opportunity_id = o.id
  WHERE pc.id = NEW.pipeline_candidate_id
  LIMIT 1;

  -- Determine notification type and message based on activity
  IF NEW.activity_type = 'stage_change' THEN
    -- Stage change notification
    v_notification_type := 'pipeline_stage_changed';
    
    IF NEW.to_stage = 'hired' THEN
      v_notification_title := 'Congratulations! You''ve been hired!';
      v_notification_message := 'Great news! You have been selected for the position of ' || COALESCE(v_opportunity_title, 'the opportunity') || '.';
    ELSIF NEW.to_stage = 'offer' THEN
      v_notification_title := 'Offer Extended!';
      v_notification_message := 'You have received an offer for ' || COALESCE(v_opportunity_title, 'a position') || '. Review the details in your dashboard.';
    ELSIF NEW.to_stage = 'interview_2' THEN
      v_notification_title := 'Advanced to Final Interview';
      v_notification_message := 'Congratulations! You have been selected for the final interview round for ' || COALESCE(v_opportunity_title, 'a position') || '.';
    ELSIF NEW.to_stage = 'interview_1' THEN
      v_notification_title := 'Interview Scheduled';
      v_notification_message := 'You have been selected for an interview for ' || COALESCE(v_opportunity_title, 'a position') || '.';
    ELSIF NEW.to_stage = 'screened' THEN
      v_notification_title := 'Application Screened';
      v_notification_message := 'Your application for ' || COALESCE(v_opportunity_title, 'a position') || ' is under review.';
    ELSIF NEW.to_stage = 'rejected' THEN
      v_notification_type := 'candidate_rejected';
      v_notification_title := 'Application Status Update';
      v_notification_message := 'Thank you for your interest in ' || COALESCE(v_opportunity_title, 'a position') || '. We have decided to move forward with other candidates.';
    END IF;
  
  ELSIF NEW.activity_type = 'note_added' THEN
    v_notification_type := 'pipeline_stage_changed';
    v_notification_title := 'Update on your application';
    v_notification_message := 'Your application for ' || COALESCE(v_opportunity_title, 'a position') || ' has been updated.';
  
  ELSIF NEW.activity_type = 'next_action_set' THEN
    v_notification_type := 'interview_reminder';
    v_notification_title := 'Action Required';
    v_notification_message := 'Next steps for your application for ' || COALESCE(v_opportunity_title, 'a position') || ' have been set.';
  
  ELSE
    -- For other activity types, use generic notification
    v_notification_type := 'pipeline_stage_changed';
    v_notification_title := 'Application Update';
    v_notification_message := 'Your application for ' || COALESCE(v_opportunity_title, 'a position') || ' has been updated.';
  END IF;

  -- Only create notification if student_id exists
  IF v_student_id IS NOT NULL THEN
    -- Store student_id in the pipeline_activities record if not already set
    IF NEW.student_id IS NULL THEN
      NEW.student_id := v_student_id;
    END IF;

    -- Create notification in notifications table
    INSERT INTO notifications (
      recipient_id,
      type,
      title,
      message,
      read,
      created_at
    ) VALUES (
      v_student_id,
      v_notification_type,
      v_notification_title,
      v_notification_message,
      false,
      NOW()
    );
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_skills_from_external_course()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  skill_name text;
  training_record_id uuid;
BEGIN
  -- Only process when course is completed
  IF NEW.completion_date IS NOT NULL AND (OLD IS NULL OR OLD.completion_date IS NULL OR OLD.completion_date != NEW.completion_date) THEN
    
    -- Create or update training record
    IF NEW.training_id IS NULL THEN
      INSERT INTO public.trainings (
        student_id,
        title,
        organization,
        start_date,
        end_date,
        status,
        source
      ) VALUES (
        NEW.student_id,
        NEW.course_name,
        NEW.organization,
        NEW.start_date,
        NEW.completion_date,
        'completed',
        'external_course'
      )
      RETURNING id INTO training_record_id;
      
      -- Update external course with training_id
      NEW.training_id := training_record_id;
    END IF;
    
    -- Create skills from skills_acquired array
    IF NEW.skills_acquired IS NOT NULL AND jsonb_array_length(NEW.skills_acquired) > 0 THEN
      FOR skill_name IN SELECT jsonb_array_elements_text(NEW.skills_acquired)
      LOOP
        INSERT INTO public.skills (
          student_id,
          name,
          type,
          level,
          training_id,
          verified,
          approval_status
        ) VALUES (
          NEW.student_id,
          skill_name,
          'technical',
          3, -- Default level
          COALESCE(NEW.training_id, training_record_id),
          true, -- Auto-verified from course completion
          'approved'
        )
        ON CONFLICT DO NOTHING;
      END LOOP;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_skills_from_internal_course()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  skill_name text;
  training_record_id uuid;
BEGIN
  -- Only process when course is completed
  IF NEW.completed_at IS NOT NULL AND (OLD.completed_at IS NULL OR OLD.completed_at != NEW.completed_at) THEN
    
    -- Create or update training record
    IF NEW.training_id IS NULL THEN
      INSERT INTO public.trainings (
        student_id,
        title,
        organization,
        start_date,
        end_date,
        status,
        course_id,
        source
      ) VALUES (
        NEW.student_id,
        NEW.course_title,
        NEW.educator_name,
        NEW.enrolled_at::date,
        NEW.completed_at::date,
        'completed',
        NEW.course_id,
        'internal_course'
      )
      RETURNING id INTO training_record_id;
      
      -- Update enrollment with training_id
      NEW.training_id := training_record_id;
    END IF;
    
    -- Create skills from skills_acquired array
    IF NEW.skills_acquired IS NOT NULL AND jsonb_array_length(NEW.skills_acquired) > 0 THEN
      FOR skill_name IN SELECT jsonb_array_elements_text(NEW.skills_acquired)
      LOOP
        INSERT INTO public.skills (
          student_id,
          name,
          type,
          level,
          training_id,
          verified,
          approval_status
        ) VALUES (
          NEW.student_id,
          skill_name,
          'technical',
          3, -- Default level
          COALESCE(NEW.training_id, training_record_id),
          true, -- Auto-verified from course completion
          'approved'
        )
        ON CONFLICT DO NOTHING;
      END LOOP;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_student_with_user(p_email text, p_name text, p_student_id text, p_grade text, p_school_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_user_id UUID;
    v_first_name TEXT;
    v_last_name TEXT;
BEGIN
    v_user_id := gen_random_uuid();
    v_first_name := split_part(p_name, ' ', 1);
    v_last_name := COALESCE(split_part(p_name, ' ', 2), '');
    
    INSERT INTO public.users (
        id,
        email,
        role,
        "firstName",
        "lastName",
        "createdAt",
        "updatedAt"
    ) VALUES (
        v_user_id,
        p_email,
        'school_student',
        v_first_name,
        v_last_name,
        NOW(),
        NOW()
    ) ON CONFLICT (email) DO UPDATE SET email = EXCLUDED.email
    RETURNING id INTO v_user_id;
    
    INSERT INTO public.students (
        id,
        user_id,
        school_id,
        name,
        email,
        student_id,
        grade,
        student_type,
        created_at
    ) VALUES (
        v_user_id,
        v_user_id,
        p_school_id,
        p_name,
        p_email,
        p_student_id,
        p_grade,
        'direct',
        NOW()
    ) ON CONFLICT (email) DO NOTHING;
    
    RETURN v_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_swap_history_entry()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- On INSERT, create 'created' history entry
  IF TG_OP = 'INSERT' THEN
    INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
    VALUES (NEW.id, 'created', NEW.requester_faculty_id, 'requester', NEW.reason);
    RETURN NEW;
  END IF;
  
  -- On UPDATE, detect what changed and create appropriate history entry
  IF TG_OP = 'UPDATE' THEN
    -- Status changed to accepted
    IF OLD.status = 'pending' AND NEW.status = 'accepted' THEN
      INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
      VALUES (NEW.id, 'accepted', NEW.target_faculty_id, 'target', NEW.target_response);
    END IF;
    
    -- Status changed to rejected
    IF OLD.status = 'pending' AND NEW.status = 'rejected' THEN
      INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
      VALUES (NEW.id, 'rejected', NEW.target_faculty_id, 'target', NEW.target_response);
    END IF;
    
    -- Status changed to cancelled
    IF NEW.status = 'cancelled' THEN
      INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
      VALUES (NEW.id, 'cancelled', NEW.requester_faculty_id, 'requester', 'Request cancelled by requester');
    END IF;
    
    -- Admin approval status changed
    IF OLD.admin_approval_status IS DISTINCT FROM NEW.admin_approval_status THEN
      IF NEW.admin_approval_status = 'approved' THEN
        INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
        VALUES (NEW.id, 'admin_approved', NEW.admin_id, 'admin', NEW.admin_response);
      ELSIF NEW.admin_approval_status = 'rejected' THEN
        INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
        VALUES (NEW.id, 'admin_rejected', NEW.admin_id, 'admin', NEW.admin_response);
      END IF;
    END IF;
    
    -- Status changed to completed
    IF OLD.status != 'completed' AND NEW.status = 'completed' THEN
      INSERT INTO class_swap_history (swap_request_id, action, actor_id, actor_role, notes)
      VALUES (NEW.id, 'completed', COALESCE(NEW.admin_id, NEW.requester_faculty_id), 'admin', 'Swap completed successfully');
    END IF;
    
    RETURN NEW;
  END IF;
  
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.curriculum_add_pending_change(p_curriculum_id uuid, p_change_type text, p_entity_id uuid DEFAULT NULL::uuid, p_change_data jsonb DEFAULT '{}'::jsonb, p_message text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_change_id UUID;
  v_user_id UUID;
  v_user_name TEXT;
  v_user_email TEXT;
BEGIN
  -- Get current user info
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'User not authenticated';
  END IF;
  
  SELECT name, email INTO v_user_name, v_user_email
  FROM users 
  WHERE id = v_user_id;
  
  -- Generate new change ID
  v_change_id := gen_random_uuid();
  
  -- Add to pending_changes JSONB array in college_curriculums
  UPDATE college_curriculums 
  SET 
    pending_changes = COALESCE(pending_changes, '[]'::jsonb) || 
    jsonb_build_object(
      'id', v_change_id,
      'change_type', p_change_type,
      'entity_id', p_entity_id,
      'request_timestamp', NOW(),
      'requested_by', v_user_id,
      'requester_name', COALESCE(v_user_name, v_user_email, 'Unknown'),
      'request_message', p_message,
      'status', 'pending',
      'data', p_change_data
    ),
    has_pending_changes = true,
    updated_at = NOW()
  WHERE id = p_curriculum_id;
  
  -- Add to change_history for tracking
  UPDATE college_curriculums 
  SET 
    change_history = COALESCE(change_history, '[]'::jsonb) || 
    jsonb_build_object(
      'id', v_change_id,
      'action', 'change_requested',
      'change_type', p_change_type,
      'request_timestamp', NOW(),
      'user_id', v_user_id,
      'user_name', COALESCE(v_user_name, v_user_email, 'Unknown'),
      'message', p_message
    )
  WHERE id = p_curriculum_id;
  
  RETURN v_change_id;
END;
$function$
;

create or replace view "public"."curriculum_approval_dashboard" as  SELECT c.id AS curriculum_id,
    c.academic_year,
    c.status,
    c.request_date,
    c.request_message,
    c.review_date,
    c.review_notes,
    c.published_date,
    cc.course_name,
    cc.course_code,
    cm.semester,
    college_org.name AS college_name,
    college_org.id AS college_id,
    univ_org.name AS university_name,
    univ_org.id AS university_id,
    requester.email AS requester_email,
    concat(requester."firstName", ' ', requester."lastName") AS requester_name,
    reviewer.email AS reviewer_email,
    concat(reviewer."firstName", ' ', reviewer."lastName") AS reviewer_name,
    dept.name AS department_name,
    prog.name AS program_name
   FROM ((((((((public.college_curriculums c
     LEFT JOIN public.college_course_mappings cm ON ((cm.id = c.course_id)))
     LEFT JOIN public.college_courses cc ON ((cc.id = cm.course_id)))
     LEFT JOIN public.organizations college_org ON ((college_org.id = c.college_id)))
     LEFT JOIN public.organizations univ_org ON ((univ_org.id = c.university_id)))
     LEFT JOIN public.users requester ON ((requester.id = c.requested_by)))
     LEFT JOIN public.users reviewer ON ((reviewer.id = c.reviewed_by)))
     LEFT JOIN public.departments dept ON ((dept.id = c.department_id)))
     LEFT JOIN public.programs prog ON ((prog.id = c.program_id)))
  WHERE ((c.status)::text = ANY ((ARRAY['pending_approval'::character varying, 'rejected'::character varying, 'published'::character varying])::text[]));


CREATE OR REPLACE FUNCTION public.curriculum_approve_pending_change(p_curriculum_id uuid, p_change_id uuid, p_review_notes text DEFAULT NULL::text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_change JSONB;
  v_change_type TEXT;
  v_change_data JSONB;
  v_entity_id UUID;
  v_user_id UUID;
  v_user_name TEXT;
  v_user_email TEXT;
  v_new_outcome_id UUID;
  v_pending_changes JSONB;
  v_updated_changes JSONB;
  v_change_elem JSONB;
  v_outcome_unit_id UUID;
  v_outcome_text TEXT;
  v_bloom_level TEXT;
  v_assessment_mappings JSONB;
BEGIN
  -- Get current user info
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'User not authenticated';
  END IF;
  
  SELECT name, email INTO v_user_name, v_user_email
  FROM users 
  WHERE id = v_user_id;
  
  -- Get pending changes
  SELECT pending_changes INTO v_pending_changes
  FROM college_curriculums
  WHERE id = p_curriculum_id;
  
  IF v_pending_changes IS NULL THEN
    RAISE EXCEPTION 'No pending changes found for curriculum';
  END IF;
  
  -- Find the specific change
  v_change := NULL;
  FOR i IN 0..jsonb_array_length(v_pending_changes) - 1 LOOP
    v_change_elem := v_pending_changes->i;
    IF v_change_elem->>'id' = p_change_id::text THEN
      v_change := v_change_elem;
      EXIT;
    END IF;
  END LOOP;
  
  IF v_change IS NULL THEN
    RAISE EXCEPTION 'Change request not found with ID: %', p_change_id;
  END IF;
  
  -- Extract change details
  v_change_type := v_change->>'change_type';
  v_change_data := v_change->'data';
  v_entity_id := (v_change->>'entity_id')::UUID;
  
  -- Apply the change based on type
  IF v_change_type = 'outcome_add' THEN
    -- Add new outcome - handle the specific data structure we found
    -- Data structure: {"data": {"unitId": "...", "outcome": "...", "bloomLevel": "...", "assessmentMappings": [...]}}
    
    -- Extract unit_id (it's nested as data.data.unitId)
    v_outcome_unit_id := NULL;
    IF v_change_data->'data'->>'unitId' IS NOT NULL THEN
      v_outcome_unit_id := (v_change_data->'data'->>'unitId')::UUID;
    ELSIF v_change_data->'data'->>'unit_id' IS NOT NULL THEN
      v_outcome_unit_id := (v_change_data->'data'->>'unit_id')::UUID;
    ELSIF v_change_data->>'unitId' IS NOT NULL THEN
      v_outcome_unit_id := (v_change_data->>'unitId')::UUID;
    ELSIF v_change_data->>'unit_id' IS NOT NULL THEN
      v_outcome_unit_id := (v_change_data->>'unit_id')::UUID;
    END IF;
    
    -- Extract outcome text (it's nested as data.data.outcome)
    v_outcome_text := NULL;
    IF v_change_data->'data'->>'outcome' IS NOT NULL THEN
      v_outcome_text := v_change_data->'data'->>'outcome';
    ELSIF v_change_data->'data'->>'outcome_text' IS NOT NULL THEN
      v_outcome_text := v_change_data->'data'->>'outcome_text';
    ELSIF v_change_data->>'outcome' IS NOT NULL THEN
      v_outcome_text := v_change_data->>'outcome';
    ELSIF v_change_data->>'outcome_text' IS NOT NULL THEN
      v_outcome_text := v_change_data->>'outcome_text';
    END IF;
    
    -- Extract bloom level (it's nested as data.data.bloomLevel)
    v_bloom_level := 'Apply'; -- Default value
    IF v_change_data->'data'->>'bloomLevel' IS NOT NULL THEN
      v_bloom_level := v_change_data->'data'->>'bloomLevel';
    ELSIF v_change_data->'data'->>'bloom_level' IS NOT NULL THEN
      v_bloom_level := v_change_data->'data'->>'bloom_level';
    ELSIF v_change_data->>'bloomLevel' IS NOT NULL THEN
      v_bloom_level := v_change_data->>'bloomLevel';
    ELSIF v_change_data->>'bloom_level' IS NOT NULL THEN
      v_bloom_level := v_change_data->>'bloom_level';
    END IF;
    
    -- Extract assessment mappings (it's nested as data.data.assessmentMappings)
    v_assessment_mappings := '[]'::jsonb;
    IF v_change_data->'data'->'assessmentMappings' IS NOT NULL THEN
      v_assessment_mappings := v_change_data->'data'->'assessmentMappings';
    ELSIF v_change_data->'data'->'assessment_mappings' IS NOT NULL THEN
      v_assessment_mappings := v_change_data->'data'->'assessment_mappings';
    ELSIF v_change_data->'assessmentMappings' IS NOT NULL THEN
      v_assessment_mappings := v_change_data->'assessmentMappings';
    ELSIF v_change_data->'assessment_mappings' IS NOT NULL THEN
      v_assessment_mappings := v_change_data->'assessment_mappings';
    END IF;
    
    -- Validate required fields
    IF v_outcome_unit_id IS NULL THEN
      RAISE EXCEPTION 'unit_id is required for outcome_add but was not found. Change data: %. Looking for: data.data.unitId or data.data.unit_id', v_change_data::text;
    END IF;
    
    IF v_outcome_text IS NULL OR v_outcome_text = '' OR v_outcome_text = 'NA' THEN
      RAISE EXCEPTION 'outcome_text is required for outcome_add but was not found or is invalid. Change data: %. Looking for: data.data.outcome or data.data.outcome_text', v_change_data::text;
    END IF;
    
    -- Verify the unit exists
    IF NOT EXISTS (SELECT 1 FROM college_curriculum_units WHERE id = v_outcome_unit_id AND curriculum_id = p_curriculum_id) THEN
      RAISE EXCEPTION 'Unit with id % does not exist in curriculum %', v_outcome_unit_id, p_curriculum_id;
    END IF;
    
    -- Add new outcome
    v_new_outcome_id := gen_random_uuid();
    INSERT INTO college_curriculum_outcomes (
      id,
      curriculum_id,
      unit_id,
      outcome_text,
      bloom_level,
      assessment_mappings,
      created_by,
      updated_by
    ) VALUES (
      v_new_outcome_id,
      p_curriculum_id,
      v_outcome_unit_id,
      v_outcome_text,
      v_bloom_level,
      v_assessment_mappings,
      v_user_id,
      v_user_id
    );
    
  ELSE
    RAISE EXCEPTION 'This function currently only handles outcome_add changes. Change type: %', v_change_type;
  END IF;
  
  -- Remove the change from pending_changes array
  SELECT jsonb_agg(elem) INTO v_updated_changes
  FROM jsonb_array_elements(v_pending_changes) elem
  WHERE elem->>'id' != p_change_id::text;
  
  UPDATE college_curriculums 
  SET 
    pending_changes = COALESCE(v_updated_changes, '[]'::jsonb),
    has_pending_changes = CASE 
      WHEN jsonb_array_length(COALESCE(v_updated_changes, '[]'::jsonb)) > 0 THEN true 
      ELSE false 
    END,
    updated_at = NOW()
  WHERE id = p_curriculum_id;
  
  -- Add to change_history
  UPDATE college_curriculums 
  SET 
    change_history = COALESCE(change_history, '[]'::jsonb) || 
    jsonb_build_object(
      'id', p_change_id,
      'action', 'change_approved',
      'change_type', v_change_type,
      'request_timestamp', NOW(),
      'user_id', v_user_id,
      'user_name', COALESCE(v_user_name, v_user_email, 'Unknown'),
      'review_notes', p_review_notes,
      'applied', true
    )
  WHERE id = p_curriculum_id;
  
  RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.curriculum_reject_pending_change(p_curriculum_id uuid, p_change_id uuid, p_review_notes text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_change JSONB;
  v_change_type TEXT;
  v_user_id UUID;
  v_user_name TEXT;
  v_user_email TEXT;
  v_pending_changes JSONB;
  v_updated_changes JSONB;
  v_change_elem JSONB;
BEGIN
  -- Get current user info
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RAISE EXCEPTION 'User not authenticated';
  END IF;
  
  SELECT name, email INTO v_user_name, v_user_email
  FROM users 
  WHERE id = v_user_id;
  
  -- Get pending changes
  SELECT pending_changes INTO v_pending_changes
  FROM college_curriculums
  WHERE id = p_curriculum_id;
  
  IF v_pending_changes IS NULL THEN
    RAISE EXCEPTION 'No pending changes found for curriculum';
  END IF;
  
  -- Find the specific change
  v_change := NULL;
  FOR i IN 0..jsonb_array_length(v_pending_changes) - 1 LOOP
    v_change_elem := v_pending_changes->i;
    IF v_change_elem->>'id' = p_change_id::text THEN
      v_change := v_change_elem;
      EXIT;
    END IF;
  END LOOP;
  
  IF v_change IS NULL THEN
    RAISE EXCEPTION 'Change request not found';
  END IF;
  
  v_change_type := v_change->>'change_type';
  
  -- Remove the change from pending_changes array
  SELECT jsonb_agg(elem) INTO v_updated_changes
  FROM jsonb_array_elements(v_pending_changes) elem
  WHERE elem->>'id' != p_change_id::text;
  
  UPDATE college_curriculums 
  SET 
    pending_changes = COALESCE(v_updated_changes, '[]'::jsonb),
    has_pending_changes = CASE 
      WHEN jsonb_array_length(COALESCE(v_updated_changes, '[]'::jsonb)) > 0 THEN true 
      ELSE false 
    END,
    updated_at = NOW()
  WHERE id = p_curriculum_id;
  
  -- Add to change_history
  UPDATE college_curriculums 
  SET 
    change_history = COALESCE(change_history, '[]'::jsonb) || 
    jsonb_build_object(
      'id', p_change_id,
      'action', 'change_rejected',
      'change_type', v_change_type,
      'request_timestamp', NOW(),
      'user_id', v_user_id,
      'user_name', COALESCE(v_user_name, v_user_email, 'Unknown'),
      'review_notes', p_review_notes,
      'applied', false
    )
  WHERE id = p_curriculum_id;
  
  RETURN TRUE;
END;
$function$
;

create or replace view "public"."curriculum_summary" as  SELECT c.id,
    c.school_id,
    c.subject,
    c.class,
    c.academic_year,
    c.status,
    c.created_by,
    c.approved_by,
    c.approval_date,
    c.rejection_reason,
    c.last_modified,
    c.created_at,
    (((se.first_name)::text || ' '::text) || (se.last_name)::text) AS created_by_name,
    se.email AS created_by_email,
    count(DISTINCT cc.id) AS total_chapters,
    count(DISTINCT clo.id) AS total_outcomes,
    count(DISTINCT oam.id) AS total_assessment_mappings,
        CASE
            WHEN (count(DISTINCT cc.id) = 0) THEN (0)::numeric
            ELSE round((((count(DISTINCT
            CASE
                WHEN (clo.id IS NOT NULL) THEN cc.id
                ELSE NULL::uuid
            END))::numeric / (count(DISTINCT cc.id))::numeric) * (100)::numeric))
        END AS completion_percentage
   FROM ((((public.curriculums c
     LEFT JOIN public.school_educators se ON ((c.created_by = se.id)))
     LEFT JOIN public.curriculum_chapters cc ON ((c.id = cc.curriculum_id)))
     LEFT JOIN public.curriculum_learning_outcomes clo ON ((cc.id = clo.chapter_id)))
     LEFT JOIN public.outcome_assessment_mappings oam ON ((clo.id = oam.learning_outcome_id)))
  GROUP BY c.id, se.first_name, se.last_name, se.email;


CREATE OR REPLACE FUNCTION public.decrement_applications_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE public.opportunities
  SET applications_count = GREATEST(applications_count - 1, 0)
  WHERE id = OLD.opportunity_id;
  RETURN OLD;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_from_profile_array(p_student_id uuid, p_array_name text, p_item_id integer)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_profile JSONB;
  v_array JSONB;
  v_new_array JSONB := '[]'::jsonb;
  v_item JSONB;
BEGIN
  -- Get current profile
  SELECT profile INTO v_profile
  FROM students
  WHERE id = p_student_id;
  
  -- Get array
  v_array := v_profile -> p_array_name;
  
  -- Filter out matching item
  FOR v_item IN SELECT * FROM jsonb_array_elements(v_array)
  LOOP
    IF (v_item->>'id')::int != p_item_id THEN
      v_new_array := v_new_array || v_item;
    END IF;
  END LOOP;
  
  -- Update profile
  v_profile := jsonb_set(v_profile, ARRAY[p_array_name], v_new_array);
  
  -- Save and return
  UPDATE students SET profile = v_profile WHERE id = p_student_id;
  
  RETURN v_profile;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.detect_timetable_conflicts(p_timetable_id uuid)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Clear existing unresolved conflicts
  DELETE FROM timetable_conflicts 
  WHERE timetable_id = p_timetable_id AND resolved = FALSE;
  
  -- Check for max periods exceeded
  INSERT INTO timetable_conflicts (timetable_id, conflict_type, educator_id, conflict_details)
  SELECT 
    p_timetable_id,
    'max_periods_exceeded',
    educator_id,
    jsonb_build_object('total_periods', total_periods_per_week, 'limit', 30)
  FROM teacher_workload
  WHERE timetable_id = p_timetable_id AND total_periods_per_week > 30;
  
  -- Check for consecutive classes exceeded
  INSERT INTO timetable_conflicts (timetable_id, conflict_type, educator_id, conflict_details)
  SELECT 
    p_timetable_id,
    'consecutive_classes_exceeded',
    educator_id,
    jsonb_build_object('max_consecutive', max_consecutive_classes, 'limit', 3)
  FROM teacher_workload
  WHERE timetable_id = p_timetable_id AND max_consecutive_classes > 3;
  
  -- Check for double booking
  INSERT INTO timetable_conflicts (timetable_id, conflict_type, educator_id, slot_id, conflict_details)
  SELECT 
    p_timetable_id,
    'double_booking',
    ts1.educator_id,
    ts1.id,
    jsonb_build_object('day', ts1.day_of_week, 'period', ts1.period_number, 'conflicting_slots', jsonb_agg(ts2.id))
  FROM timetable_slots ts1
  JOIN timetable_slots ts2 ON 
    ts1.timetable_id = ts2.timetable_id AND
    ts1.educator_id = ts2.educator_id AND
    ts1.day_of_week = ts2.day_of_week AND
    ts1.period_number = ts2.period_number AND
    ts1.id < ts2.id
  WHERE ts1.timetable_id = p_timetable_id
  GROUP BY ts1.id, ts1.educator_id, ts1.day_of_week, ts1.period_number;
END;
$function$
;

create or replace view "public"."enrolled_students_view" as  SELECT se.id AS enrollment_id,
    s.id AS student_id,
    s.name AS student_name,
    s.roll_number,
    s.email,
    s.contact_number,
    s.college_id,
    d.id AS department_id,
    d.name AS department_name,
    d.code AS department_code,
    p.id AS program_id,
    p.name AS program_name,
    p.code AS program_code,
    ps.id AS section_id,
    ps.section,
    ps.max_students AS section_capacity,
    se.semester,
    se.academic_year,
    se.enrollment_date,
    se.enrollment_status,
    se.created_at,
    se.updated_at
   FROM ((((public.student_enrollments se
     JOIN public.students s ON ((se.student_id = s.id)))
     JOIN public.programs p ON ((se.program_id = p.id)))
     JOIN public.departments d ON ((p.department_id = d.id)))
     LEFT JOIN public.program_sections ps ON ((se.section_id = ps.id)))
  WHERE (s.is_deleted = false);


CREATE OR REPLACE FUNCTION public.expire_old_subscriptions()
 RETURNS TABLE(expired_count integer)
 LANGUAGE plpgsql
AS $function$
DECLARE
  count INTEGER;
BEGIN
  WITH expired_subs AS (
    UPDATE public.subscriptions
    SET 
      status = 'expired'::subscription_status,
      auto_renew = false,
      updated_at = NOW()
    WHERE 
      status IN ('active', 'cancelled', 'paused')
      AND subscription_end_date < NOW()
      AND subscription_end_date IS NOT NULL
    RETURNING id
  )
  SELECT COUNT(*)::INTEGER INTO count FROM expired_subs;
  
  RETURN QUERY SELECT count;
END;
$function$
;

create or replace view "public"."faculty_with_user_data" as  SELECT cl.id,
    cl."employeeId",
    cl."collegeId",
    cl.specialization,
    cl.qualification,
    cl."experienceYears",
    cl.designation,
    cl."accountStatus",
    cl.first_name,
    cl.last_name,
    cl.email,
    cl.phone,
    cl.subject_expertise,
    u.id AS user_id,
    u."firstName" AS user_first_name,
    u."lastName" AS user_last_name,
    u.email AS user_email,
    u.phone AS user_phone,
    COALESCE(cl.first_name, u."firstName") AS display_first_name,
    COALESCE(cl.last_name, u."lastName") AS display_last_name,
    COALESCE(cl.email, (u.email)::character varying) AS display_email,
    COALESCE(cl.phone, u.phone) AS display_phone
   FROM (public.college_lecturers cl
     LEFT JOIN public.users u ON ((cl.user_id = u.id)));


CREATE OR REPLACE FUNCTION public.generate_certificate_credential_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NEW.credential_id IS NULL THEN
        NEW.credential_id := UPPER(SUBSTRING(
            CASE NEW.certificate_type
                WHEN 'course_completion' THEN 'CC'
                WHEN 'skill_achievement' THEN 'SA'
                WHEN 'competition' THEN 'CM'
                WHEN 'workshop' THEN 'WS'
                WHEN 'leadership' THEN 'LD'
                WHEN 'participation' THEN 'PT'
                WHEN 'excellence' THEN 'EX'
                ELSE 'CT'
            END || '-' ||
            TO_CHAR(NEW.issued_date, 'YYYY') || '-' ||
            LPAD(FLOOR(RANDOM() * 10000)::TEXT, 4, '0'),
            1, 20
        ));
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_enrollment_number(p_school_id uuid, p_academic_year text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_count INTEGER;
  v_enrollment_number TEXT;
BEGIN
  -- Count existing enrollments for this school and year
  SELECT COUNT(*) INTO v_count
  FROM student_management_records
  WHERE school_id = p_school_id
    AND academic_year = p_academic_year;
  
  -- Generate enrollment number: YEAR-SCHOOLID-SEQUENCE
  v_enrollment_number := p_academic_year || '-' || 
                         SUBSTRING(p_school_id::TEXT, 1, 8) || '-' || 
                         LPAD((v_count + 1)::TEXT, 4, '0');
  
  RETURN v_enrollment_number;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_student_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  seq_num TEXT;
  prefix TEXT;
  year_part TEXT;
  name_part TEXT;
BEGIN
  IF NEW.student_id IS NULL THEN
    --  Generate next sequence (8 digits)
    seq_num := lpad(nextval('student_id_seq')::text, 8, '0');

    --  Remove ALL non-alphabetic characters (no spaces, dots, etc.)
    name_part := upper(substring(regexp_replace(coalesce(NEW.name, 'NONAME'), '[^A-Za-z]', '', 'g') from 1 for 3));

    --  Extract year from createdAt (or now if missing)
    year_part := to_char(coalesce(NEW."createdAt", now()), 'YY');

    --  Build final ID
    prefix := 'STU';
    NEW.student_id := prefix || '-' || name_part || year_part || '-' || seq_num;
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_teacher_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  school_code VARCHAR(10);
  next_number INTEGER;
  new_teacher_id VARCHAR(20);
BEGIN
  -- Get school code from organizations table
  SELECT COALESCE(UPPER(SUBSTRING(name FROM 1 FOR 3)), 'SCH')
  INTO school_code
  FROM organizations
  WHERE id = NEW.school_id AND organization_type = 'school';
  
  -- Get next sequential number
  SELECT COALESCE(MAX(CAST(SUBSTRING(teacher_id FROM '[0-9]+$') AS INTEGER)), 0) + 1
  INTO next_number
  FROM school_educators
  WHERE school_id = NEW.school_id AND teacher_id IS NOT NULL;
  
  -- Generate Teacher ID: SCHOOLCODE-T-0001
  new_teacher_id := school_code || '-T-' || LPAD(next_number::TEXT, 4, '0');
  
  NEW.teacher_id := new_teacher_id;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public."getActiveEnrollment"("p_studentId" uuid)
 RETURNS TABLE("enrollmentId" uuid, "entityType" text, "entityName" text, "className" text, "enrollmentDate" date, "expectedGraduationDate" date)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        se."id" as "enrollmentId",
        CASE 
            WHEN se."schoolId" IS NOT NULL THEN 'school'
            WHEN se."collegeId" IS NOT NULL THEN 'college'
            WHEN se."universityId" IS NOT NULL THEN 'university'
        END as "entityType",
        o."name" as "entityName",
        COALESCE(sc."name", cc."name", uc."name") as "className",
        se."enrollmentDate",
        se."expectedGraduationDate"
    FROM "studentEnrollments" se
    LEFT JOIN "organizations" o ON (se."schoolId" = o."id" OR se."collegeId" = o."id" OR se."universityId" = o."id")
    LEFT JOIN "school_classes" sc ON se."schoolClassId" = sc."id"
    LEFT JOIN "college_courses" cc ON se."collegeCourseId" = cc."id"
    LEFT JOIN "university_courses" uc ON se."universityCourseId" = uc."id"
    WHERE se."studentId" = "p_studentId"
    AND se."enrollmentStatus" = 'active'
    ORDER BY se."enrollmentDate" DESC
    LIMIT 1;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_active_subscription(uid uuid)
 RETURNS TABLE(id uuid, plan_type character varying, subscription_end_date timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT s.id, s.plan_type, s.subscription_end_date
  FROM subscriptions s
  WHERE s.user_id = uid
    AND s.status = 'active'
    AND s.subscription_end_date > NOW()
  ORDER BY s.subscription_end_date DESC
  LIMIT 1;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_all_pending_changes_for_university(p_university_id uuid)
 RETURNS TABLE(curriculum_id uuid, curriculum_name text, college_name text, change_id uuid, change_type text, change_timestamp timestamp with time zone, requester_name text, request_message text, change_data jsonb)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_user_id UUID;
    v_user_role TEXT;
    v_user_org_id UUID;
BEGIN
    -- Get current user
    v_user_id := auth.uid();
    
    IF v_user_id IS NULL THEN 
        RAISE EXCEPTION 'User not authenticated'; 
    END IF;
    
    -- Get user role and organization
    SELECT role, "organizationId" 
    INTO v_user_role, v_user_org_id 
    FROM users 
    WHERE id = v_user_id;
    
    -- Check if user is university admin
    IF v_user_role != 'university_admin' THEN 
        RAISE EXCEPTION 'Only university admins can view pending changes'; 
    END IF;
    
    -- Verify user can access this university
    IF v_user_org_id IS NOT NULL AND v_user_org_id != p_university_id THEN 
        RAISE EXCEPTION 'Access denied: You can only view changes for your own university'; 
    END IF;
    
    -- Return pending changes
    RETURN QUERY
    SELECT 
        c.id::UUID,
        CASE 
            WHEN cc.course_name IS NOT NULL AND cc.course_name != '' 
            THEN CONCAT(cc.course_name, ' ', c.academic_year)::TEXT
            ELSE c.academic_year::TEXT
        END,
        o.name::TEXT,
        (change_obj->>'id')::UUID,
        (change_obj->>'change_type')::TEXT,
        (change_obj->>'timestamp')::TIMESTAMPTZ,
        (change_obj->>'requester_name')::TEXT,
        (change_obj->>'request_message')::TEXT,
        change_obj::JSONB
    FROM college_curriculums c
    LEFT JOIN college_course_mappings cm ON cm.id = c.course_id
    LEFT JOIN college_courses cc ON cc.id = cm.course_id
    LEFT JOIN organizations o ON o.id = c.college_id,
         jsonb_array_elements(COALESCE(c.pending_changes, '[]'::jsonb)) AS change_obj
    WHERE c.university_id = p_university_id 
    AND c.has_pending_changes = TRUE 
    AND (change_obj->>'status')::TEXT = 'pending'
    ORDER BY (change_obj->>'timestamp')::TIMESTAMPTZ DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_approved_trainings_for_student(student_email text)
 RETURNS TABLE(id uuid, student_id uuid, title character varying, organization character varying, start_date date, end_date date, duration character varying, description text, status text, completed_modules integer, total_modules integer, hours_spent integer, course_id uuid, source character varying, approval_status character varying, approval_authority character varying, created_at timestamp with time zone, updated_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT t.*
    FROM public.trainings t
    JOIN public.students s ON t.student_id = s.id
    WHERE s.email = student_email 
    AND t.approval_status = 'approved';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_available_questions(p_grade_level public.grade_level, p_phase public.test_phase, p_difficulty smallint DEFAULT NULL::smallint, p_subtag public.question_subtag DEFAULT NULL::public.question_subtag, p_limit integer DEFAULT 10)
 RETURNS TABLE(id uuid, question_id text, text text, options jsonb, correct_answer character, difficulty smallint, subtag public.question_subtag, explanation text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    q.id,
    q.question_id,
    q.text,
    q.options,
    q.correct_answer,
    q.difficulty,
    q.subtag,
    q.explanation
  FROM adaptive_aptitude_questions_cache q
  WHERE q.grade_level = p_grade_level
    AND q.phase = p_phase
    AND q.is_active = TRUE
    AND (p_difficulty IS NULL OR q.difficulty = p_difficulty)
    AND (p_subtag IS NULL OR q.subtag = p_subtag)
  ORDER BY q.usage_count ASC, RANDOM()
  LIMIT p_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_cached_job_matches(p_student_id uuid)
 RETURNS TABLE(matches jsonb, match_count integer, computed_at timestamp with time zone, is_cached boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Check if cache is valid
    IF is_job_matches_cache_valid(p_student_id) THEN
        RETURN QUERY
        SELECT 
            sjm.matches,
            sjm.match_count,
            sjm.computed_at,
            true::boolean as is_cached
        FROM student_job_matches sjm
        WHERE sjm.student_id = p_student_id;
    ELSE
        -- Return empty result indicating cache miss
        RETURN QUERY
        SELECT 
            NULL::jsonb as matches,
            0 as match_count,
            NULL::timestamptz as computed_at,
            false::boolean as is_cached;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_club_details(p_club_id uuid)
 RETURNS TABLE(club_id uuid, name character varying, category character varying, description text, capacity integer, member_count bigint, meeting_day character varying, meeting_time character varying, location character varying, mentor_name text, avg_attendance numeric, upcoming_competitions bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        c.club_id,
        c.name,
        c.category,
        c.description,
        c.capacity,
        COUNT(DISTINCT cm.student_email) as member_count,
        c.meeting_day,
        c.meeting_time,
        c.location,
        CASE 
            WHEN c.mentor_type = 'educator' THEN se.first_name || ' ' || se.last_name
            WHEN c.mentor_type = 'school' THEN sc.principal_name
            ELSE 'TBD'
        END as mentor_name,
        ROUND(AVG(cm.attendance_percentage), 2) as avg_attendance,
        COUNT(DISTINCT cc.comp_id) as upcoming_competitions
    FROM public.clubs c
    LEFT JOIN public.club_memberships cm ON c.club_id = cm.club_id AND cm.status = 'active'
    LEFT JOIN public.school_educators se ON c.mentor_educator_id = se.id
    LEFT JOIN public.schools sc ON c.mentor_school_id = sc.id
    LEFT JOIN public.competition_clubs cc ON c.club_id = cc.club_id
    LEFT JOIN public.competitions comp ON cc.comp_id = comp.comp_id AND comp.status = 'upcoming'
    WHERE c.club_id = p_club_id
    GROUP BY c.club_id, c.name, c.category, c.description, c.capacity, 
             c.meeting_day, c.meeting_time, c.location, c.mentor_type,
             se.first_name, se.last_name, sc.principal_name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_college_admin_notifications(admin_college_id uuid, unread_only boolean DEFAULT false)
 RETURNS TABLE(notification_id uuid, training_id uuid, experience_id uuid, project_id uuid, message text, is_read boolean, created_at timestamp with time zone, item_title text, student_name text, notification_type text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        tn.id as notification_id,
        tn.training_id,
        tn.experience_id,
        tn.project_id,
        tn.message,
        tn.is_read,
        tn.created_at,
        CASE 
            WHEN tn.training_id IS NOT NULL THEN t.title
            WHEN tn.experience_id IS NOT NULL THEN CONCAT(e.role, ' at ', e.organization)
            WHEN tn.project_id IS NOT NULL THEN p.title
            ELSE 'Unknown'
        END as item_title,
        COALESCE(s.name, sp.name) as student_name,
        CASE 
            WHEN tn.training_id IS NOT NULL THEN 'training'
            WHEN tn.experience_id IS NOT NULL THEN 'experience'
            WHEN tn.project_id IS NOT NULL THEN 'project'
            ELSE 'unknown'
        END as notification_type
    FROM training_notifications tn
    LEFT JOIN trainings t ON tn.training_id = t.id
    LEFT JOIN experience e ON tn.experience_id = e.id
    LEFT JOIN projects p ON tn.project_id = p.id
    LEFT JOIN students s ON (t.student_id = s.id OR e.student_id = s.id OR p.student_id = s.id)
    LEFT JOIN students sp ON s.id = sp.id  -- For profile name fallback
    WHERE tn.recipient_type = 'college_admin'
    AND tn.college_id = admin_college_id
    AND (NOT unread_only OR tn.is_read = FALSE)
    ORDER BY tn.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_college_admin_project_notifications(admin_college_id uuid, unread_only boolean DEFAULT false)
 RETURNS TABLE(notification_id uuid, project_id uuid, message text, is_read boolean, created_at timestamp with time zone, project_title text, student_name text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        pn.id as notification_id,
        pn.project_id,
        pn.message,
        pn.is_read,
        pn.created_at,
        p.title as project_title,
        COALESCE(s.name, sp.name) as student_name
    FROM project_notifications pn
    JOIN projects p ON pn.project_id = p.id
    JOIN students s ON p.student_id = s.id
    LEFT JOIN students sp ON s.id = sp.id  -- For profile name fallback
    WHERE pn.recipient_type = 'college_admin'
    AND pn.college_id = admin_college_id
    AND (NOT unread_only OR pn.is_read = FALSE)
    ORDER BY pn.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_college_educator_assignments(educator_user_id uuid)
 RETURNS TABLE(assignment_id uuid, title text, description text, instructions text, course_name text, course_code text, college_educator_id uuid, educator_name text, college_id uuid, program_section_id uuid, department_id uuid, program_id uuid, total_points numeric, assignment_type text, skill_outcomes text[], due_date timestamp with time zone, available_from timestamp with time zone, allow_late_submission boolean, document_pdf text, instruction_files jsonb, created_date timestamp with time zone, updated_date timestamp with time zone, status text, program_name text, department_name text, semester integer, section text, academic_year text, student_count integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        ca.assignment_id,
        ca.title,
        ca.description,
        ca.instructions,
        ca.course_name,
        ca.course_code,
        ca.college_educator_id,
        ca.educator_name,
        ca.college_id,
        ca.program_section_id,
        ca.department_id,
        ca.program_id,
        ca.total_points,
        ca.assignment_type,
        ca.skill_outcomes,
        ca.due_date,
        ca.available_from,
        ca.allow_late_submission,
        ca.document_pdf,
        COALESCE(ca.instruction_files, '[]'::jsonb) as instruction_files,
        ca.created_date,
        ca.updated_date,
        CASE 
            WHEN ca.due_date < NOW() THEN 'completed'::text
            ELSE 'active'::text
        END as status,
        COALESCE(p.name, '')::text as program_name,
        COALESCE(d.name, '')::text as department_name,
        ps.semester,
        COALESCE(ps.section, '')::text as section,
        COALESCE(ps.academic_year, '')::text as academic_year,
        0 as student_count
    FROM 
        college_assignments ca
    LEFT JOIN programs p ON ca.program_id = p.id
    LEFT JOIN departments d ON ca.department_id = d.id
    LEFT JOIN program_sections ps ON ca.program_section_id = ps.id
    WHERE 
        ca.college_educator_id = educator_user_id
        AND ca.is_deleted = false
    ORDER BY 
        ca.created_date DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_course_full_details(course_uuid uuid)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSON;
BEGIN
    SELECT json_build_object(
        'course', row_to_json(c),
        'modules', (
            SELECT json_agg(
                json_build_object(
                    'module', row_to_json(cm),
                    'lessons', (
                        SELECT json_agg(
                            json_build_object(
                                'lesson', row_to_json(l),
                                'resources', (
                                    SELECT json_agg(row_to_json(lr))
                                    FROM lesson_resources lr
                                    WHERE lr.lesson_id = l.lesson_id
                                    ORDER BY lr.order_index
                                )
                            )
                        )
                        FROM lessons l
                        WHERE l.module_id = cm.module_id
                        ORDER BY l.order_index
                    )
                )
            )
            FROM course_modules cm
            WHERE cm.course_id = c.course_id
            ORDER BY cm.order_index
        ),
        'skills', (
            SELECT json_agg(cs.skill_name)
            FROM course_skills cs
            WHERE cs.course_id = c.course_id
        ),
        'classes', (
            SELECT json_agg(cc.class_name)
            FROM course_classes cc
            WHERE cc.course_id = c.course_id
        ),
        'co_educators', (
            SELECT json_agg(json_build_object('id', cce.educator_id, 'name', cce.educator_name))
            FROM course_co_educators cce
            WHERE cce.course_id = c.course_id
        )
    ) INTO result
    FROM courses c
    WHERE c.course_id = course_uuid;

    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_current_academic_year(p_school_id uuid DEFAULT NULL::uuid)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_year VARCHAR;
BEGIN
  SELECT year INTO v_year
  FROM curriculum_academic_years
  WHERE (school_id = p_school_id OR (school_id IS NULL AND p_school_id IS NULL))
  AND is_current = TRUE
  AND is_active = TRUE
  ORDER BY school_id NULLS LAST
  LIMIT 1;
  
  RETURN v_year;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_embedding_queue_batch(batch_size integer DEFAULT 20)
 RETURNS TABLE(id uuid, record_id uuid, table_name text, operation text, priority integer, retry_count integer)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY SELECT eq.id, eq.record_id, eq.table_name, eq.operation, eq.priority, eq.retry_count
  FROM embedding_queue eq WHERE eq.status = 'pending' AND (eq.next_retry_at IS NULL OR eq.next_retry_at <= NOW())
  ORDER BY eq.priority DESC, eq.created_at ASC LIMIT batch_size FOR UPDATE SKIP LOCKED;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_embedding_queue_stats()
 RETURNS TABLE(queue_status text, item_count bigint, oldest_item timestamp with time zone, newest_item timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    eq.status,
    COUNT(*)::BIGINT,
    MIN(eq.created_at),
    MAX(eq.created_at)
  FROM embedding_queue eq
  GROUP BY eq.status;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_embedding_stats()
 RETURNS TABLE(table_name text, total_records bigint, with_embedding bigint, without_embedding bigint, coverage_percent numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    'students'::TEXT,
    COUNT(*)::BIGINT,
    COUNT(embedding)::BIGINT,
    (COUNT(*) - COUNT(embedding))::BIGINT,
    ROUND(COUNT(embedding)::NUMERIC / NULLIF(COUNT(*), 0) * 100, 2)
  FROM students
  UNION ALL
  SELECT 
    'opportunities'::TEXT,
    COUNT(*)::BIGINT,
    COUNT(embedding)::BIGINT,
    (COUNT(*) - COUNT(embedding))::BIGINT,
    ROUND(COUNT(embedding)::NUMERIC / NULLIF(COUNT(*), 0) * 100, 2)
  FROM opportunities;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_lecturer_details(p_user_id uuid)
 RETURNS TABLE(lecturer_id uuid, user_id uuid, college_id uuid, college_name text, employee_id text, department text, specialization text, qualification text, experience_years integer, date_of_joining date)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    cl.id,
    cl.user_id,
    cl."collegeId",
    o.name as college_name,
    cl."employeeId"::TEXT,
    cl.department::TEXT,
    cl.specialization::TEXT,
    cl.qualification::TEXT,
    cl."experienceYears",
    cl."dateOfJoining"
  FROM college_lecturers cl
  LEFT JOIN organizations o ON o.id = cl."collegeId" AND o.organization_type = 'college'
  WHERE cl.user_id = p_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_or_create_college_educator_admin_conversation(p_educator_id uuid, p_college_id uuid, p_subject text DEFAULT 'General Discussion'::text)
 RETURNS TABLE(conversation_id text)
 LANGUAGE plpgsql
AS $function$
DECLARE
  existing_conversation_id TEXT;
  new_conversation_id TEXT;
BEGIN
  -- Check for existing conversation
  SELECT id INTO existing_conversation_id
  FROM conversations
  WHERE educator_id = p_educator_id
    AND college_id = p_college_id
    AND conversation_type = 'college_educator_admin'
    AND (subject = p_subject OR (subject IS NULL AND p_subject = 'General Discussion'))
  LIMIT 1;
  
  IF existing_conversation_id IS NOT NULL THEN
    -- Return existing conversation
    RETURN QUERY SELECT existing_conversation_id;
  ELSE
    -- Create new conversation
    new_conversation_id := 'conv_cea_' || extract(epoch from now())::bigint || '_' || substr(md5(random()::text), 1, 9);
    
    INSERT INTO conversations (
      id,
      educator_id,
      college_id,
      subject,
      conversation_type,
      status,
      created_at,
      updated_at
    ) VALUES (
      new_conversation_id,
      p_educator_id,
      p_college_id,
      p_subject,
      'college_educator_admin',
      'active',
      timezone('utc'::text, now()),
      timezone('utc'::text, now())
    );
    
    RETURN QUERY SELECT new_conversation_id;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_or_create_educator_admin_conversation(p_educator_id uuid, p_school_id uuid, p_subject text DEFAULT 'General Discussion'::text)
 RETURNS TABLE(conversation_id text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    existing_conversation_id TEXT;
    new_conversation_id TEXT;
BEGIN
    -- Try to find existing conversation
    SELECT id INTO existing_conversation_id
    FROM conversations
    WHERE educator_id = p_educator_id 
      AND school_id = p_school_id
      AND conversation_type = 'educator_admin'
      AND (p_subject IS NULL OR subject = p_subject)
    LIMIT 1;
    
    IF existing_conversation_id IS NOT NULL THEN
        -- If conversation was soft deleted, restore it
        UPDATE conversations 
        SET deleted_by_educator = FALSE,
            deleted_by_admin = FALSE,
            educator_deleted_at = NULL,
            admin_deleted_at = NULL,
            updated_at = NOW()
        WHERE id = existing_conversation_id;
        
        RETURN QUERY SELECT existing_conversation_id;
    ELSE
        -- Create new conversation with explicit NULL for student_id
        new_conversation_id := 'conv_ea_' || EXTRACT(EPOCH FROM NOW())::BIGINT || '_' || SUBSTRING(MD5(RANDOM()::TEXT), 1, 9);
        
        INSERT INTO conversations (
            id,
            student_id,
            educator_id,
            school_id,
            recruiter_id,
            subject,
            conversation_type,
            status,
            student_unread_count,
            recruiter_unread_count,
            educator_unread_count,
            admin_unread_count,
            created_at,
            updated_at
        ) VALUES (
            new_conversation_id,
            NULL,
            p_educator_id,
            p_school_id,
            NULL,
            p_subject,
            'educator_admin',
            'active',
            0,
            0,
            0,
            0,
            NOW(),
            NOW()
        );
        
        RETURN QUERY SELECT new_conversation_id;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_or_create_student_admin_conversation(p_student_id uuid, p_school_id uuid, p_subject text DEFAULT 'General Discussion'::text)
 RETURNS TABLE(conversation_id text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    existing_conversation_id TEXT;
    new_conversation_id TEXT;
BEGIN
    -- Try to find existing conversation
    SELECT id INTO existing_conversation_id
    FROM conversations
    WHERE student_id = p_student_id 
      AND school_id = p_school_id
      AND conversation_type = 'student_admin'
      AND (p_subject IS NULL OR subject = p_subject)
    LIMIT 1;
    
    IF existing_conversation_id IS NOT NULL THEN
        -- If conversation was soft deleted, restore it
        UPDATE conversations 
        SET deleted_by_student = FALSE,
            deleted_by_admin = FALSE,
            student_deleted_at = NULL,
            admin_deleted_at = NULL,
            updated_at = NOW()
        WHERE id = existing_conversation_id;
        
        RETURN QUERY SELECT existing_conversation_id;
    ELSE
        -- Create new conversation
        new_conversation_id := 'conv_sa_' || EXTRACT(EPOCH FROM NOW())::BIGINT || '_' || SUBSTRING(MD5(RANDOM()::TEXT), 1, 9);
        
        INSERT INTO conversations (
            id,
            student_id,
            school_id,
            subject,
            conversation_type,
            status,
            student_unread_count,
            recruiter_unread_count,
            educator_unread_count,
            admin_unread_count,
            created_at,
            updated_at
        ) VALUES (
            new_conversation_id,
            p_student_id,
            p_school_id,
            p_subject,
            'student_admin',
            'active',
            0,
            0,
            0,
            0,
            NOW(),
            NOW()
        );
        
        RETURN QUERY SELECT new_conversation_id;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_or_create_student_college_admin_conversation(p_student_id uuid, p_college_id uuid, p_subject text DEFAULT 'General Discussion'::text)
 RETURNS TABLE(conversation_id text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    existing_conversation_id TEXT;
    new_conversation_id TEXT;
BEGIN
    -- Try to find existing conversation
    SELECT id INTO existing_conversation_id
    FROM conversations
    WHERE student_id = p_student_id 
      AND college_id = p_college_id
      AND conversation_type = 'student_college_admin'
      AND (p_subject IS NULL OR subject = p_subject)
    LIMIT 1;
    
    IF existing_conversation_id IS NOT NULL THEN
        -- If conversation was soft deleted, restore it
        UPDATE conversations 
        SET deleted_by_student = FALSE,
            deleted_by_college_admin = FALSE,
            student_deleted_at = NULL,
            college_admin_deleted_at = NULL,
            updated_at = NOW()
        WHERE id = existing_conversation_id;
        
        RETURN QUERY SELECT existing_conversation_id;
    ELSE
        -- Create new conversation
        new_conversation_id := 'conv_ca_' || EXTRACT(EPOCH FROM NOW())::BIGINT || '_' || SUBSTRING(MD5(RANDOM()::TEXT), 1, 9);
        
        INSERT INTO conversations (
            id,
            student_id,
            college_id,
            subject,
            conversation_type,
            status,
            student_unread_count,
            recruiter_unread_count,
            educator_unread_count,
            admin_unread_count,
            college_admin_unread_count,
            created_at,
            updated_at
        ) VALUES (
            new_conversation_id,
            p_student_id,
            p_college_id,
            p_subject,
            'student_college_admin',
            'active',
            0,
            0,
            0,
            0,
            0,
            NOW(),
            NOW()
        );
        
        RETURN QUERY SELECT new_conversation_id;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_or_create_student_educator_conversation(p_student_id uuid, p_educator_id uuid, p_class_id uuid DEFAULT NULL::uuid, p_subject text DEFAULT 'General Discussion'::text)
 RETURNS TABLE(conversation_id text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    existing_conversation_id TEXT;
    new_conversation_id TEXT;
BEGIN
    -- Try to find existing conversation
    SELECT id INTO existing_conversation_id
    FROM conversations
    WHERE student_id = p_student_id 
      AND educator_id = p_educator_id
      AND conversation_type = 'student_educator'
      AND (p_class_id IS NULL OR class_id = p_class_id)
      AND (p_subject IS NULL OR subject = p_subject)
    LIMIT 1;
    
    IF existing_conversation_id IS NOT NULL THEN
        -- If conversation was soft deleted, restore it
        UPDATE conversations 
        SET deleted_by_student = FALSE,
            deleted_by_educator = FALSE,
            student_deleted_at = NULL,
            educator_deleted_at = NULL,
            updated_at = NOW()
        WHERE id = existing_conversation_id;
        
        RETURN QUERY SELECT existing_conversation_id;
    ELSE
        -- Create new conversation
        new_conversation_id := 'conv_se_' || EXTRACT(EPOCH FROM NOW())::BIGINT || '_' || SUBSTRING(MD5(RANDOM()::TEXT), 1, 9);
        
        INSERT INTO conversations (
            id,
            student_id,
            educator_id,
            class_id,
            subject,
            conversation_type,
            status,
            student_unread_count,
            recruiter_unread_count,
            educator_unread_count,
            created_at,
            updated_at
        ) VALUES (
            new_conversation_id,
            p_student_id,
            p_educator_id,
            p_class_id,
            p_subject,
            'student_educator',
            'active',
            0,
            0,
            0,
            NOW(),
            NOW()
        );
        
        RETURN QUERY SELECT new_conversation_id;
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_changes(p_curriculum_id uuid)
 RETURNS TABLE(change_id uuid, change_type text, entity_id uuid, change_timestamp timestamp with time zone, requested_by uuid, requester_name text, request_message text, change_status text, change_data jsonb)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        (change_obj->>'id')::UUID,
        (change_obj->>'change_type')::TEXT,
        (change_obj->>'entity_id')::UUID,
        (change_obj->>'timestamp')::TIMESTAMPTZ,
        (change_obj->>'requested_by')::UUID,
        (change_obj->>'requester_name')::TEXT,
        (change_obj->>'request_message')::TEXT,
        (change_obj->>'status')::TEXT,
        change_obj::JSONB
    FROM college_curriculums,
         jsonb_array_elements(COALESCE(pending_changes, '[]'::jsonb)) AS change_obj
    WHERE id = p_curriculum_id AND (change_obj->>'status')::TEXT = 'pending'
    ORDER BY (change_obj->>'timestamp')::TIMESTAMPTZ DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_college_experiences()
 RETURNS TABLE(id uuid, student_id uuid, role character varying, organization character varying, start_date date, end_date date, duration character varying, description text, approval_status character varying, approval_authority character varying, created_at timestamp with time zone, updated_at timestamp with time zone, student_name character varying, student_email text, student_college character varying, student_type character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    e.id,
    e.student_id,
    e.role,
    e.organization,
    e.start_date,
    e.end_date,
    e.duration,
    e.description,
    e.approval_status,
    e.approval_authority,
    e.created_at,
    e.updated_at,
    p.name as student_name,
    p.email as student_email,
    p.college_school_name as student_college,
    s.student_type
  FROM experience e
  JOIN students s ON e.student_id = s.id
  JOIN profiles p ON s.user_id = p.id
  WHERE e.approval_status = 'pending'
    AND e.approval_authority = 'college_admin'
    AND s.student_type = 'college_student'
  ORDER BY e.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_college_experiences(p_admin_user_id uuid)
 RETURNS TABLE(id uuid, student_id uuid, role character varying, organization character varying, start_date date, end_date date, duration character varying, description text, approval_status character varying, approval_authority character varying, created_at timestamp with time zone, updated_at timestamp with time zone, student_name text, student_email text, student_college text, student_type text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    e.id,
    e.student_id,
    e.role,
    e.organization,
    e.start_date,
    e.end_date,
    e.duration,
    e.description,
    e.approval_status,
    e.approval_authority,
    e.created_at,
    e.updated_at,
    p.name as student_name,
    p.email as student_email,
    p.college_school_name as student_college,
    s.student_type
  FROM experience e
  JOIN students s ON e.student_id = s.id
  JOIN profiles p ON s.user_id = p.id
  WHERE e.approval_status = 'pending'
    AND e.approval_authority = 'college_admin'
    AND s.student_type = 'college_student'
  ORDER BY e.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_college_projects(input_college_id uuid)
 RETURNS TABLE(project_id uuid, student_id uuid, student_name character varying, title character varying, description text, organization text, status character varying, start_date date, end_date date, duration character varying, tech_stack text[], demo_link text, github_link text, certificate_url text, video_url text, ppt_url text, created_at timestamp with time zone, approval_status character varying, approval_authority character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        p.id as project_id,
        p.student_id,
        COALESCE(s.name, sp.name) as student_name,
        p.title,
        p.description,
        p.organization,
        p.status,
        p.start_date,
        p.end_date,
        p.duration,
        p.tech_stack,
        p.demo_link,
        p.github_link,
        p.certificate_url,
        p.video_url,
        p.ppt_url,
        p.created_at,
        p.approval_status,
        p.approval_authority
    FROM projects p
    JOIN students s ON p.student_id = s.id
    LEFT JOIN students sp ON s.id = sp.id
    WHERE p.approval_status = 'pending'
    AND p.approval_authority = 'college_admin'
    AND (s.college_id = input_college_id OR s.university_college_id = input_college_id)
    ORDER BY p.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_college_trainings()
 RETURNS TABLE(id uuid, student_id uuid, title character varying, organization character varying, start_date date, end_date date, duration character varying, description text, status text, completed_modules integer, total_modules integer, hours_spent integer, skills jsonb, certificate_url text, progress integer, approval_status character varying, approval_authority character varying, created_at timestamp with time zone, updated_at timestamp with time zone, student_name character varying, student_email text, student_college character varying, student_type character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    t.id,
    t.student_id,
    t.title,
    t.organization,
    t.start_date,
    t.end_date,
    t.duration,
    t.description,
    t.status,
    t.completed_modules,
    t.total_modules,
    t.hours_spent,
    NULL::JSONB as skills,
    NULL::TEXT as certificate_url,
    NULL::INTEGER as progress,
    t.approval_status,
    t.approval_authority,
    t.created_at,
    t.updated_at,
    p.name as student_name,
    p.email as student_email,
    p.college_school_name as student_college,
    s.student_type
  FROM trainings t
  JOIN students s ON t.student_id = s.id
  JOIN profiles p ON s.user_id = p.id
  WHERE t.approval_status = 'pending'
    AND t.approval_authority = 'college_admin'
    AND s.student_type = 'college_student'
  ORDER BY t.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_college_trainings(p_admin_user_id uuid)
 RETURNS TABLE(id uuid, student_id uuid, title character varying, organization character varying, start_date date, end_date date, duration character varying, description text, status text, completed_modules integer, total_modules integer, hours_spent integer, skills text[], certificate_url text, progress integer, approval_status character varying, approval_authority character varying, created_at timestamp with time zone, updated_at timestamp with time zone, student_name text, student_email text, student_college text, student_type text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    t.id,
    t.student_id,
    t.title,
    t.organization,
    t.start_date,
    t.end_date,
    t.duration,
    t.description,
    t.status,
    t.completed_modules,
    t.total_modules,
    t.hours_spent,
    t.skills,
    t.certificate_url,
    t.progress,
    t.approval_status,
    t.approval_authority,
    t.created_at,
    t.updated_at,
    p.name as student_name,
    p.email as student_email,
    p.college_school_name as student_college,
    s.student_type
  FROM trainings t
  JOIN students s ON t.student_id = s.id
  JOIN profiles p ON s.user_id = p.id
  WHERE t.approval_status = 'pending'
    AND t.approval_authority = 'college_admin'
    AND s.student_type = 'college_student'
  ORDER BY t.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_rareminds_trainings()
 RETURNS TABLE(id uuid, student_id uuid, student_name text, student_email text, school_name text, title character varying, organization character varying, start_date date, end_date date, description text, approval_status character varying, approval_authority character varying, created_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        t.id,
        t.student_id,
        s.name as student_name,
        s.email as student_email,
        o.name as school_name,
        t.title,
        t.organization,
        t.start_date,
        t.end_date,
        t.description,
        t.approval_status,
        t.approval_authority,
        t.created_at
    FROM public.trainings t
    JOIN public.students s ON t.student_id = s.id
    LEFT JOIN public.organizations o ON s.school_id = o.id
    WHERE t.approval_status = 'pending'
    AND t.approval_authority = 'rareminds_admin'
    ORDER BY t.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_school_experiences(input_school_id uuid)
 RETURNS TABLE(id uuid, student_id uuid, student_name character varying, student_email text, organization character varying, role character varying, start_date date, end_date date, duration character varying, approval_status character varying, approval_authority character varying, created_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
DECLARE
    school_name_var TEXT;
BEGIN
    -- Get the school name for the input school ID from organizations table
    SELECT o.name INTO school_name_var
    FROM organizations o
    WHERE o.id = input_school_id;
    
    IF school_name_var IS NULL THEN
        -- If school not found, return empty result
        RETURN;
    END IF;
    
    RETURN QUERY
    SELECT 
        e.id,
        e.student_id,
        s.name as student_name,
        s.email as student_email,
        e.organization,
        e.role,
        e.start_date,
        e.end_date,
        e.duration,
        e.approval_status::VARCHAR(20),
        e.approval_authority,
        e.created_at
    FROM public.experience e
    JOIN public.students s ON e.student_id = s.id
    WHERE e.approval_status = 'pending'
    AND e.approval_authority = 'school_admin'
    AND LOWER(TRIM(e.organization)) = LOWER(TRIM(school_name_var))
    ORDER BY e.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_school_projects(input_school_id uuid)
 RETURNS TABLE(project_id uuid, student_id uuid, student_name character varying, title character varying, description text, organization text, status character varying, start_date date, end_date date, duration character varying, tech_stack text[], demo_link text, github_link text, certificate_url text, video_url text, ppt_url text, created_at timestamp with time zone, approval_status character varying, approval_authority character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        p.id as project_id,
        p.student_id,
        COALESCE(s.name, sp.name) as student_name,
        p.title,
        p.description,
        p.organization,
        p.status,
        p.start_date,
        p.end_date,
        p.duration,
        p.tech_stack,
        p.demo_link,
        p.github_link,
        p.certificate_url,
        p.video_url,
        p.ppt_url,
        p.created_at,
        p.approval_status,
        p.approval_authority
    FROM projects p
    JOIN students s ON p.student_id = s.id
    LEFT JOIN students sp ON s.id = sp.id
    WHERE p.approval_status = 'pending'
    AND p.approval_authority = 'school_admin'
    AND s.school_id = input_school_id
    ORDER BY p.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_school_trainings(input_school_id uuid)
 RETURNS TABLE(id uuid, student_id uuid, student_name character varying, student_email text, title character varying, organization character varying, start_date date, end_date date, description text, approval_status character varying, approval_authority character varying, created_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        t.id,
        t.student_id,
        s.name as student_name,
        s.email as student_email,
        t.title,
        t.organization,
        t.start_date,
        t.end_date,
        t.description,
        t.approval_status::VARCHAR(20),
        t.approval_authority,
        t.created_at
    FROM public.trainings t
    JOIN public.students s ON t.student_id = s.id
    WHERE s.school_id = input_school_id
    AND t.approval_status = 'pending'
    AND t.approval_authority = 'school_admin'
    ORDER BY t.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_pending_swap_count(p_faculty_id uuid)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN (
    SELECT COUNT(*)::INTEGER
    FROM class_swap_requests
    WHERE target_faculty_id = p_faculty_id
    AND status = 'pending'
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_plan_features(p_plan_code text, p_limit integer DEFAULT NULL::integer)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_features JSONB;
  v_total_count INTEGER;
BEGIN
  -- Get features from subscription_plans
  SELECT features INTO v_features
  FROM subscription_plans
  WHERE plan_code = p_plan_code AND is_active = true;
  
  IF v_features IS NULL THEN
    RETURN jsonb_build_object('features', '[]'::jsonb, 'total', 0, 'limited', false);
  END IF;
  
  v_total_count := jsonb_array_length(v_features);
  
  -- If limit is provided and less than total, slice the array
  IF p_limit IS NOT NULL AND p_limit < v_total_count THEN
    -- Use jsonb array slice: features[0:limit]
    SELECT jsonb_agg(elem)
    INTO v_features
    FROM (
      SELECT elem
      FROM jsonb_array_elements(v_features) WITH ORDINALITY AS t(elem, idx)
      WHERE idx <= p_limit
    ) sub;
    
    RETURN jsonb_build_object(
      'features', COALESCE(v_features, '[]'::jsonb),
      'total', v_total_count,
      'limited', true
    );
  END IF;
  
  RETURN jsonb_build_object(
    'features', v_features,
    'total', v_total_count,
    'limited', false
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_popular_opportunities(student_id_param uuid, limit_count integer DEFAULT 20)
 RETURNS TABLE(id uuid, title text, job_title text, company_name text, company_logo text, employment_type text, location text, mode text, stipend_or_salary text, experience_required text, experience_level text, skills_required jsonb, requirements jsonb, responsibilities jsonb, description text, application_link text, deadline timestamp with time zone, department text, salary_range_min integer, salary_range_max integer, posted_date timestamp with time zone, is_active boolean, status text, created_at timestamp with time zone, updated_at timestamp with time zone, views_count integer, applications_count integer, embedding extensions.vector, view_count integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    o.id,
    o.title,
    o.job_title,
    o.company_name,
    o.company_logo,
    o.employment_type,
    o.location,
    o.mode,
    o.stipend_or_salary,
    o.experience_required,
    o.experience_level,
    o.skills_required,
    o.requirements,
    o.responsibilities,
    o.description,
    o.application_link,
    o.deadline,
    o.department,
    o.salary_range_min,
    o.salary_range_max,
    o.posted_date,
    o.is_active,
    o.status,
    o.created_at,
    o.updated_at,
    o.views_count,
    o.applications_count,
    o.embedding,
    COALESCE(
      (SELECT COUNT(*) 
       FROM opportunity_interactions 
       WHERE opportunity_id = o.id AND action = 'view')::INTEGER,
      0
    ) as view_count
  FROM opportunities o
  WHERE o.is_active = true
    AND o.status = 'open'
    AND (o.deadline IS NULL OR o.deadline > NOW())
  ORDER BY 
    o.posted_date DESC NULLS LAST,
    o.created_at DESC
  LIMIT limit_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_popular_opportunities_with_eligibility(student_id_param uuid, student_grade_param text, student_course_param text DEFAULT NULL::text, student_type_param text DEFAULT NULL::text, limit_count integer DEFAULT 10)
 RETURNS TABLE(id integer, title text, job_title text, company_name text, company_logo text, employment_type text, location text, mode text, stipend_or_salary text, experience_required text, experience_level text, skills_required jsonb, requirements jsonb, responsibilities jsonb, description text, application_link text, deadline timestamp with time zone, department text, salary_range_min integer, salary_range_max integer, posted_date timestamp with time zone, is_active boolean, status text, created_at timestamp with time zone, updated_at timestamp with time zone, views_count integer, applications_count integer, similarity double precision)
 LANGUAGE plpgsql
AS $function$
DECLARE
  allowed_types TEXT[];
  max_exp INT;
  elig_level TEXT;
  effective_grade TEXT;
BEGIN
  effective_grade := COALESCE(student_grade_param, student_course_param, student_type_param, '');
  
  SELECT e.allowed_employment_types, e.max_experience_years, e.eligibility_level
  INTO allowed_types, max_exp, elig_level
  FROM get_student_eligibility(effective_grade) e;

  IF elig_level = 'school_junior' THEN
    RETURN QUERY
    SELECT 
      o.id, o.title, o.job_title, o.company_name, o.company_logo, o.employment_type,
      o.location, o.mode, o.stipend_or_salary, o.experience_required, o.experience_level,
      o.skills_required, o.requirements, o.responsibilities, o.description,
      o.application_link, o.deadline, o.department, o.salary_range_min, o.salary_range_max,
      o.posted_date, o.is_active, o.status, o.created_at, o.updated_at,
      o.views_count, o.applications_count,
      0.5::FLOAT as similarity
    FROM opportunities o
    WHERE (o.is_active IS NULL OR o.is_active = true)
      AND (o.status IS NULL OR o.status IN ('open', 'published'))
      AND (o.deadline IS NULL OR o.deadline > NOW())
      AND (o.employment_type IS NULL OR o.employment_type = ANY(allowed_types) OR o.employment_type ILIKE ANY(SELECT '%' || unnest(allowed_types) || '%'))
      AND (o.experience_required IS NULL OR parse_experience_years(o.experience_required) <= max_exp)
      AND NOT has_advanced_skills(o.skills_required)
    ORDER BY COALESCE(o.views_count, 0) DESC, COALESCE(o.applications_count, 0) DESC, o.created_at DESC
    LIMIT limit_count;
  ELSE
    RETURN QUERY
    SELECT 
      o.id, o.title, o.job_title, o.company_name, o.company_logo, o.employment_type,
      o.location, o.mode, o.stipend_or_salary, o.experience_required, o.experience_level,
      o.skills_required, o.requirements, o.responsibilities, o.description,
      o.application_link, o.deadline, o.department, o.salary_range_min, o.salary_range_max,
      o.posted_date, o.is_active, o.status, o.created_at, o.updated_at,
      o.views_count, o.applications_count,
      0.5::FLOAT as similarity
    FROM opportunities o
    WHERE (o.is_active IS NULL OR o.is_active = true)
      AND (o.status IS NULL OR o.status IN ('open', 'published'))
      AND (o.deadline IS NULL OR o.deadline > NOW())
      AND (o.employment_type IS NULL OR o.employment_type = ANY(allowed_types) OR o.employment_type ILIKE ANY(SELECT '%' || unnest(allowed_types) || '%'))
      AND (o.experience_required IS NULL OR parse_experience_years(o.experience_required) <= max_exp)
    ORDER BY COALESCE(o.views_count, 0) DESC, COALESCE(o.applications_count, 0) DESC, o.created_at DESC
    LIMIT limit_count;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_program_section_students(section_id uuid)
 RETURNS TABLE(student_id uuid, user_id uuid, name text, email text, roll_number text, program_id uuid, section text, semester integer)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        s.id as student_id,
        s.user_id,
        s.name::text,
        s.email::text,
        s.roll_number::text,
        s.program_id,
        s.section::text,
        s.semester
    FROM students s
    INNER JOIN program_sections ps ON s.program_id = ps.program_id 
        AND s.section = ps.section 
        AND s.semester = ps.semester
    WHERE ps.id = section_id
        AND s.is_deleted = false
    ORDER BY s.name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_scheduled_assessment_reminders(days_ahead integer DEFAULT 30)
 RETURNS TABLE(notification_id uuid, student_id uuid, assessment_id uuid, scheduled_date timestamp with time zone, days_until integer, assessment_date timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        n.id as notification_id,
        n.recipient_id as student_id,
        n.assessment_id,
        n.scheduled_for as scheduled_date,
        EXTRACT(DAY FROM n.scheduled_for - NOW())::INTEGER as days_until,
        par.created_at as assessment_date
    FROM notifications n
    JOIN personal_assessment_results par ON n.assessment_id = par.id
    WHERE n.status = 'scheduled'
    AND n.type = 'assessment_6month_reminder'
    AND n.scheduled_for <= NOW() + (days_ahead || ' days')::INTERVAL
    ORDER BY n.scheduled_for;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_school_admin_notifications(admin_school_id uuid, unread_only boolean DEFAULT false)
 RETURNS TABLE(notification_id uuid, training_id uuid, experience_id uuid, project_id uuid, message text, is_read boolean, created_at timestamp with time zone, item_title text, student_name text, notification_type text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        tn.id as notification_id,
        tn.training_id,
        tn.experience_id,
        tn.project_id,
        tn.message,
        tn.is_read,
        tn.created_at,
        CASE 
            WHEN tn.training_id IS NOT NULL THEN t.title
            WHEN tn.experience_id IS NOT NULL THEN CONCAT(e.role, ' at ', e.organization)
            WHEN tn.project_id IS NOT NULL THEN p.title
            ELSE 'Unknown'
        END as item_title,
        COALESCE(s.name, sp.name) as student_name,
        CASE 
            WHEN tn.training_id IS NOT NULL THEN 'training'
            WHEN tn.experience_id IS NOT NULL THEN 'experience'
            WHEN tn.project_id IS NOT NULL THEN 'project'
            ELSE 'unknown'
        END as notification_type
    FROM training_notifications tn
    LEFT JOIN trainings t ON tn.training_id = t.id
    LEFT JOIN experience e ON tn.experience_id = e.id
    LEFT JOIN projects p ON tn.project_id = p.id
    LEFT JOIN students s ON (t.student_id = s.id OR e.student_id = s.id OR p.student_id = s.id)
    LEFT JOIN students sp ON s.id = sp.id  -- For profile name fallback
    WHERE tn.recipient_type = 'school_admin'
    AND tn.school_id = admin_school_id
    AND (NOT unread_only OR tn.is_read = FALSE)
    ORDER BY tn.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_school_admin_project_notifications(admin_school_id uuid, unread_only boolean DEFAULT false)
 RETURNS TABLE(notification_id uuid, project_id uuid, message text, is_read boolean, created_at timestamp with time zone, project_title text, student_name text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        pn.id as notification_id,
        pn.project_id,
        pn.message,
        pn.is_read,
        pn.created_at,
        p.title as project_title,
        COALESCE(s.name, sp.name) as student_name
    FROM project_notifications pn
    JOIN projects p ON pn.project_id = p.id
    JOIN students s ON p.student_id = s.id
    LEFT JOIN students sp ON s.id = sp.id  -- For profile name fallback
    WHERE pn.recipient_type = 'school_admin'
    AND pn.school_id = admin_school_id
    AND (NOT unread_only OR pn.is_read = FALSE)
    ORDER BY pn.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_student_academic_summary(p_student_user_id uuid)
 RETURNS TABLE(student_name text, roll_number text, college_name text, program_name text, current_semester integer, current_cgpa numeric, total_assessments integer, passed_assessments integer, failed_assessments integer, average_percentage numeric, total_fee_due numeric, total_fee_paid numeric, fee_balance numeric, books_issued integer, books_overdue integer)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    s.name,
    s.roll_number,
    o.name as college_name,
    p.name as program_name,
    CAST(s.grade AS INTEGER) as current_semester,
    s."currentCgpa",
    COUNT(DISTINCT m.id)::INTEGER as total_assessments,
    COUNT(DISTINCT CASE WHEN m.is_pass = TRUE THEN m.id END)::INTEGER as passed_assessments,
    COUNT(DISTINCT CASE WHEN m.is_pass = FALSE THEN m.id END)::INTEGER as failed_assessments,
    ROUND(AVG(m.percentage), 2) as average_percentage,
    COALESCE(SUM(DISTINCT l.due_amount), 0) as total_fee_due,
    COALESCE(SUM(DISTINCT l.paid_amount), 0) as total_fee_paid,
    COALESCE(SUM(DISTINCT l.balance), 0) as fee_balance,
    COUNT(DISTINCT lib.id)::INTEGER as books_issued,
    COUNT(DISTINCT CASE WHEN lib.days_overdue > 0 THEN lib.id END)::INTEGER as books_overdue
  FROM students s
  LEFT JOIN organizations o ON o.id = s.college_id AND o.organization_type = 'college'
  LEFT JOIN programs p ON p.id = CAST(s.grade AS UUID) -- Adjust based on actual relationship
  LEFT JOIN mark_entries m ON m.student_id = s.user_id
  LEFT JOIN student_ledgers l ON l.student_id = s.user_id
  LEFT JOIN library_issued_books lib ON lib.student_id = s.user_id AND lib.status = 'issued'
  WHERE s.user_id = p_student_user_id
  GROUP BY s.id, s.name, s.roll_number, o.name, p.name, s.grade, s."currentCgpa";
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_student_details(p_user_id uuid)
 RETURNS TABLE(student_id uuid, user_id uuid, email text, name text, roll_number text, admission_number text, college_id uuid, college_name text, grade text, section text, category text, quota text, current_cgpa numeric, enrollment_date date, expected_graduation_date date)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    s.id,
    s.user_id,
    s.email,
    s.name,
    s.roll_number,
    s.admission_number,
    s.college_id,
    o.name as college_name,
    s.grade,
    s.section,
    s.category,
    s.quota,
    s."currentCgpa",
    s."enrollmentDate",
    s."expectedGraduationDate"
  FROM students s
  LEFT JOIN organizations o ON o.id = s.college_id AND o.organization_type = 'college'
  WHERE s.user_id = p_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_student_eligibility(student_grade text)
 RETURNS TABLE(allowed_employment_types text[], max_experience_years integer, eligibility_level text)
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
BEGIN
  student_grade := LOWER(COALESCE(student_grade, ''));
  
  -- Grade 6-10: Only internships, no experience required
  -- Matches: 'grade 10', 'class 10', '10th', '10', 'Grade 10', etc.
  IF student_grade ~ '(grade\s*(6|7|8|9|10)|class\s*(6|7|8|9|10)|6th|7th|8th|9th|10th|^(6|7|8|9|10)$)' THEN
    RETURN QUERY SELECT 
      ARRAY['Internship']::TEXT[],
      0::INT,
      'school_junior'::TEXT;
  
  -- Grade 11-12: Internships and part-time, 0-1 year experience
  ELSIF student_grade ~ '(grade\s*(11|12)|class\s*(11|12)|11th|12th|plus\s*two|intermediate|^(11|12)$)' THEN
    RETURN QUERY SELECT 
      ARRAY['Internship', 'Part-time']::TEXT[],
      1::INT,
      'school_senior'::TEXT;
  
  -- Undergraduate: Internships, part-time, entry-level, 0-2 years
  ELSIF student_grade ~ '(b\.?tech|b\.?e|b\.?sc|b\.?com|b\.?a|bba|bca|undergraduate|ug|bachelor|1st\s*year|2nd\s*year|3rd\s*year|4th\s*year|semester)' THEN
    RETURN QUERY SELECT 
      ARRAY['Internship', 'Part-time', 'Full-time', 'Contract']::TEXT[],
      2::INT,
      'undergraduate'::TEXT;
  
  -- Postgraduate: All types, all experience levels
  ELSIF student_grade ~ '(m\.?tech|m\.?e|m\.?sc|m\.?com|m\.?a|mba|mca|postgraduate|pg|master|phd|doctorate)' THEN
    RETURN QUERY SELECT 
      ARRAY['Internship', 'Part-time', 'Full-time', 'Contract']::TEXT[],
      99::INT,
      'postgraduate'::TEXT;
  
  -- Default: Treat as undergraduate (safe default)
  ELSE
    RETURN QUERY SELECT 
      ARRAY['Internship', 'Part-time', 'Full-time', 'Contract']::TEXT[],
      2::INT,
      'default'::TEXT;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_student_stream_recommendation_data(p_student_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    result JSONB;
    student_data JSONB;
    marks_data JSONB;
    projects_data JSONB;
    experiences_data JSONB;
BEGIN
    -- Get student basic info
    SELECT jsonb_build_object(
        'id', s.id,
        'name', s.name,
        'grade', s.grade,
        'interests', COALESCE(s.interests, '[]'::jsonb),
        'hobbies', COALESCE(s.hobbies, '[]'::jsonb),
        'skill_summary', s.skill_summary
    ) INTO student_data
    FROM students s
    WHERE s.id = p_student_id;
    
    -- Get subject-wise marks (aggregate by subject)
    SELECT COALESCE(jsonb_object_agg(
        course_name,
        jsonb_build_object(
            'average_marks', avg_marks,
            'max_marks', max_marks,
            'percentage', ROUND((avg_marks / max_marks * 100)::numeric, 2),
            'assessments_count', assessment_count
        )
    ), '{}'::jsonb) INTO marks_data
    FROM (
        SELECT 
            a.course_name,
            AVG(me.marks_obtained) as avg_marks,
            MAX(me.total_marks) as max_marks,
            COUNT(*) as assessment_count
        FROM mark_entries me
        JOIN assessments a ON me.assessment_id = a.id
        WHERE (me.student_id = p_student_id OR me.student_record_id = p_student_id)
        AND me.marks_obtained IS NOT NULL
        GROUP BY a.course_name
    ) subject_marks;
    
    -- Get projects
    SELECT COALESCE(jsonb_agg(
        jsonb_build_object(
            'title', p.title,
            'description', p.description,
            'tech_stack', p.tech_stack,
            'status', p.status,
            'organization', p.organization
        )
    ), '[]'::jsonb) INTO projects_data
    FROM projects p
    WHERE p.student_id = p_student_id
    AND p.approval_status = 'approved';
    
    -- Get experiences
    SELECT COALESCE(jsonb_agg(
        jsonb_build_object(
            'organization', e.organization,
            'role', e.role,
            'duration', e.duration
        )
    ), '[]'::jsonb) INTO experiences_data
    FROM experience e
    WHERE e.student_id = p_student_id
    AND e.approval_status = 'approved';
    
    -- Combine all data
    result := jsonb_build_object(
        'student', student_data,
        'subject_marks', marks_data,
        'projects', projects_data,
        'experiences', experiences_data
    );
    
    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_student_trainings_with_approvers(student_email text)
 RETURNS TABLE(id uuid, title character varying, organization character varying, approval_status character varying, approval_authority character varying, approved_by_email text, approved_at timestamp with time zone, rejected_by_email text, rejected_at timestamp with time zone, approval_notes text, approver_type text, created_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        t.id,
        t.title,
        t.organization,
        t.approval_status,
        t.approval_authority,
        approver.email as approved_by_email,
        t.approved_at,
        rejector.email as rejected_by_email,
        t.rejected_at,
        t.approval_notes,
        CASE 
            WHEN t.approval_authority = 'school_admin' THEN 'School Admin'
            ELSE 'Rareminds Admin'
        END as approver_type,
        t.created_at
    FROM public.trainings t
    JOIN public.students s ON t.student_id = s.id
    LEFT JOIN auth.users approver ON t.approved_by = approver.id
    LEFT JOIN auth.users rejector ON t.rejected_by = rejector.id
    WHERE s.email = student_email
    ORDER BY t.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_students_needing_reminder()
 RETURNS TABLE(student_id uuid, student_email text, student_name text, current_streak integer, emails_sent_today integer)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    s.id AS student_id,
    s.email::TEXT AS student_email,
    s.name::TEXT AS student_name,
    COALESCE(ss.current_streak, 0) AS current_streak,
    COALESCE(
      (SELECT COUNT(*)::INTEGER
       FROM streak_notification_log
       WHERE streak_notification_log.student_id = s.id
       AND notification_date = CURRENT_DATE
       AND status = 'sent'),
      0
    ) AS emails_sent_today
  FROM students s
  LEFT JOIN student_streaks ss ON s.id = ss.student_id
  WHERE
    -- Student hasn't completed streak today
    (ss.streak_completed_today = FALSE OR ss.streak_completed_today IS NULL)
    -- Haven't sent 4 emails yet today
    AND (
      SELECT COUNT(*)
      FROM streak_notification_log
      WHERE streak_notification_log.student_id = s.id
      AND notification_date = CURRENT_DATE
      AND status = 'sent'
    ) < 4
    -- Student has an email address
    AND s.email IS NOT NULL
    AND s.email != '';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_training_with_approver_details(training_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    result json;
BEGIN
    SELECT json_build_object(
        'training', json_build_object(
            'id', t.id,
            'title', t.title,
            'organization', t.organization,
            'student_name', s.name,
            'student_email', s.email,
            'school_name', o.name,
            'approval_status', t.approval_status,
            'approval_authority', t.approval_authority,
            'created_at', t.created_at,
            'updated_at', t.updated_at
        ),
        'approval_details', CASE 
            WHEN t.approval_status = 'approved' THEN json_build_object(
                'approved_by_id', t.approved_by,
                'approved_by_email', approver.email,
                'approved_at', t.approved_at,
                'approval_notes', t.approval_notes,
                'approver_type', CASE 
                    WHEN t.approval_authority = 'school_admin' THEN 'School Admin'
                    ELSE 'Rareminds Admin'
                END
            )
            WHEN t.approval_status = 'rejected' THEN json_build_object(
                'rejected_by_id', t.rejected_by,
                'rejected_by_email', rejector.email,
                'rejected_at', t.rejected_at,
                'rejection_notes', t.approval_notes,
                'rejector_type', CASE 
                    WHEN t.approval_authority = 'school_admin' THEN 'School Admin'
                    ELSE 'Rareminds Admin'
                END
            )
            ELSE json_build_object(
                'status', 'pending',
                'pending_with', CASE 
                    WHEN t.approval_authority = 'school_admin' THEN 'School Admin'
                    ELSE 'Rareminds Admin'
                END
            )
        END
    ) INTO result
    FROM public.trainings t
    JOIN public.students s ON t.student_id = s.id
    LEFT JOIN public.organizations o ON s.school_id = o.id
    LEFT JOIN auth.users approver ON t.approved_by = approver.id
    LEFT JOIN auth.users rejector ON t.rejected_by = rejector.id
    WHERE t.id = training_id;
    
    RETURN COALESCE(result, json_build_object('error', 'Training not found'));
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_university_admins(p_university_id uuid)
 RETURNS TABLE(id uuid, email text, full_name text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT u.id, u.email, CONCAT(u."firstName", ' ', u."lastName") as full_name
    FROM users u
    WHERE u."organizationId" = p_university_id
    AND u.role = 'university_admin'
    AND u."isActive" = true;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_unread_notification_count(admin_school_id uuid DEFAULT NULL::uuid, admin_college_id uuid DEFAULT NULL::uuid, admin_type text DEFAULT 'school_admin'::text)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
    count_result INTEGER;
BEGIN
    IF admin_type = 'school_admin' AND admin_school_id IS NOT NULL THEN
        SELECT COUNT(*)
        INTO count_result
        FROM training_notifications
        WHERE recipient_type = 'school_admin'
        AND school_id = admin_school_id
        AND is_read = FALSE;
    ELSIF admin_type = 'college_admin' AND admin_college_id IS NOT NULL THEN
        SELECT COUNT(*)
        INTO count_result
        FROM training_notifications
        WHERE recipient_type = 'college_admin'
        AND college_id = admin_college_id
        AND is_read = FALSE;
    ELSE
        count_result := 0;
    END IF;
    
    RETURN COALESCE(count_result, 0);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_email(user_id uuid)
 RETURNS text
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT email FROM auth.users WHERE id = user_id;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_unread_count(user_id text, user_type text)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
  unread_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO unread_count
  FROM messages
  WHERE receiver_id = user_id
    AND receiver_type = user_type
    AND is_read = false;
  
  RETURN COALESCE(unread_count, 0);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_auth_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_first_name TEXT;
  v_last_name TEXT;
  v_full_name TEXT;
  v_role_text TEXT;
  v_role public.user_role;
  v_phone TEXT;
BEGIN
  -- Extract data from user metadata
  v_full_name := COALESCE(
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'name',
    ''
  );
  
  -- Try to split full name into first and last name
  v_first_name := COALESCE(
    NEW.raw_user_meta_data->>'first_name',
    SPLIT_PART(v_full_name, ' ', 1),
    ''
  );
  
  v_last_name := COALESCE(
    NEW.raw_user_meta_data->>'last_name',
    CASE 
      WHEN POSITION(' ' IN v_full_name) > 0 
      THEN SUBSTRING(v_full_name FROM POSITION(' ' IN v_full_name) + 1)
      ELSE ''
    END,
    ''
  );
  
  -- Get role from metadata and validate against enum
  v_role_text := COALESCE(
    NEW.raw_user_meta_data->>'user_role',
    NEW.raw_user_meta_data->>'role',
    'school_student'
  );
  
  -- Validate and cast role to enum
  IF v_role_text IN ('super_admin', 'rm_admin', 'rm_manager', 'school_admin', 'college_admin', 
                     'university_admin', 'company_admin', 'school_educator', 'recruiter', 
                     'school_student', 'college_student', 'college_educator') THEN
    v_role := v_role_text::public.user_role;
  ELSE
    v_role := 'school_student'::public.user_role;
  END IF;
  
  -- Get phone from metadata
  v_phone := NEW.raw_user_meta_data->>'phone';
  
  -- Insert into public.users if not exists
  INSERT INTO public.users (
    id,
    email,
    "firstName",
    "lastName",
    role,
    phone,
    "isActive",
    "organizationId",
    metadata,
    "createdAt",
    "updatedAt"
  )
  VALUES (
    NEW.id,
    NEW.email,
    v_first_name,
    v_last_name,
    v_role,
    v_phone,
    true,
    NULL,  -- organizationId will be set later when user joins/creates an organization
    jsonb_build_object(
      'source', 'auth_trigger',
      'registrationDate', NOW()::text,
      'fullName', v_full_name
    ),
    NOW(),
    NOW()
  )
  ON CONFLICT (id) DO NOTHING;  -- Don't fail if record already exists
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.has_advanced_skills(skills_json jsonb)
 RETURNS boolean
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
  skill_text TEXT;
  advanced_skills TEXT[] := ARRAY[
    'python', 'sql', 'java', 'javascript', 'react', 'node', 'angular', 'vue',
    'machine learning', 'ml', 'ai', 'data science', 'data analysis', 'analytics',
    'aws', 'azure', 'gcp', 'cloud', 'devops', 'docker', 'kubernetes',
    'spring boot', 'django', 'flask', 'express', 'mongodb', 'postgresql',
    'tensorflow', 'pytorch', 'deep learning', 'nlp', 'computer vision',
    'gmp', 'haccp', 'fssai', 'organic standards', 'lab skills', 'food tech',
    'marketing', 'content writing', 'seo', 'digital marketing',
    'accounting', 'finance', 'taxation', 'audit',
    'autocad', 'solidworks', 'matlab', 'simulation'
  ];
  skill_item TEXT;
BEGIN
  IF skills_json IS NULL THEN
    RETURN FALSE;
  END IF;
  skill_text := LOWER(skills_json::TEXT);
  FOREACH skill_item IN ARRAY advanced_skills LOOP
    IF skill_text LIKE '%' || skill_item || '%' THEN
      RETURN TRUE;
    END IF;
  END LOOP;
  RETURN FALSE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_applications_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE public.opportunities
  SET applications_count = applications_count + 1
  WHERE id = NEW.opportunity_id;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_course_enrollment(course_id_param uuid)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE courses
  SET enrollment_count = COALESCE(enrollment_count, 0) + 1
  WHERE course_id = course_id_param;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_search_usage(search_id uuid)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE recruiter_saved_searches
  SET 
    use_count = use_count + 1,
    last_used = NOW()
  WHERE id = search_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.initialize_student_streak()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO student_streaks (student_id, current_streak, longest_streak)
  VALUES (NEW.id, 0, 0)
  ON CONFLICT (student_id) DO NOTHING;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.invalidate_all_job_matches_on_opportunity_change()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- When an opportunity is added, updated, or deleted, invalidate all caches
    UPDATE student_job_matches
    SET is_valid = false,
        invalidation_reason = 'Opportunity catalog changed',
        updated_at = NOW()
    WHERE is_valid = true;
    
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.invalidate_job_matches_cache()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_student_id UUID;
    v_reason TEXT;
BEGIN
    -- Determine student_id based on table
    IF TG_TABLE_NAME = 'students' THEN
        v_student_id := COALESCE(NEW.id, OLD.id);
        v_reason := 'Student profile updated';
    ELSIF TG_TABLE_NAME = 'course_enrollments' THEN
        v_student_id := COALESCE(NEW.student_id, OLD.student_id);
        v_reason := 'Course enrollment changed';
    ELSIF TG_TABLE_NAME = 'trainings' THEN
        v_student_id := COALESCE(NEW.student_id, OLD.student_id);
        v_reason := 'Training record changed';
    ELSE
        RETURN COALESCE(NEW, OLD);
    END IF;
    
    -- Invalidate the cache
    UPDATE student_job_matches
    SET is_valid = false,
        invalidation_reason = v_reason,
        updated_at = NOW()
    WHERE student_id = v_student_id
    AND is_valid = true;
    
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_job_matches_cache_valid(p_student_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_cache RECORD;
    v_current_hash VARCHAR(64);
BEGIN
    -- Get current cache
    SELECT * INTO v_cache
    FROM student_job_matches
    WHERE student_id = p_student_id;
    
    -- No cache exists
    IF NOT FOUND THEN
        RETURN false;
    END IF;
    
    -- Cache explicitly invalidated
    IF NOT v_cache.is_valid THEN
        RETURN false;
    END IF;
    
    -- Cache expired
    IF v_cache.expires_at < NOW() THEN
        RETURN false;
    END IF;
    
    -- Check if student data has changed
    v_current_hash := compute_student_profile_hash(p_student_id);
    IF v_current_hash IS DISTINCT FROM v_cache.student_profile_hash THEN
        -- Mark cache as invalid
        UPDATE student_job_matches
        SET is_valid = false,
            invalidation_reason = 'Student profile changed',
            updated_at = NOW()
        WHERE student_id = p_student_id;
        RETURN false;
    END IF;
    
    RETURN true;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_organization_admin(user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1 FROM users u 
    WHERE u.id = user_id 
    AND u.role IN ('school_admin', 'college_admin', 'university_admin', 'company_admin', 'super_admin')
  );
$function$
;

CREATE OR REPLACE FUNCTION public.is_senior_level_job(p_title text, p_experience_level text, p_experience_required text)
 RETURNS boolean
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
  title_lower TEXT := LOWER(COALESCE(p_title, ''));
  exp_level_lower TEXT := LOWER(COALESCE(p_experience_level, ''));
  exp_req_lower TEXT := LOWER(COALESCE(p_experience_required, ''));
  years_required INT;
BEGIN
  IF exp_level_lower = 'senior' THEN
    RETURN TRUE;
  END IF;
  
  IF title_lower ~ '(senior|lead|principal|staff|head|director|manager|chief|vp|vice president|architect)' THEN
    RETURN TRUE;
  END IF;
  
  IF exp_req_lower ~ '(\d+)' THEN
    years_required := (regexp_match(exp_req_lower, '(\d+)'))[1]::INT;
    IF years_required >= 5 THEN
      RETURN TRUE;
    END IF;
  END IF;
  
  RETURN FALSE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_student_fresher(p_student_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
  student_rec RECORD;
  has_work_experience BOOLEAN := FALSE;
BEGIN
  SELECT 
    work_experience,
    student_type,
    course_name
  INTO student_rec
  FROM students 
  WHERE id = p_student_id;
  
  IF student_rec.work_experience IS NOT NULL 
     AND TRIM(student_rec.work_experience) != '' 
     AND LOWER(student_rec.work_experience) NOT IN ('none', 'no', 'n/a', 'nil', '0', 'fresher', 'no experience') THEN
    has_work_experience := TRUE;
  END IF;
  
  IF NOT has_work_experience THEN
    IF student_rec.student_type IN ('school', 'school_student', 'school-student', 'college', 'university', 'student', 'direct') THEN
      RETURN TRUE;
    END IF;
  END IF;
  
  RETURN NOT has_work_experience;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_subscription_active(sub_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
  sub_status VARCHAR(50);
  end_date TIMESTAMPTZ;
BEGIN
  SELECT status, subscription_end_date 
  INTO sub_status, end_date
  FROM subscriptions
  WHERE id = sub_id;
  
  RETURN sub_status = 'active' AND end_date > NOW();
END;
$function$
;

create or replace view "public"."learning_outcome_details" as  SELECT clo.id,
    clo.chapter_id,
    clo.outcome,
    clo.bloom_level,
    cc.name AS chapter_name,
    cc.curriculum_id,
    c.subject,
    c.class,
    c.academic_year,
    count(oam.id) AS assessment_count,
    array_agg(
        CASE
            WHEN (at.name IS NOT NULL) THEN jsonb_build_object('assessment_type', at.name, 'weightage', oam.weightage)
            ELSE NULL::jsonb
        END) FILTER (WHERE (at.name IS NOT NULL)) AS assessment_mappings
   FROM ((((public.curriculum_learning_outcomes clo
     JOIN public.curriculum_chapters cc ON ((clo.chapter_id = cc.id)))
     JOIN public.curriculums c ON ((cc.curriculum_id = c.id)))
     LEFT JOIN public.outcome_assessment_mappings oam ON ((clo.id = oam.learning_outcome_id)))
     LEFT JOIN public.assessment_types at ON ((oam.assessment_type_id = at.id)))
  GROUP BY clo.id, cc.name, cc.curriculum_id, c.subject, c.class, c.academic_year;


CREATE OR REPLACE FUNCTION public.log_notification_sent(p_student_id uuid, p_template_number integer, p_notification_type character varying DEFAULT 'email'::character varying, p_status character varying DEFAULT 'sent'::character varying, p_error_message text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_log_id UUID;
BEGIN
  INSERT INTO streak_notification_log (
    student_id,
    notification_type,
    email_template_number,
    notification_date,
    status,
    error_message
  ) VALUES (
    p_student_id,
    p_notification_type,
    p_template_number,
    CURRENT_DATE,
    p_status,
    p_error_message
  )
  RETURNING id INTO v_log_id;

  RETURN v_log_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.mark_conversation_as_read(p_conversation_id text, p_user_id text)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
  affected_rows INTEGER;
BEGIN
  UPDATE messages
  SET 
    is_read = true,
    read_at = NOW(),
    updated_at = NOW()
  WHERE conversation_id = p_conversation_id
    AND receiver_id = p_user_id
    AND is_read = false;
  
  GET DIAGNOSTICS affected_rows = ROW_COUNT;
  RETURN affected_rows;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.mark_notification_read(notification_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    UPDATE public.training_notifications 
    SET is_read = true, updated_at = NOW()
    WHERE id = notification_id;
    
    RETURN FOUND;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.mark_previous_stream_reports_not_latest()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Mark all previous reports for this student as not latest
    UPDATE stream_recommendation_reports
    SET is_latest = false
    WHERE student_id = NEW.student_id
    AND id != NEW.id;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.match_opportunities(query_embedding extensions.vector, student_id_param uuid, dismissed_ids uuid[], match_threshold double precision, match_count integer)
 RETURNS TABLE(id uuid, title text, job_title text, company_name text, company_logo text, description text, location text, employment_type text, department text, salary_min numeric, salary_max numeric, experience_level text, skills_required jsonb, requirements jsonb, responsibilities jsonb, created_at timestamp with time zone, similarity double precision, view_count integer, application_count integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    o.id,
    o.title,
    o.job_title,
    o.company_name,
    o.company_logo,
    o.description,
    o.location,
    o.employment_type,
    o.department,
    o.salary_range_min,
    o.salary_range_max,
    o.experience_level,
    o.skills_required,
    o.requirements,
    o.responsibilities,
    o.created_at,
    (1 - (o.embedding <=> query_embedding))::FLOAT,
    o.views_count,
    o.applications_count
  FROM opportunities o
  WHERE o.embedding IS NOT NULL
    AND o.is_active = true
    AND o.status = 'published'
    AND NOT (o.id = ANY(dismissed_ids))
    AND (1 - (o.embedding <=> query_embedding)) >= match_threshold
  ORDER BY o.embedding <=> query_embedding
  LIMIT match_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.match_opportunities_enhanced(query_embedding extensions.vector, student_id_param uuid, dismissed_ids uuid[] DEFAULT '{}'::uuid[], match_threshold double precision DEFAULT 0.30, match_count integer DEFAULT 50)
 RETURNS TABLE(id uuid, title text, job_title text, company_name text, company_logo text, employment_type text, location text, mode text, stipend_or_salary text, experience_required text, experience_level text, skills_required jsonb, requirements jsonb, responsibilities jsonb, description text, application_link text, deadline timestamp with time zone, department text, salary_range_min integer, salary_range_max integer, posted_date timestamp with time zone, is_active boolean, status text, created_at timestamp with time zone, updated_at timestamp with time zone, views_count integer, applications_count integer, embedding extensions.vector, similarity double precision, skill_match_score double precision, final_score double precision)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  student_grade TEXT;
  student_type TEXT;
  student_semester INTEGER;
  student_branch TEXT;
  student_courses TEXT[];
  profile_completeness FLOAT;
BEGIN
  -- Get comprehensive student info
  SELECT 
    s.grade, 
    s.student_type,
    COALESCE(s.semester, 1) as semester,
    COALESCE(s.branch_field, s.course_name, '') as branch,
    ARRAY(
      SELECT ce.course_title 
      FROM course_enrollments ce 
      WHERE ce.student_id = s.id 
        AND ce.status IN ('in_progress', 'active', 'completed')
    ) as courses
  INTO student_grade, student_type, student_semester, student_branch, student_courses
  FROM students s 
  WHERE s.id = student_id_param;

  -- Calculate profile completeness (0.0 - 1.0)
  SELECT 
    (
      CASE WHEN s.branch_field IS NOT NULL THEN 0.15 ELSE 0.0 END +
      CASE WHEN s.course_name IS NOT NULL THEN 0.15 ELSE 0.0 END +
      CASE WHEN s.university IS NOT NULL THEN 0.10 ELSE 0.0 END +
      CASE WHEN EXISTS(SELECT 1 FROM skills sk WHERE sk.student_id = s.id AND sk.enabled = true) THEN 0.20 ELSE 0.0 END +
      CASE WHEN EXISTS(SELECT 1 FROM projects p WHERE p.student_id = s.id) THEN 0.20 ELSE 0.0 END +
      CASE WHEN EXISTS(SELECT 1 FROM trainings t WHERE t.student_id = s.id) THEN 0.10 ELSE 0.0 END +
      CASE WHEN EXISTS(SELECT 1 FROM course_enrollments ce WHERE ce.student_id = s.id AND ce.status = 'completed') THEN 0.10 ELSE 0.0 END
    )
  INTO profile_completeness
  FROM students s
  WHERE s.id = student_id_param;

  RETURN QUERY
  SELECT 
    o.id,
    o.title,
    o.job_title,
    o.company_name,
    o.company_logo,
    o.employment_type,
    o.location,
    o.mode,
    o.stipend_or_salary,
    o.experience_required,
    o.experience_level,
    o.skills_required,
    o.requirements,
    o.responsibilities,
    o.description,
    o.application_link,
    o.deadline,
    o.department,
    o.salary_range_min,
    o.salary_range_max,
    o.posted_date,
    o.is_active,
    o.status,
    o.created_at,
    o.updated_at,
    o.views_count,
    o.applications_count,
    o.embedding,
    (1 - (query_embedding <=> o.embedding))::FLOAT as similarity,
    0.0::FLOAT as skill_match_score,
    LEAST(1.0, 
      (1 - (query_embedding <=> o.embedding)) * 
      (1.0 + 
        CASE WHEN o.description IS NOT NULL AND length(o.description) > 100 THEN 0.15 ELSE 0.0 END +
        CASE WHEN o.skills_required IS NOT NULL 
          AND jsonb_typeof(o.skills_required) = 'array' 
          AND jsonb_array_length(o.skills_required) > 0 THEN 0.10 ELSE 0.0 END +
        CASE WHEN o.company_name IS NOT NULL AND o.company_name != '' THEN 0.05 ELSE 0.0 END
      ) *
      CASE
        WHEN student_grade = 'UG' 
          AND student_semester <= 4 
          AND o.employment_type = 'Full-time' THEN 0.0
        WHEN student_grade = 'UG' 
          AND o.employment_type = 'Internship' 
          AND o.description IS NOT NULL THEN 1.3
        WHEN (student_grade = 'UG' AND student_semester >= 7) 
          OR student_grade = 'PG'
          AND o.employment_type = 'Full-time' THEN 1.2
        WHEN student_grade IN ('UG', 'PG') AND (
          o.title LIKE '%School Newsletter%' OR 
          o.title LIKE '%Road Safety%' OR 
          o.title LIKE '%Mindfulness Buddy%' OR
          o.title LIKE '%Young%' OR
          o.title LIKE '%School Garden%'
        ) THEN 0.7
        ELSE 1.0
      END *
      CASE
        WHEN EXISTS(
          SELECT 1 FROM unnest(student_courses) course 
          WHERE LOWER(course) LIKE '%blockchain%' OR LOWER(course) LIKE '%crypto%'
        ) AND (
          LOWER(o.title) LIKE '%blockchain%' OR 
          LOWER(o.description) LIKE '%blockchain%' OR
          LOWER(o.title) LIKE '%crypto%' OR
          LOWER(o.description) LIKE '%web3%'
        ) THEN 1.5
        WHEN EXISTS(
          SELECT 1 FROM unnest(student_courses) course 
          WHERE LOWER(course) LIKE '%python%' OR LOWER(course) LIKE '%programming%'
        ) AND (
          LOWER(o.title) LIKE '%python%' OR 
          LOWER(o.title) LIKE '%developer%' OR
          LOWER(o.title) LIKE '%software%'
        ) THEN 1.4
        WHEN EXISTS(
          SELECT 1 FROM unnest(student_courses) course 
          WHERE LOWER(course) LIKE '%data%' OR LOWER(course) LIKE '%analytics%'
        ) AND (
          LOWER(o.title) LIKE '%data%' OR 
          LOWER(o.title) LIKE '%analyst%' OR
          LOWER(o.title) LIKE '%analytics%'
        ) THEN 1.4
        WHEN EXISTS(
          SELECT 1 FROM unnest(student_courses) course 
          WHERE LOWER(course) LIKE '%marketing%' OR LOWER(course) LIKE '%business%'
        ) AND (
          LOWER(o.title) LIKE '%marketing%' OR 
          LOWER(o.title) LIKE '%business%' OR
          LOWER(o.title) LIKE '%sales%'
        ) THEN 1.4
        WHEN EXISTS(
          SELECT 1 FROM unnest(student_courses) course 
          WHERE LOWER(course) LIKE '%design%' OR LOWER(course) LIKE '%ui%' OR LOWER(course) LIKE '%ux%'
        ) AND (
          LOWER(o.title) LIKE '%design%' OR 
          LOWER(o.title) LIKE '%ui%' OR
          LOWER(o.title) LIKE '%ux%'
        ) THEN 1.4
        ELSE 1.0
      END *
      CASE
        WHEN profile_completeness >= 0.60 THEN 1.0
        WHEN profile_completeness >= 0.40 THEN 0.95
        WHEN profile_completeness >= 0.20 THEN 0.85
        ELSE 0.75
      END *
      CASE
        WHEN o.experience_level IN ('Entry', 'Fresher', 'Beginner') 
          AND student_grade IN ('UG', 'Grade 12', 'Grade 11') THEN 1.2
        WHEN o.experience_level IN ('Junior', 'Associate') 
          AND (
            (student_grade = 'UG' AND student_semester >= 5) OR 
            student_grade = 'PG'
          ) THEN 1.1
        WHEN o.experience_level IN ('Senior', 'Lead', 'Manager') 
          AND student_grade IN ('UG', 'PG', 'Grade 12') THEN 0.8
        ELSE 1.0
      END
    )::FLOAT as final_score
  FROM opportunities o
  WHERE o.embedding IS NOT NULL
    AND o.is_active = true
    AND o.status = 'open'
    AND (o.deadline IS NULL OR o.deadline > NOW())
    AND NOT (o.id = ANY(dismissed_ids))
    AND length(o.title) > 10
    AND (1 - (query_embedding <=> o.embedding)) >= (match_threshold * 0.7)
    AND NOT (
      student_grade = 'UG' 
      AND student_semester <= 4 
      AND o.employment_type = 'Full-time'
    )
  ORDER BY final_score DESC
  LIMIT match_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.match_opportunities_enhanced_v2(query_embedding extensions.vector, student_id_param uuid, dismissed_ids uuid[] DEFAULT '{}'::uuid[], match_threshold double precision DEFAULT 0.01, match_count integer DEFAULT 50)
 RETURNS TABLE(id uuid, title text, company_name text, employment_type text, location text, mode text, stipend_or_salary text, experience_level text, skills_required jsonb, description text, deadline timestamp with time zone, similarity double precision, skill_match_score double precision, certificate_match_score double precision, project_match_score double precision, final_score double precision, match_percentage integer)
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
  student_is_fresher BOOLEAN;
BEGIN
  student_is_fresher := is_student_fresher(student_id_param);
  
  RETURN QUERY
  WITH base_matches AS (
    SELECT 
      o.id,
      o.title,
      o.company_name,
      o.employment_type,
      o.location,
      o.mode,
      o.stipend_or_salary,
      o.experience_level,
      o.experience_required,
      o.skills_required,
      o.description,
      o.deadline,
      1 - (query_embedding <=> o.embedding) AS similarity,
      is_senior_level_job(o.title, o.experience_level, o.experience_required) AS is_senior
    FROM opportunities o
    WHERE o.is_active = true
      AND o.status = 'open'
      AND (o.deadline IS NULL OR o.deadline > NOW())
      AND o.embedding IS NOT NULL
      AND o.id != ALL(dismissed_ids)
      AND (1 - (query_embedding <=> o.embedding)) >= match_threshold
    ORDER BY query_embedding <=> o.embedding
    LIMIT match_count * 2
  ),
  certificate_scores AS (
    SELECT 
      bm.id AS opportunity_id,
      COALESCE(MAX(1 - (c.embedding <=> o.embedding)), 0) AS cert_score
    FROM base_matches bm
    JOIN opportunities o ON o.id = bm.id
    LEFT JOIN certificates c ON c.student_id = student_id_param 
      AND c.enabled = true 
      AND c.embedding IS NOT NULL
    GROUP BY bm.id
  ),
  project_scores AS (
    SELECT 
      bm.id AS opportunity_id,
      COALESCE(MAX(1 - (p.embedding <=> o.embedding)), 0) AS proj_score
    FROM base_matches bm
    JOIN opportunities o ON o.id = bm.id
    LEFT JOIN projects p ON p.student_id = student_id_param 
      AND p.enabled = true 
      AND p.embedding IS NOT NULL
    GROUP BY bm.id
  ),
  skill_matches AS (
    SELECT 
      bm.id AS opportunity_id,
      CASE 
        WHEN o.skills_required IS NULL THEN 0.5
        WHEN jsonb_typeof(o.skills_required) = 'string' THEN
          (
            SELECT COALESCE(
              COUNT(DISTINCT s.name)::FLOAT / GREATEST(
                array_length(string_to_array(o.skills_required #>> '{}', ','), 1), 1
              ),
              0
            )
            FROM skills s
            WHERE s.student_id = student_id_param
              AND s.enabled = true
              AND EXISTS (
                SELECT 1 FROM unnest(string_to_array(o.skills_required #>> '{}', ',')) AS req_skill
                WHERE LOWER(TRIM(req_skill)) LIKE '%' || LOWER(s.name) || '%'
                   OR LOWER(s.name) LIKE '%' || LOWER(TRIM(req_skill)) || '%'
              )
          )
        WHEN jsonb_typeof(o.skills_required) = 'array' AND jsonb_array_length(o.skills_required) = 0 THEN 0.5
        WHEN jsonb_typeof(o.skills_required) = 'array' THEN
          (
            SELECT COALESCE(
              COUNT(DISTINCT s.name)::FLOAT / GREATEST(jsonb_array_length(o.skills_required), 1),
              0
            )
            FROM skills s
            WHERE s.student_id = student_id_param
              AND s.enabled = true
              AND LOWER(s.name) IN (
                SELECT LOWER(jsonb_array_elements_text(o.skills_required))
              )
          )
        ELSE 0.5
      END AS skill_overlap
    FROM base_matches bm
    JOIN opportunities o ON o.id = bm.id
  ),
  scored_opportunities AS (
    SELECT 
      bm.id,
      bm.title,
      bm.company_name,
      bm.employment_type,
      bm.location,
      bm.mode,
      bm.stipend_or_salary,
      bm.experience_level,
      bm.experience_required,
      bm.skills_required,
      bm.description,
      bm.deadline,
      bm.similarity,
      sm.skill_overlap AS skill_match_score,
      cs.cert_score AS certificate_match_score,
      ps.proj_score AS project_match_score,
      bm.is_senior,
      (
        (bm.similarity * 0.40) +
        (COALESCE(sm.skill_overlap, 0.5) * 0.25) +
        (cs.cert_score * 0.20) +
        (ps.proj_score * 0.15)
      ) AS base_score,
      (student_is_fresher AND bm.is_senior) AS exp_mismatch
    FROM base_matches bm
    LEFT JOIN certificate_scores cs ON cs.opportunity_id = bm.id
    LEFT JOIN project_scores ps ON ps.opportunity_id = bm.id
    LEFT JOIN skill_matches sm ON sm.opportunity_id = bm.id
  )
  SELECT 
    so.id,
    so.title,
    so.company_name,
    so.employment_type,
    so.location,
    so.mode,
    so.stipend_or_salary,
    so.experience_level,
    so.skills_required,
    so.description,
    so.deadline,
    so.similarity,
    COALESCE(so.skill_match_score, 0.5) AS skill_match_score,
    so.certificate_match_score,
    so.project_match_score,
    CASE 
      WHEN so.exp_mismatch THEN LEAST(1.0, so.base_score * 0.70)
      ELSE LEAST(1.0, so.base_score)
    END AS final_score,
    CASE 
      WHEN so.exp_mismatch THEN LEAST(100, ROUND(so.base_score * 0.70 * 100))::INT
      ELSE LEAST(100, ROUND(so.base_score * 100))::INT
    END AS match_percentage
  FROM scored_opportunities so
  WHERE NOT (
    student_is_fresher 
    AND so.is_senior 
    AND so.experience_level = 'Senior'
    AND (
      COALESCE((SELECT (regexp_match(LOWER(o.experience_required), '(\d+)'))[1]::INT 
                FROM opportunities o WHERE o.id = so.id), 0) >= 5
    )
  )
  ORDER BY final_score DESC
  LIMIT match_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.match_opportunities_smart(p_student_id uuid, p_query_embedding extensions.vector, p_student_type text DEFAULT NULL::text, p_grade text DEFAULT NULL::text, p_semester integer DEFAULT NULL::integer, p_dismissed_ids uuid[] DEFAULT '{}'::uuid[], p_match_threshold double precision DEFAULT 0.30, p_match_count integer DEFAULT 50)
 RETURNS TABLE(id uuid, title text, company_name text, company_logo text, employment_type text, location text, mode text, stipend_or_salary text, experience_required text, experience_level text, skills_required jsonb, requirements jsonb, responsibilities jsonb, description text, application_link text, deadline timestamp with time zone, department text, salary_range_min integer, salary_range_max integer, posted_date timestamp with time zone, is_active boolean, status text, created_at timestamp with time zone, updated_at timestamp with time zone, views_count integer, applications_count integer, similarity_score double precision, skill_match_score double precision, certificate_match_score double precision, project_match_score double precision, experience_match_score double precision, final_score double precision, match_percentage integer, match_reasons jsonb)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_student_skills TEXT[];
  v_student_certificates TEXT[];
  v_student_projects TEXT[];
  v_student_experience_count INTEGER;
  v_is_school_student BOOLEAN;
  v_grade_number INTEGER;
BEGIN
  -- Determine if student is a school student
  v_is_school_student := (p_student_type = 'school-student');
  
  -- Extract grade number for school students
  IF v_is_school_student AND p_grade IS NOT NULL THEN
    v_grade_number := CAST(REGEXP_REPLACE(p_grade, '[^0-9]', '', 'g') AS INTEGER);
  END IF;

  -- Fetch student skills
  SELECT ARRAY_AGG(DISTINCT LOWER(s.name))
  INTO v_student_skills
  FROM skills s
  WHERE s.student_id = p_student_id
    AND s.enabled = true;

  -- Fetch student certificates
  SELECT ARRAY_AGG(DISTINCT LOWER(c.title))
  INTO v_student_certificates
  FROM certificates c
  WHERE c.student_id = p_student_id
    AND c.enabled = true;

  -- Fetch student projects
  SELECT ARRAY_AGG(DISTINCT LOWER(p.title))
  INTO v_student_projects
  FROM projects p
  WHERE p.student_id = p_student_id
    AND p.enabled = true;

  -- Count student experience
  SELECT COUNT(*)
  INTO v_student_experience_count
  FROM experience e
  WHERE e.student_id = p_student_id
    AND e.enabled = true;

  -- Return matched opportunities with comprehensive scoring
  RETURN QUERY
  WITH filtered_opportunities AS (
    SELECT o.*
    FROM opportunities o
    WHERE o.embedding IS NOT NULL
      AND o.is_active = true
      AND o.status = 'open'
      AND (o.deadline IS NULL OR o.deadline > NOW())
      AND NOT (o.id = ANY(p_dismissed_ids))
      -- Filter by student type and experience level
      AND (
        CASE
          -- School students (Grade 6-12): Only internships and entry-level
          WHEN v_is_school_student THEN
            LOWER(o.employment_type) IN ('internship', 'part-time') OR
            LOWER(o.experience_level) IN ('entry', 'intern', 'fresher', 'beginner')
          
          -- University students: Filter by semester/year
          WHEN p_student_type = 'university-student' THEN
            CASE
              -- Early years (Semester 1-4): Internships and entry-level
              WHEN p_semester IS NOT NULL AND p_semester <= 4 THEN
                LOWER(o.employment_type) IN ('internship', 'part-time', 'full-time') AND
                LOWER(o.experience_level) IN ('entry', 'intern', 'fresher', 'junior')
              
              -- Final years (Semester 5+): Entry to mid-level
              WHEN p_semester IS NOT NULL AND p_semester >= 5 THEN
                LOWER(o.experience_level) IN ('entry', 'junior', 'mid', 'fresher')
              
              -- Default: Entry and junior level
              ELSE
                LOWER(o.experience_level) IN ('entry', 'junior', 'intern', 'fresher')
            END
          
          -- College students: Similar to university
          WHEN p_student_type = 'college-student' THEN
            LOWER(o.experience_level) IN ('entry', 'junior', 'intern', 'fresher')
          
          -- Default: Show all
          ELSE true
        END
      )
  ),
  scored_opportunities AS (
    SELECT 
      o.*,
      
      -- 1. Semantic Similarity Score (40% weight)
      GREATEST(0, LEAST(1, (1 - (p_query_embedding <=> o.embedding))))::FLOAT as similarity,
      
      -- 2. Skill Match Score (30% weight)
      CASE 
        WHEN o.skills_required IS NULL OR jsonb_array_length(o.skills_required) = 0 THEN 0.5
        WHEN v_student_skills IS NULL THEN 0.0
        ELSE (
          SELECT COUNT(DISTINCT skill)::FLOAT / GREATEST(jsonb_array_length(o.skills_required), 1)
          FROM jsonb_array_elements_text(o.skills_required) skill
          WHERE EXISTS (
            SELECT 1 FROM UNNEST(v_student_skills) student_skill
            WHERE LOWER(skill) LIKE '%' || student_skill || '%'
               OR student_skill LIKE '%' || LOWER(skill) || '%'
          )
        )
      END as skill_match,
      
      -- 3. Certificate Match Score (15% weight)
      CASE
        WHEN v_student_certificates IS NULL THEN 0.0
        WHEN o.requirements IS NULL THEN 0.3
        ELSE (
          SELECT LEAST(1.0, COUNT(*)::FLOAT * 0.3)
          FROM jsonb_array_elements_text(o.requirements) req
          WHERE EXISTS (
            SELECT 1 FROM UNNEST(v_student_certificates) cert
            WHERE LOWER(req) LIKE '%' || cert || '%'
               OR cert LIKE '%' || LOWER(req) || '%'
          )
        )
      END as certificate_match,
      
      -- 4. Project Match Score (15% weight)
      CASE
        WHEN v_student_projects IS NULL THEN 0.0
        WHEN o.responsibilities IS NULL THEN 0.2
        ELSE (
          SELECT LEAST(1.0, COUNT(*)::FLOAT * 0.25)
          FROM jsonb_array_elements_text(o.responsibilities) resp
          WHERE EXISTS (
            SELECT 1 FROM UNNEST(v_student_projects) proj
            WHERE LOWER(resp) LIKE '%' || proj || '%'
               OR proj LIKE '%' || LOWER(resp) || '%'
          )
        )
      END as project_match,
      
      -- 5. Experience Level Match Score (bonus)
      CASE
        WHEN v_student_experience_count = 0 AND LOWER(o.experience_level) IN ('entry', 'intern', 'fresher') THEN 0.2
        WHEN v_student_experience_count >= 1 AND LOWER(o.experience_level) IN ('junior', 'mid') THEN 0.15
        WHEN v_student_experience_count >= 3 AND LOWER(o.experience_level) IN ('mid', 'senior') THEN 0.1
        ELSE 0.0
      END as experience_bonus
      
    FROM filtered_opportunities o
  )
  SELECT 
    so.id,
    so.title,
    so.company_name,
    so.company_logo,
    so.employment_type,
    so.location,
    so.mode,
    so.stipend_or_salary,
    so.experience_required,
    so.experience_level,
    so.skills_required,
    so.requirements,
    so.responsibilities,
    so.description,
    so.application_link,
    so.deadline,
    so.department,
    so.salary_range_min,
    so.salary_range_max,
    so.posted_date,
    so.is_active,
    so.status,
    so.created_at,
    so.updated_at,
    so.views_count,
    so.applications_count,
    
    -- Individual scores
    so.similarity as similarity_score,
    so.skill_match as skill_match_score,
    so.certificate_match as certificate_match_score,
    so.project_match as project_match_score,
    so.experience_bonus as experience_match_score,
    
    -- Final weighted score
    (
      (so.similarity * 0.40) +
      (so.skill_match * 0.30) +
      (so.certificate_match * 0.15) +
      (so.project_match * 0.15) +
      so.experience_bonus
    )::FLOAT as final_score,
    
    -- Match percentage (0-100)
    LEAST(100, GREATEST(0, ROUND(
      (
        (so.similarity * 0.40) +
        (so.skill_match * 0.30) +
        (so.certificate_match * 0.15) +
        (so.project_match * 0.15) +
        so.experience_bonus
      ) * 100
    )))::INTEGER as match_percentage,
    
    -- Match reasons (for UI display)
    jsonb_build_object(
      'profile_match', so.similarity >= 0.6,
      'skill_match', so.skill_match >= 0.5,
      'certificate_match', so.certificate_match >= 0.3,
      'project_match', so.project_match >= 0.3,
      'experience_appropriate', so.experience_bonus > 0,
      'recently_posted', (NOW() - so.posted_date) < INTERVAL '7 days',
      'high_demand', so.views_count > 50
    ) as match_reasons
    
  FROM scored_opportunities so
  WHERE (
    (so.similarity * 0.40) +
    (so.skill_match * 0.30) +
    (so.certificate_match * 0.15) +
    (so.project_match * 0.15) +
    so.experience_bonus
  ) >= p_match_threshold
  ORDER BY final_score DESC, so.posted_date DESC
  LIMIT p_match_count;
  
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_admin_assessment_completion()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    admin_user_id UUID;
    student_name TEXT;
    student_school_id UUID;
    student_school_name TEXT;
    assessment_name TEXT;
BEGIN
    IF (TG_OP = 'INSERT' AND NEW.status = 'completed') OR 
       (TG_OP = 'UPDATE' AND OLD.status != 'completed' AND NEW.status = 'completed') THEN
        
        -- Get student details from organizations table
        SELECT s.name, s.school_id, o.name 
        INTO student_name, student_school_id, student_school_name
        FROM students s 
        LEFT JOIN organizations o ON s.school_id = o.id
        WHERE s.id = NEW.student_id;
        
        -- Create assessment name
        assessment_name := CASE 
            WHEN NEW.stream_id = 'middle_school' THEN 'Middle School Career Assessment'
            WHEN NEW.stream_id = 'high_school' THEN 'High School Career Assessment'
            WHEN NEW.stream_id = 'science' THEN 'Science Stream Assessment'
            WHEN NEW.stream_id = 'commerce' THEN 'Commerce Stream Assessment'
            WHEN NEW.stream_id = 'arts' THEN 'Arts Stream Assessment'
            WHEN NEW.stream_id = 'cs' THEN 'Computer Science Assessment'
            WHEN NEW.stream_id = 'bca' THEN 'BCA Career Assessment'
            WHEN NEW.stream_id = 'bba' THEN 'BBA Career Assessment'
            WHEN NEW.stream_id = 'engineering' THEN 'Engineering Assessment'
            WHEN NEW.stream_id = 'medical' THEN 'Medical Assessment'
            ELSE COALESCE(UPPER(NEW.stream_id), 'Career Assessment')
        END;
        
        IF NEW.grade_level IS NOT NULL THEN
            assessment_name := assessment_name || ' (' || 
                CASE NEW.grade_level
                    WHEN 'middle' THEN 'Grade 6-8'
                    WHEN 'highschool' THEN 'Grade 9-12'
                    WHEN 'after12' THEN 'After 12th'
                    ELSE NEW.grade_level
                END || ')';
        END IF;
        
        IF student_school_id IS NOT NULL THEN
            SELECT se.user_id INTO admin_user_id
            FROM school_educators se
            WHERE se.school_id = student_school_id 
            AND se.role = 'school_admin'
            LIMIT 1;
            
            IF admin_user_id IS NOT NULL THEN
                IF NOT EXISTS (
                    SELECT 1 FROM notifications 
                    WHERE recipient_id = admin_user_id 
                    AND type = 'assessment_completed'
                    AND message LIKE '%' || COALESCE(student_name, 'Student') || '%'
                    AND message LIKE '%' || assessment_name || '%'
                    AND created_at > NOW() - INTERVAL '1 hour'
                ) THEN
                    INSERT INTO notifications (recipient_id, type, title, message, read)
                    VALUES (
                        admin_user_id,
                        'assessment_completed',
                        'Student Assessment Completed',
                        COALESCE(student_name, 'Student') || ' completed ' || 
                        assessment_name || ' assessment',
                        false
                    );
                END IF;
            END IF;
        ELSE
            SELECT u.id INTO admin_user_id
            FROM users u
            WHERE u.role = 'super_admin'
            LIMIT 1;
            
            IF admin_user_id IS NOT NULL THEN
                IF NOT EXISTS (
                    SELECT 1 FROM notifications 
                    WHERE recipient_id = admin_user_id 
                    AND type = 'assessment_completed'
                    AND message LIKE '%' || COALESCE(student_name, 'Student') || '%'
                    AND message LIKE '%' || assessment_name || '%'
                    AND created_at > NOW() - INTERVAL '1 hour'
                ) THEN
                    INSERT INTO notifications (recipient_id, type, title, message, read)
                    VALUES (
                        admin_user_id,
                        'assessment_completed',
                        'Assessment Completed',
                        COALESCE(student_name, 'Student') || ' completed ' || 
                        assessment_name || ' assessment',
                        false
                    );
                END IF;
            END IF;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_admin_experience_submission()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    admin_user_id UUID;
    student_name TEXT;
    student_school_id UUID;
    student_school_name TEXT;
    is_school_experience BOOLEAN := FALSE;
BEGIN
    -- Handle both INSERT and UPDATE events for pending experiences
    IF (TG_OP = 'INSERT' AND NEW.approval_status = 'pending') OR 
       (TG_OP = 'UPDATE' AND OLD.approval_status != 'pending' AND NEW.approval_status = 'pending') THEN
        
        -- Get student details including school info from organizations table
        SELECT s.name, s.school_id, o.name 
        INTO student_name, student_school_id, student_school_name
        FROM students s 
        LEFT JOIN organizations o ON s.school_id = o.id
        WHERE s.user_id = NEW.student_id;
        
        -- Check if the experience is at the student's own school
        IF student_school_name IS NOT NULL AND NEW.organization IS NOT NULL THEN
            is_school_experience := LOWER(TRIM(NEW.organization)) = LOWER(TRIM(student_school_name));
        END IF;
        
        -- Only notify school admin if student belongs to a school and experience is at their school
        IF student_school_id IS NOT NULL AND is_school_experience THEN
            SELECT se.user_id INTO admin_user_id
            FROM school_educators se
            WHERE se.school_id = student_school_id 
            AND se.role = 'school_admin'
            LIMIT 1;
            
            IF admin_user_id IS NOT NULL THEN
                IF NOT EXISTS (
                    SELECT 1 FROM notifications 
                    WHERE recipient_id = admin_user_id 
                    AND type = 'experience_submitted'
                    AND message LIKE '%' || COALESCE(NEW.role, 'Experience') || '%'
                    AND message LIKE '%' || COALESCE(NEW.organization, 'Organization') || '%'
                    AND created_at > NOW() - INTERVAL '1 hour'
                ) THEN
                    INSERT INTO notifications (recipient_id, type, title, message, read)
                    VALUES (
                        admin_user_id,
                        'experience_submitted',
                        'New School Experience Submitted',
                        COALESCE(student_name, 'Student') || ' submitted "' || 
                        COALESCE(NEW.role, 'Experience') || ' at ' || 
                        COALESCE(NEW.organization, 'Organization') || '" for approval',
                        false
                    );
                END IF;
            END IF;
        ELSE
            -- For external experiences, notify super admin
            IF student_school_id IS NOT NULL AND NOT is_school_experience THEN
                SELECT u.id INTO admin_user_id
                FROM users u
                WHERE u.role = 'super_admin'
                LIMIT 1;
                
                IF admin_user_id IS NOT NULL THEN
                    IF NOT EXISTS (
                        SELECT 1 FROM notifications 
                        WHERE recipient_id = admin_user_id 
                        AND type = 'experience_submitted'
                        AND message LIKE '%' || COALESCE(NEW.role, 'Experience') || '%'
                        AND message LIKE '%' || COALESCE(NEW.organization, 'Organization') || '%'
                        AND created_at > NOW() - INTERVAL '1 hour'
                    ) THEN
                        INSERT INTO notifications (recipient_id, type, title, message, read)
                        VALUES (
                            admin_user_id,
                            'experience_submitted',
                            'External Experience Submitted',
                            COALESCE(student_name, 'Student') || ' from ' || 
                            COALESCE(student_school_name, 'School') || ' submitted "' || 
                            COALESCE(NEW.role, 'Experience') || ' at ' || 
                            COALESCE(NEW.organization, 'Organization') || '" for approval',
                            false
                        );
                    END IF;
                END IF;
            END IF;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_admin_training_submission()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    admin_user_id UUID;
    student_name TEXT;
    student_school_id UUID;
BEGIN
    -- Only create notification for new trainings with pending status
    IF TG_OP = 'INSERT' AND NEW.approval_status = 'pending' THEN
        -- Get student details
        SELECT s.name, s.school_id INTO student_name, student_school_id
        FROM students s 
        WHERE s.user_id = NEW.student_id;
        
        -- If student has a school, find the school admin
        IF student_school_id IS NOT NULL THEN
            SELECT se.user_id INTO admin_user_id
            FROM school_educators se
            WHERE se.school_id = student_school_id 
            AND se.role = 'admin'
            LIMIT 1;
            
            -- Create notification for school admin
            IF admin_user_id IS NOT NULL THEN
                INSERT INTO notifications (recipient_id, type, title, message, read)
                VALUES (
                    admin_user_id,
                    'training_submitted',
                    'New Training Submitted',
                    COALESCE(student_name, 'Student') || ' submitted "' || 
                    COALESCE(NEW.title, 'Training') || '" for approval',
                    false
                );
            END IF;
        ELSE
            -- If no school admin found, notify super admin
            SELECT u.id INTO admin_user_id
            FROM users u
            WHERE u.role = 'super_admin'
            LIMIT 1;
            
            IF admin_user_id IS NOT NULL THEN
                INSERT INTO notifications (recipient_id, type, title, message, read)
                VALUES (
                    admin_user_id,
                    'training_submitted',
                    'New Training Submitted',
                    COALESCE(student_name, 'Student') || ' submitted "' || 
                    COALESCE(NEW.title, 'Training') || '" for approval',
                    false
                );
            END IF;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_experience_submission()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    student_record record;
    notification_message text;
    recipient_school_id uuid;
BEGIN
    -- Get student and school details
    SELECT s.*, o.name as school_name, o.id as school_id
    INTO student_record
    FROM public.students s
    LEFT JOIN public.organizations o ON s.school_id = o.id
    WHERE s.id = NEW.student_id;
    
    -- Create notification message
    notification_message := format(
        'New experience submitted by %s: "%s" at %s',
        COALESCE(student_record.name, 'Student'),
        COALESCE(NEW.role, 'Position'),
        COALESCE(NEW.organization, 'Unknown Organization')
    );
    
    -- Determine recipient school ID
    IF NEW.approval_authority IN ('school_admin', 'college_admin') THEN
        recipient_school_id := student_record.school_id;
    ELSE
        recipient_school_id := NULL; -- For rareminds_admin
    END IF;
    
    -- Insert notification
    INSERT INTO public.training_notifications (
        experience_id,
        recipient_type,
        school_id,
        message
    ) VALUES (
        NEW.id,
        NEW.approval_authority,
        recipient_school_id,
        notification_message
    );
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_project_approval()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    student_record RECORD;
    notification_message TEXT;
    target_school_id UUID;
    target_college_id UUID;
BEGIN
    -- Only create notifications for pending status
    IF NEW.approval_status != 'pending' THEN
        RETURN NEW;
    END IF;

    -- Get student and school/college information from organizations table
    SELECT 
        s.id as student_id,
        s.student_type,
        s.school_id,
        s.college_id,
        s.university_college_id,
        COALESCE(s.name, p.name) as student_name,
        sch.id as school_uuid,
        col.id as college_uuid
    INTO student_record
    FROM students s
    LEFT JOIN students p ON s.id = p.id  -- For profile name fallback
    LEFT JOIN organizations sch ON s.school_id = sch.id AND sch.organization_type = 'school'
    LEFT JOIN organizations col ON (s.college_id = col.id OR s.university_college_id = col.id) AND col.organization_type = 'college'
    WHERE s.id = NEW.student_id;

    IF NOT FOUND THEN
        RETURN NEW;
    END IF;

    -- Prepare notification message
    notification_message := format(
        'New project "%s" submitted by %s for approval (Organization: %s)',
        NEW.title,
        COALESCE(student_record.student_name, 'Student'),
        COALESCE(NEW.organization, 'Not specified')
    );

    -- Determine target school/college based on approval authority
    IF NEW.approval_authority = 'school_admin' THEN
        target_school_id := student_record.school_uuid;
        target_college_id := NULL;
    ELSIF NEW.approval_authority = 'college_admin' THEN
        target_school_id := NULL;
        target_college_id := student_record.college_uuid;
    ELSE
        -- For rareminds_admin, we don't create notifications in this table
        RETURN NEW;
    END IF;

    -- Insert notification
    INSERT INTO project_notifications (
        project_id,
        recipient_type,
        school_id,
        college_id,
        message,
        is_read,
        created_at
    ) VALUES (
        NEW.id,
        NEW.approval_authority,
        target_school_id,
        target_college_id,
        notification_message,
        FALSE,
        NOW()
    );

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_project_approval_unified()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    student_record RECORD;
    notification_message TEXT;
    target_school_id UUID;
    target_college_id UUID;
BEGIN
    -- Only create notifications for pending status
    IF NEW.approval_status != 'pending' THEN
        RETURN NEW;
    END IF;

    -- Get student and school/college information from organizations table
    SELECT 
        s.id as student_id,
        s.student_type,
        s.school_id,
        s.college_id,
        s.university_college_id,
        COALESCE(s.name, sp.name) as student_name,
        sch.id as school_uuid,
        col.id as college_uuid
    INTO student_record
    FROM students s
    LEFT JOIN students sp ON s.id = sp.id  -- For profile name fallback
    LEFT JOIN organizations sch ON s.school_id = sch.id AND sch.organization_type = 'school'
    LEFT JOIN organizations col ON (s.college_id = col.id OR s.university_college_id = col.id) AND col.organization_type = 'college'
    WHERE s.id = NEW.student_id;

    IF NOT FOUND THEN
        RETURN NEW;
    END IF;

    -- Prepare notification message
    notification_message := format(
        'New project "%s" submitted by %s for approval (Organization: %s)',
        NEW.title,
        COALESCE(student_record.student_name, 'Student'),
        COALESCE(NEW.organization, 'Not specified')
    );

    -- Determine target school/college based on approval authority
    IF NEW.approval_authority = 'school_admin' THEN
        target_school_id := student_record.school_uuid;
        target_college_id := NULL;
    ELSIF NEW.approval_authority = 'college_admin' THEN
        target_school_id := NULL;
        target_college_id := student_record.college_uuid;
    ELSE
        -- For rareminds_admin, we don't create notifications in this table
        RETURN NEW;
    END IF;

    -- Insert notification into training_notifications table (unified)
    INSERT INTO training_notifications (
        project_id,
        recipient_type,
        school_id,
        college_id,
        message,
        is_read,
        created_at
    ) VALUES (
        NEW.id,
        NEW.approval_authority,
        target_school_id,
        target_college_id,
        notification_message,
        FALSE,
        NOW()
    );

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_students_new_opportunity()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_notification_title TEXT;
  v_notification_message TEXT;
  v_is_internship BOOLEAN;
BEGIN
  -- Only process if the opportunity is active
  IF NEW.is_active IS NOT TRUE THEN
    RETURN NEW;
  END IF;

  -- Check if this is an internship opportunity
  v_is_internship := LOWER(COALESCE(NEW.employment_type, '')) = 'internship';

  -- Build notification content
  v_notification_title := NEW.job_title || ' at ' || NEW.company_name;
  v_notification_message := NEW.title || ' - ' || NEW.location || 
    CASE 
      WHEN NEW.salary_range_min IS NOT NULL AND NEW.salary_range_max IS NOT NULL 
        THEN ' | ' || NEW.salary_range_min || ' - ' || NEW.salary_range_max
      ELSE ''
    END;

  -- Create notifications for matching students based on their type
  -- School students: only receive notifications for internships
  -- College/University students: receive notifications for all opportunities
  INSERT INTO notifications (recipient_id, type, title, message, read, created_at)
  SELECT DISTINCT
    s.user_id,
    'new_opportunity'::text,
    v_notification_title,
    v_notification_message,
    false,
    NOW()
  FROM students s
  INNER JOIN users u ON s.user_id = u.id
  WHERE u.role IN ('school_student', 'college_student')
    AND s.id IS NOT NULL
    AND (
      -- College/University students get all opportunities
      (u.role = 'college_student')
      OR
      -- School students only get internship opportunities
      (u.role = 'school_student' AND v_is_internship)
    )
  ON CONFLICT DO NOTHING;

  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  RAISE WARNING 'Error in notify_students_new_opportunity: %', SQLERRM;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_students_opportunity_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_notification_title TEXT;
  v_notification_message TEXT;
BEGIN
  -- Check if opportunity became inactive
  IF OLD.is_active IS DISTINCT FROM NEW.is_active THEN
    IF NEW.is_active IS FALSE THEN
      v_notification_title := 'Opportunity Closed: ' || NEW.job_title;
      v_notification_message := 'The position at ' || NEW.company_name || ' is no longer available.';
      
      -- Create notifications for students who applied
      INSERT INTO notifications (recipient_id, type, title, message, read, created_at)
      SELECT DISTINCT
        aj.student_id,
        'opportunity_closed'::text,
        v_notification_title,
        v_notification_message,
        false,
        NOW()
      FROM applied_jobs aj
      WHERE aj.opportunity_id = NEW.id
        AND aj.student_id IS NOT NULL
      ON CONFLICT DO NOTHING;
    END IF;
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_training_submission()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    student_record RECORD;
    notification_message TEXT;
BEGIN
    -- Get student information from students table only
    SELECT s.*
    INTO student_record
    FROM students s
    WHERE s.id = NEW.student_id;
    
    IF NOT FOUND THEN
        RETURN NEW;
    END IF;
    
    -- Create notification message
    notification_message := format(
        'New training "%s" by %s (%s) requires approval',
        NEW.title,
        COALESCE(student_record.name, 'Unknown Student'),
        COALESCE(student_record.email, 'No email')
    );
    
    -- Insert into training_notifications table
    INSERT INTO training_notifications (
        training_id,
        recipient_type,
        school_id,
        message,
        is_read,
        created_at
    ) VALUES (
        NEW.id,
        NEW.approval_authority,
        student_record.school_id,
        notification_message,
        false,
        NOW()
    );
    
    RETURN NEW;
EXCEPTION WHEN OTHERS THEN
    -- If notification fails, don't block the training insertion
    RAISE WARNING 'Failed to create training notification: %', SQLERRM;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.on_timetable_slot_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  PERFORM calculate_teacher_workload(
    COALESCE(NEW.educator_id, OLD.educator_id),
    COALESCE(NEW.timetable_id, OLD.timetable_id)
  );
  
  PERFORM detect_timetable_conflicts(COALESCE(NEW.timetable_id, OLD.timetable_id));
  
  RETURN COALESCE(NEW, OLD);
END;
$function$
;

create or replace view "public"."overdue_books" as  SELECT lbi.id,
    lbi.book_id,
    lbi.student_id,
    lbi.student_name,
    lbi.roll_number,
    lbi.class,
    lbi.academic_year,
    lbi.issue_date,
    lbi.due_date,
    lbi.return_date,
    lbi.status,
    lbi.fine_amount,
    lbi.fine_paid,
    lbi.remarks,
    lbi.issued_by,
    lbi.returned_by,
    lbi.created_at,
    lbi.updated_at,
    lb.title,
    lb.author,
    lb.isbn,
    public.calculate_fine(lbi.issue_date, CURRENT_DATE) AS current_fine,
    (CURRENT_DATE - lbi.due_date) AS days_overdue
   FROM (public.library_book_issues lbi
     JOIN public.library_books lb ON ((lbi.book_id = lb.id)))
  WHERE ((lbi.status = 'issued'::text) AND (lbi.due_date < CURRENT_DATE));


create or replace view "public"."overdue_books_college" as  SELECT lbi.id,
    lbi.college_id,
    lbi.book_id,
    lbi.student_id,
    lbi.student_name,
    lbi.roll_number,
    lbi.class,
    lbi.academic_year,
    lbi.issue_date,
    lbi.due_date,
    lbi.return_date,
    lbi.status,
    lbi.fine_amount,
    lbi.fine_paid,
    lbi.remarks,
    lbi.issued_by,
    lbi.returned_by,
    lbi.created_at,
    lbi.updated_at,
    lb.title,
    lb.author,
    lb.isbn,
    public.calculate_fine_college(lbi.college_id, lbi.issue_date, CURRENT_DATE) AS current_fine,
    (CURRENT_DATE - lbi.due_date) AS days_overdue
   FROM (public.library_book_issues_college lbi
     JOIN public.library_books_college lb ON ((lbi.book_id = lb.id)))
  WHERE ((lbi.status = 'issued'::text) AND (lbi.due_date < CURRENT_DATE));


create or replace view "public"."overdue_books_school" as  SELECT lbi.id,
    lbi.school_id,
    lbi.book_id,
    lbi.student_id,
    lbi.student_name,
    lbi.roll_number,
    lbi.class,
    lbi.academic_year,
    lbi.issue_date,
    lbi.due_date,
    lbi.return_date,
    lbi.status,
    lbi.fine_amount,
    lbi.fine_paid,
    lbi.remarks,
    lbi.issued_by,
    lbi.returned_by,
    lbi.created_at,
    lbi.updated_at,
    lb.title,
    lb.author,
    lb.isbn,
    public.calculate_fine_school(lbi.school_id, lbi.issue_date, CURRENT_DATE) AS current_fine,
    (CURRENT_DATE - lbi.due_date) AS days_overdue
   FROM (public.library_book_issues_school lbi
     JOIN public.library_books_school lb ON ((lbi.book_id = lb.id)))
  WHERE ((lbi.status = 'issued'::text) AND (lbi.due_date < CURRENT_DATE));


CREATE OR REPLACE FUNCTION public.parse_experience_years(experience_text text)
 RETURNS integer
 LANGUAGE plpgsql
 IMMUTABLE
 SET search_path TO ''
AS $function$
DECLARE
  years INT;
  exp_lower TEXT;
BEGIN
  IF experience_text IS NULL OR experience_text = '' THEN
    RETURN 0;
  END IF;
  
  exp_lower := LOWER(experience_text);
  
  -- Handle "Fresher" or "No experience"
  IF exp_lower ~ '(fresher|no\s*experience|entry|beginner|0\s*year|none)' THEN
    RETURN 0;
  END IF;
  
  -- Handle "15 years+" or "15+ years"
  IF exp_lower ~ '(\d+)\s*\+?\s*year' THEN
    SELECT (regexp_matches(exp_lower, '(\d+)'))[1]::INT INTO years;
    RETURN COALESCE(years, 0);
  END IF;
  
  -- Handle "1-3 years" - take the minimum
  IF exp_lower ~ '(\d+)\s*[-]\s*(\d+)' THEN
    SELECT (regexp_matches(exp_lower, '(\d+)'))[1]::INT INTO years;
    RETURN COALESCE(years, 0);
  END IF;
  
  -- Handle just a number like "2"
  IF exp_lower ~ '^\d+$' THEN
    RETURN exp_lower::INT;
  END IF;
  
  RETURN 0;
END;
$function$
;

create or replace view "public"."pending_scorecards" as  SELECT i.id,
    i.student_id,
    i.candidate_name,
    i.candidate_email,
    i.candidate_phone,
    i.job_title,
    i.interviewer,
    i.interviewer_email,
    i.date,
    i.duration,
    i.status,
    i.type,
    i.meeting_type,
    i.meeting_link,
    i.meeting_notes,
    i.reminders_sent,
    i.completed_date,
    i.scorecard,
    i.created_by,
    i.created_at,
    i.updated_at,
    s.name AS student_name,
    s.branch_field AS department
   FROM (public.interviews i
     LEFT JOIN public.students s ON ((i.student_id = s.id)))
  WHERE ((i.status = 'completed'::text) AND ((i.scorecard IS NULL) OR ((i.scorecard ->> 'overall_rating'::text) IS NULL)))
  ORDER BY i.completed_date DESC;


create or replace view "public"."pipeline_candidates_detailed" as  SELECT pc.id,
    pc.opportunity_id,
    pc.student_id,
    pc.candidate_name,
    pc.candidate_email,
    pc.candidate_phone,
    pc.stage,
    pc.previous_stage,
    pc.status,
    pc.source,
    pc.recruiter_rating,
    pc.recruiter_notes,
    pc.next_action,
    pc.next_action_date,
    pc.next_action_notes,
    pc.rejection_reason,
    pc.rejection_date,
    pc.assigned_to,
    pc.added_at,
    pc.updated_at,
    pc.added_by,
    pc.stage_changed_at,
    pc.stage_changed_by,
    s.name AS student_name,
    s.email AS student_email,
    s.contact_number AS student_phone,
    s.university AS student_university,
    s.branch_field AS student_department,
    s.course_name AS student_course,
    s.college_school_name AS student_college,
    s.district_name AS student_location,
    o.job_title AS opportunity_title,
    o.company_name,
    o.location AS opportunity_location,
    o.employment_type,
    o.experience_level
   FROM ((public.pipeline_candidates pc
     LEFT JOIN public.students s ON ((pc.student_id = s.id)))
     LEFT JOIN public.opportunities o ON ((pc.opportunity_id = o.id)))
  WHERE (pc.status = 'active'::text);


CREATE OR REPLACE FUNCTION public.populate_chapter_name()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Auto-populate chapter_name when chapter_id is set
  IF NEW.chapter_id IS NOT NULL THEN
    SELECT name INTO NEW.chapter_name
    FROM curriculum_chapters
    WHERE id = NEW.chapter_id;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.populate_result_columns_from_gemini()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only populate if gemini_results exists and individual columns are null
  IF NEW.gemini_results IS NOT NULL THEN
    -- RIASEC
    IF NEW.riasec_scores IS NULL AND NEW.gemini_results->'riasec'->'scores' IS NOT NULL THEN
      NEW.riasec_scores := NEW.gemini_results->'riasec'->'scores';
    END IF;
    IF NEW.riasec_code IS NULL AND NEW.gemini_results->'riasec'->>'code' IS NOT NULL THEN
      NEW.riasec_code := NEW.gemini_results->'riasec'->>'code';
    END IF;
    
    -- Aptitude
    IF NEW.aptitude_scores IS NULL AND NEW.gemini_results->'aptitude'->'scores' IS NOT NULL THEN
      NEW.aptitude_scores := NEW.gemini_results->'aptitude'->'scores';
    END IF;
    IF NEW.aptitude_overall IS NULL AND NEW.gemini_results->'aptitude'->>'overallScore' IS NOT NULL THEN
      NEW.aptitude_overall := (NEW.gemini_results->'aptitude'->>'overallScore')::numeric;
    END IF;
    
    -- BigFive
    IF NEW.bigfive_scores IS NULL AND NEW.gemini_results->'bigFive' IS NOT NULL THEN
      NEW.bigfive_scores := NEW.gemini_results->'bigFive';
    END IF;
    
    -- Work Values
    IF NEW.work_values_scores IS NULL AND NEW.gemini_results->'workValues'->'scores' IS NOT NULL THEN
      NEW.work_values_scores := NEW.gemini_results->'workValues'->'scores';
    END IF;
    
    -- Employability
    IF NEW.employability_scores IS NULL AND NEW.gemini_results->'employability'->'skillScores' IS NOT NULL THEN
      NEW.employability_scores := NEW.gemini_results->'employability'->'skillScores';
    END IF;
    IF NEW.employability_readiness IS NULL AND NEW.gemini_results->'employability'->>'overallReadiness' IS NOT NULL THEN
      NEW.employability_readiness := NEW.gemini_results->'employability'->>'overallReadiness';
    END IF;
    
    -- Knowledge
    IF NEW.knowledge_score IS NULL AND NEW.gemini_results->'knowledge'->>'score' IS NOT NULL THEN
      NEW.knowledge_score := (NEW.gemini_results->'knowledge'->>'score')::numeric;
    END IF;
    IF NEW.knowledge_details IS NULL AND NEW.gemini_results->'knowledge' IS NOT NULL THEN
      NEW.knowledge_details := NEW.gemini_results->'knowledge';
    END IF;
    
    -- Career guidance
    IF NEW.career_fit IS NULL AND NEW.gemini_results->'careerFit' IS NOT NULL THEN
      NEW.career_fit := NEW.gemini_results->'careerFit';
    END IF;
    IF NEW.skill_gap IS NULL AND NEW.gemini_results->'skillGap' IS NOT NULL THEN
      NEW.skill_gap := NEW.gemini_results->'skillGap';
    END IF;
    IF NEW.skill_gap_courses IS NULL AND NEW.gemini_results->'skillGapCourses' IS NOT NULL THEN
      NEW.skill_gap_courses := NEW.gemini_results->'skillGapCourses';
    END IF;
    IF NEW.roadmap IS NULL AND NEW.gemini_results->'roadmap' IS NOT NULL THEN
      NEW.roadmap := NEW.gemini_results->'roadmap';
    END IF;
    IF NEW.profile_snapshot IS NULL AND NEW.gemini_results->'profileSnapshot' IS NOT NULL THEN
      NEW.profile_snapshot := NEW.gemini_results->'profileSnapshot';
    END IF;
    IF NEW.timing_analysis IS NULL AND NEW.gemini_results->'timingAnalysis' IS NOT NULL THEN
      NEW.timing_analysis := NEW.gemini_results->'timingAnalysis';
    END IF;
    IF NEW.final_note IS NULL AND NEW.gemini_results->'finalNote' IS NOT NULL THEN
      NEW.final_note := NEW.gemini_results->'finalNote';
    END IF;
    IF NEW.overall_summary IS NULL AND NEW.gemini_results->>'overallSummary' IS NOT NULL THEN
      NEW.overall_summary := NEW.gemini_results->>'overallSummary';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.process_assessment_reminders()
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
    reminder_record RECORD;
    assessment_data RECORD;
    priority_a_courses TEXT[] := '{}';
    priority_b_courses TEXT[] := '{}';
    priority_a_completed BOOLEAN := true;
    priority_b_completed BOOLEAN := true;
    course_id TEXT;
    notifications_sent INTEGER := 0;
    skill_item JSONB;
    course_item JSONB;
    priority_skills JSONB;
    skill_gap_courses JSONB;
    course_recommendations TEXT := '';
BEGIN
    -- Process all scheduled notifications that are due
    FOR reminder_record IN 
        SELECT * FROM notifications 
        WHERE status = 'scheduled' 
        AND type = 'assessment_6month_reminder'
        AND scheduled_for <= NOW()
    LOOP
        -- Get assessment data
        SELECT * INTO assessment_data 
        FROM personal_assessment_results 
        WHERE id = reminder_record.assessment_id;
        
        IF NOT FOUND THEN
            -- Mark as cancelled if assessment not found
            UPDATE notifications 
            SET status = 'cancelled', updated_at = NOW()
            WHERE id = reminder_record.id;
            CONTINUE;
        END IF;

        -- Reset arrays for this assessment
        priority_a_courses := '{}';
        priority_b_courses := '{}';
        priority_a_completed := true;
        priority_b_completed := true;

        -- Collect Priority A courses
        IF assessment_data.skill_gap ? 'priorityA' THEN
            priority_skills := assessment_data.skill_gap->'priorityA';
            
            FOR skill_item IN SELECT * FROM jsonb_array_elements(priority_skills)
            LOOP
                IF assessment_data.skill_gap_courses ? (skill_item->>'skill') THEN
                    skill_gap_courses := assessment_data.skill_gap_courses->(skill_item->>'skill');
                    
                    FOR course_item IN SELECT * FROM jsonb_array_elements(skill_gap_courses)
                    LOOP
                        priority_a_courses := priority_a_courses || (course_item->>'course_id');
                    END LOOP;
                END IF;
            END LOOP;
        END IF;

        -- Check Priority A completion status
        IF array_length(priority_a_courses, 1) > 0 THEN
            FOREACH course_id IN ARRAY priority_a_courses
            LOOP
                -- Check if student has completed this course
                IF NOT EXISTS (
                    SELECT 1 FROM course_progress cp
                    WHERE cp.student_id = reminder_record.recipient_id
                    AND cp.course_id::TEXT = course_id
                    AND cp.completion_percentage = 100
                ) THEN
                    priority_a_completed := false;
                    EXIT; -- Exit loop early if any Priority A course is incomplete
                END IF;
            END LOOP;
        END IF;

        -- If Priority A is not completed, cancel notification (student should focus on Priority A first)
        IF NOT priority_a_completed THEN
            UPDATE notifications 
            SET status = 'cancelled', 
                message = 'Cancelled: Priority A skills still need attention',
                updated_at = NOW()
            WHERE id = reminder_record.id;
            CONTINUE;
        END IF;

        -- Collect Priority B courses
        IF assessment_data.skill_gap ? 'priorityB' THEN
            priority_skills := assessment_data.skill_gap->'priorityB';
            
            FOR skill_item IN SELECT * FROM jsonb_array_elements(priority_skills)
            LOOP
                IF assessment_data.skill_gap_courses ? (skill_item->>'skill') THEN
                    skill_gap_courses := assessment_data.skill_gap_courses->(skill_item->>'skill');
                    
                    FOR course_item IN SELECT * FROM jsonb_array_elements(skill_gap_courses)
                    LOOP
                        priority_b_courses := priority_b_courses || (course_item->>'course_id');
                        
                        -- Build course recommendations message
                        IF course_recommendations != '' THEN
                            course_recommendations := course_recommendations || ', ';
                        END IF;
                        course_recommendations := course_recommendations || (course_item->>'title');
                    END LOOP;
                END IF;
            END LOOP;
        END IF;

        -- Check Priority B completion status
        IF array_length(priority_b_courses, 1) > 0 THEN
            FOREACH course_id IN ARRAY priority_b_courses
            LOOP
                -- Check if student has completed this course
                IF NOT EXISTS (
                    SELECT 1 FROM course_progress cp
                    WHERE cp.student_id = reminder_record.recipient_id
                    AND cp.course_id::TEXT = course_id
                    AND cp.completion_percentage = 100
                ) THEN
                    priority_b_completed := false;
                    EXIT; -- Exit loop early if any Priority B course is incomplete
                END IF;
            END LOOP;
        END IF;

        -- If Priority B is completed, cancel notification (all skills developed)
        IF priority_b_completed THEN
            UPDATE notifications 
            SET status = 'cancelled', 
                message = 'Cancelled: All priority skills have been developed',
                updated_at = NOW()
            WHERE id = reminder_record.id;
            CONTINUE;
        END IF;

        -- Send Priority B course recommendations
        UPDATE notifications 
        SET status = 'sent',
            title = 'Time to Develop Your Priority B Skills!',
            message = FORMAT('Great progress on your Priority A skills! Now it''s time to focus on Priority B skills. We recommend these courses: %s. These will help you advance further in your career journey.',
                COALESCE(course_recommendations, 'your recommended courses')),
            updated_at = NOW()
        WHERE id = reminder_record.id;

        notifications_sent := notifications_sent + 1;
    END LOOP;

    RETURN notifications_sent;
END;
$function$
;

create or replace view "public"."program_sections_view" as  SELECT ps.id,
    ps.department_id,
    d.name AS department_name,
    ps.program_id,
    p.name AS program_name,
    p.code AS program_code,
    ps.semester,
    ps.section,
    ps.academic_year,
    ps.max_students,
    ps.current_students,
    ps.faculty_id,
    COALESCE((((u."firstName")::text || ' '::text) || (u."lastName")::text), u.email) AS faculty_name,
    ps.status,
    ps.created_at,
    ps.updated_at
   FROM (((public.program_sections ps
     LEFT JOIN public.departments d ON ((ps.department_id = d.id)))
     LEFT JOIN public.programs p ON ((ps.program_id = p.id)))
     LEFT JOIN public.users u ON ((ps.faculty_id = u.id)))
  ORDER BY d.name, p.name, ps.semester, ps.section;


CREATE OR REPLACE FUNCTION public.queue_embedding_generation(p_record_id uuid, p_table_name text, p_operation text DEFAULT 'update'::text, p_priority integer DEFAULT 5)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_queue_id UUID;
BEGIN
  SELECT id INTO v_queue_id FROM embedding_queue
  WHERE record_id = p_record_id AND table_name = p_table_name AND status = 'pending';
  
  IF v_queue_id IS NOT NULL THEN
    UPDATE embedding_queue SET priority = GREATEST(priority, p_priority), operation = p_operation WHERE id = v_queue_id;
    RETURN v_queue_id;
  END IF;
  
  INSERT INTO embedding_queue (record_id, table_name, operation, priority, status)
  VALUES (p_record_id, p_table_name, p_operation, p_priority, 'pending')
  ON CONFLICT (record_id, table_name, status) DO UPDATE
  SET priority = GREATEST(embedding_queue.priority, EXCLUDED.priority), operation = EXCLUDED.operation
  RETURNING id INTO v_queue_id;
  
  RETURN v_queue_id;
END;
$function$
;

create or replace view "public"."requisitions_with_pipeline_stats" as  SELECT r.id,
    r.title,
    r.department,
    r.location,
    r.job_type,
    r.openings,
    r.status,
    r.priority,
    r.description,
    r.requirements,
    r.salary_range,
    r.owner,
    r.hiring_manager,
    r.created_by,
    r.created_date,
    r.target_date,
    r.filled_date,
    r.tags,
    r.created_at,
    r.updated_at,
    count(pc.id_old) AS total_candidates,
    count(
        CASE
            WHEN (pc.stage = 'sourced'::text) THEN 1
            ELSE NULL::integer
        END) AS sourced_count,
    count(
        CASE
            WHEN (pc.stage = 'screened'::text) THEN 1
            ELSE NULL::integer
        END) AS screened_count,
    count(
        CASE
            WHEN (pc.stage = 'interview_1'::text) THEN 1
            ELSE NULL::integer
        END) AS interview_1_count,
    count(
        CASE
            WHEN (pc.stage = 'interview_2'::text) THEN 1
            ELSE NULL::integer
        END) AS interview_2_count,
    count(
        CASE
            WHEN (pc.stage = 'offer'::text) THEN 1
            ELSE NULL::integer
        END) AS offer_count,
    count(
        CASE
            WHEN (pc.stage = 'hired'::text) THEN 1
            ELSE NULL::integer
        END) AS hired_count
   FROM (public.requisitions r
     LEFT JOIN public.pipeline_candidates pc ON ((r.id_uuid = pc.requisition_id)))
  GROUP BY r.id, r.title, r.department, r.location, r.job_type, r.openings, r.status, r.priority, r.description, r.requirements, r.salary_range, r.owner, r.hiring_manager, r.created_by, r.created_date, r.target_date, r.filled_date, r.tags, r.created_at, r.updated_at;


CREATE OR REPLACE FUNCTION public.reset_attempt_on_result_delete()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- When a result is deleted, reset the associated attempt to 'in_progress'
  UPDATE personal_assessment_attempts
  SET 
    status = 'in_progress',
    completed_at = NULL,
    updated_at = NOW()
  WHERE id = OLD.attempt_id
    AND status = 'completed'; -- Only reset if it was completed
  
  -- Log the action
  RAISE NOTICE 'Result deleted for attempt %. Attempt reset to in_progress.', OLD.attempt_id;
  
  RETURN OLD;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reset_daily_streak_flags()
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_updated_count INTEGER;
BEGIN
  -- Reset all flags
  UPDATE student_streaks
  SET streak_completed_today = FALSE
  WHERE streak_completed_today = TRUE;

  GET DIAGNOSTICS v_updated_count = ROW_COUNT;

  -- Check for broken streaks (no activity yesterday)
  UPDATE student_streaks
  SET current_streak = 0
  WHERE last_activity_date < CURRENT_DATE - INTERVAL '1 day'
    AND current_streak > 0;

  RETURN v_updated_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reset_enrollment_progress(p_student_email text, p_course_id uuid)
 RETURNS TABLE(enrollment_id uuid, student_email text, course_title text, new_status text, training_synced boolean)
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_enrollment_id UUID;
    v_course_title TEXT;
    v_training_id UUID;
BEGIN
    -- Get enrollment details
    SELECT ce.id, ce.course_title, ce.training_id
    INTO v_enrollment_id, v_course_title, v_training_id
    FROM course_enrollments ce
    WHERE ce.student_email = p_student_email
    AND ce.course_id = p_course_id;
    
    IF v_enrollment_id IS NULL THEN
        RAISE EXCEPTION 'No enrollment found for % in course %', p_student_email, p_course_id;
    END IF;
    
    -- Reset the enrollment (triggers will handle the rest)
    UPDATE course_enrollments
    SET 
        progress = 0,
        status = 'enrolled',
        completed_lessons = ARRAY[]::text[],
        completed_at = NULL,
        last_accessed = NOW(),
        last_module_index = 0,
        last_lesson_index = 0,
        last_lesson_id = NULL,
        last_video_position = 0,
        total_time_spent_seconds = 0,
        sessions_count = 0,
        average_session_duration = 0,
        skills_acquired = '[]'::jsonb,
        certificate_url = NULL,
        grade = NULL,
        updated_at = NOW()
    WHERE id = v_enrollment_id;
    
    RETURN QUERY
    SELECT 
        v_enrollment_id,
        p_student_email,
        v_course_title,
        'enrolled'::TEXT,
        (v_training_id IS NOT NULL);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reset_quiz_progress_on_enrollment_reset()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- If progress is reset to 0 and completed_lessons is empty, delete quiz progress
    IF NEW.progress = 0 AND (NEW.completed_lessons IS NULL OR array_length(NEW.completed_lessons, 1) IS NULL) THEN
        DELETE FROM student_quiz_progress
        WHERE student_id = NEW.student_id
        AND course_id = NEW.course_id;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.reset_unread_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    unread_count INTEGER;
    conv_id TEXT;
BEGIN
    -- Get conversation_id from NEW (for INSERT/UPDATE) or OLD (for DELETE)
    IF TG_OP = 'DELETE' THEN
        conv_id := OLD.conversation_id;
    ELSE
        conv_id := NEW.conversation_id;
    END IF;

    -- Count unread messages for student
    SELECT COUNT(*) INTO unread_count
    FROM messages
    WHERE conversation_id = conv_id
        AND receiver_type = 'student'
        AND is_read = false;
    
    -- Update student unread count
    UPDATE conversations
    SET student_unread_count = unread_count
    WHERE id = conv_id;

    -- Count unread messages for recruiter
    SELECT COUNT(*) INTO unread_count
    FROM messages
    WHERE conversation_id = conv_id
        AND receiver_type = 'recruiter'
        AND is_read = false;
    
    -- Update recruiter unread count
    UPDATE conversations
    SET recruiter_unread_count = unread_count
    WHERE id = conv_id;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.review_curriculum(p_curriculum_id uuid, p_decision text, p_notes text DEFAULT NULL::text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_user_id UUID;
    v_curriculum RECORD;
    v_new_status TEXT;
BEGIN
    -- Get current user ID
    v_user_id := auth.uid();
    
    -- Validate decision
    IF p_decision NOT IN ('approved', 'rejected') THEN
        RAISE EXCEPTION 'Invalid decision. Must be approved or rejected';
    END IF;
    
    -- Get curriculum info (using existing status column)
    SELECT * INTO v_curriculum
    FROM college_curriculums 
    WHERE id = p_curriculum_id
    AND status = 'pending_approval';
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Curriculum not found or not pending approval';
    END IF;
    
    -- Check if user is university admin for this curriculum
    IF NOT EXISTS (
        SELECT 1 FROM users 
        WHERE id = v_user_id 
        AND role = 'university_admin'
        AND "organizationId" = v_curriculum.university_id
    ) THEN
        RAISE EXCEPTION 'Access denied. University admin role required';
    END IF;
    
    -- Set new status (auto-publish on approval, no intermediate 'approved' status)
    v_new_status := CASE 
        WHEN p_decision = 'approved' THEN 'published'  -- Auto-publish on approval
        ELSE 'rejected'
    END;
    
    -- Update curriculum (using existing status column)
    UPDATE college_curriculums 
    SET 
        status = v_new_status,  -- Use existing status column
        reviewed_by = v_user_id,
        review_date = NOW(),
        review_notes = p_notes,
        published_date = CASE WHEN p_decision = 'approved' THEN NOW() ELSE NULL END
    WHERE id = p_curriculum_id;
    
    -- Create notification for requester (only if notifications table exists)
    IF to_regclass('public.notifications') IS NOT NULL THEN
        INSERT INTO notifications (
            recipient_id,
            title,
            message,
            type,
            metadata
        )
        VALUES (
            v_curriculum.requested_by,
            CASE 
                WHEN p_decision = 'approved' THEN 'Curriculum Approved and Published'
                ELSE 'Curriculum Approval Rejected'
            END,
            CASE 
                WHEN p_decision = 'approved' THEN 'Your curriculum has been approved and is now published'
                ELSE 'Your curriculum approval request has been rejected. Please review the feedback and resubmit.'
            END,
            CASE 
                WHEN p_decision = 'approved' THEN 'curriculum_approved'
                ELSE 'curriculum_rejected'
            END,
            jsonb_build_object(
                'curriculum_id', p_curriculum_id,
                'decision', p_decision,
                'notes', p_notes,
                'reviewer_id', v_user_id
            )
        );
    END IF;
    
    RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.save_job_matches_cache(p_student_id uuid, p_matches jsonb, p_algorithm_version character varying DEFAULT 'v1.0'::character varying)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_profile_hash VARCHAR(64);
BEGIN
    -- Get current profile hash
    v_profile_hash := compute_student_profile_hash(p_student_id);
    
    -- Upsert the cache entry
    INSERT INTO student_job_matches (
        student_id,
        matches,
        match_count,
        algorithm_version,
        student_profile_hash,
        is_valid,
        invalidation_reason,
        computed_at,
        expires_at,
        created_at,
        updated_at
    ) VALUES (
        p_student_id,
        p_matches,
        jsonb_array_length(p_matches),
        p_algorithm_version,
        v_profile_hash,
        true,
        NULL,
        NOW(),
        NOW() + INTERVAL '24 hours',
        NOW(),
        NOW()
    )
    ON CONFLICT (student_id) DO UPDATE SET
        matches = EXCLUDED.matches,
        match_count = EXCLUDED.match_count,
        algorithm_version = EXCLUDED.algorithm_version,
        student_profile_hash = EXCLUDED.student_profile_hash,
        is_valid = true,
        invalidation_reason = NULL,
        computed_at = NOW(),
        expires_at = NOW() + INTERVAL '24 hours',
        updated_at = NOW();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.schedule_assessment_reminder()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    skill_item JSONB;
    course_item JSONB;
    priority_skills JSONB;
    skill_gap_courses JSONB;
    course_titles TEXT[] := '{}';
    priority_a_courses TEXT[] := '{}';
    priority_b_courses TEXT[] := '{}';
    student_user_id UUID;
BEGIN
    -- Only process completed assessments
    IF NEW.status != 'completed' THEN
        RETURN NEW;
    END IF;

    -- Get the student's user_id for notifications (since notifications.recipient_id references users.id)
    SELECT user_id INTO student_user_id FROM students WHERE id = NEW.student_id;
    
    -- If no user_id found, skip notification (don't fail)
    IF student_user_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- Collect Priority A skill courses
    IF NEW.skill_gap ? 'priorityA' THEN
        priority_skills := NEW.skill_gap->'priorityA';
        
        FOR skill_item IN SELECT * FROM jsonb_array_elements(priority_skills)
        LOOP
            IF NEW.skill_gap_courses ? (skill_item->>'skill') THEN
                skill_gap_courses := NEW.skill_gap_courses->(skill_item->>'skill');
                
                FOR course_item IN SELECT * FROM jsonb_array_elements(skill_gap_courses)
                LOOP
                    priority_a_courses := priority_a_courses || (course_item->>'course_id');
                END LOOP;
            END IF;
        END LOOP;
    END IF;

    -- Collect Priority B skill courses
    IF NEW.skill_gap ? 'priorityB' THEN
        priority_skills := NEW.skill_gap->'priorityB';
        
        FOR skill_item IN SELECT * FROM jsonb_array_elements(priority_skills)
        LOOP
            IF NEW.skill_gap_courses ? (skill_item->>'skill') THEN
                skill_gap_courses := NEW.skill_gap_courses->(skill_item->>'skill');
                
                FOR course_item IN SELECT * FROM jsonb_array_elements(skill_gap_courses)
                LOOP
                    priority_b_courses := priority_b_courses || (course_item->>'course_id');
                END LOOP;
            END IF;
        END LOOP;
    END IF;

    -- Only schedule if there are courses to recommend
    IF array_length(priority_a_courses, 1) > 0 OR array_length(priority_b_courses, 1) > 0 THEN
        -- Schedule notification for exactly 6 months from assessment completion
        -- Use student_user_id (auth user ID) instead of student_id (student table ID)
        INSERT INTO notifications (
            recipient_id,
            type,
            title,
            message,
            read,
            status,
            scheduled_for,
            assessment_id,
            created_at
        ) VALUES (
            student_user_id,  -- Changed from NEW.student_id to student_user_id
            'assessment_6month_reminder',
            'Skill Development Reminder',
            'Time to continue your learning journey based on your assessment results.',
            false,
            'scheduled',
            NEW.created_at + INTERVAL '6 months',
            NEW.id,
            NOW()
        );
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_approval_authority()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF LOWER(NEW.organization) = 'rareminds' THEN
        NEW.approval_authority = 'school_admin';
    ELSE
        NEW.approval_authority = 'rareminds_admin';
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_experience_approval_authority()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    student_record RECORD;
    matching_school RECORD;
    matching_college RECORD;
    org_lower TEXT;
BEGIN
    -- Get student information
    SELECT s.*
    INTO student_record
    FROM students s
    WHERE s.id = NEW.student_id;
    
    IF NOT FOUND THEN
        -- Default to rareminds_admin if student not found
        NEW.approval_authority := 'rareminds_admin';
        RETURN NEW;
    END IF;
    
    -- Get organization name in lowercase for comparison
    org_lower := LOWER(TRIM(COALESCE(NEW.organization, '')));
    
    -- If organization is empty, default to rareminds_admin
    IF org_lower = '' THEN
        NEW.approval_authority := 'rareminds_admin';
        RETURN NEW;
    END IF;
    
    -- Check if organization matches any school name from organizations table
    SELECT o.*
    INTO matching_school
    FROM organizations o
    WHERE LOWER(TRIM(o.name)) = org_lower
    AND o.organization_type = 'school'
    LIMIT 1;
    
    -- Check if organization matches any college name from organizations table
    SELECT o.*
    INTO matching_college
    FROM organizations o
    WHERE LOWER(TRIM(o.name)) = org_lower
    AND o.organization_type = 'college'
    LIMIT 1;
    
    -- Determine approval authority based on matches
    IF matching_school.id IS NOT NULL THEN
        -- Organization matches a school - assign to school_admin
        NEW.approval_authority := 'school_admin';
    ELSIF matching_college.id IS NOT NULL THEN
        -- Organization matches a college - assign to college_admin
        NEW.approval_authority := 'college_admin';
    ELSE
        -- Check if it's the student's own institution
        IF (student_record.student_type IN ('school', 'school_student') AND 
            org_lower = LOWER(TRIM(COALESCE(student_record.college_school_name, '')))) THEN
            NEW.approval_authority := 'school_admin';
        ELSIF (student_record.student_type IN ('college', 'college_student') AND 
               (org_lower = LOWER(TRIM(COALESCE(student_record.university, ''))) OR
                org_lower = LOWER(TRIM(COALESCE(student_record.college_school_name, ''))))) THEN
            NEW.approval_authority := 'college_admin';
        ELSE
            -- External organization - assign to rareminds_admin
            NEW.approval_authority := 'rareminds_admin';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_project_approval_authority()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    student_record RECORD;
    org_lower TEXT;
    student_school_name TEXT;
    student_college_name TEXT;
    is_school_student BOOLEAN := FALSE;
    is_college_student BOOLEAN := FALSE;
BEGIN
    -- Get student information with school and college names from organizations table
    SELECT 
        s.student_type, 
        s.school_id, 
        s.college_id, 
        s.university_college_id,
        sch.name as school_name,
        col.name as college_name
    INTO student_record
    FROM students s
    LEFT JOIN organizations sch ON s.school_id = sch.id AND sch.organization_type = 'school'
    LEFT JOIN organizations col ON (s.college_id = col.id OR s.university_college_id = col.id) AND col.organization_type = 'college'
    WHERE s.id = NEW.student_id;

    -- If no student found, default to rareminds_admin
    IF NOT FOUND THEN
        NEW.approval_authority := 'rareminds_admin';
        RETURN NEW;
    END IF;

    -- If no organization specified, default to rareminds_admin
    IF NEW.organization IS NULL OR TRIM(NEW.organization) = '' THEN
        NEW.approval_authority := 'rareminds_admin';
        RETURN NEW;
    END IF;

    -- Normalize organization name for comparison
    org_lower := LOWER(TRIM(NEW.organization));
    
    -- Get student's school and college names (normalized)
    student_school_name := CASE 
        WHEN student_record.school_name IS NOT NULL 
        THEN LOWER(TRIM(student_record.school_name))
        ELSE NULL 
    END;
    
    student_college_name := CASE 
        WHEN student_record.college_name IS NOT NULL 
        THEN LOWER(TRIM(student_record.college_name))
        ELSE NULL 
    END;

    -- Determine if student is school or college type
    -- School students: have school_id OR student_type contains 'school' OR student_type is 'direct' with school_id
    is_school_student := (
        student_record.school_id IS NOT NULL OR
        student_record.student_type IN ('school', 'school_student', 'school-student') OR
        (student_record.student_type = 'direct' AND student_record.school_id IS NOT NULL)
    );
    
    -- College students: have college_id OR student_type contains 'college' OR student_type is 'direct' with college_id
    is_college_student := (
        student_record.college_id IS NOT NULL OR 
        student_record.university_college_id IS NOT NULL OR
        student_record.student_type IN ('college', 'college_student', 'college-student') OR
        (student_record.student_type = 'direct' AND (student_record.college_id IS NOT NULL OR student_record.university_college_id IS NOT NULL))
    );

    -- Route based on student type and organization matching
    IF is_school_student THEN
        -- For school students: check if organization matches their school name
        IF student_school_name IS NOT NULL AND org_lower = student_school_name THEN
            NEW.approval_authority := 'school_admin';
            RETURN NEW;
        END IF;
        
        -- Also check if organization matches any school name in the organizations table
        IF EXISTS (
            SELECT 1 FROM organizations 
            WHERE LOWER(TRIM(name)) = org_lower 
            AND organization_type = 'school'
            AND account_status IN ('active', 'pending')
        ) THEN
            NEW.approval_authority := 'school_admin';
            RETURN NEW;
        END IF;
        
    END IF;
    
    IF is_college_student THEN
        -- For college students: check if organization matches their college name
        IF student_college_name IS NOT NULL AND org_lower = student_college_name THEN
            NEW.approval_authority := 'college_admin';
            RETURN NEW;
        END IF;
        
        -- Also check if organization matches any college name in the organizations table
        IF EXISTS (
            SELECT 1 FROM organizations 
            WHERE LOWER(TRIM(name)) = org_lower 
            AND organization_type = 'college'
            AND account_status = 'active'
        ) THEN
            NEW.approval_authority := 'college_admin';
            RETURN NEW;
        END IF;
    END IF;

    -- Default to rareminds_admin for external/custom organizations
    NEW.approval_authority := 'rareminds_admin';
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_session_total_students()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Set total students from program_sections_view
    NEW.total_students := COALESCE((
        SELECT max_students
        FROM program_sections_view psv
        WHERE psv.department_name = NEW.department_name
        AND psv.program_name = NEW.program_name
        AND psv.semester = NEW.semester
        AND psv.section = NEW.section
        AND psv.status = 'active'
        LIMIT 1
    ), 0);
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_training_approval_authority()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    student_record RECORD;
    org_lower TEXT;
BEGIN
    -- Get student information from students table only
    SELECT s.*
    INTO student_record
    FROM students s
    WHERE s.id = NEW.student_id;
    
    IF NOT FOUND THEN
        NEW.approval_authority := 'rareminds_admin';
        RETURN NEW;
    END IF;
    
    -- Get organization in lowercase for comparison
    org_lower := LOWER(TRIM(COALESCE(NEW.organization, '')));
    
    -- Check if it's a Rareminds training
    IF org_lower = 'rareminds' THEN
        -- Check if student is a college student (handle both 'college' and 'college_student')
        IF student_record.student_type IN ('college', 'college_student') 
           OR student_record.college_school_name IS NOT NULL THEN
            NEW.approval_authority := 'college_admin';
        ELSE
            NEW.approval_authority := 'school_admin';
        END IF;
    ELSE
        NEW.approval_authority := 'rareminds_admin';
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_updated_at_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

create or replace view "public"."shortlists_with_counts" as  SELECT s.id,
    s.name,
    s.description,
    s.created_by,
    s.created_date,
    s.status,
    s.shared,
    s.share_link,
    s.share_expiry,
    s.watermark,
    s.include_pii,
    s.notify_on_access,
    s.tags,
    s.updated_at,
    count(sc.id) AS candidate_count
   FROM (public.shortlists s
     LEFT JOIN public.shortlist_candidates sc ON ((s.id = sc.shortlist_id)))
  GROUP BY s.id, s.name, s.description, s.created_by, s.created_date, s.status, s.shared, s.share_link, s.share_expiry, s.watermark, s.include_pii, s.notify_on_access, s.tags, s.updated_at;


create or replace view "public"."student_applications_with_pipeline" as  SELECT s.id AS student_id,
    s.name AS student_name,
    s.email AS student_email,
    o.id_old AS opportunity_id,
    o.title AS opportunity_title,
    o.company_name,
    o.requisition_id,
    pc.stage,
    pc.status,
    pc.added_at,
    pc.stage_changed_at,
    pc.next_action,
    pc.next_action_date
   FROM ((public.students s
     LEFT JOIN public.pipeline_candidates pc ON ((s.id = pc.student_id)))
     LEFT JOIN public.opportunities o ON ((pc.opportunity_id_old = o.id_old)));


create or replace view "public"."student_badges_summary" as  SELECT ssb.student_email,
    s.name AS student_name,
    s.grade,
    s.section,
    sb.name AS badge_name,
    sb.level AS badge_level,
    sb.category AS badge_category,
    ssb.status,
    ssb.progress_percentage,
    ssb.earned_at
   FROM ((public.student_skill_badges ssb
     JOIN public.skill_badges sb ON ((ssb.badge_id = sb.badge_id)))
     JOIN public.students s ON (((ssb.student_email)::text = s.email)));


CREATE OR REPLACE FUNCTION public.submit_curriculum_for_approval(p_curriculum_id uuid, p_message text DEFAULT NULL::text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_user_id UUID;
    v_college_info RECORD;
    v_college_name TEXT;
BEGIN
    -- Get current user ID
    v_user_id := auth.uid();
    
    -- Get college affiliation info
    SELECT * INTO v_college_info FROM check_college_affiliation() LIMIT 1;
    
    -- Check if college is affiliated
    IF NOT v_college_info.is_affiliated THEN
        RAISE EXCEPTION 'College is not affiliated with any university';
    END IF;
    
    -- Get college name from organizations table
    SELECT name INTO v_college_name
    FROM organizations 
    WHERE id = v_college_info.college_id;
    
    -- Update curriculum status (using existing status column)
    UPDATE college_curriculums 
    SET 
        status = 'pending_approval',
        requested_by = v_user_id,
        request_date = NOW(),
        request_message = p_message,
        university_id = v_college_info.university_id
    WHERE id = p_curriculum_id
    AND college_id = v_college_info.college_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Curriculum not found or access denied';
    END IF;
    
    -- Create notifications for university admins (only if notifications table exists)
    -- Skip metadata column if it doesn't exist
    IF to_regclass('public.notifications') IS NOT NULL THEN
        -- Check if metadata column exists
        IF EXISTS (
            SELECT 1 FROM information_schema.columns 
            WHERE table_name = 'notifications' 
            AND column_name = 'metadata'
        ) THEN
            -- Insert with metadata
            INSERT INTO notifications (
                recipient_id,
                title,
                message,
                type,
                metadata
            )
            SELECT 
                ua.id,
                'New Curriculum Approval Request',
                'A new curriculum approval request has been submitted by ' || COALESCE(v_college_name, 'Unknown College'),
                'curriculum_approval_request',
                jsonb_build_object(
                    'curriculum_id', p_curriculum_id,
                    'college_id', v_college_info.college_id,
                    'university_id', v_college_info.university_id,
                    'requested_by_email', (SELECT email FROM users WHERE id = v_user_id)
                )
            FROM get_university_admins(v_college_info.university_id) ua;
        ELSE
            -- Insert without metadata
            INSERT INTO notifications (
                recipient_id,
                title,
                message,
                type
            )
            SELECT 
                ua.id,
                'New Curriculum Approval Request',
                'A new curriculum approval request has been submitted by ' || COALESCE(v_college_name, 'Unknown College'),
                'curriculum_approval_request'
            FROM get_university_admins(v_college_info.university_id) ua;
        END IF;
    END IF;
    
    RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_lecturer_record_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Auto-populate lecturer_record_id from invigilator_id
  IF NEW.invigilator_id IS NOT NULL AND NEW.lecturer_record_id IS NULL THEN
    SELECT id INTO NEW.lecturer_record_id
    FROM college_lecturers
    WHERE user_id = NEW.invigilator_id;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_pool_assigned_seats()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- Only increment if status is active
        IF NEW.status = 'active' THEN
            UPDATE license_pools
            SET assigned_seats = COALESCE(assigned_seats, 0) + 1,
                updated_at = NOW()
            WHERE id = NEW.license_pool_id;
            
            -- Also update organization_subscriptions
            UPDATE organization_subscriptions
            SET assigned_seats = COALESCE(assigned_seats, 0) + 1,
                updated_at = NOW()
            WHERE id = NEW.organization_subscription_id;
        END IF;
        RETURN NEW;
        
    ELSIF TG_OP = 'UPDATE' THEN
        -- Handle status changes
        IF OLD.status = 'active' AND NEW.status != 'active' THEN
            -- License was revoked/expired, decrement count
            UPDATE license_pools
            SET assigned_seats = GREATEST(COALESCE(assigned_seats, 0) - 1, 0),
                updated_at = NOW()
            WHERE id = NEW.license_pool_id;
            
            UPDATE organization_subscriptions
            SET assigned_seats = GREATEST(COALESCE(assigned_seats, 0) - 1, 0),
                updated_at = NOW()
            WHERE id = NEW.organization_subscription_id;
            
        ELSIF OLD.status != 'active' AND NEW.status = 'active' THEN
            -- License was reactivated, increment count
            UPDATE license_pools
            SET assigned_seats = COALESCE(assigned_seats, 0) + 1,
                updated_at = NOW()
            WHERE id = NEW.license_pool_id;
            
            UPDATE organization_subscriptions
            SET assigned_seats = COALESCE(assigned_seats, 0) + 1,
                updated_at = NOW()
            WHERE id = NEW.organization_subscription_id;
        END IF;
        RETURN NEW;
        
    ELSIF TG_OP = 'DELETE' THEN
        -- Decrement assigned_seats when assignment is deleted
        IF OLD.status = 'active' THEN
            UPDATE license_pools
            SET assigned_seats = GREATEST(COALESCE(assigned_seats, 0) - 1, 0),
                updated_at = NOW()
            WHERE id = OLD.license_pool_id;
            
            UPDATE organization_subscriptions
            SET assigned_seats = GREATEST(COALESCE(assigned_seats, 0) - 1, 0),
                updated_at = NOW()
            WHERE id = OLD.organization_subscription_id;
        END IF;
        RETURN OLD;
    END IF;
    
    RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_student_record_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Auto-populate student_record_id from user_id
  IF NEW.student_id IS NOT NULL AND NEW.student_record_id IS NULL THEN
    SELECT id INTO NEW.student_record_id
    FROM students
    WHERE user_id = NEW.student_id;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.sync_training_from_enrollment()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Only sync if there's a linked training_id
    IF NEW.training_id IS NOT NULL THEN
        UPDATE trainings
        SET 
            status = CASE 
                WHEN NEW.status = 'completed' THEN 'completed'
                ELSE 'ongoing'
            END,
            completed_modules = COALESCE(array_length(NEW.completed_lessons, 1), 0),
            hours_spent = COALESCE(NEW.total_time_spent_seconds / 3600, 0),
            end_date = CASE 
                WHEN NEW.status = 'completed' THEN NEW.completed_at::date
                ELSE NULL
            END,
            updated_at = NOW()
        WHERE id = NEW.training_id;
    END IF;
    
    RETURN NEW;
END;
$function$
;

create or replace view "public"."teacher_weekly_timetable" as  SELECT ts.id AS slot_id,
    ts.educator_id,
    se.teacher_id AS teacher_code,
    (((se.first_name)::text || ' '::text) || (se.last_name)::text) AS teacher_name,
    ts.day_of_week,
    ts.period_number,
    ts.start_time,
    ts.end_time,
    sc.name AS class_name,
    ts.subject_name,
    ts.room_number,
    tt.academic_year,
    tt.term,
    lp.id AS lesson_plan_id,
    lp.title AS lesson_plan_title,
    lp.status AS lesson_plan_status,
    lp.chapter_name,
    lp.teaching_methodology
   FROM ((((public.timetable_slots ts
     JOIN public.school_educators se ON ((ts.educator_id = se.id)))
     JOIN public.school_classes sc ON ((ts.class_id = sc.id)))
     JOIN public.timetables tt ON ((ts.timetable_id = tt.id)))
     LEFT JOIN public.lesson_plans lp ON (((lp.educator_id = ts.educator_id) AND (lp.class_id = ts.class_id) AND ((lp.subject)::text = (ts.subject_name)::text) AND (EXTRACT(dow FROM lp.date) = (ts.day_of_week)::numeric))))
  WHERE ((tt.status)::text = 'published'::text)
  ORDER BY ts.day_of_week, ts.period_number;


CREATE OR REPLACE FUNCTION public.test_assessment_reminders(student_uuid uuid DEFAULT NULL::uuid)
 RETURNS TABLE(notification_id uuid, student_id uuid, assessment_id uuid, status text, scheduled_for timestamp with time zone, action_taken text)
 LANGUAGE plpgsql
AS $function$
DECLARE
    test_results RECORD;
BEGIN
    -- Temporarily set scheduled_for to now for testing
    UPDATE notifications 
    SET scheduled_for = NOW() - INTERVAL '1 minute'
    WHERE type = 'assessment_6month_reminder'
    AND status = 'scheduled'
    AND (student_uuid IS NULL OR recipient_id = student_uuid);

    -- Process the reminders
    PERFORM process_assessment_reminders();

    -- Return results
    RETURN QUERY
    SELECT 
        n.id as notification_id,
        n.recipient_id as student_id,
        n.assessment_id,
        n.status,
        n.scheduled_for,
        CASE 
            WHEN n.status = 'sent' THEN 'Notification sent'
            WHEN n.status = 'cancelled' THEN 'Notification cancelled: ' || COALESCE(n.message, 'Unknown reason')
            ELSE 'No action taken'
        END as action_taken
    FROM notifications n
    WHERE n.type = 'assessment_6month_reminder'
    AND (student_uuid IS NULL OR n.recipient_id = student_uuid)
    ORDER BY n.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.test_outcome_approval_debug(p_curriculum_id uuid, p_change_id uuid)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_change JSONB;
  v_change_data JSONB;
  v_pending_changes JSONB;
  v_change_elem JSONB;
  v_debug_info TEXT;
BEGIN
  -- Get pending changes
  SELECT pending_changes INTO v_pending_changes
  FROM college_curriculums
  WHERE id = p_curriculum_id;
  
  -- Find the specific change
  v_change := NULL;
  FOR i IN 0..jsonb_array_length(v_pending_changes) - 1 LOOP
    v_change_elem := v_pending_changes->i;
    IF v_change_elem->>'id' = p_change_id::text THEN
      v_change := v_change_elem;
      EXIT;
    END IF;
  END LOOP;
  
  IF v_change IS NULL THEN
    RETURN 'Change not found';
  END IF;
  
  v_change_data := v_change->'data';
  
  v_debug_info := 'Change Type: ' || (v_change->>'change_type') || E'\n';
  v_debug_info := v_debug_info || 'Full Change Data: ' || v_change_data::text || E'\n';
  v_debug_info := v_debug_info || 'Direct unit_id: ' || COALESCE(v_change_data->>'unit_id', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'Nested unit_id: ' || COALESCE(v_change_data->'data'->>'unit_id', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'CamelCase unitId: ' || COALESCE(v_change_data->>'unitId', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'Nested camelCase unitId: ' || COALESCE(v_change_data->'data'->>'unitId', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'Direct outcome_text: ' || COALESCE(v_change_data->>'outcome_text', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'Nested outcome_text: ' || COALESCE(v_change_data->'data'->>'outcome_text', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'Direct outcome: ' || COALESCE(v_change_data->>'outcome', 'NULL') || E'\n';
  v_debug_info := v_debug_info || 'Nested outcome: ' || COALESCE(v_change_data->'data'->>'outcome', 'NULL') || E'\n';
  
  RETURN v_debug_info;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.toggle_save_job(p_student_id uuid, p_opportunity_id integer)
 RETURNS TABLE(success boolean, message text, is_saved boolean, saved_job_id integer)
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_saved_job_id INTEGER;
  v_is_saved BOOLEAN;
BEGIN
  -- Check if already saved
  SELECT id INTO v_saved_job_id
  FROM public.saved_jobs
  WHERE student_id = p_student_id 
    AND opportunity_id = p_opportunity_id;
  
  IF FOUND THEN
    -- Already saved, so unsave it
    DELETE FROM public.saved_jobs
    WHERE id = v_saved_job_id;
    
    RETURN QUERY SELECT TRUE, 'Job unsaved successfully', FALSE, NULL::INTEGER;
  ELSE
    -- Not saved, so save it
    INSERT INTO public.saved_jobs (
      student_id,
      opportunity_id,
      saved_at
    ) 
    VALUES (
      p_student_id,
      p_opportunity_id,
      NOW()
    )
    RETURNING id INTO v_saved_job_id;
    
    RETURN QUERY SELECT TRUE, 'Job saved successfully', TRUE, v_saved_job_id;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.track_profile_view(p_student_id uuid, p_viewer_type text DEFAULT 'anonymous'::text, p_viewer_id uuid DEFAULT NULL::uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_recent_views int;
BEGIN
  -- Insert the view
  INSERT INTO public.profile_views (student_id, viewer_type, viewer_id)
  VALUES (p_student_id, p_viewer_type, p_viewer_id);

  -- Count views in the last 7 days
  SELECT COUNT(*) INTO v_recent_views
  FROM public.profile_views
  WHERE student_id = p_student_id
  AND viewed_at >= now() - interval '7 days';

  -- Add update every 5 views
  IF v_recent_views % 5 = 0 THEN
    PERFORM add_recent_update(
      p_student_id,
      'Your profile has been viewed ' || v_recent_views::text || ' times this week',
      'profile_view'
    );
    RAISE LOG 'Profile view milestone for student %: % views', p_student_id, v_recent_views;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public."transferStudent"("p_studentId" uuid, "p_newEntityType" text, "p_newEntityId" uuid, "p_newClassId" uuid, "p_transferReason" text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_oldEnrollmentId UUID;
    v_newEnrollmentId UUID;
BEGIN
    -- Mark current enrollment as transferred
    UPDATE "studentEnrollments"
    SET "enrollmentStatus" = 'transferred',
        "transferDate" = CURRENT_DATE,
        "transferReason" = "p_transferReason",
        "transferToEntityId" = "p_newEntityId",
        "transferToClassId" = "p_newClassId",
        "updatedAt" = NOW()
    WHERE "studentId" = "p_studentId"
    AND "enrollmentStatus" = 'active'
    RETURNING "id" INTO v_oldEnrollmentId;
    
    -- Create new enrollment
    INSERT INTO "studentEnrollments" (
        "studentId", "schoolId", "collegeId",
        "universityId", "schoolClassId", "collegeCourseId", 
        "universityCourseId", "enrollmentDate", "enrollmentStatus"
    )
    VALUES (
        "p_studentId",
        CASE WHEN "p_newEntityType" = 'school' THEN "p_newEntityId" ELSE NULL END,
        CASE WHEN "p_newEntityType" = 'college' THEN "p_newEntityId" ELSE NULL END,
        CASE WHEN "p_newEntityType" = 'university' THEN "p_newEntityId" ELSE NULL END,
        CASE WHEN "p_newEntityType" = 'school' THEN "p_newClassId" ELSE NULL END,
        CASE WHEN "p_newEntityType" = 'college' THEN "p_newClassId" ELSE NULL END,
        CASE WHEN "p_newEntityType" = 'university' THEN "p_newClassId" ELSE NULL END,
        CURRENT_DATE,
        'active'
    )
    RETURNING "id" INTO v_newEnrollmentId;
    
    RETURN v_newEnrollmentId;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_assignments_completion_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
        IF NEW.submission_date IS NULL THEN
            NEW.submission_date := CURRENT_TIMESTAMP;
        END IF;
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_assignments_grade_pct_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NEW.grade_received IS NOT NULL AND NEW.total_points IS NOT NULL AND NEW.total_points > 0 THEN
        NEW.grade_percentage := ROUND((NEW.grade_received / NEW.total_points) * 100, 2);
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_assignments_updated_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_date := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_college_assignments_updated_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_date = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_college_student_assignments_grade_pct_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_total_points numeric;
BEGIN
    IF NEW.grade_received IS NOT NULL THEN
        SELECT total_points INTO v_total_points
        FROM college_assignments
        WHERE assignment_id = NEW.assignment_id;
        
        IF v_total_points > 0 THEN
            NEW.grade_percentage := (NEW.grade_received / v_total_points) * 100;
        END IF;
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_college_student_assignments_late_check_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_due_date timestamp with time zone;
BEGIN
    IF NEW.submission_date IS NOT NULL THEN
        SELECT due_date INTO v_due_date
        FROM college_assignments
        WHERE assignment_id = NEW.assignment_id;
        
        IF NEW.submission_date > v_due_date THEN
            NEW.is_late := true;
        ELSE
            NEW.is_late := false;
        END IF;
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_college_student_assignments_status_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NEW.status = 'in-progress' AND OLD.status = 'todo' THEN
        NEW.started_date := NOW();
    END IF;
    
    IF NEW.status = 'submitted' AND OLD.status <> 'submitted' THEN
        NEW.completed_date := NOW();
        NEW.submission_date := NOW();
    END IF;
    
    IF NEW.status = 'graded' AND OLD.status <> 'graded' THEN
        NEW.graded_date := NOW();
        NEW.feedback_date := NOW();
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_college_student_assignments_updated_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_date = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_insert_recent_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only insert when training is marked as completed
  IF NEW.status = 'completed' AND (OLD.status IS DISTINCT FROM NEW.status) THEN
    INSERT INTO public.recent_updates (student_id, title, description, type)
    VALUES (
      NEW.student_id,
      CONCAT('You completed ', NEW.course, '.'),
      NEW.description,
      'achievement'
    );
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_student_assignments_grade_pct_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_total_points numeric(7,2);
BEGIN
    -- Get total points from the assignment
    SELECT total_points INTO v_total_points
    FROM assignments
    WHERE assignment_id = NEW.assignment_id;
    
    IF NEW.grade_received IS NOT NULL AND v_total_points IS NOT NULL AND v_total_points > 0 THEN
        NEW.grade_percentage := ROUND((NEW.grade_received / v_total_points) * 100, 2);
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_student_assignments_late_check_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_due_date timestamptz;
BEGIN
    -- Only check if submission_date is being set
    IF NEW.submission_date IS NOT NULL THEN
        -- Get due date from assignment
        SELECT due_date INTO v_due_date
        FROM assignments
        WHERE assignment_id = NEW.assignment_id;
        
        -- Mark as late if submitted after due date
        IF v_due_date IS NOT NULL AND NEW.submission_date > v_due_date THEN
            NEW.is_late := true;
        ELSE
            NEW.is_late := false;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_student_assignments_status_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Set started_date when status changes to in-progress
    IF NEW.status = 'in-progress' AND (OLD.status IS NULL OR OLD.status = 'todo') THEN
        IF NEW.started_date IS NULL THEN
            NEW.started_date := CURRENT_TIMESTAMP;
        END IF;
    END IF;
    
    -- Set completed_date when status changes to submitted
    IF NEW.status = 'submitted' AND (OLD IS NULL OR OLD.status != 'submitted') THEN
        IF NEW.completed_date IS NULL THEN
            NEW.completed_date := CURRENT_TIMESTAMP;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_student_assignments_updated_fn()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_date := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_course_embedding_queue()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  PERFORM queue_embedding_generation(NEW.id, 'courses', CASE WHEN TG_OP = 'INSERT' THEN 'insert' ELSE 'update' END, CASE WHEN TG_OP = 'INSERT' THEN 7 ELSE 4 END);
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_enrollment_completion_embedding()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF (NEW.progress >= 100 OR NEW.status = 'completed') AND (OLD.progress < 100 AND OLD.status != 'completed') THEN
    PERFORM queue_embedding_generation(NEW.student_id, 'students', 'update', 7);
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_entity_embedding_generation()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  payload JSONB;
  entity_type TEXT;
BEGIN
  -- Determine entity type from table name
  entity_type := TG_TABLE_NAME;
  
  -- Build payload with student_id and entity type
  IF TG_OP = 'DELETE' THEN
    -- No need to generate embeddings for deleted records
    RETURN OLD;
  END IF;
  
  -- Only trigger for INSERT or UPDATE
  -- For updates, only trigger if relevant fields changed (not just embedding)
  IF TG_OP = 'UPDATE' AND NEW.embedding IS NOT NULL THEN
    -- Skip if only embedding was updated (avoid infinite loop)
    RETURN NEW;
  END IF;
  
  payload := jsonb_build_object(
    'studentId', COALESCE(NEW.student_id::text, ''),
    'entityTypes', jsonb_build_array(entity_type),
    'batchSize', 5
  );
  
  -- Call the backfill endpoint asynchronously using pg_net
  PERFORM net.http_post(
    url := 'https://career-api.dark-mode-d021.workers.dev/backfill-embeddings',
    headers := jsonb_build_object('Content-Type', 'application/json'),
    body := payload
  );
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_opportunity_embedding()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  embedding_text TEXT;
BEGIN
  -- Build the embedding text from opportunity data
  embedding_text := NEW.title;
  
  IF NEW.company_name IS NOT NULL THEN
    embedding_text := embedding_text || ' at ' || NEW.company_name;
  END IF;
  
  IF NEW.description IS NOT NULL THEN
    embedding_text := embedding_text || '. ' || NEW.description;
  END IF;
  
  IF NEW.skills_required IS NOT NULL AND jsonb_typeof(NEW.skills_required) = 'array' THEN
    embedding_text := embedding_text || '. Required Skills: ' || 
                     (SELECT string_agg(value::text, ', ') 
                      FROM jsonb_array_elements_text(NEW.skills_required));
  END IF;
  
  IF NEW.requirements IS NOT NULL AND jsonb_typeof(NEW.requirements) = 'array' THEN
    embedding_text := embedding_text || '. Requirements: ' || 
                     (SELECT string_agg(value::text, '. ') 
                      FROM jsonb_array_elements_text(NEW.requirements));
  END IF;

  -- Log the trigger execution
  RAISE NOTICE 'Opportunity embedding trigger fired for: % (ID: %)', NEW.title, NEW.id;
  RAISE NOTICE 'Embedding text length: % characters', length(embedding_text);
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_opportunity_embedding_queue()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  PERFORM queue_embedding_generation(NEW.id, 'opportunities', CASE WHEN TG_OP = 'INSERT' THEN 'insert' ELSE 'update' END, CASE WHEN TG_OP = 'INSERT' THEN 9 ELSE 7 END);
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_profile_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_changes text;
BEGIN
  v_changes := '';
  
  IF OLD.profile->>'name' != NEW.profile->>'name' THEN
    v_changes := 'Profile information updated';
  ELSIF OLD.profile->'education' != NEW.profile->'education' THEN
    v_changes := 'Education details updated';
  ELSIF OLD.profile->'experience' != NEW.profile->'experience' THEN
    v_changes := 'Experience information updated';
  ELSIF OLD.profile->'technicalSkills' != NEW.profile->'technicalSkills' THEN
    v_changes := 'Technical skills updated';
  ELSIF OLD.profile->'softSkills' != NEW.profile->'softSkills' THEN
    v_changes := 'Soft skills updated';
  ELSE
    v_changes := 'Profile updated';
  END IF;

  PERFORM add_recent_update(
    NEW.id,
    v_changes,
    'profile_update'
  );

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_related_student_embedding()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE v_student_id UUID;
BEGIN
  IF TG_OP = 'DELETE' THEN v_student_id := OLD.student_id; ELSE v_student_id := NEW.student_id; END IF;
  IF v_student_id IS NOT NULL THEN PERFORM queue_embedding_generation(v_student_id, 'students', 'update', 6); END IF;
  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_skills_improvement()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_old_tech_skills jsonb;
  v_new_tech_skills jsonb;
  v_skill_count_old int;
  v_skill_count_new int;
BEGIN
  -- Extract technical skills arrays
  v_old_tech_skills := OLD.profile->'technicalSkills';
  v_new_tech_skills := NEW.profile->'technicalSkills';
  
  -- Count skills
  SELECT jsonb_array_length(v_old_tech_skills) INTO v_skill_count_old;
  SELECT jsonb_array_length(v_new_tech_skills) INTO v_skill_count_new;
  
  -- Check if skills increased
  IF v_skill_count_new > v_skill_count_old THEN
    PERFORM add_recent_update(
      NEW.id,
      'Added new technical skills to your profile',
      'skills_update'
    );
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_student_embedding_queue()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  PERFORM queue_embedding_generation(NEW.id, 'students', CASE WHEN TG_OP = 'INSERT' THEN 'insert' ELSE 'update' END, CASE WHEN TG_OP = 'INSERT' THEN 8 ELSE 5 END);
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_training_completion()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_old_training jsonb;
  v_new_training jsonb;
  v_training_item jsonb;
  v_course_name text;
BEGIN
  v_old_training := OLD.profile->'training';
  v_new_training := NEW.profile->'training';

  IF v_old_training IS NOT NULL AND v_new_training IS NOT NULL THEN
    FOR v_training_item IN SELECT * FROM jsonb_array_elements(v_new_training)
    LOOP
      v_course_name := v_training_item->>'course';
      
      IF v_training_item->>'status' = 'completed' THEN
        IF NOT EXISTS (
          SELECT 1 FROM jsonb_array_elements(v_old_training) old_item
          WHERE old_item->>'id' = v_training_item->>'id'
          AND old_item->>'status' = 'completed'
        ) THEN
          PERFORM add_recent_update(
            NEW.id,
            'You completed ' || v_course_name || ' course',
            'training_completion'
          );
        END IF;
      END IF;
    END LOOP;
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_validate_aadhar()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.aadhar_number IS NOT NULL AND NOT validate_aadhar_number(NEW.aadhar_number) THEN
    RAISE EXCEPTION 'Invalid Aadhar number format. Must be 12 digits and cannot start with 0 or 1.';
  END IF;
  RETURN NEW;
END;
$function$
;

create or replace view "public"."upcoming_interviews" as  SELECT i.id,
    i.student_id,
    i.candidate_name,
    i.candidate_email,
    i.candidate_phone,
    i.job_title,
    i.interviewer,
    i.interviewer_email,
    i.date,
    i.duration,
    i.status,
    i.type,
    i.meeting_type,
    i.meeting_link,
    i.meeting_notes,
    i.reminders_sent,
    i.completed_date,
    i.scorecard,
    i.created_by,
    i.created_at,
    i.updated_at,
    s.name AS student_name,
    s.email AS student_email,
    COALESCE(s."contactNumber", s.contact_number) AS student_phone,
    s.branch_field AS department,
    COALESCE(s.university_main, s.university) AS university
   FROM (public.interviews i
     LEFT JOIN public.students s ON ((i.student_id = s.id)))
  WHERE ((i.date > now()) AND (i.status <> ALL (ARRAY['completed'::text, 'cancelled'::text])))
  ORDER BY i.date;


CREATE OR REPLACE FUNCTION public.update_adaptive_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_applied_jobs_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = TIMEZONE('utc'::text, NOW());
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_book_availability()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- If inserting a new issue (book being issued)
    IF TG_OP = 'INSERT' AND NEW.status = 'issued' THEN
        UPDATE library_books 
        SET available_copies = available_copies - 1,
            status = CASE 
                WHEN available_copies - 1 = 0 THEN 'all_issued'
                ELSE 'available'
            END
        WHERE id = NEW.book_id;
        
    -- If updating an issue (book being returned)
    ELSIF TG_OP = 'UPDATE' AND OLD.status = 'issued' AND NEW.status = 'returned' THEN
        UPDATE library_books 
        SET available_copies = available_copies + 1,
            status = 'available'
        WHERE id = NEW.book_id;
        
    -- If deleting an issue record (cleanup)
    ELSIF TG_OP = 'DELETE' AND OLD.status = 'issued' THEN
        UPDATE library_books 
        SET available_copies = available_copies + 1,
            status = 'available'
        WHERE id = OLD.book_id;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_book_availability_college()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- If inserting a new issue (book being issued)
    IF TG_OP = 'INSERT' AND NEW.status = 'issued' THEN
        UPDATE library_books_college 
        SET available_copies = available_copies - 1,
            status = CASE 
                WHEN available_copies - 1 = 0 THEN 'all_issued'
                ELSE 'available'
            END
        WHERE id = NEW.book_id AND college_id = NEW.college_id;
        
    -- If updating an issue (book being returned)
    ELSIF TG_OP = 'UPDATE' AND OLD.status = 'issued' AND NEW.status = 'returned' THEN
        UPDATE library_books_college 
        SET available_copies = available_copies + 1,
            status = 'available'
        WHERE id = NEW.book_id AND college_id = NEW.college_id;
        
    -- If deleting an issue record (cleanup)
    ELSIF TG_OP = 'DELETE' AND OLD.status = 'issued' THEN
        UPDATE library_books_college 
        SET available_copies = available_copies + 1,
            status = 'available'
        WHERE id = OLD.book_id AND college_id = OLD.college_id;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_book_availability_on_issue()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Decrease available copies when book is issued
  UPDATE library_books 
  SET available_copies = available_copies - 1,
      total_issues = total_issues + 1,
      last_issued_date = NEW.issue_date
  WHERE id = NEW.book_id;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_book_availability_on_return()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Increase available copies when book is returned
  IF NEW.return_date IS NOT NULL AND OLD.return_date IS NULL THEN
    UPDATE library_books 
    SET available_copies = available_copies + 1
    WHERE id = NEW.book_id;
    
    -- Archive to history
    INSERT INTO library_history (
      book_id, book_title, book_author, book_isbn, book_category,
      student_id, student_name, roll_number, email, department_id, academic_year,
      issue_date, due_date, return_date, days_overdue,
      fine_amount, fine_paid, fine_waived,
      issue_condition, return_condition, damage_charges,
      status, renewal_count,
      issued_by, issued_by_name, returned_to, returned_to_name,
      remarks
    )
    SELECT 
      lb.id, lb.title, lb.author, lb.isbn, lb.category,
      NEW.student_id, NEW.student_name, NEW.roll_number, NEW.email, NEW.department_id, NEW.academic_year,
      NEW.issue_date, NEW.due_date, NEW.return_date, NEW.days_overdue,
      NEW.fine_amount, NEW.fine_paid, NEW.fine_waived,
      NEW.issue_condition, NEW.return_condition, NEW.damage_charges,
      NEW.status, NEW.renewal_count,
      NEW.issued_by, u1.name, NEW.returned_to, u2.name,
      NEW.return_remarks
    FROM library_books lb
    LEFT JOIN users u1 ON u1.id = NEW.issued_by
    LEFT JOIN users u2 ON u2.id = NEW.returned_to
    WHERE lb.id = NEW.book_id;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_book_availability_school()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- If inserting a new issue (book being issued)
    IF TG_OP = 'INSERT' AND NEW.status = 'issued' THEN
        UPDATE library_books_school 
        SET available_copies = available_copies - 1,
            status = CASE 
                WHEN available_copies - 1 = 0 THEN 'all_issued'
                ELSE 'available'
            END
        WHERE id = NEW.book_id AND school_id = NEW.school_id;
        
    -- If updating an issue (book being returned)
    ELSIF TG_OP = 'UPDATE' AND OLD.status = 'issued' AND NEW.status = 'returned' THEN
        UPDATE library_books_school 
        SET available_copies = available_copies + 1,
            status = 'available'
        WHERE id = NEW.book_id AND school_id = NEW.school_id;
        
    -- If deleting an issue record (cleanup)
    ELSIF TG_OP = 'DELETE' AND OLD.status = 'issued' THEN
        UPDATE library_books_school 
        SET available_copies = available_copies + 1,
            status = 'available'
        WHERE id = OLD.book_id AND school_id = OLD.school_id;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_book_rating()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE library_books
  SET average_rating = (
    SELECT ROUND(AVG(rating)::numeric, 1)
    FROM library_reviews
    WHERE book_id = NEW.book_id AND is_approved = TRUE
  ),
  total_reviews = (
    SELECT COUNT(*)
    FROM library_reviews
    WHERE book_id = NEW.book_id AND is_approved = TRUE
  )
  WHERE id = NEW.book_id;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_budget_on_expenditure()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  budget_head_index INTEGER;
  current_heads JSONB;
  updated_heads JSONB;
BEGIN
  -- Only update when expenditure is approved
  IF NEW.status = 'approved' AND (OLD.status IS NULL OR OLD.status != 'approved') THEN
    -- Update total spent in budget
    UPDATE department_budgets
    SET total_spent = total_spent + NEW.total_amount
    WHERE id = NEW.budget_id;
    
    -- Update specific budget head
    SELECT budget_heads INTO current_heads
    FROM department_budgets
    WHERE id = NEW.budget_id;
    
    -- Find and update the specific budget head
    updated_heads := (
      SELECT jsonb_agg(
        CASE 
          WHEN elem->>'head' = NEW.budget_head_name 
          THEN jsonb_set(
            elem,
            '{spent}',
            to_jsonb(COALESCE((elem->>'spent')::numeric, 0) + NEW.total_amount)
          )
          ELSE elem
        END
      )
      FROM jsonb_array_elements(current_heads) elem
    );
    
    UPDATE department_budgets
    SET budget_heads = updated_heads
    WHERE id = NEW.budget_id;
    
    -- Check for budget alerts
    PERFORM check_budget_alerts(NEW.budget_id, NEW.budget_head_name);
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_certificates_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = TIMEZONE('utc'::text, NOW());
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_college_circulars_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_college_events_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_college_lesson_plans_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_conversation_on_message()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Update conversation with last message info
    UPDATE conversations
    SET 
        last_message_at = NEW.created_at,
        last_message_preview = LEFT(NEW.message_text, 100),
        last_message_sender = NEW.sender_id::TEXT,
        updated_at = NOW()
    WHERE id = NEW.conversation_id;

    -- Increment unread count for receiver
    IF NEW.receiver_type = 'student' THEN
        UPDATE conversations
        SET student_unread_count = student_unread_count + 1
        WHERE id = NEW.conversation_id;
    ELSE
        UPDATE conversations
        SET recruiter_unread_count = recruiter_unread_count + 1
        WHERE id = NEW.conversation_id;
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_conversation_unread_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Update unread count based on receiver type
    IF NEW.receiver_type = 'student' THEN
        UPDATE conversations 
        SET student_unread_count = student_unread_count + 1,
            last_message_at = NEW.created_at,
            last_message_preview = LEFT(NEW.message_text, 100),
            last_message_sender = NEW.sender_type,
            updated_at = NEW.created_at
        WHERE id = NEW.conversation_id;
    ELSIF NEW.receiver_type = 'recruiter' THEN
        UPDATE conversations 
        SET recruiter_unread_count = recruiter_unread_count + 1,
            last_message_at = NEW.created_at,
            last_message_preview = LEFT(NEW.message_text, 100),
            last_message_sender = NEW.sender_type,
            updated_at = NEW.created_at
        WHERE id = NEW.conversation_id;
    ELSIF NEW.receiver_type = 'educator' THEN
        UPDATE conversations 
        SET educator_unread_count = educator_unread_count + 1,
            last_message_at = NEW.created_at,
            last_message_preview = LEFT(NEW.message_text, 100),
            last_message_sender = NEW.sender_type,
            updated_at = NEW.created_at
        WHERE id = NEW.conversation_id;
    ELSIF NEW.receiver_type = 'school_admin' THEN
        UPDATE conversations 
        SET admin_unread_count = admin_unread_count + 1,
            last_message_at = NEW.created_at,
            last_message_preview = LEFT(NEW.message_text, 100),
            last_message_sender = NEW.sender_type,
            updated_at = NEW.created_at
        WHERE id = NEW.conversation_id;
    ELSIF NEW.receiver_type = 'college_admin' THEN
        UPDATE conversations 
        SET college_admin_unread_count = college_admin_unread_count + 1,
            last_message_at = NEW.created_at,
            last_message_preview = LEFT(NEW.message_text, 100),
            last_message_sender = NEW.sender_type,
            updated_at = NEW.created_at
        WHERE id = NEW.conversation_id;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_curriculum_last_modified()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_curriculum_id UUID;
BEGIN
  -- Determine curriculum_id based on which table triggered this
  IF TG_TABLE_NAME = 'curriculum_chapters' THEN
    -- For curriculum_chapters, use curriculum_id directly
    v_curriculum_id := COALESCE(NEW.curriculum_id, OLD.curriculum_id);
  ELSIF TG_TABLE_NAME = 'curriculum_learning_outcomes' THEN
    -- For curriculum_learning_outcomes, get curriculum_id via chapter_id
    SELECT curriculum_id INTO v_curriculum_id
    FROM curriculum_chapters
    WHERE id = COALESCE(NEW.chapter_id, OLD.chapter_id);
  END IF;
  
  -- Update last_modified on parent curriculum
  IF v_curriculum_id IS NOT NULL THEN
    UPDATE curriculums 
    SET last_modified = NOW() 
    WHERE id = v_curriculum_id;
  END IF;
  
  RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_departments_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_email_tracking_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_external_assessment_attempts_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_grade_on_program_mapping()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    program_degree_level VARCHAR;
BEGIN
    -- Only proceed if program_id is being set or changed
    IF NEW.program_id IS NOT NULL AND (OLD.program_id IS NULL OR OLD.program_id != NEW.program_id) THEN
        -- Get the degree level from the program
        SELECT degree_level INTO program_degree_level
        FROM programs
        WHERE id = NEW.program_id;
        
        -- Map degree level to grade
        -- Undergraduate programs (BBA, BCA, BSC, etc.) = After 12th
        -- Postgraduate programs (MBA, MCA, MSC, etc.) = After graduation
        IF program_degree_level IS NOT NULL THEN
            CASE program_degree_level
                WHEN 'Undergraduate' THEN
                    NEW.grade := 'UG'; -- Undergraduate (After 12th)
                WHEN 'Postgraduate' THEN
                    NEW.grade := 'PG'; -- Postgraduate
                WHEN 'Diploma' THEN
                    NEW.grade := 'Diploma'; -- Diploma (can be after 10th or 12th)
                WHEN 'Certificate' THEN
                    NEW.grade := 'Certificate';
                ELSE
                    NEW.grade := program_degree_level; -- Use as-is for other levels
            END CASE;
            
            -- Also set grade_start_date to current date if not already set
            IF NEW.grade_start_date IS NULL THEN
                NEW.grade_start_date := CURRENT_DATE;
            END IF;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_ledger_overdue_status()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Update is_overdue based on current conditions
  IF NEW.payment_status IN ('paid', 'waived') THEN
    NEW.is_overdue := FALSE;
  ELSIF NEW.due_date < CURRENT_DATE AND (NEW.due_amount - NEW.paid_amount) > 0 THEN
    NEW.is_overdue := TRUE;
  ELSE
    NEW.is_overdue := FALSE;
  END IF;
  
  -- Auto-update payment_status based on amounts
  IF NEW.paid_amount >= NEW.due_amount THEN
    NEW.payment_status := 'paid';
  ELSIF NEW.paid_amount > 0 AND NEW.paid_amount < NEW.due_amount THEN
    NEW.payment_status := 'partial';
  ELSIF NEW.due_date < CURRENT_DATE AND NEW.paid_amount < NEW.due_amount THEN
    NEW.payment_status := 'overdue';
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_license_assignments_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_license_pools_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_membership_attendance()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    UPDATE public.club_memberships cm
    SET 
        total_sessions_attended = (
            SELECT COUNT(*) 
            FROM public.club_attendance_records car
            JOIN public.club_attendance ca ON car.attendance_id = ca.attendance_id
            WHERE ca.club_id = cm.club_id 
            AND car.student_email = cm.student_email 
            AND car.status IN ('present', 'late')
        ),
        total_sessions_held = (
            SELECT COUNT(*) 
            FROM public.club_attendance ca
            WHERE ca.club_id = cm.club_id
            AND ca.session_date <= CURRENT_DATE
        ),
        attendance_percentage = CASE 
            WHEN (SELECT COUNT(*) FROM public.club_attendance ca WHERE ca.club_id = cm.club_id) > 0
            THEN (
                SELECT COUNT(*) * 100.0 / NULLIF((SELECT COUNT(*) FROM public.club_attendance ca WHERE ca.club_id = cm.club_id), 0)
                FROM public.club_attendance_records car
                JOIN public.club_attendance ca ON car.attendance_id = ca.attendance_id
                WHERE ca.club_id = cm.club_id 
                AND car.student_email = cm.student_email 
                AND car.status IN ('present', 'late')
            )
            ELSE 0
        END
    WHERE cm.club_id = (SELECT club_id FROM public.club_attendance WHERE attendance_id = NEW.attendance_id)
    AND cm.student_email = NEW.student_email;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_mentor_note_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.last_updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_organization_invitations_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_organization_subscriptions_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_phone_otps_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_profile_array_item(p_student_id uuid, p_array_name text, p_item_id integer, p_updates jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_profile JSONB;
  v_array JSONB;
  v_new_array JSONB := '[]'::jsonb;
  v_item JSONB;
BEGIN
  -- Get current profile
  SELECT profile INTO v_profile
  FROM students
  WHERE id = p_student_id;
  
  -- Get array
  v_array := v_profile -> p_array_name;
  
  -- Update matching item
  FOR v_item IN SELECT * FROM jsonb_array_elements(v_array)
  LOOP
    IF (v_item->>'id')::int = p_item_id THEN
      -- Merge updates with existing item
      v_item := v_item || p_updates;
    END IF;
    v_new_array := v_new_array || v_item;
  END LOOP;
  
  -- Update profile
  v_profile := jsonb_set(v_profile, ARRAY[p_array_name], v_new_array);
  
  -- Save and return
  UPDATE students SET profile = v_profile WHERE id = p_student_id;
  
  RETURN v_profile;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_question_usage(p_question_id text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE adaptive_aptitude_questions_cache
  SET 
    usage_count = usage_count + 1,
    last_used_at = NOW()
  WHERE question_id = p_question_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_saved_jobs_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = TIMEZONE('utc'::text, NOW());
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_section_enrollment_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'INSERT' AND NEW.section_id IS NOT NULL THEN
    UPDATE program_sections
    SET current_students = current_students + 1
    WHERE id = NEW.section_id;
  ELSIF TG_OP = 'DELETE' AND OLD.section_id IS NOT NULL THEN
    UPDATE program_sections
    SET current_students = GREATEST(0, current_students - 1)
    WHERE id = OLD.section_id;
  ELSIF TG_OP = 'UPDATE' AND OLD.section_id IS DISTINCT FROM NEW.section_id THEN
    IF OLD.section_id IS NOT NULL THEN
      UPDATE program_sections
      SET current_students = GREATEST(0, current_students - 1)
      WHERE id = OLD.section_id;
    END IF;
    IF NEW.section_id IS NOT NULL THEN
      UPDATE program_sections
      SET current_students = current_students + 1
      WHERE id = NEW.section_id;
    END IF;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_session_attendance_stats()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Update attendance counts for the session
    UPDATE college_attendance_sessions 
    SET 
        present_count = (
            SELECT COUNT(*) FROM college_attendance_records 
            WHERE session_id = COALESCE(NEW.session_id, OLD.session_id) 
            AND status = 'present'
        ),
        absent_count = (
            SELECT COUNT(*) FROM college_attendance_records 
            WHERE session_id = COALESCE(NEW.session_id, OLD.session_id) 
            AND status = 'absent'
        ),
        late_count = (
            SELECT COUNT(*) FROM college_attendance_records 
            WHERE session_id = COALESCE(NEW.session_id, OLD.session_id) 
            AND status = 'late'
        ),
        excused_count = (
            SELECT COUNT(*) FROM college_attendance_records 
            WHERE session_id = COALESCE(NEW.session_id, OLD.session_id) 
            AND status = 'excused'
        ),
        updated_at = NOW()
    WHERE id = COALESCE(NEW.session_id, OLD.session_id);
    
    -- Calculate attendance percentage
    UPDATE college_attendance_sessions 
    SET attendance_percentage = CASE 
        WHEN total_students > 0 THEN 
            ROUND(((present_count + late_count + excused_count) * 100.0 / total_students), 2)
        ELSE 0 
    END
    WHERE id = COALESCE(NEW.session_id, OLD.session_id);
    
    RETURN COALESCE(NEW, OLD);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_streak_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_student_course_progress_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_student_grade_on_promotion()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Only update if student is promoted and to_grade is set
    IF NEW.is_promoted = true AND NEW.to_grade IS NOT NULL THEN
        UPDATE students
        SET 
            grade = NEW.to_grade,
            grade_start_date = COALESCE(NEW.promotion_date, CURRENT_DATE),
            updated_at = NOW()
        WHERE id = NEW.student_id;
        
        RAISE NOTICE 'Student % promoted from grade % to grade %', NEW.student_id, NEW.from_grade, NEW.to_grade;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_student_promotions_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_student_streak(p_student_id uuid, p_activity_date date DEFAULT CURRENT_DATE)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_streak_record RECORD;
  v_new_streak INTEGER;
  v_new_longest INTEGER;
  v_result JSONB;
BEGIN
  -- Get current streak record
  SELECT * INTO v_streak_record
  FROM student_streaks
  WHERE student_id = p_student_id;

  -- If no record exists, create one
  IF NOT FOUND THEN
    INSERT INTO student_streaks (student_id, current_streak, longest_streak, last_activity_date, streak_completed_today)
    VALUES (p_student_id, 1, 1, p_activity_date, TRUE)
    RETURNING current_streak, longest_streak INTO v_new_streak, v_new_longest;

    RETURN jsonb_build_object(
      'success', TRUE,
      'current_streak', v_new_streak,
      'longest_streak', v_new_longest,
      'streak_broken', FALSE
    );
  END IF;

  -- Check if activity is for today
  IF p_activity_date = CURRENT_DATE THEN
    -- Check if already completed today
    IF v_streak_record.streak_completed_today = TRUE THEN
      RETURN jsonb_build_object(
        'success', TRUE,
        'current_streak', v_streak_record.current_streak,
        'longest_streak', v_streak_record.longest_streak,
        'streak_broken', FALSE,
        'message', 'Already completed today'
      );
    END IF;

    -- Check if this continues the streak
    IF v_streak_record.last_activity_date = CURRENT_DATE - INTERVAL '1 day'
       OR v_streak_record.last_activity_date = CURRENT_DATE
       OR v_streak_record.last_activity_date IS NULL THEN
      -- Continue streak
      v_new_streak := v_streak_record.current_streak + 1;
    ELSE
      -- Streak broken, restart
      v_new_streak := 1;
    END IF;

    -- Update longest streak if needed
    v_new_longest := GREATEST(v_streak_record.longest_streak, v_new_streak);

    -- Update the record
    UPDATE student_streaks
    SET
      current_streak = v_new_streak,
      longest_streak = v_new_longest,
      last_activity_date = p_activity_date,
      streak_completed_today = TRUE
    WHERE student_id = p_student_id;

    RETURN jsonb_build_object(
      'success', TRUE,
      'current_streak', v_new_streak,
      'longest_streak', v_new_longest,
      'streak_broken', v_new_streak = 1 AND v_streak_record.current_streak > 1
    );
  END IF;

  -- If activity is not for today, just return current state
  RETURN jsonb_build_object(
    'success', FALSE,
    'message', 'Activity date is not today',
    'current_streak', v_streak_record.current_streak,
    'longest_streak', v_streak_record.longest_streak
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_students_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW."updatedAt" = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_subscription_plans_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_swap_request_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_tutor_conversations_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_has_license_for_org_subscription(org_sub_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1 FROM license_assignments la
    WHERE la.organization_subscription_id = org_sub_id
    AND la.user_id = auth.uid()
    AND la.status = 'active'
  );
$function$
;

CREATE OR REPLACE FUNCTION public."validateOneActiveEnrollment"()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_activeCount INTEGER;
BEGIN
    -- Count active enrollments for this student
    SELECT COUNT(*) INTO v_activeCount
    FROM "studentEnrollments"
    WHERE "studentId" = NEW."studentId"
    AND "enrollmentStatus" = 'active'
    AND id != NEW.id;  -- Exclude current enrollment being updated/inserted

    -- If trying to add/update to active and there's already an active enrollment
    IF NEW."enrollmentStatus" = 'active' AND v_activeCount > 0 THEN
        RAISE EXCEPTION 'Student already has an active enrollment. Only one active enrollment allowed per student.';
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_aadhar_number(aadhar_num text)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Check if it's exactly 12 digits
  IF aadhar_num IS NULL OR LENGTH(aadhar_num) != 12 THEN
    RETURN FALSE;
  END IF;
  
  -- Check if all characters are digits
  IF aadhar_num !~ '^[0-9]{12}$' THEN
    RETURN FALSE;
  END IF;
  
  -- Basic Aadhar validation: first digit cannot be 0 or 1
  IF SUBSTRING(aadhar_num, 1, 1) IN ('0', '1') THEN
    RETURN FALSE;
  END IF;
  
  RETURN TRUE;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_curriculum(p_curriculum_id uuid)
 RETURNS TABLE(is_valid boolean, validation_errors jsonb)
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_errors JSONB := '[]'::jsonb;
  v_chapter_count INTEGER;
  v_outcome_count INTEGER;
  v_outcomes_without_assessments INTEGER;
BEGIN
  -- Check if curriculum has chapters
  SELECT COUNT(*) INTO v_chapter_count
  FROM curriculum_chapters
  WHERE curriculum_id = p_curriculum_id;
  
  IF v_chapter_count = 0 THEN
    v_errors := v_errors || jsonb_build_object('field', 'chapters', 'message', 'At least one chapter is required');
  END IF;
  
  -- Check if curriculum has learning outcomes
  SELECT COUNT(*) INTO v_outcome_count
  FROM curriculum_learning_outcomes clo
  JOIN curriculum_chapters cc ON clo.chapter_id = cc.id
  WHERE cc.curriculum_id = p_curriculum_id;
  
  IF v_outcome_count = 0 THEN
    v_errors := v_errors || jsonb_build_object('field', 'outcomes', 'message', 'Learning Outcomes cannot be empty');
  END IF;
  
  -- Check if all outcomes have at least one assessment mapping
  SELECT COUNT(*) INTO v_outcomes_without_assessments
  FROM curriculum_learning_outcomes clo
  JOIN curriculum_chapters cc ON clo.chapter_id = cc.id
  WHERE cc.curriculum_id = p_curriculum_id
  AND NOT EXISTS (
    SELECT 1 FROM outcome_assessment_mappings oam
    WHERE oam.learning_outcome_id = clo.id
  );
  
  IF v_outcomes_without_assessments > 0 THEN
    v_errors := v_errors || jsonb_build_object(
      'field', 'assessments', 
      'message', v_outcomes_without_assessments || ' learning outcome(s) missing assessment mappings'
    );
  END IF;
  
  RETURN QUERY SELECT 
    jsonb_array_length(v_errors) = 0 AS is_valid,
    v_errors AS validation_errors;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_evaluation_items()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  total_percentage NUMERIC;
BEGIN
  -- Calculate total percentage from evaluation_items
  IF NEW.evaluation_items IS NOT NULL AND jsonb_array_length(NEW.evaluation_items) > 0 THEN
    SELECT SUM((item->>'percentage')::NUMERIC)
    INTO total_percentage
    FROM jsonb_array_elements(NEW.evaluation_items) AS item;
    
    -- Check if total exceeds 100%
    IF total_percentage > 100 THEN
      RAISE EXCEPTION 'Total evaluation percentage cannot exceed 100%%. Current total: %', total_percentage;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_pool_allocation()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  total_allocated INTEGER;
  subscription_seats INTEGER;
BEGIN
  -- Get total allocated seats across all pools for this subscription
  SELECT COALESCE(SUM(allocated_seats), 0) INTO total_allocated
  FROM license_pools
  WHERE organization_subscription_id = NEW.organization_subscription_id
    AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::UUID);
  
  -- Get total seats from subscription
  SELECT total_seats INTO subscription_seats
  FROM organization_subscriptions
  WHERE id = NEW.organization_subscription_id;
  
  -- Check if total allocation exceeds subscription seats
  IF (total_allocated + NEW.allocated_seats) > subscription_seats THEN
    RAISE EXCEPTION 'Total pool allocation (%) exceeds subscription seats (%)', 
      (total_allocated + NEW.allocated_seats), subscription_seats;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_seat_availability()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  available INTEGER;
BEGIN
  IF TG_OP = 'INSERT' AND NEW.status = 'active' THEN
    SELECT available_seats INTO available
    FROM license_pools
    WHERE id = NEW.license_pool_id;
    
    IF available <= 0 THEN
      RAISE EXCEPTION 'No available seats in license pool. Available: %, Requested: 1', available;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_student_competition_school()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    comp_school_id UUID;
    student_school_id UUID;
BEGIN
    -- Get the school_id from the competition
    SELECT school_id INTO comp_school_id
    FROM public.competitions
    WHERE comp_id = NEW.comp_id;
    
    -- Get the school_id from the student
    SELECT school_id INTO student_school_id
    FROM public.students
    WHERE email = NEW.student_email;
    
    -- Check if student has a school_id
    IF student_school_id IS NULL THEN
        RAISE EXCEPTION 'Student % does not belong to any school', NEW.student_email;
    END IF;
    
    -- Check if schools match
    IF comp_school_id != student_school_id THEN
        RAISE EXCEPTION 'Student % (school: %) cannot register for competition from different school (%)', 
            NEW.student_email, student_school_id, comp_school_id;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_student_school_match()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    club_school_id UUID;
    student_school_id UUID;
BEGIN
    -- Get the school_id from the club
    SELECT school_id INTO club_school_id
    FROM public.clubs
    WHERE club_id = NEW.club_id;
    
    -- Get the school_id from the student
    SELECT school_id INTO student_school_id
    FROM public.students
    WHERE email = NEW.student_email;
    
    -- Check if student has a school_id
    IF student_school_id IS NULL THEN
        RAISE EXCEPTION 'Student % does not belong to any school', NEW.student_email;
    END IF;
    
    -- Check if schools match
    IF club_school_id != student_school_id THEN
        RAISE EXCEPTION 'Student % (school: %) cannot join club from different school (%)', 
            NEW.student_email, student_school_id, club_school_id;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validate_subscription_status_transition()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  old_status subscription_status;
  new_status subscription_status;
BEGIN
  old_status := OLD.status;
  new_status := NEW.status;
  
  -- If status hasn't changed, allow it
  IF old_status = new_status THEN
    RETURN NEW;
  END IF;
  
  -- Define invalid transitions
  -- Expired subscriptions cannot be reactivated
  IF old_status = 'expired' AND new_status IN ('active', 'pending') THEN
    RAISE EXCEPTION 'Cannot reactivate expired subscription. Create a new subscription instead.'
      USING HINT = 'Create new subscription',
            ERRCODE = '23514'; -- check_violation
  END IF;
  
  -- Cancelled subscriptions can only go to expired
  IF old_status = 'cancelled' AND new_status NOT IN ('expired', 'cancelled') THEN
    RAISE EXCEPTION 'Cancelled subscription can only transition to expired status'
      USING HINT = 'Create new subscription to reactivate',
            ERRCODE = '23514';
  END IF;
  
  -- Pending can only go to active or expired
  IF old_status = 'pending' AND new_status NOT IN ('active', 'expired', 'pending') THEN
    RAISE EXCEPTION 'Pending subscription can only become active or expired'
      USING HINT = 'Invalid status transition',
            ERRCODE = '23514';
  END IF;
  
  -- Log the transition (optional - good for debugging)
  RAISE NOTICE 'Subscription status transition: %  % for user %', 
    old_status, new_status, NEW.user_id;
  
  RETURN NEW;
END;
$function$
;

create or replace view "public"."library_stats" as  SELECT ( SELECT count(*) AS count
           FROM public.library_books) AS total_books,
    ( SELECT sum(library_books.total_copies) AS sum
           FROM public.library_books) AS total_copies,
    ( SELECT sum(library_books.available_copies) AS sum
           FROM public.library_books) AS available_copies,
    ( SELECT count(*) AS count
           FROM public.library_book_issues
          WHERE (library_book_issues.status = 'issued'::text)) AS currently_issued,
    ( SELECT count(*) AS count
           FROM public.overdue_books) AS overdue_count,
    ( SELECT sum(overdue_books.current_fine) AS sum
           FROM public.overdue_books) AS total_pending_fines;


create or replace view "public"."library_stats_college" as  SELECT college_id,
    ( SELECT count(*) AS count
           FROM public.library_books_college
          WHERE (library_books_college.college_id = main.college_id)) AS total_books,
    ( SELECT sum(library_books_college.total_copies) AS sum
           FROM public.library_books_college
          WHERE (library_books_college.college_id = main.college_id)) AS total_copies,
    ( SELECT sum(library_books_college.available_copies) AS sum
           FROM public.library_books_college
          WHERE (library_books_college.college_id = main.college_id)) AS available_copies,
    ( SELECT count(*) AS count
           FROM public.library_book_issues_college
          WHERE ((library_book_issues_college.college_id = main.college_id) AND (library_book_issues_college.status = 'issued'::text))) AS currently_issued,
    ( SELECT count(*) AS count
           FROM public.overdue_books_college
          WHERE (overdue_books_college.college_id = main.college_id)) AS overdue_count,
    ( SELECT COALESCE(sum(overdue_books_college.current_fine), (0)::numeric) AS "coalesce"
           FROM public.overdue_books_college
          WHERE (overdue_books_college.college_id = main.college_id)) AS total_pending_fines
   FROM ( SELECT DISTINCT library_books_college.college_id
           FROM public.library_books_college
        UNION
         SELECT DISTINCT library_book_issues_college.college_id
           FROM public.library_book_issues_college) main;


create or replace view "public"."library_stats_school" as  SELECT school_id,
    ( SELECT count(*) AS count
           FROM public.library_books_school lbs
          WHERE (lbs.school_id = main.school_id)) AS total_books,
    ( SELECT sum(lbs.total_copies) AS sum
           FROM public.library_books_school lbs
          WHERE (lbs.school_id = main.school_id)) AS total_copies,
    ( SELECT sum(lbs.available_copies) AS sum
           FROM public.library_books_school lbs
          WHERE (lbs.school_id = main.school_id)) AS available_copies,
    ( SELECT count(*) AS count
           FROM public.library_book_issues_school lbis
          WHERE ((lbis.school_id = main.school_id) AND (lbis.status = 'issued'::text))) AS currently_issued,
    ( SELECT count(*) AS count
           FROM public.overdue_books_school obs
          WHERE (obs.school_id = main.school_id)) AS overdue_count,
    ( SELECT sum(obs.current_fine) AS sum
           FROM public.overdue_books_school obs
          WHERE (obs.school_id = main.school_id)) AS total_pending_fines
   FROM ( SELECT DISTINCT library_books_school.school_id
           FROM public.library_books_school
        UNION
         SELECT DISTINCT library_book_issues_school.school_id
           FROM public.library_book_issues_school) main;


grant delete on table "public"."adaptive_aptitude_questions_cache" to "anon";

grant insert on table "public"."adaptive_aptitude_questions_cache" to "anon";

grant references on table "public"."adaptive_aptitude_questions_cache" to "anon";

grant select on table "public"."adaptive_aptitude_questions_cache" to "anon";

grant trigger on table "public"."adaptive_aptitude_questions_cache" to "anon";

grant truncate on table "public"."adaptive_aptitude_questions_cache" to "anon";

grant update on table "public"."adaptive_aptitude_questions_cache" to "anon";

grant delete on table "public"."adaptive_aptitude_questions_cache" to "authenticated";

grant insert on table "public"."adaptive_aptitude_questions_cache" to "authenticated";

grant references on table "public"."adaptive_aptitude_questions_cache" to "authenticated";

grant select on table "public"."adaptive_aptitude_questions_cache" to "authenticated";

grant trigger on table "public"."adaptive_aptitude_questions_cache" to "authenticated";

grant truncate on table "public"."adaptive_aptitude_questions_cache" to "authenticated";

grant update on table "public"."adaptive_aptitude_questions_cache" to "authenticated";

grant delete on table "public"."adaptive_aptitude_questions_cache" to "service_role";

grant insert on table "public"."adaptive_aptitude_questions_cache" to "service_role";

grant references on table "public"."adaptive_aptitude_questions_cache" to "service_role";

grant select on table "public"."adaptive_aptitude_questions_cache" to "service_role";

grant trigger on table "public"."adaptive_aptitude_questions_cache" to "service_role";

grant truncate on table "public"."adaptive_aptitude_questions_cache" to "service_role";

grant update on table "public"."adaptive_aptitude_questions_cache" to "service_role";

grant delete on table "public"."adaptive_aptitude_responses" to "anon";

grant insert on table "public"."adaptive_aptitude_responses" to "anon";

grant references on table "public"."adaptive_aptitude_responses" to "anon";

grant select on table "public"."adaptive_aptitude_responses" to "anon";

grant trigger on table "public"."adaptive_aptitude_responses" to "anon";

grant truncate on table "public"."adaptive_aptitude_responses" to "anon";

grant update on table "public"."adaptive_aptitude_responses" to "anon";

grant delete on table "public"."adaptive_aptitude_responses" to "authenticated";

grant insert on table "public"."adaptive_aptitude_responses" to "authenticated";

grant references on table "public"."adaptive_aptitude_responses" to "authenticated";

grant select on table "public"."adaptive_aptitude_responses" to "authenticated";

grant trigger on table "public"."adaptive_aptitude_responses" to "authenticated";

grant truncate on table "public"."adaptive_aptitude_responses" to "authenticated";

grant update on table "public"."adaptive_aptitude_responses" to "authenticated";

grant delete on table "public"."adaptive_aptitude_responses" to "service_role";

grant insert on table "public"."adaptive_aptitude_responses" to "service_role";

grant references on table "public"."adaptive_aptitude_responses" to "service_role";

grant select on table "public"."adaptive_aptitude_responses" to "service_role";

grant trigger on table "public"."adaptive_aptitude_responses" to "service_role";

grant truncate on table "public"."adaptive_aptitude_responses" to "service_role";

grant update on table "public"."adaptive_aptitude_responses" to "service_role";

grant delete on table "public"."adaptive_aptitude_results" to "anon";

grant insert on table "public"."adaptive_aptitude_results" to "anon";

grant references on table "public"."adaptive_aptitude_results" to "anon";

grant select on table "public"."adaptive_aptitude_results" to "anon";

grant trigger on table "public"."adaptive_aptitude_results" to "anon";

grant truncate on table "public"."adaptive_aptitude_results" to "anon";

grant update on table "public"."adaptive_aptitude_results" to "anon";

grant delete on table "public"."adaptive_aptitude_results" to "authenticated";

grant insert on table "public"."adaptive_aptitude_results" to "authenticated";

grant references on table "public"."adaptive_aptitude_results" to "authenticated";

grant select on table "public"."adaptive_aptitude_results" to "authenticated";

grant trigger on table "public"."adaptive_aptitude_results" to "authenticated";

grant truncate on table "public"."adaptive_aptitude_results" to "authenticated";

grant update on table "public"."adaptive_aptitude_results" to "authenticated";

grant delete on table "public"."adaptive_aptitude_results" to "service_role";

grant insert on table "public"."adaptive_aptitude_results" to "service_role";

grant references on table "public"."adaptive_aptitude_results" to "service_role";

grant select on table "public"."adaptive_aptitude_results" to "service_role";

grant trigger on table "public"."adaptive_aptitude_results" to "service_role";

grant truncate on table "public"."adaptive_aptitude_results" to "service_role";

grant update on table "public"."adaptive_aptitude_results" to "service_role";

grant delete on table "public"."adaptive_aptitude_sessions" to "anon";

grant insert on table "public"."adaptive_aptitude_sessions" to "anon";

grant references on table "public"."adaptive_aptitude_sessions" to "anon";

grant select on table "public"."adaptive_aptitude_sessions" to "anon";

grant trigger on table "public"."adaptive_aptitude_sessions" to "anon";

grant truncate on table "public"."adaptive_aptitude_sessions" to "anon";

grant update on table "public"."adaptive_aptitude_sessions" to "anon";

grant delete on table "public"."adaptive_aptitude_sessions" to "authenticated";

grant insert on table "public"."adaptive_aptitude_sessions" to "authenticated";

grant references on table "public"."adaptive_aptitude_sessions" to "authenticated";

grant select on table "public"."adaptive_aptitude_sessions" to "authenticated";

grant trigger on table "public"."adaptive_aptitude_sessions" to "authenticated";

grant truncate on table "public"."adaptive_aptitude_sessions" to "authenticated";

grant update on table "public"."adaptive_aptitude_sessions" to "authenticated";

grant delete on table "public"."adaptive_aptitude_sessions" to "service_role";

grant insert on table "public"."adaptive_aptitude_sessions" to "service_role";

grant references on table "public"."adaptive_aptitude_sessions" to "service_role";

grant select on table "public"."adaptive_aptitude_sessions" to "service_role";

grant trigger on table "public"."adaptive_aptitude_sessions" to "service_role";

grant truncate on table "public"."adaptive_aptitude_sessions" to "service_role";

grant update on table "public"."adaptive_aptitude_sessions" to "service_role";

grant delete on table "public"."addon_discount_codes" to "anon";

grant insert on table "public"."addon_discount_codes" to "anon";

grant references on table "public"."addon_discount_codes" to "anon";

grant select on table "public"."addon_discount_codes" to "anon";

grant trigger on table "public"."addon_discount_codes" to "anon";

grant truncate on table "public"."addon_discount_codes" to "anon";

grant update on table "public"."addon_discount_codes" to "anon";

grant delete on table "public"."addon_discount_codes" to "authenticated";

grant insert on table "public"."addon_discount_codes" to "authenticated";

grant references on table "public"."addon_discount_codes" to "authenticated";

grant select on table "public"."addon_discount_codes" to "authenticated";

grant trigger on table "public"."addon_discount_codes" to "authenticated";

grant truncate on table "public"."addon_discount_codes" to "authenticated";

grant update on table "public"."addon_discount_codes" to "authenticated";

grant delete on table "public"."addon_discount_codes" to "service_role";

grant insert on table "public"."addon_discount_codes" to "service_role";

grant references on table "public"."addon_discount_codes" to "service_role";

grant select on table "public"."addon_discount_codes" to "service_role";

grant trigger on table "public"."addon_discount_codes" to "service_role";

grant truncate on table "public"."addon_discount_codes" to "service_role";

grant update on table "public"."addon_discount_codes" to "service_role";

grant delete on table "public"."addon_events" to "anon";

grant insert on table "public"."addon_events" to "anon";

grant references on table "public"."addon_events" to "anon";

grant select on table "public"."addon_events" to "anon";

grant trigger on table "public"."addon_events" to "anon";

grant truncate on table "public"."addon_events" to "anon";

grant update on table "public"."addon_events" to "anon";

grant delete on table "public"."addon_events" to "authenticated";

grant insert on table "public"."addon_events" to "authenticated";

grant references on table "public"."addon_events" to "authenticated";

grant select on table "public"."addon_events" to "authenticated";

grant trigger on table "public"."addon_events" to "authenticated";

grant truncate on table "public"."addon_events" to "authenticated";

grant update on table "public"."addon_events" to "authenticated";

grant delete on table "public"."addon_events" to "service_role";

grant insert on table "public"."addon_events" to "service_role";

grant references on table "public"."addon_events" to "service_role";

grant select on table "public"."addon_events" to "service_role";

grant trigger on table "public"."addon_events" to "service_role";

grant truncate on table "public"."addon_events" to "service_role";

grant update on table "public"."addon_events" to "service_role";

grant delete on table "public"."addon_pending_orders" to "anon";

grant insert on table "public"."addon_pending_orders" to "anon";

grant references on table "public"."addon_pending_orders" to "anon";

grant select on table "public"."addon_pending_orders" to "anon";

grant trigger on table "public"."addon_pending_orders" to "anon";

grant truncate on table "public"."addon_pending_orders" to "anon";

grant update on table "public"."addon_pending_orders" to "anon";

grant delete on table "public"."addon_pending_orders" to "authenticated";

grant insert on table "public"."addon_pending_orders" to "authenticated";

grant references on table "public"."addon_pending_orders" to "authenticated";

grant select on table "public"."addon_pending_orders" to "authenticated";

grant trigger on table "public"."addon_pending_orders" to "authenticated";

grant truncate on table "public"."addon_pending_orders" to "authenticated";

grant update on table "public"."addon_pending_orders" to "authenticated";

grant delete on table "public"."addon_pending_orders" to "service_role";

grant insert on table "public"."addon_pending_orders" to "service_role";

grant references on table "public"."addon_pending_orders" to "service_role";

grant select on table "public"."addon_pending_orders" to "service_role";

grant trigger on table "public"."addon_pending_orders" to "service_role";

grant truncate on table "public"."addon_pending_orders" to "service_role";

grant update on table "public"."addon_pending_orders" to "service_role";

grant delete on table "public"."admin_users" to "anon";

grant insert on table "public"."admin_users" to "anon";

grant references on table "public"."admin_users" to "anon";

grant select on table "public"."admin_users" to "anon";

grant trigger on table "public"."admin_users" to "anon";

grant truncate on table "public"."admin_users" to "anon";

grant update on table "public"."admin_users" to "anon";

grant delete on table "public"."admin_users" to "authenticated";

grant insert on table "public"."admin_users" to "authenticated";

grant references on table "public"."admin_users" to "authenticated";

grant select on table "public"."admin_users" to "authenticated";

grant trigger on table "public"."admin_users" to "authenticated";

grant truncate on table "public"."admin_users" to "authenticated";

grant update on table "public"."admin_users" to "authenticated";

grant delete on table "public"."admin_users" to "service_role";

grant insert on table "public"."admin_users" to "service_role";

grant references on table "public"."admin_users" to "service_role";

grant select on table "public"."admin_users" to "service_role";

grant trigger on table "public"."admin_users" to "service_role";

grant truncate on table "public"."admin_users" to "service_role";

grant update on table "public"."admin_users" to "service_role";

grant delete on table "public"."admission_applications" to "anon";

grant insert on table "public"."admission_applications" to "anon";

grant references on table "public"."admission_applications" to "anon";

grant select on table "public"."admission_applications" to "anon";

grant trigger on table "public"."admission_applications" to "anon";

grant truncate on table "public"."admission_applications" to "anon";

grant update on table "public"."admission_applications" to "anon";

grant delete on table "public"."admission_applications" to "authenticated";

grant insert on table "public"."admission_applications" to "authenticated";

grant references on table "public"."admission_applications" to "authenticated";

grant select on table "public"."admission_applications" to "authenticated";

grant trigger on table "public"."admission_applications" to "authenticated";

grant truncate on table "public"."admission_applications" to "authenticated";

grant update on table "public"."admission_applications" to "authenticated";

grant delete on table "public"."admission_applications" to "service_role";

grant insert on table "public"."admission_applications" to "service_role";

grant references on table "public"."admission_applications" to "service_role";

grant select on table "public"."admission_applications" to "service_role";

grant trigger on table "public"."admission_applications" to "service_role";

grant truncate on table "public"."admission_applications" to "service_role";

grant update on table "public"."admission_applications" to "service_role";

grant delete on table "public"."ai_evaluations" to "anon";

grant insert on table "public"."ai_evaluations" to "anon";

grant references on table "public"."ai_evaluations" to "anon";

grant select on table "public"."ai_evaluations" to "anon";

grant trigger on table "public"."ai_evaluations" to "anon";

grant truncate on table "public"."ai_evaluations" to "anon";

grant update on table "public"."ai_evaluations" to "anon";

grant delete on table "public"."ai_evaluations" to "authenticated";

grant insert on table "public"."ai_evaluations" to "authenticated";

grant references on table "public"."ai_evaluations" to "authenticated";

grant select on table "public"."ai_evaluations" to "authenticated";

grant trigger on table "public"."ai_evaluations" to "authenticated";

grant truncate on table "public"."ai_evaluations" to "authenticated";

grant update on table "public"."ai_evaluations" to "authenticated";

grant delete on table "public"."ai_evaluations" to "service_role";

grant insert on table "public"."ai_evaluations" to "service_role";

grant references on table "public"."ai_evaluations" to "service_role";

grant select on table "public"."ai_evaluations" to "service_role";

grant trigger on table "public"."ai_evaluations" to "service_role";

grant truncate on table "public"."ai_evaluations" to "service_role";

grant update on table "public"."ai_evaluations" to "service_role";

grant delete on table "public"."app_config" to "anon";

grant insert on table "public"."app_config" to "anon";

grant references on table "public"."app_config" to "anon";

grant select on table "public"."app_config" to "anon";

grant trigger on table "public"."app_config" to "anon";

grant truncate on table "public"."app_config" to "anon";

grant update on table "public"."app_config" to "anon";

grant delete on table "public"."app_config" to "authenticated";

grant insert on table "public"."app_config" to "authenticated";

grant references on table "public"."app_config" to "authenticated";

grant select on table "public"."app_config" to "authenticated";

grant trigger on table "public"."app_config" to "authenticated";

grant truncate on table "public"."app_config" to "authenticated";

grant update on table "public"."app_config" to "authenticated";

grant delete on table "public"."app_config" to "service_role";

grant insert on table "public"."app_config" to "service_role";

grant references on table "public"."app_config" to "service_role";

grant select on table "public"."app_config" to "service_role";

grant trigger on table "public"."app_config" to "service_role";

grant truncate on table "public"."app_config" to "service_role";

grant update on table "public"."app_config" to "service_role";

grant delete on table "public"."applied_jobs" to "anon";

grant insert on table "public"."applied_jobs" to "anon";

grant references on table "public"."applied_jobs" to "anon";

grant select on table "public"."applied_jobs" to "anon";

grant trigger on table "public"."applied_jobs" to "anon";

grant truncate on table "public"."applied_jobs" to "anon";

grant update on table "public"."applied_jobs" to "anon";

grant delete on table "public"."applied_jobs" to "authenticated";

grant insert on table "public"."applied_jobs" to "authenticated";

grant references on table "public"."applied_jobs" to "authenticated";

grant select on table "public"."applied_jobs" to "authenticated";

grant trigger on table "public"."applied_jobs" to "authenticated";

grant truncate on table "public"."applied_jobs" to "authenticated";

grant update on table "public"."applied_jobs" to "authenticated";

grant delete on table "public"."applied_jobs" to "service_role";

grant insert on table "public"."applied_jobs" to "service_role";

grant references on table "public"."applied_jobs" to "service_role";

grant select on table "public"."applied_jobs" to "service_role";

grant trigger on table "public"."applied_jobs" to "service_role";

grant truncate on table "public"."applied_jobs" to "service_role";

grant update on table "public"."applied_jobs" to "service_role";

grant delete on table "public"."applied_jobs_backup_migration" to "anon";

grant insert on table "public"."applied_jobs_backup_migration" to "anon";

grant references on table "public"."applied_jobs_backup_migration" to "anon";

grant select on table "public"."applied_jobs_backup_migration" to "anon";

grant trigger on table "public"."applied_jobs_backup_migration" to "anon";

grant truncate on table "public"."applied_jobs_backup_migration" to "anon";

grant update on table "public"."applied_jobs_backup_migration" to "anon";

grant delete on table "public"."applied_jobs_backup_migration" to "authenticated";

grant insert on table "public"."applied_jobs_backup_migration" to "authenticated";

grant references on table "public"."applied_jobs_backup_migration" to "authenticated";

grant select on table "public"."applied_jobs_backup_migration" to "authenticated";

grant trigger on table "public"."applied_jobs_backup_migration" to "authenticated";

grant truncate on table "public"."applied_jobs_backup_migration" to "authenticated";

grant update on table "public"."applied_jobs_backup_migration" to "authenticated";

grant delete on table "public"."applied_jobs_backup_migration" to "service_role";

grant insert on table "public"."applied_jobs_backup_migration" to "service_role";

grant references on table "public"."applied_jobs_backup_migration" to "service_role";

grant select on table "public"."applied_jobs_backup_migration" to "service_role";

grant trigger on table "public"."applied_jobs_backup_migration" to "service_role";

grant truncate on table "public"."applied_jobs_backup_migration" to "service_role";

grant update on table "public"."applied_jobs_backup_migration" to "service_role";

grant delete on table "public"."approval_actions" to "anon";

grant insert on table "public"."approval_actions" to "anon";

grant references on table "public"."approval_actions" to "anon";

grant select on table "public"."approval_actions" to "anon";

grant trigger on table "public"."approval_actions" to "anon";

grant truncate on table "public"."approval_actions" to "anon";

grant update on table "public"."approval_actions" to "anon";

grant delete on table "public"."approval_actions" to "authenticated";

grant insert on table "public"."approval_actions" to "authenticated";

grant references on table "public"."approval_actions" to "authenticated";

grant select on table "public"."approval_actions" to "authenticated";

grant trigger on table "public"."approval_actions" to "authenticated";

grant truncate on table "public"."approval_actions" to "authenticated";

grant update on table "public"."approval_actions" to "authenticated";

grant delete on table "public"."approval_actions" to "service_role";

grant insert on table "public"."approval_actions" to "service_role";

grant references on table "public"."approval_actions" to "service_role";

grant select on table "public"."approval_actions" to "service_role";

grant trigger on table "public"."approval_actions" to "service_role";

grant truncate on table "public"."approval_actions" to "service_role";

grant update on table "public"."approval_actions" to "service_role";

grant delete on table "public"."approval_requests" to "anon";

grant insert on table "public"."approval_requests" to "anon";

grant references on table "public"."approval_requests" to "anon";

grant select on table "public"."approval_requests" to "anon";

grant trigger on table "public"."approval_requests" to "anon";

grant truncate on table "public"."approval_requests" to "anon";

grant update on table "public"."approval_requests" to "anon";

grant delete on table "public"."approval_requests" to "authenticated";

grant insert on table "public"."approval_requests" to "authenticated";

grant references on table "public"."approval_requests" to "authenticated";

grant select on table "public"."approval_requests" to "authenticated";

grant trigger on table "public"."approval_requests" to "authenticated";

grant truncate on table "public"."approval_requests" to "authenticated";

grant update on table "public"."approval_requests" to "authenticated";

grant delete on table "public"."approval_requests" to "service_role";

grant insert on table "public"."approval_requests" to "service_role";

grant references on table "public"."approval_requests" to "service_role";

grant select on table "public"."approval_requests" to "service_role";

grant trigger on table "public"."approval_requests" to "service_role";

grant truncate on table "public"."approval_requests" to "service_role";

grant update on table "public"."approval_requests" to "service_role";

grant delete on table "public"."approval_types" to "anon";

grant insert on table "public"."approval_types" to "anon";

grant references on table "public"."approval_types" to "anon";

grant select on table "public"."approval_types" to "anon";

grant trigger on table "public"."approval_types" to "anon";

grant truncate on table "public"."approval_types" to "anon";

grant update on table "public"."approval_types" to "anon";

grant delete on table "public"."approval_types" to "authenticated";

grant insert on table "public"."approval_types" to "authenticated";

grant references on table "public"."approval_types" to "authenticated";

grant select on table "public"."approval_types" to "authenticated";

grant trigger on table "public"."approval_types" to "authenticated";

grant truncate on table "public"."approval_types" to "authenticated";

grant update on table "public"."approval_types" to "authenticated";

grant delete on table "public"."approval_types" to "service_role";

grant insert on table "public"."approval_types" to "service_role";

grant references on table "public"."approval_types" to "service_role";

grant select on table "public"."approval_types" to "service_role";

grant trigger on table "public"."approval_types" to "service_role";

grant truncate on table "public"."approval_types" to "service_role";

grant update on table "public"."approval_types" to "service_role";

grant delete on table "public"."approval_workflows" to "anon";

grant insert on table "public"."approval_workflows" to "anon";

grant references on table "public"."approval_workflows" to "anon";

grant select on table "public"."approval_workflows" to "anon";

grant trigger on table "public"."approval_workflows" to "anon";

grant truncate on table "public"."approval_workflows" to "anon";

grant update on table "public"."approval_workflows" to "anon";

grant delete on table "public"."approval_workflows" to "authenticated";

grant insert on table "public"."approval_workflows" to "authenticated";

grant references on table "public"."approval_workflows" to "authenticated";

grant select on table "public"."approval_workflows" to "authenticated";

grant trigger on table "public"."approval_workflows" to "authenticated";

grant truncate on table "public"."approval_workflows" to "authenticated";

grant update on table "public"."approval_workflows" to "authenticated";

grant delete on table "public"."approval_workflows" to "service_role";

grant insert on table "public"."approval_workflows" to "service_role";

grant references on table "public"."approval_workflows" to "service_role";

grant select on table "public"."approval_workflows" to "service_role";

grant trigger on table "public"."approval_workflows" to "service_role";

grant truncate on table "public"."approval_workflows" to "service_role";

grant update on table "public"."approval_workflows" to "service_role";

grant delete on table "public"."assessment_types" to "anon";

grant insert on table "public"."assessment_types" to "anon";

grant references on table "public"."assessment_types" to "anon";

grant select on table "public"."assessment_types" to "anon";

grant trigger on table "public"."assessment_types" to "anon";

grant truncate on table "public"."assessment_types" to "anon";

grant update on table "public"."assessment_types" to "anon";

grant delete on table "public"."assessment_types" to "authenticated";

grant insert on table "public"."assessment_types" to "authenticated";

grant references on table "public"."assessment_types" to "authenticated";

grant select on table "public"."assessment_types" to "authenticated";

grant trigger on table "public"."assessment_types" to "authenticated";

grant truncate on table "public"."assessment_types" to "authenticated";

grant update on table "public"."assessment_types" to "authenticated";

grant delete on table "public"."assessment_types" to "service_role";

grant insert on table "public"."assessment_types" to "service_role";

grant references on table "public"."assessment_types" to "service_role";

grant select on table "public"."assessment_types" to "service_role";

grant trigger on table "public"."assessment_types" to "service_role";

grant truncate on table "public"."assessment_types" to "service_role";

grant update on table "public"."assessment_types" to "service_role";

grant delete on table "public"."assessments" to "anon";

grant insert on table "public"."assessments" to "anon";

grant references on table "public"."assessments" to "anon";

grant select on table "public"."assessments" to "anon";

grant trigger on table "public"."assessments" to "anon";

grant truncate on table "public"."assessments" to "anon";

grant update on table "public"."assessments" to "anon";

grant delete on table "public"."assessments" to "authenticated";

grant insert on table "public"."assessments" to "authenticated";

grant references on table "public"."assessments" to "authenticated";

grant select on table "public"."assessments" to "authenticated";

grant trigger on table "public"."assessments" to "authenticated";

grant truncate on table "public"."assessments" to "authenticated";

grant update on table "public"."assessments" to "authenticated";

grant delete on table "public"."assessments" to "service_role";

grant insert on table "public"."assessments" to "service_role";

grant references on table "public"."assessments" to "service_role";

grant select on table "public"."assessments" to "service_role";

grant trigger on table "public"."assessments" to "service_role";

grant truncate on table "public"."assessments" to "service_role";

grant update on table "public"."assessments" to "service_role";

grant delete on table "public"."assignment_attachments" to "anon";

grant insert on table "public"."assignment_attachments" to "anon";

grant references on table "public"."assignment_attachments" to "anon";

grant select on table "public"."assignment_attachments" to "anon";

grant trigger on table "public"."assignment_attachments" to "anon";

grant truncate on table "public"."assignment_attachments" to "anon";

grant update on table "public"."assignment_attachments" to "anon";

grant delete on table "public"."assignment_attachments" to "authenticated";

grant insert on table "public"."assignment_attachments" to "authenticated";

grant references on table "public"."assignment_attachments" to "authenticated";

grant select on table "public"."assignment_attachments" to "authenticated";

grant trigger on table "public"."assignment_attachments" to "authenticated";

grant truncate on table "public"."assignment_attachments" to "authenticated";

grant update on table "public"."assignment_attachments" to "authenticated";

grant delete on table "public"."assignment_attachments" to "service_role";

grant insert on table "public"."assignment_attachments" to "service_role";

grant references on table "public"."assignment_attachments" to "service_role";

grant select on table "public"."assignment_attachments" to "service_role";

grant trigger on table "public"."assignment_attachments" to "service_role";

grant truncate on table "public"."assignment_attachments" to "service_role";

grant update on table "public"."assignment_attachments" to "service_role";

grant delete on table "public"."assignments" to "anon";

grant insert on table "public"."assignments" to "anon";

grant references on table "public"."assignments" to "anon";

grant select on table "public"."assignments" to "anon";

grant trigger on table "public"."assignments" to "anon";

grant truncate on table "public"."assignments" to "anon";

grant update on table "public"."assignments" to "anon";

grant delete on table "public"."assignments" to "authenticated";

grant insert on table "public"."assignments" to "authenticated";

grant references on table "public"."assignments" to "authenticated";

grant select on table "public"."assignments" to "authenticated";

grant trigger on table "public"."assignments" to "authenticated";

grant truncate on table "public"."assignments" to "authenticated";

grant update on table "public"."assignments" to "authenticated";

grant delete on table "public"."assignments" to "service_role";

grant insert on table "public"."assignments" to "service_role";

grant references on table "public"."assignments" to "service_role";

grant select on table "public"."assignments" to "service_role";

grant trigger on table "public"."assignments" to "service_role";

grant truncate on table "public"."assignments" to "service_role";

grant update on table "public"."assignments" to "service_role";

grant delete on table "public"."attendance_alerts" to "anon";

grant insert on table "public"."attendance_alerts" to "anon";

grant references on table "public"."attendance_alerts" to "anon";

grant select on table "public"."attendance_alerts" to "anon";

grant trigger on table "public"."attendance_alerts" to "anon";

grant truncate on table "public"."attendance_alerts" to "anon";

grant update on table "public"."attendance_alerts" to "anon";

grant delete on table "public"."attendance_alerts" to "authenticated";

grant insert on table "public"."attendance_alerts" to "authenticated";

grant references on table "public"."attendance_alerts" to "authenticated";

grant select on table "public"."attendance_alerts" to "authenticated";

grant trigger on table "public"."attendance_alerts" to "authenticated";

grant truncate on table "public"."attendance_alerts" to "authenticated";

grant update on table "public"."attendance_alerts" to "authenticated";

grant delete on table "public"."attendance_alerts" to "service_role";

grant insert on table "public"."attendance_alerts" to "service_role";

grant references on table "public"."attendance_alerts" to "service_role";

grant select on table "public"."attendance_alerts" to "service_role";

grant trigger on table "public"."attendance_alerts" to "service_role";

grant truncate on table "public"."attendance_alerts" to "service_role";

grant update on table "public"."attendance_alerts" to "service_role";

grant delete on table "public"."attendance_records" to "anon";

grant insert on table "public"."attendance_records" to "anon";

grant references on table "public"."attendance_records" to "anon";

grant select on table "public"."attendance_records" to "anon";

grant trigger on table "public"."attendance_records" to "anon";

grant truncate on table "public"."attendance_records" to "anon";

grant update on table "public"."attendance_records" to "anon";

grant delete on table "public"."attendance_records" to "authenticated";

grant insert on table "public"."attendance_records" to "authenticated";

grant references on table "public"."attendance_records" to "authenticated";

grant select on table "public"."attendance_records" to "authenticated";

grant trigger on table "public"."attendance_records" to "authenticated";

grant truncate on table "public"."attendance_records" to "authenticated";

grant update on table "public"."attendance_records" to "authenticated";

grant delete on table "public"."attendance_records" to "service_role";

grant insert on table "public"."attendance_records" to "service_role";

grant references on table "public"."attendance_records" to "service_role";

grant select on table "public"."attendance_records" to "service_role";

grant trigger on table "public"."attendance_records" to "service_role";

grant truncate on table "public"."attendance_records" to "service_role";

grant update on table "public"."attendance_records" to "service_role";

grant delete on table "public"."audit_logs" to "anon";

grant insert on table "public"."audit_logs" to "anon";

grant references on table "public"."audit_logs" to "anon";

grant select on table "public"."audit_logs" to "anon";

grant trigger on table "public"."audit_logs" to "anon";

grant truncate on table "public"."audit_logs" to "anon";

grant update on table "public"."audit_logs" to "anon";

grant delete on table "public"."audit_logs" to "authenticated";

grant insert on table "public"."audit_logs" to "authenticated";

grant references on table "public"."audit_logs" to "authenticated";

grant select on table "public"."audit_logs" to "authenticated";

grant trigger on table "public"."audit_logs" to "authenticated";

grant truncate on table "public"."audit_logs" to "authenticated";

grant update on table "public"."audit_logs" to "authenticated";

grant delete on table "public"."audit_logs" to "service_role";

grant insert on table "public"."audit_logs" to "service_role";

grant references on table "public"."audit_logs" to "service_role";

grant select on table "public"."audit_logs" to "service_role";

grant trigger on table "public"."audit_logs" to "service_role";

grant truncate on table "public"."audit_logs" to "service_role";

grant update on table "public"."audit_logs" to "service_role";

grant delete on table "public"."budget_alerts" to "anon";

grant insert on table "public"."budget_alerts" to "anon";

grant references on table "public"."budget_alerts" to "anon";

grant select on table "public"."budget_alerts" to "anon";

grant trigger on table "public"."budget_alerts" to "anon";

grant truncate on table "public"."budget_alerts" to "anon";

grant update on table "public"."budget_alerts" to "anon";

grant delete on table "public"."budget_alerts" to "authenticated";

grant insert on table "public"."budget_alerts" to "authenticated";

grant references on table "public"."budget_alerts" to "authenticated";

grant select on table "public"."budget_alerts" to "authenticated";

grant trigger on table "public"."budget_alerts" to "authenticated";

grant truncate on table "public"."budget_alerts" to "authenticated";

grant update on table "public"."budget_alerts" to "authenticated";

grant delete on table "public"."budget_alerts" to "service_role";

grant insert on table "public"."budget_alerts" to "service_role";

grant references on table "public"."budget_alerts" to "service_role";

grant select on table "public"."budget_alerts" to "service_role";

grant trigger on table "public"."budget_alerts" to "service_role";

grant truncate on table "public"."budget_alerts" to "service_role";

grant update on table "public"."budget_alerts" to "service_role";

grant delete on table "public"."budget_revisions" to "anon";

grant insert on table "public"."budget_revisions" to "anon";

grant references on table "public"."budget_revisions" to "anon";

grant select on table "public"."budget_revisions" to "anon";

grant trigger on table "public"."budget_revisions" to "anon";

grant truncate on table "public"."budget_revisions" to "anon";

grant update on table "public"."budget_revisions" to "anon";

grant delete on table "public"."budget_revisions" to "authenticated";

grant insert on table "public"."budget_revisions" to "authenticated";

grant references on table "public"."budget_revisions" to "authenticated";

grant select on table "public"."budget_revisions" to "authenticated";

grant trigger on table "public"."budget_revisions" to "authenticated";

grant truncate on table "public"."budget_revisions" to "authenticated";

grant update on table "public"."budget_revisions" to "authenticated";

grant delete on table "public"."budget_revisions" to "service_role";

grant insert on table "public"."budget_revisions" to "service_role";

grant references on table "public"."budget_revisions" to "service_role";

grant select on table "public"."budget_revisions" to "service_role";

grant trigger on table "public"."budget_revisions" to "service_role";

grant truncate on table "public"."budget_revisions" to "service_role";

grant update on table "public"."budget_revisions" to "service_role";

grant delete on table "public"."bundle_features" to "anon";

grant insert on table "public"."bundle_features" to "anon";

grant references on table "public"."bundle_features" to "anon";

grant select on table "public"."bundle_features" to "anon";

grant trigger on table "public"."bundle_features" to "anon";

grant truncate on table "public"."bundle_features" to "anon";

grant update on table "public"."bundle_features" to "anon";

grant delete on table "public"."bundle_features" to "authenticated";

grant insert on table "public"."bundle_features" to "authenticated";

grant references on table "public"."bundle_features" to "authenticated";

grant select on table "public"."bundle_features" to "authenticated";

grant trigger on table "public"."bundle_features" to "authenticated";

grant truncate on table "public"."bundle_features" to "authenticated";

grant update on table "public"."bundle_features" to "authenticated";

grant delete on table "public"."bundle_features" to "service_role";

grant insert on table "public"."bundle_features" to "service_role";

grant references on table "public"."bundle_features" to "service_role";

grant select on table "public"."bundle_features" to "service_role";

grant trigger on table "public"."bundle_features" to "service_role";

grant truncate on table "public"."bundle_features" to "service_role";

grant update on table "public"."bundle_features" to "service_role";

grant delete on table "public"."bundles" to "anon";

grant insert on table "public"."bundles" to "anon";

grant references on table "public"."bundles" to "anon";

grant select on table "public"."bundles" to "anon";

grant trigger on table "public"."bundles" to "anon";

grant truncate on table "public"."bundles" to "anon";

grant update on table "public"."bundles" to "anon";

grant delete on table "public"."bundles" to "authenticated";

grant insert on table "public"."bundles" to "authenticated";

grant references on table "public"."bundles" to "authenticated";

grant select on table "public"."bundles" to "authenticated";

grant trigger on table "public"."bundles" to "authenticated";

grant truncate on table "public"."bundles" to "authenticated";

grant update on table "public"."bundles" to "authenticated";

grant delete on table "public"."bundles" to "service_role";

grant insert on table "public"."bundles" to "service_role";

grant references on table "public"."bundles" to "service_role";

grant select on table "public"."bundles" to "service_role";

grant trigger on table "public"."bundles" to "service_role";

grant truncate on table "public"."bundles" to "service_role";

grant update on table "public"."bundles" to "service_role";

grant delete on table "public"."career_ai_conversations" to "anon";

grant insert on table "public"."career_ai_conversations" to "anon";

grant references on table "public"."career_ai_conversations" to "anon";

grant select on table "public"."career_ai_conversations" to "anon";

grant trigger on table "public"."career_ai_conversations" to "anon";

grant truncate on table "public"."career_ai_conversations" to "anon";

grant update on table "public"."career_ai_conversations" to "anon";

grant delete on table "public"."career_ai_conversations" to "authenticated";

grant insert on table "public"."career_ai_conversations" to "authenticated";

grant references on table "public"."career_ai_conversations" to "authenticated";

grant select on table "public"."career_ai_conversations" to "authenticated";

grant trigger on table "public"."career_ai_conversations" to "authenticated";

grant truncate on table "public"."career_ai_conversations" to "authenticated";

grant update on table "public"."career_ai_conversations" to "authenticated";

grant delete on table "public"."career_ai_conversations" to "service_role";

grant insert on table "public"."career_ai_conversations" to "service_role";

grant references on table "public"."career_ai_conversations" to "service_role";

grant select on table "public"."career_ai_conversations" to "service_role";

grant trigger on table "public"."career_ai_conversations" to "service_role";

grant truncate on table "public"."career_ai_conversations" to "service_role";

grant update on table "public"."career_ai_conversations" to "service_role";

grant delete on table "public"."career_assessment_ai_questions" to "anon";

grant insert on table "public"."career_assessment_ai_questions" to "anon";

grant references on table "public"."career_assessment_ai_questions" to "anon";

grant select on table "public"."career_assessment_ai_questions" to "anon";

grant trigger on table "public"."career_assessment_ai_questions" to "anon";

grant truncate on table "public"."career_assessment_ai_questions" to "anon";

grant update on table "public"."career_assessment_ai_questions" to "anon";

grant delete on table "public"."career_assessment_ai_questions" to "authenticated";

grant insert on table "public"."career_assessment_ai_questions" to "authenticated";

grant references on table "public"."career_assessment_ai_questions" to "authenticated";

grant select on table "public"."career_assessment_ai_questions" to "authenticated";

grant trigger on table "public"."career_assessment_ai_questions" to "authenticated";

grant truncate on table "public"."career_assessment_ai_questions" to "authenticated";

grant update on table "public"."career_assessment_ai_questions" to "authenticated";

grant delete on table "public"."career_assessment_ai_questions" to "service_role";

grant insert on table "public"."career_assessment_ai_questions" to "service_role";

grant references on table "public"."career_assessment_ai_questions" to "service_role";

grant select on table "public"."career_assessment_ai_questions" to "service_role";

grant trigger on table "public"."career_assessment_ai_questions" to "service_role";

grant truncate on table "public"."career_assessment_ai_questions" to "service_role";

grant update on table "public"."career_assessment_ai_questions" to "service_role";

grant delete on table "public"."certificates" to "anon";

grant insert on table "public"."certificates" to "anon";

grant references on table "public"."certificates" to "anon";

grant select on table "public"."certificates" to "anon";

grant trigger on table "public"."certificates" to "anon";

grant truncate on table "public"."certificates" to "anon";

grant update on table "public"."certificates" to "anon";

grant delete on table "public"."certificates" to "authenticated";

grant insert on table "public"."certificates" to "authenticated";

grant references on table "public"."certificates" to "authenticated";

grant select on table "public"."certificates" to "authenticated";

grant trigger on table "public"."certificates" to "authenticated";

grant truncate on table "public"."certificates" to "authenticated";

grant update on table "public"."certificates" to "authenticated";

grant delete on table "public"."certificates" to "service_role";

grant insert on table "public"."certificates" to "service_role";

grant references on table "public"."certificates" to "service_role";

grant select on table "public"."certificates" to "service_role";

grant trigger on table "public"."certificates" to "service_role";

grant truncate on table "public"."certificates" to "service_role";

grant update on table "public"."certificates" to "service_role";

grant delete on table "public"."class_swap_history" to "anon";

grant insert on table "public"."class_swap_history" to "anon";

grant references on table "public"."class_swap_history" to "anon";

grant select on table "public"."class_swap_history" to "anon";

grant trigger on table "public"."class_swap_history" to "anon";

grant truncate on table "public"."class_swap_history" to "anon";

grant update on table "public"."class_swap_history" to "anon";

grant delete on table "public"."class_swap_history" to "authenticated";

grant insert on table "public"."class_swap_history" to "authenticated";

grant references on table "public"."class_swap_history" to "authenticated";

grant select on table "public"."class_swap_history" to "authenticated";

grant trigger on table "public"."class_swap_history" to "authenticated";

grant truncate on table "public"."class_swap_history" to "authenticated";

grant update on table "public"."class_swap_history" to "authenticated";

grant delete on table "public"."class_swap_history" to "service_role";

grant insert on table "public"."class_swap_history" to "service_role";

grant references on table "public"."class_swap_history" to "service_role";

grant select on table "public"."class_swap_history" to "service_role";

grant trigger on table "public"."class_swap_history" to "service_role";

grant truncate on table "public"."class_swap_history" to "service_role";

grant update on table "public"."class_swap_history" to "service_role";

grant delete on table "public"."class_swap_requests" to "anon";

grant insert on table "public"."class_swap_requests" to "anon";

grant references on table "public"."class_swap_requests" to "anon";

grant select on table "public"."class_swap_requests" to "anon";

grant trigger on table "public"."class_swap_requests" to "anon";

grant truncate on table "public"."class_swap_requests" to "anon";

grant update on table "public"."class_swap_requests" to "anon";

grant delete on table "public"."class_swap_requests" to "authenticated";

grant insert on table "public"."class_swap_requests" to "authenticated";

grant references on table "public"."class_swap_requests" to "authenticated";

grant select on table "public"."class_swap_requests" to "authenticated";

grant trigger on table "public"."class_swap_requests" to "authenticated";

grant truncate on table "public"."class_swap_requests" to "authenticated";

grant update on table "public"."class_swap_requests" to "authenticated";

grant delete on table "public"."class_swap_requests" to "service_role";

grant insert on table "public"."class_swap_requests" to "service_role";

grant references on table "public"."class_swap_requests" to "service_role";

grant select on table "public"."class_swap_requests" to "service_role";

grant trigger on table "public"."class_swap_requests" to "service_role";

grant truncate on table "public"."class_swap_requests" to "service_role";

grant update on table "public"."class_swap_requests" to "service_role";

grant delete on table "public"."club_activities" to "anon";

grant insert on table "public"."club_activities" to "anon";

grant references on table "public"."club_activities" to "anon";

grant select on table "public"."club_activities" to "anon";

grant trigger on table "public"."club_activities" to "anon";

grant truncate on table "public"."club_activities" to "anon";

grant update on table "public"."club_activities" to "anon";

grant delete on table "public"."club_activities" to "authenticated";

grant insert on table "public"."club_activities" to "authenticated";

grant references on table "public"."club_activities" to "authenticated";

grant select on table "public"."club_activities" to "authenticated";

grant trigger on table "public"."club_activities" to "authenticated";

grant truncate on table "public"."club_activities" to "authenticated";

grant update on table "public"."club_activities" to "authenticated";

grant delete on table "public"."club_activities" to "service_role";

grant insert on table "public"."club_activities" to "service_role";

grant references on table "public"."club_activities" to "service_role";

grant select on table "public"."club_activities" to "service_role";

grant trigger on table "public"."club_activities" to "service_role";

grant truncate on table "public"."club_activities" to "service_role";

grant update on table "public"."club_activities" to "service_role";

grant delete on table "public"."club_attendance" to "anon";

grant insert on table "public"."club_attendance" to "anon";

grant references on table "public"."club_attendance" to "anon";

grant select on table "public"."club_attendance" to "anon";

grant trigger on table "public"."club_attendance" to "anon";

grant truncate on table "public"."club_attendance" to "anon";

grant update on table "public"."club_attendance" to "anon";

grant delete on table "public"."club_attendance" to "authenticated";

grant insert on table "public"."club_attendance" to "authenticated";

grant references on table "public"."club_attendance" to "authenticated";

grant select on table "public"."club_attendance" to "authenticated";

grant trigger on table "public"."club_attendance" to "authenticated";

grant truncate on table "public"."club_attendance" to "authenticated";

grant update on table "public"."club_attendance" to "authenticated";

grant delete on table "public"."club_attendance" to "service_role";

grant insert on table "public"."club_attendance" to "service_role";

grant references on table "public"."club_attendance" to "service_role";

grant select on table "public"."club_attendance" to "service_role";

grant trigger on table "public"."club_attendance" to "service_role";

grant truncate on table "public"."club_attendance" to "service_role";

grant update on table "public"."club_attendance" to "service_role";

grant delete on table "public"."club_attendance_records" to "anon";

grant insert on table "public"."club_attendance_records" to "anon";

grant references on table "public"."club_attendance_records" to "anon";

grant select on table "public"."club_attendance_records" to "anon";

grant trigger on table "public"."club_attendance_records" to "anon";

grant truncate on table "public"."club_attendance_records" to "anon";

grant update on table "public"."club_attendance_records" to "anon";

grant delete on table "public"."club_attendance_records" to "authenticated";

grant insert on table "public"."club_attendance_records" to "authenticated";

grant references on table "public"."club_attendance_records" to "authenticated";

grant select on table "public"."club_attendance_records" to "authenticated";

grant trigger on table "public"."club_attendance_records" to "authenticated";

grant truncate on table "public"."club_attendance_records" to "authenticated";

grant update on table "public"."club_attendance_records" to "authenticated";

grant delete on table "public"."club_attendance_records" to "service_role";

grant insert on table "public"."club_attendance_records" to "service_role";

grant references on table "public"."club_attendance_records" to "service_role";

grant select on table "public"."club_attendance_records" to "service_role";

grant trigger on table "public"."club_attendance_records" to "service_role";

grant truncate on table "public"."club_attendance_records" to "service_role";

grant update on table "public"."club_attendance_records" to "service_role";

grant delete on table "public"."club_certificates" to "anon";

grant insert on table "public"."club_certificates" to "anon";

grant references on table "public"."club_certificates" to "anon";

grant select on table "public"."club_certificates" to "anon";

grant trigger on table "public"."club_certificates" to "anon";

grant truncate on table "public"."club_certificates" to "anon";

grant update on table "public"."club_certificates" to "anon";

grant delete on table "public"."club_certificates" to "authenticated";

grant insert on table "public"."club_certificates" to "authenticated";

grant references on table "public"."club_certificates" to "authenticated";

grant select on table "public"."club_certificates" to "authenticated";

grant trigger on table "public"."club_certificates" to "authenticated";

grant truncate on table "public"."club_certificates" to "authenticated";

grant update on table "public"."club_certificates" to "authenticated";

grant delete on table "public"."club_certificates" to "service_role";

grant insert on table "public"."club_certificates" to "service_role";

grant references on table "public"."club_certificates" to "service_role";

grant select on table "public"."club_certificates" to "service_role";

grant trigger on table "public"."club_certificates" to "service_role";

grant truncate on table "public"."club_certificates" to "service_role";

grant update on table "public"."club_certificates" to "service_role";

grant delete on table "public"."club_memberships" to "anon";

grant insert on table "public"."club_memberships" to "anon";

grant references on table "public"."club_memberships" to "anon";

grant select on table "public"."club_memberships" to "anon";

grant trigger on table "public"."club_memberships" to "anon";

grant truncate on table "public"."club_memberships" to "anon";

grant update on table "public"."club_memberships" to "anon";

grant delete on table "public"."club_memberships" to "authenticated";

grant insert on table "public"."club_memberships" to "authenticated";

grant references on table "public"."club_memberships" to "authenticated";

grant select on table "public"."club_memberships" to "authenticated";

grant trigger on table "public"."club_memberships" to "authenticated";

grant truncate on table "public"."club_memberships" to "authenticated";

grant update on table "public"."club_memberships" to "authenticated";

grant delete on table "public"."club_memberships" to "service_role";

grant insert on table "public"."club_memberships" to "service_role";

grant references on table "public"."club_memberships" to "service_role";

grant select on table "public"."club_memberships" to "service_role";

grant trigger on table "public"."club_memberships" to "service_role";

grant truncate on table "public"."club_memberships" to "service_role";

grant update on table "public"."club_memberships" to "service_role";

grant delete on table "public"."clubs" to "anon";

grant insert on table "public"."clubs" to "anon";

grant references on table "public"."clubs" to "anon";

grant select on table "public"."clubs" to "anon";

grant trigger on table "public"."clubs" to "anon";

grant truncate on table "public"."clubs" to "anon";

grant update on table "public"."clubs" to "anon";

grant delete on table "public"."clubs" to "authenticated";

grant insert on table "public"."clubs" to "authenticated";

grant references on table "public"."clubs" to "authenticated";

grant select on table "public"."clubs" to "authenticated";

grant trigger on table "public"."clubs" to "authenticated";

grant truncate on table "public"."clubs" to "authenticated";

grant update on table "public"."clubs" to "authenticated";

grant delete on table "public"."clubs" to "service_role";

grant insert on table "public"."clubs" to "service_role";

grant references on table "public"."clubs" to "service_role";

grant select on table "public"."clubs" to "service_role";

grant trigger on table "public"."clubs" to "service_role";

grant truncate on table "public"."clubs" to "service_role";

grant update on table "public"."clubs" to "service_role";

grant delete on table "public"."college_assignment_attachments" to "anon";

grant insert on table "public"."college_assignment_attachments" to "anon";

grant references on table "public"."college_assignment_attachments" to "anon";

grant select on table "public"."college_assignment_attachments" to "anon";

grant trigger on table "public"."college_assignment_attachments" to "anon";

grant truncate on table "public"."college_assignment_attachments" to "anon";

grant update on table "public"."college_assignment_attachments" to "anon";

grant delete on table "public"."college_assignment_attachments" to "authenticated";

grant insert on table "public"."college_assignment_attachments" to "authenticated";

grant references on table "public"."college_assignment_attachments" to "authenticated";

grant select on table "public"."college_assignment_attachments" to "authenticated";

grant trigger on table "public"."college_assignment_attachments" to "authenticated";

grant truncate on table "public"."college_assignment_attachments" to "authenticated";

grant update on table "public"."college_assignment_attachments" to "authenticated";

grant delete on table "public"."college_assignment_attachments" to "service_role";

grant insert on table "public"."college_assignment_attachments" to "service_role";

grant references on table "public"."college_assignment_attachments" to "service_role";

grant select on table "public"."college_assignment_attachments" to "service_role";

grant trigger on table "public"."college_assignment_attachments" to "service_role";

grant truncate on table "public"."college_assignment_attachments" to "service_role";

grant update on table "public"."college_assignment_attachments" to "service_role";

grant delete on table "public"."college_assignments" to "anon";

grant insert on table "public"."college_assignments" to "anon";

grant references on table "public"."college_assignments" to "anon";

grant select on table "public"."college_assignments" to "anon";

grant trigger on table "public"."college_assignments" to "anon";

grant truncate on table "public"."college_assignments" to "anon";

grant update on table "public"."college_assignments" to "anon";

grant delete on table "public"."college_assignments" to "authenticated";

grant insert on table "public"."college_assignments" to "authenticated";

grant references on table "public"."college_assignments" to "authenticated";

grant select on table "public"."college_assignments" to "authenticated";

grant trigger on table "public"."college_assignments" to "authenticated";

grant truncate on table "public"."college_assignments" to "authenticated";

grant update on table "public"."college_assignments" to "authenticated";

grant delete on table "public"."college_assignments" to "service_role";

grant insert on table "public"."college_assignments" to "service_role";

grant references on table "public"."college_assignments" to "service_role";

grant select on table "public"."college_assignments" to "service_role";

grant trigger on table "public"."college_assignments" to "service_role";

grant truncate on table "public"."college_assignments" to "service_role";

grant update on table "public"."college_assignments" to "service_role";

grant delete on table "public"."college_attendance_records" to "anon";

grant insert on table "public"."college_attendance_records" to "anon";

grant references on table "public"."college_attendance_records" to "anon";

grant select on table "public"."college_attendance_records" to "anon";

grant trigger on table "public"."college_attendance_records" to "anon";

grant truncate on table "public"."college_attendance_records" to "anon";

grant update on table "public"."college_attendance_records" to "anon";

grant delete on table "public"."college_attendance_records" to "authenticated";

grant insert on table "public"."college_attendance_records" to "authenticated";

grant references on table "public"."college_attendance_records" to "authenticated";

grant select on table "public"."college_attendance_records" to "authenticated";

grant trigger on table "public"."college_attendance_records" to "authenticated";

grant truncate on table "public"."college_attendance_records" to "authenticated";

grant update on table "public"."college_attendance_records" to "authenticated";

grant delete on table "public"."college_attendance_records" to "service_role";

grant insert on table "public"."college_attendance_records" to "service_role";

grant references on table "public"."college_attendance_records" to "service_role";

grant select on table "public"."college_attendance_records" to "service_role";

grant trigger on table "public"."college_attendance_records" to "service_role";

grant truncate on table "public"."college_attendance_records" to "service_role";

grant update on table "public"."college_attendance_records" to "service_role";

grant delete on table "public"."college_attendance_sessions" to "anon";

grant insert on table "public"."college_attendance_sessions" to "anon";

grant references on table "public"."college_attendance_sessions" to "anon";

grant select on table "public"."college_attendance_sessions" to "anon";

grant trigger on table "public"."college_attendance_sessions" to "anon";

grant truncate on table "public"."college_attendance_sessions" to "anon";

grant update on table "public"."college_attendance_sessions" to "anon";

grant delete on table "public"."college_attendance_sessions" to "authenticated";

grant insert on table "public"."college_attendance_sessions" to "authenticated";

grant references on table "public"."college_attendance_sessions" to "authenticated";

grant select on table "public"."college_attendance_sessions" to "authenticated";

grant trigger on table "public"."college_attendance_sessions" to "authenticated";

grant truncate on table "public"."college_attendance_sessions" to "authenticated";

grant update on table "public"."college_attendance_sessions" to "authenticated";

grant delete on table "public"."college_attendance_sessions" to "service_role";

grant insert on table "public"."college_attendance_sessions" to "service_role";

grant references on table "public"."college_attendance_sessions" to "service_role";

grant select on table "public"."college_attendance_sessions" to "service_role";

grant trigger on table "public"."college_attendance_sessions" to "service_role";

grant truncate on table "public"."college_attendance_sessions" to "service_role";

grant update on table "public"."college_attendance_sessions" to "service_role";

grant delete on table "public"."college_attendance_settings" to "anon";

grant insert on table "public"."college_attendance_settings" to "anon";

grant references on table "public"."college_attendance_settings" to "anon";

grant select on table "public"."college_attendance_settings" to "anon";

grant trigger on table "public"."college_attendance_settings" to "anon";

grant truncate on table "public"."college_attendance_settings" to "anon";

grant update on table "public"."college_attendance_settings" to "anon";

grant delete on table "public"."college_attendance_settings" to "authenticated";

grant insert on table "public"."college_attendance_settings" to "authenticated";

grant references on table "public"."college_attendance_settings" to "authenticated";

grant select on table "public"."college_attendance_settings" to "authenticated";

grant trigger on table "public"."college_attendance_settings" to "authenticated";

grant truncate on table "public"."college_attendance_settings" to "authenticated";

grant update on table "public"."college_attendance_settings" to "authenticated";

grant delete on table "public"."college_attendance_settings" to "service_role";

grant insert on table "public"."college_attendance_settings" to "service_role";

grant references on table "public"."college_attendance_settings" to "service_role";

grant select on table "public"."college_attendance_settings" to "service_role";

grant trigger on table "public"."college_attendance_settings" to "service_role";

grant truncate on table "public"."college_attendance_settings" to "service_role";

grant update on table "public"."college_attendance_settings" to "service_role";

grant delete on table "public"."college_breaks" to "anon";

grant insert on table "public"."college_breaks" to "anon";

grant references on table "public"."college_breaks" to "anon";

grant select on table "public"."college_breaks" to "anon";

grant trigger on table "public"."college_breaks" to "anon";

grant truncate on table "public"."college_breaks" to "anon";

grant update on table "public"."college_breaks" to "anon";

grant delete on table "public"."college_breaks" to "authenticated";

grant insert on table "public"."college_breaks" to "authenticated";

grant references on table "public"."college_breaks" to "authenticated";

grant select on table "public"."college_breaks" to "authenticated";

grant trigger on table "public"."college_breaks" to "authenticated";

grant truncate on table "public"."college_breaks" to "authenticated";

grant update on table "public"."college_breaks" to "authenticated";

grant delete on table "public"."college_breaks" to "service_role";

grant insert on table "public"."college_breaks" to "service_role";

grant references on table "public"."college_breaks" to "service_role";

grant select on table "public"."college_breaks" to "service_role";

grant trigger on table "public"."college_breaks" to "service_role";

grant truncate on table "public"."college_breaks" to "service_role";

grant update on table "public"."college_breaks" to "service_role";

grant delete on table "public"."college_circulars" to "anon";

grant insert on table "public"."college_circulars" to "anon";

grant references on table "public"."college_circulars" to "anon";

grant select on table "public"."college_circulars" to "anon";

grant trigger on table "public"."college_circulars" to "anon";

grant truncate on table "public"."college_circulars" to "anon";

grant update on table "public"."college_circulars" to "anon";

grant delete on table "public"."college_circulars" to "authenticated";

grant insert on table "public"."college_circulars" to "authenticated";

grant references on table "public"."college_circulars" to "authenticated";

grant select on table "public"."college_circulars" to "authenticated";

grant trigger on table "public"."college_circulars" to "authenticated";

grant truncate on table "public"."college_circulars" to "authenticated";

grant update on table "public"."college_circulars" to "authenticated";

grant delete on table "public"."college_circulars" to "service_role";

grant insert on table "public"."college_circulars" to "service_role";

grant references on table "public"."college_circulars" to "service_role";

grant select on table "public"."college_circulars" to "service_role";

grant trigger on table "public"."college_circulars" to "service_role";

grant truncate on table "public"."college_circulars" to "service_role";

grant update on table "public"."college_circulars" to "service_role";

grant delete on table "public"."college_classes" to "anon";

grant insert on table "public"."college_classes" to "anon";

grant references on table "public"."college_classes" to "anon";

grant select on table "public"."college_classes" to "anon";

grant trigger on table "public"."college_classes" to "anon";

grant truncate on table "public"."college_classes" to "anon";

grant update on table "public"."college_classes" to "anon";

grant delete on table "public"."college_classes" to "authenticated";

grant insert on table "public"."college_classes" to "authenticated";

grant references on table "public"."college_classes" to "authenticated";

grant select on table "public"."college_classes" to "authenticated";

grant trigger on table "public"."college_classes" to "authenticated";

grant truncate on table "public"."college_classes" to "authenticated";

grant update on table "public"."college_classes" to "authenticated";

grant delete on table "public"."college_classes" to "service_role";

grant insert on table "public"."college_classes" to "service_role";

grant references on table "public"."college_classes" to "service_role";

grant select on table "public"."college_classes" to "service_role";

grant trigger on table "public"."college_classes" to "service_role";

grant truncate on table "public"."college_classes" to "service_role";

grant update on table "public"."college_classes" to "service_role";

grant delete on table "public"."college_course_mappings" to "anon";

grant insert on table "public"."college_course_mappings" to "anon";

grant references on table "public"."college_course_mappings" to "anon";

grant select on table "public"."college_course_mappings" to "anon";

grant trigger on table "public"."college_course_mappings" to "anon";

grant truncate on table "public"."college_course_mappings" to "anon";

grant update on table "public"."college_course_mappings" to "anon";

grant delete on table "public"."college_course_mappings" to "authenticated";

grant insert on table "public"."college_course_mappings" to "authenticated";

grant references on table "public"."college_course_mappings" to "authenticated";

grant select on table "public"."college_course_mappings" to "authenticated";

grant trigger on table "public"."college_course_mappings" to "authenticated";

grant truncate on table "public"."college_course_mappings" to "authenticated";

grant update on table "public"."college_course_mappings" to "authenticated";

grant delete on table "public"."college_course_mappings" to "service_role";

grant insert on table "public"."college_course_mappings" to "service_role";

grant references on table "public"."college_course_mappings" to "service_role";

grant select on table "public"."college_course_mappings" to "service_role";

grant trigger on table "public"."college_course_mappings" to "service_role";

grant truncate on table "public"."college_course_mappings" to "service_role";

grant update on table "public"."college_course_mappings" to "service_role";

grant delete on table "public"."college_courses" to "anon";

grant insert on table "public"."college_courses" to "anon";

grant references on table "public"."college_courses" to "anon";

grant select on table "public"."college_courses" to "anon";

grant trigger on table "public"."college_courses" to "anon";

grant truncate on table "public"."college_courses" to "anon";

grant update on table "public"."college_courses" to "anon";

grant delete on table "public"."college_courses" to "authenticated";

grant insert on table "public"."college_courses" to "authenticated";

grant references on table "public"."college_courses" to "authenticated";

grant select on table "public"."college_courses" to "authenticated";

grant trigger on table "public"."college_courses" to "authenticated";

grant truncate on table "public"."college_courses" to "authenticated";

grant update on table "public"."college_courses" to "authenticated";

grant delete on table "public"."college_courses" to "service_role";

grant insert on table "public"."college_courses" to "service_role";

grant references on table "public"."college_courses" to "service_role";

grant select on table "public"."college_courses" to "service_role";

grant trigger on table "public"."college_courses" to "service_role";

grant truncate on table "public"."college_courses" to "service_role";

grant update on table "public"."college_courses" to "service_role";

grant delete on table "public"."college_curriculum_outcomes" to "anon";

grant insert on table "public"."college_curriculum_outcomes" to "anon";

grant references on table "public"."college_curriculum_outcomes" to "anon";

grant select on table "public"."college_curriculum_outcomes" to "anon";

grant trigger on table "public"."college_curriculum_outcomes" to "anon";

grant truncate on table "public"."college_curriculum_outcomes" to "anon";

grant update on table "public"."college_curriculum_outcomes" to "anon";

grant delete on table "public"."college_curriculum_outcomes" to "authenticated";

grant insert on table "public"."college_curriculum_outcomes" to "authenticated";

grant references on table "public"."college_curriculum_outcomes" to "authenticated";

grant select on table "public"."college_curriculum_outcomes" to "authenticated";

grant trigger on table "public"."college_curriculum_outcomes" to "authenticated";

grant truncate on table "public"."college_curriculum_outcomes" to "authenticated";

grant update on table "public"."college_curriculum_outcomes" to "authenticated";

grant delete on table "public"."college_curriculum_outcomes" to "service_role";

grant insert on table "public"."college_curriculum_outcomes" to "service_role";

grant references on table "public"."college_curriculum_outcomes" to "service_role";

grant select on table "public"."college_curriculum_outcomes" to "service_role";

grant trigger on table "public"."college_curriculum_outcomes" to "service_role";

grant truncate on table "public"."college_curriculum_outcomes" to "service_role";

grant update on table "public"."college_curriculum_outcomes" to "service_role";

grant delete on table "public"."college_curriculum_units" to "anon";

grant insert on table "public"."college_curriculum_units" to "anon";

grant references on table "public"."college_curriculum_units" to "anon";

grant select on table "public"."college_curriculum_units" to "anon";

grant trigger on table "public"."college_curriculum_units" to "anon";

grant truncate on table "public"."college_curriculum_units" to "anon";

grant update on table "public"."college_curriculum_units" to "anon";

grant delete on table "public"."college_curriculum_units" to "authenticated";

grant insert on table "public"."college_curriculum_units" to "authenticated";

grant references on table "public"."college_curriculum_units" to "authenticated";

grant select on table "public"."college_curriculum_units" to "authenticated";

grant trigger on table "public"."college_curriculum_units" to "authenticated";

grant truncate on table "public"."college_curriculum_units" to "authenticated";

grant update on table "public"."college_curriculum_units" to "authenticated";

grant delete on table "public"."college_curriculum_units" to "service_role";

grant insert on table "public"."college_curriculum_units" to "service_role";

grant references on table "public"."college_curriculum_units" to "service_role";

grant select on table "public"."college_curriculum_units" to "service_role";

grant trigger on table "public"."college_curriculum_units" to "service_role";

grant truncate on table "public"."college_curriculum_units" to "service_role";

grant update on table "public"."college_curriculum_units" to "service_role";

grant delete on table "public"."college_curriculums" to "anon";

grant insert on table "public"."college_curriculums" to "anon";

grant references on table "public"."college_curriculums" to "anon";

grant select on table "public"."college_curriculums" to "anon";

grant trigger on table "public"."college_curriculums" to "anon";

grant truncate on table "public"."college_curriculums" to "anon";

grant update on table "public"."college_curriculums" to "anon";

grant delete on table "public"."college_curriculums" to "authenticated";

grant insert on table "public"."college_curriculums" to "authenticated";

grant references on table "public"."college_curriculums" to "authenticated";

grant select on table "public"."college_curriculums" to "authenticated";

grant trigger on table "public"."college_curriculums" to "authenticated";

grant truncate on table "public"."college_curriculums" to "authenticated";

grant update on table "public"."college_curriculums" to "authenticated";

grant delete on table "public"."college_curriculums" to "service_role";

grant insert on table "public"."college_curriculums" to "service_role";

grant references on table "public"."college_curriculums" to "service_role";

grant select on table "public"."college_curriculums" to "service_role";

grant trigger on table "public"."college_curriculums" to "service_role";

grant truncate on table "public"."college_curriculums" to "service_role";

grant update on table "public"."college_curriculums" to "service_role";

grant delete on table "public"."college_event_registrations" to "anon";

grant insert on table "public"."college_event_registrations" to "anon";

grant references on table "public"."college_event_registrations" to "anon";

grant select on table "public"."college_event_registrations" to "anon";

grant trigger on table "public"."college_event_registrations" to "anon";

grant truncate on table "public"."college_event_registrations" to "anon";

grant update on table "public"."college_event_registrations" to "anon";

grant delete on table "public"."college_event_registrations" to "authenticated";

grant insert on table "public"."college_event_registrations" to "authenticated";

grant references on table "public"."college_event_registrations" to "authenticated";

grant select on table "public"."college_event_registrations" to "authenticated";

grant trigger on table "public"."college_event_registrations" to "authenticated";

grant truncate on table "public"."college_event_registrations" to "authenticated";

grant update on table "public"."college_event_registrations" to "authenticated";

grant delete on table "public"."college_event_registrations" to "service_role";

grant insert on table "public"."college_event_registrations" to "service_role";

grant references on table "public"."college_event_registrations" to "service_role";

grant select on table "public"."college_event_registrations" to "service_role";

grant trigger on table "public"."college_event_registrations" to "service_role";

grant truncate on table "public"."college_event_registrations" to "service_role";

grant update on table "public"."college_event_registrations" to "service_role";

grant delete on table "public"."college_events" to "anon";

grant insert on table "public"."college_events" to "anon";

grant references on table "public"."college_events" to "anon";

grant select on table "public"."college_events" to "anon";

grant trigger on table "public"."college_events" to "anon";

grant truncate on table "public"."college_events" to "anon";

grant update on table "public"."college_events" to "anon";

grant delete on table "public"."college_events" to "authenticated";

grant insert on table "public"."college_events" to "authenticated";

grant references on table "public"."college_events" to "authenticated";

grant select on table "public"."college_events" to "authenticated";

grant trigger on table "public"."college_events" to "authenticated";

grant truncate on table "public"."college_events" to "authenticated";

grant update on table "public"."college_events" to "authenticated";

grant delete on table "public"."college_events" to "service_role";

grant insert on table "public"."college_events" to "service_role";

grant references on table "public"."college_events" to "service_role";

grant select on table "public"."college_events" to "service_role";

grant trigger on table "public"."college_events" to "service_role";

grant truncate on table "public"."college_events" to "service_role";

grant update on table "public"."college_events" to "service_role";

grant delete on table "public"."college_faculty_class_assignments" to "anon";

grant insert on table "public"."college_faculty_class_assignments" to "anon";

grant references on table "public"."college_faculty_class_assignments" to "anon";

grant select on table "public"."college_faculty_class_assignments" to "anon";

grant trigger on table "public"."college_faculty_class_assignments" to "anon";

grant truncate on table "public"."college_faculty_class_assignments" to "anon";

grant update on table "public"."college_faculty_class_assignments" to "anon";

grant delete on table "public"."college_faculty_class_assignments" to "authenticated";

grant insert on table "public"."college_faculty_class_assignments" to "authenticated";

grant references on table "public"."college_faculty_class_assignments" to "authenticated";

grant select on table "public"."college_faculty_class_assignments" to "authenticated";

grant trigger on table "public"."college_faculty_class_assignments" to "authenticated";

grant truncate on table "public"."college_faculty_class_assignments" to "authenticated";

grant update on table "public"."college_faculty_class_assignments" to "authenticated";

grant delete on table "public"."college_faculty_class_assignments" to "service_role";

grant insert on table "public"."college_faculty_class_assignments" to "service_role";

grant references on table "public"."college_faculty_class_assignments" to "service_role";

grant select on table "public"."college_faculty_class_assignments" to "service_role";

grant trigger on table "public"."college_faculty_class_assignments" to "service_role";

grant truncate on table "public"."college_faculty_class_assignments" to "service_role";

grant update on table "public"."college_faculty_class_assignments" to "service_role";

grant delete on table "public"."college_faculty_leave_balances" to "anon";

grant insert on table "public"."college_faculty_leave_balances" to "anon";

grant references on table "public"."college_faculty_leave_balances" to "anon";

grant select on table "public"."college_faculty_leave_balances" to "anon";

grant trigger on table "public"."college_faculty_leave_balances" to "anon";

grant truncate on table "public"."college_faculty_leave_balances" to "anon";

grant update on table "public"."college_faculty_leave_balances" to "anon";

grant delete on table "public"."college_faculty_leave_balances" to "authenticated";

grant insert on table "public"."college_faculty_leave_balances" to "authenticated";

grant references on table "public"."college_faculty_leave_balances" to "authenticated";

grant select on table "public"."college_faculty_leave_balances" to "authenticated";

grant trigger on table "public"."college_faculty_leave_balances" to "authenticated";

grant truncate on table "public"."college_faculty_leave_balances" to "authenticated";

grant update on table "public"."college_faculty_leave_balances" to "authenticated";

grant delete on table "public"."college_faculty_leave_balances" to "service_role";

grant insert on table "public"."college_faculty_leave_balances" to "service_role";

grant references on table "public"."college_faculty_leave_balances" to "service_role";

grant select on table "public"."college_faculty_leave_balances" to "service_role";

grant trigger on table "public"."college_faculty_leave_balances" to "service_role";

grant truncate on table "public"."college_faculty_leave_balances" to "service_role";

grant update on table "public"."college_faculty_leave_balances" to "service_role";

grant delete on table "public"."college_faculty_leaves" to "anon";

grant insert on table "public"."college_faculty_leaves" to "anon";

grant references on table "public"."college_faculty_leaves" to "anon";

grant select on table "public"."college_faculty_leaves" to "anon";

grant trigger on table "public"."college_faculty_leaves" to "anon";

grant truncate on table "public"."college_faculty_leaves" to "anon";

grant update on table "public"."college_faculty_leaves" to "anon";

grant delete on table "public"."college_faculty_leaves" to "authenticated";

grant insert on table "public"."college_faculty_leaves" to "authenticated";

grant references on table "public"."college_faculty_leaves" to "authenticated";

grant select on table "public"."college_faculty_leaves" to "authenticated";

grant trigger on table "public"."college_faculty_leaves" to "authenticated";

grant truncate on table "public"."college_faculty_leaves" to "authenticated";

grant update on table "public"."college_faculty_leaves" to "authenticated";

grant delete on table "public"."college_faculty_leaves" to "service_role";

grant insert on table "public"."college_faculty_leaves" to "service_role";

grant references on table "public"."college_faculty_leaves" to "service_role";

grant select on table "public"."college_faculty_leaves" to "service_role";

grant trigger on table "public"."college_faculty_leaves" to "service_role";

grant truncate on table "public"."college_faculty_leaves" to "service_role";

grant update on table "public"."college_faculty_leaves" to "service_role";

grant delete on table "public"."college_faculty_substitutions" to "anon";

grant insert on table "public"."college_faculty_substitutions" to "anon";

grant references on table "public"."college_faculty_substitutions" to "anon";

grant select on table "public"."college_faculty_substitutions" to "anon";

grant trigger on table "public"."college_faculty_substitutions" to "anon";

grant truncate on table "public"."college_faculty_substitutions" to "anon";

grant update on table "public"."college_faculty_substitutions" to "anon";

grant delete on table "public"."college_faculty_substitutions" to "authenticated";

grant insert on table "public"."college_faculty_substitutions" to "authenticated";

grant references on table "public"."college_faculty_substitutions" to "authenticated";

grant select on table "public"."college_faculty_substitutions" to "authenticated";

grant trigger on table "public"."college_faculty_substitutions" to "authenticated";

grant truncate on table "public"."college_faculty_substitutions" to "authenticated";

grant update on table "public"."college_faculty_substitutions" to "authenticated";

grant delete on table "public"."college_faculty_substitutions" to "service_role";

grant insert on table "public"."college_faculty_substitutions" to "service_role";

grant references on table "public"."college_faculty_substitutions" to "service_role";

grant select on table "public"."college_faculty_substitutions" to "service_role";

grant trigger on table "public"."college_faculty_substitutions" to "service_role";

grant truncate on table "public"."college_faculty_substitutions" to "service_role";

grant update on table "public"."college_faculty_substitutions" to "service_role";

grant delete on table "public"."college_leave_types" to "anon";

grant insert on table "public"."college_leave_types" to "anon";

grant references on table "public"."college_leave_types" to "anon";

grant select on table "public"."college_leave_types" to "anon";

grant trigger on table "public"."college_leave_types" to "anon";

grant truncate on table "public"."college_leave_types" to "anon";

grant update on table "public"."college_leave_types" to "anon";

grant delete on table "public"."college_leave_types" to "authenticated";

grant insert on table "public"."college_leave_types" to "authenticated";

grant references on table "public"."college_leave_types" to "authenticated";

grant select on table "public"."college_leave_types" to "authenticated";

grant trigger on table "public"."college_leave_types" to "authenticated";

grant truncate on table "public"."college_leave_types" to "authenticated";

grant update on table "public"."college_leave_types" to "authenticated";

grant delete on table "public"."college_leave_types" to "service_role";

grant insert on table "public"."college_leave_types" to "service_role";

grant references on table "public"."college_leave_types" to "service_role";

grant select on table "public"."college_leave_types" to "service_role";

grant trigger on table "public"."college_leave_types" to "service_role";

grant truncate on table "public"."college_leave_types" to "service_role";

grant update on table "public"."college_leave_types" to "service_role";

grant delete on table "public"."college_lecturer_course_assignments" to "anon";

grant insert on table "public"."college_lecturer_course_assignments" to "anon";

grant references on table "public"."college_lecturer_course_assignments" to "anon";

grant select on table "public"."college_lecturer_course_assignments" to "anon";

grant trigger on table "public"."college_lecturer_course_assignments" to "anon";

grant truncate on table "public"."college_lecturer_course_assignments" to "anon";

grant update on table "public"."college_lecturer_course_assignments" to "anon";

grant delete on table "public"."college_lecturer_course_assignments" to "authenticated";

grant insert on table "public"."college_lecturer_course_assignments" to "authenticated";

grant references on table "public"."college_lecturer_course_assignments" to "authenticated";

grant select on table "public"."college_lecturer_course_assignments" to "authenticated";

grant trigger on table "public"."college_lecturer_course_assignments" to "authenticated";

grant truncate on table "public"."college_lecturer_course_assignments" to "authenticated";

grant update on table "public"."college_lecturer_course_assignments" to "authenticated";

grant delete on table "public"."college_lecturer_course_assignments" to "service_role";

grant insert on table "public"."college_lecturer_course_assignments" to "service_role";

grant references on table "public"."college_lecturer_course_assignments" to "service_role";

grant select on table "public"."college_lecturer_course_assignments" to "service_role";

grant trigger on table "public"."college_lecturer_course_assignments" to "service_role";

grant truncate on table "public"."college_lecturer_course_assignments" to "service_role";

grant update on table "public"."college_lecturer_course_assignments" to "service_role";

grant delete on table "public"."college_lecturers" to "anon";

grant insert on table "public"."college_lecturers" to "anon";

grant references on table "public"."college_lecturers" to "anon";

grant select on table "public"."college_lecturers" to "anon";

grant trigger on table "public"."college_lecturers" to "anon";

grant truncate on table "public"."college_lecturers" to "anon";

grant update on table "public"."college_lecturers" to "anon";

grant delete on table "public"."college_lecturers" to "authenticated";

grant insert on table "public"."college_lecturers" to "authenticated";

grant references on table "public"."college_lecturers" to "authenticated";

grant select on table "public"."college_lecturers" to "authenticated";

grant trigger on table "public"."college_lecturers" to "authenticated";

grant truncate on table "public"."college_lecturers" to "authenticated";

grant update on table "public"."college_lecturers" to "authenticated";

grant delete on table "public"."college_lecturers" to "service_role";

grant insert on table "public"."college_lecturers" to "service_role";

grant references on table "public"."college_lecturers" to "service_role";

grant select on table "public"."college_lecturers" to "service_role";

grant trigger on table "public"."college_lecturers" to "service_role";

grant truncate on table "public"."college_lecturers" to "service_role";

grant update on table "public"."college_lecturers" to "service_role";

grant delete on table "public"."college_lecturers_backup" to "anon";

grant insert on table "public"."college_lecturers_backup" to "anon";

grant references on table "public"."college_lecturers_backup" to "anon";

grant select on table "public"."college_lecturers_backup" to "anon";

grant trigger on table "public"."college_lecturers_backup" to "anon";

grant truncate on table "public"."college_lecturers_backup" to "anon";

grant update on table "public"."college_lecturers_backup" to "anon";

grant delete on table "public"."college_lecturers_backup" to "authenticated";

grant insert on table "public"."college_lecturers_backup" to "authenticated";

grant references on table "public"."college_lecturers_backup" to "authenticated";

grant select on table "public"."college_lecturers_backup" to "authenticated";

grant trigger on table "public"."college_lecturers_backup" to "authenticated";

grant truncate on table "public"."college_lecturers_backup" to "authenticated";

grant update on table "public"."college_lecturers_backup" to "authenticated";

grant delete on table "public"."college_lecturers_backup" to "service_role";

grant insert on table "public"."college_lecturers_backup" to "service_role";

grant references on table "public"."college_lecturers_backup" to "service_role";

grant select on table "public"."college_lecturers_backup" to "service_role";

grant trigger on table "public"."college_lecturers_backup" to "service_role";

grant truncate on table "public"."college_lecturers_backup" to "service_role";

grant update on table "public"."college_lecturers_backup" to "service_role";

grant delete on table "public"."college_lesson_plans" to "anon";

grant insert on table "public"."college_lesson_plans" to "anon";

grant references on table "public"."college_lesson_plans" to "anon";

grant select on table "public"."college_lesson_plans" to "anon";

grant trigger on table "public"."college_lesson_plans" to "anon";

grant truncate on table "public"."college_lesson_plans" to "anon";

grant update on table "public"."college_lesson_plans" to "anon";

grant delete on table "public"."college_lesson_plans" to "authenticated";

grant insert on table "public"."college_lesson_plans" to "authenticated";

grant references on table "public"."college_lesson_plans" to "authenticated";

grant select on table "public"."college_lesson_plans" to "authenticated";

grant trigger on table "public"."college_lesson_plans" to "authenticated";

grant truncate on table "public"."college_lesson_plans" to "authenticated";

grant update on table "public"."college_lesson_plans" to "authenticated";

grant delete on table "public"."college_lesson_plans" to "service_role";

grant insert on table "public"."college_lesson_plans" to "service_role";

grant references on table "public"."college_lesson_plans" to "service_role";

grant select on table "public"."college_lesson_plans" to "service_role";

grant trigger on table "public"."college_lesson_plans" to "service_role";

grant truncate on table "public"."college_lesson_plans" to "service_role";

grant update on table "public"."college_lesson_plans" to "service_role";

grant delete on table "public"."college_mentor_notes" to "anon";

grant insert on table "public"."college_mentor_notes" to "anon";

grant references on table "public"."college_mentor_notes" to "anon";

grant select on table "public"."college_mentor_notes" to "anon";

grant trigger on table "public"."college_mentor_notes" to "anon";

grant truncate on table "public"."college_mentor_notes" to "anon";

grant update on table "public"."college_mentor_notes" to "anon";

grant delete on table "public"."college_mentor_notes" to "authenticated";

grant insert on table "public"."college_mentor_notes" to "authenticated";

grant references on table "public"."college_mentor_notes" to "authenticated";

grant select on table "public"."college_mentor_notes" to "authenticated";

grant trigger on table "public"."college_mentor_notes" to "authenticated";

grant truncate on table "public"."college_mentor_notes" to "authenticated";

grant update on table "public"."college_mentor_notes" to "authenticated";

grant delete on table "public"."college_mentor_notes" to "service_role";

grant insert on table "public"."college_mentor_notes" to "service_role";

grant references on table "public"."college_mentor_notes" to "service_role";

grant select on table "public"."college_mentor_notes" to "service_role";

grant trigger on table "public"."college_mentor_notes" to "service_role";

grant truncate on table "public"."college_mentor_notes" to "service_role";

grant update on table "public"."college_mentor_notes" to "service_role";

grant delete on table "public"."college_mentor_periods" to "anon";

grant insert on table "public"."college_mentor_periods" to "anon";

grant references on table "public"."college_mentor_periods" to "anon";

grant select on table "public"."college_mentor_periods" to "anon";

grant trigger on table "public"."college_mentor_periods" to "anon";

grant truncate on table "public"."college_mentor_periods" to "anon";

grant update on table "public"."college_mentor_periods" to "anon";

grant delete on table "public"."college_mentor_periods" to "authenticated";

grant insert on table "public"."college_mentor_periods" to "authenticated";

grant references on table "public"."college_mentor_periods" to "authenticated";

grant select on table "public"."college_mentor_periods" to "authenticated";

grant trigger on table "public"."college_mentor_periods" to "authenticated";

grant truncate on table "public"."college_mentor_periods" to "authenticated";

grant update on table "public"."college_mentor_periods" to "authenticated";

grant delete on table "public"."college_mentor_periods" to "service_role";

grant insert on table "public"."college_mentor_periods" to "service_role";

grant references on table "public"."college_mentor_periods" to "service_role";

grant select on table "public"."college_mentor_periods" to "service_role";

grant trigger on table "public"."college_mentor_periods" to "service_role";

grant truncate on table "public"."college_mentor_periods" to "service_role";

grant update on table "public"."college_mentor_periods" to "service_role";

grant delete on table "public"."college_mentor_student_allocations" to "anon";

grant insert on table "public"."college_mentor_student_allocations" to "anon";

grant references on table "public"."college_mentor_student_allocations" to "anon";

grant select on table "public"."college_mentor_student_allocations" to "anon";

grant trigger on table "public"."college_mentor_student_allocations" to "anon";

grant truncate on table "public"."college_mentor_student_allocations" to "anon";

grant update on table "public"."college_mentor_student_allocations" to "anon";

grant delete on table "public"."college_mentor_student_allocations" to "authenticated";

grant insert on table "public"."college_mentor_student_allocations" to "authenticated";

grant references on table "public"."college_mentor_student_allocations" to "authenticated";

grant select on table "public"."college_mentor_student_allocations" to "authenticated";

grant trigger on table "public"."college_mentor_student_allocations" to "authenticated";

grant truncate on table "public"."college_mentor_student_allocations" to "authenticated";

grant update on table "public"."college_mentor_student_allocations" to "authenticated";

grant delete on table "public"."college_mentor_student_allocations" to "service_role";

grant insert on table "public"."college_mentor_student_allocations" to "service_role";

grant references on table "public"."college_mentor_student_allocations" to "service_role";

grant select on table "public"."college_mentor_student_allocations" to "service_role";

grant trigger on table "public"."college_mentor_student_allocations" to "service_role";

grant truncate on table "public"."college_mentor_student_allocations" to "service_role";

grant update on table "public"."college_mentor_student_allocations" to "service_role";

grant delete on table "public"."college_role_module_permissions" to "anon";

grant insert on table "public"."college_role_module_permissions" to "anon";

grant references on table "public"."college_role_module_permissions" to "anon";

grant select on table "public"."college_role_module_permissions" to "anon";

grant trigger on table "public"."college_role_module_permissions" to "anon";

grant truncate on table "public"."college_role_module_permissions" to "anon";

grant update on table "public"."college_role_module_permissions" to "anon";

grant delete on table "public"."college_role_module_permissions" to "authenticated";

grant insert on table "public"."college_role_module_permissions" to "authenticated";

grant references on table "public"."college_role_module_permissions" to "authenticated";

grant select on table "public"."college_role_module_permissions" to "authenticated";

grant trigger on table "public"."college_role_module_permissions" to "authenticated";

grant truncate on table "public"."college_role_module_permissions" to "authenticated";

grant update on table "public"."college_role_module_permissions" to "authenticated";

grant delete on table "public"."college_role_module_permissions" to "service_role";

grant insert on table "public"."college_role_module_permissions" to "service_role";

grant references on table "public"."college_role_module_permissions" to "service_role";

grant select on table "public"."college_role_module_permissions" to "service_role";

grant trigger on table "public"."college_role_module_permissions" to "service_role";

grant truncate on table "public"."college_role_module_permissions" to "service_role";

grant update on table "public"."college_role_module_permissions" to "service_role";

grant delete on table "public"."college_role_scope_rules" to "anon";

grant insert on table "public"."college_role_scope_rules" to "anon";

grant references on table "public"."college_role_scope_rules" to "anon";

grant select on table "public"."college_role_scope_rules" to "anon";

grant trigger on table "public"."college_role_scope_rules" to "anon";

grant truncate on table "public"."college_role_scope_rules" to "anon";

grant update on table "public"."college_role_scope_rules" to "anon";

grant delete on table "public"."college_role_scope_rules" to "authenticated";

grant insert on table "public"."college_role_scope_rules" to "authenticated";

grant references on table "public"."college_role_scope_rules" to "authenticated";

grant select on table "public"."college_role_scope_rules" to "authenticated";

grant trigger on table "public"."college_role_scope_rules" to "authenticated";

grant truncate on table "public"."college_role_scope_rules" to "authenticated";

grant update on table "public"."college_role_scope_rules" to "authenticated";

grant delete on table "public"."college_role_scope_rules" to "service_role";

grant insert on table "public"."college_role_scope_rules" to "service_role";

grant references on table "public"."college_role_scope_rules" to "service_role";

grant select on table "public"."college_role_scope_rules" to "service_role";

grant trigger on table "public"."college_role_scope_rules" to "service_role";

grant truncate on table "public"."college_role_scope_rules" to "service_role";

grant update on table "public"."college_role_scope_rules" to "service_role";

grant delete on table "public"."college_setting_modules" to "anon";

grant insert on table "public"."college_setting_modules" to "anon";

grant references on table "public"."college_setting_modules" to "anon";

grant select on table "public"."college_setting_modules" to "anon";

grant trigger on table "public"."college_setting_modules" to "anon";

grant truncate on table "public"."college_setting_modules" to "anon";

grant update on table "public"."college_setting_modules" to "anon";

grant delete on table "public"."college_setting_modules" to "authenticated";

grant insert on table "public"."college_setting_modules" to "authenticated";

grant references on table "public"."college_setting_modules" to "authenticated";

grant select on table "public"."college_setting_modules" to "authenticated";

grant trigger on table "public"."college_setting_modules" to "authenticated";

grant truncate on table "public"."college_setting_modules" to "authenticated";

grant update on table "public"."college_setting_modules" to "authenticated";

grant delete on table "public"."college_setting_modules" to "service_role";

grant insert on table "public"."college_setting_modules" to "service_role";

grant references on table "public"."college_setting_modules" to "service_role";

grant select on table "public"."college_setting_modules" to "service_role";

grant trigger on table "public"."college_setting_modules" to "service_role";

grant truncate on table "public"."college_setting_modules" to "service_role";

grant update on table "public"."college_setting_modules" to "service_role";

grant delete on table "public"."college_setting_permissions" to "anon";

grant insert on table "public"."college_setting_permissions" to "anon";

grant references on table "public"."college_setting_permissions" to "anon";

grant select on table "public"."college_setting_permissions" to "anon";

grant trigger on table "public"."college_setting_permissions" to "anon";

grant truncate on table "public"."college_setting_permissions" to "anon";

grant update on table "public"."college_setting_permissions" to "anon";

grant delete on table "public"."college_setting_permissions" to "authenticated";

grant insert on table "public"."college_setting_permissions" to "authenticated";

grant references on table "public"."college_setting_permissions" to "authenticated";

grant select on table "public"."college_setting_permissions" to "authenticated";

grant trigger on table "public"."college_setting_permissions" to "authenticated";

grant truncate on table "public"."college_setting_permissions" to "authenticated";

grant update on table "public"."college_setting_permissions" to "authenticated";

grant delete on table "public"."college_setting_permissions" to "service_role";

grant insert on table "public"."college_setting_permissions" to "service_role";

grant references on table "public"."college_setting_permissions" to "service_role";

grant select on table "public"."college_setting_permissions" to "service_role";

grant trigger on table "public"."college_setting_permissions" to "service_role";

grant truncate on table "public"."college_setting_permissions" to "service_role";

grant update on table "public"."college_setting_permissions" to "service_role";

grant delete on table "public"."college_student_assignments" to "anon";

grant insert on table "public"."college_student_assignments" to "anon";

grant references on table "public"."college_student_assignments" to "anon";

grant select on table "public"."college_student_assignments" to "anon";

grant trigger on table "public"."college_student_assignments" to "anon";

grant truncate on table "public"."college_student_assignments" to "anon";

grant update on table "public"."college_student_assignments" to "anon";

grant delete on table "public"."college_student_assignments" to "authenticated";

grant insert on table "public"."college_student_assignments" to "authenticated";

grant references on table "public"."college_student_assignments" to "authenticated";

grant select on table "public"."college_student_assignments" to "authenticated";

grant trigger on table "public"."college_student_assignments" to "authenticated";

grant truncate on table "public"."college_student_assignments" to "authenticated";

grant update on table "public"."college_student_assignments" to "authenticated";

grant delete on table "public"."college_student_assignments" to "service_role";

grant insert on table "public"."college_student_assignments" to "service_role";

grant references on table "public"."college_student_assignments" to "service_role";

grant select on table "public"."college_student_assignments" to "service_role";

grant trigger on table "public"."college_student_assignments" to "service_role";

grant truncate on table "public"."college_student_assignments" to "service_role";

grant update on table "public"."college_student_assignments" to "service_role";

grant delete on table "public"."college_time_periods" to "anon";

grant insert on table "public"."college_time_periods" to "anon";

grant references on table "public"."college_time_periods" to "anon";

grant select on table "public"."college_time_periods" to "anon";

grant trigger on table "public"."college_time_periods" to "anon";

grant truncate on table "public"."college_time_periods" to "anon";

grant update on table "public"."college_time_periods" to "anon";

grant delete on table "public"."college_time_periods" to "authenticated";

grant insert on table "public"."college_time_periods" to "authenticated";

grant references on table "public"."college_time_periods" to "authenticated";

grant select on table "public"."college_time_periods" to "authenticated";

grant trigger on table "public"."college_time_periods" to "authenticated";

grant truncate on table "public"."college_time_periods" to "authenticated";

grant update on table "public"."college_time_periods" to "authenticated";

grant delete on table "public"."college_time_periods" to "service_role";

grant insert on table "public"."college_time_periods" to "service_role";

grant references on table "public"."college_time_periods" to "service_role";

grant select on table "public"."college_time_periods" to "service_role";

grant trigger on table "public"."college_time_periods" to "service_role";

grant truncate on table "public"."college_time_periods" to "service_role";

grant update on table "public"."college_time_periods" to "service_role";

grant delete on table "public"."college_timetable_slots" to "anon";

grant insert on table "public"."college_timetable_slots" to "anon";

grant references on table "public"."college_timetable_slots" to "anon";

grant select on table "public"."college_timetable_slots" to "anon";

grant trigger on table "public"."college_timetable_slots" to "anon";

grant truncate on table "public"."college_timetable_slots" to "anon";

grant update on table "public"."college_timetable_slots" to "anon";

grant delete on table "public"."college_timetable_slots" to "authenticated";

grant insert on table "public"."college_timetable_slots" to "authenticated";

grant references on table "public"."college_timetable_slots" to "authenticated";

grant select on table "public"."college_timetable_slots" to "authenticated";

grant trigger on table "public"."college_timetable_slots" to "authenticated";

grant truncate on table "public"."college_timetable_slots" to "authenticated";

grant update on table "public"."college_timetable_slots" to "authenticated";

grant delete on table "public"."college_timetable_slots" to "service_role";

grant insert on table "public"."college_timetable_slots" to "service_role";

grant references on table "public"."college_timetable_slots" to "service_role";

grant select on table "public"."college_timetable_slots" to "service_role";

grant trigger on table "public"."college_timetable_slots" to "service_role";

grant truncate on table "public"."college_timetable_slots" to "service_role";

grant update on table "public"."college_timetable_slots" to "service_role";

grant delete on table "public"."college_timetables" to "anon";

grant insert on table "public"."college_timetables" to "anon";

grant references on table "public"."college_timetables" to "anon";

grant select on table "public"."college_timetables" to "anon";

grant trigger on table "public"."college_timetables" to "anon";

grant truncate on table "public"."college_timetables" to "anon";

grant update on table "public"."college_timetables" to "anon";

grant delete on table "public"."college_timetables" to "authenticated";

grant insert on table "public"."college_timetables" to "authenticated";

grant references on table "public"."college_timetables" to "authenticated";

grant select on table "public"."college_timetables" to "authenticated";

grant trigger on table "public"."college_timetables" to "authenticated";

grant truncate on table "public"."college_timetables" to "authenticated";

grant update on table "public"."college_timetables" to "authenticated";

grant delete on table "public"."college_timetables" to "service_role";

grant insert on table "public"."college_timetables" to "service_role";

grant references on table "public"."college_timetables" to "service_role";

grant select on table "public"."college_timetables" to "service_role";

grant trigger on table "public"."college_timetables" to "service_role";

grant truncate on table "public"."college_timetables" to "service_role";

grant update on table "public"."college_timetables" to "service_role";

grant delete on table "public"."companies" to "anon";

grant insert on table "public"."companies" to "anon";

grant references on table "public"."companies" to "anon";

grant select on table "public"."companies" to "anon";

grant trigger on table "public"."companies" to "anon";

grant truncate on table "public"."companies" to "anon";

grant update on table "public"."companies" to "anon";

grant delete on table "public"."companies" to "authenticated";

grant insert on table "public"."companies" to "authenticated";

grant references on table "public"."companies" to "authenticated";

grant select on table "public"."companies" to "authenticated";

grant trigger on table "public"."companies" to "authenticated";

grant truncate on table "public"."companies" to "authenticated";

grant update on table "public"."companies" to "authenticated";

grant delete on table "public"."companies" to "service_role";

grant insert on table "public"."companies" to "service_role";

grant references on table "public"."companies" to "service_role";

grant select on table "public"."companies" to "service_role";

grant trigger on table "public"."companies" to "service_role";

grant truncate on table "public"."companies" to "service_role";

grant update on table "public"."companies" to "service_role";

grant delete on table "public"."company_branches" to "anon";

grant insert on table "public"."company_branches" to "anon";

grant references on table "public"."company_branches" to "anon";

grant select on table "public"."company_branches" to "anon";

grant trigger on table "public"."company_branches" to "anon";

grant truncate on table "public"."company_branches" to "anon";

grant update on table "public"."company_branches" to "anon";

grant delete on table "public"."company_branches" to "authenticated";

grant insert on table "public"."company_branches" to "authenticated";

grant references on table "public"."company_branches" to "authenticated";

grant select on table "public"."company_branches" to "authenticated";

grant trigger on table "public"."company_branches" to "authenticated";

grant truncate on table "public"."company_branches" to "authenticated";

grant update on table "public"."company_branches" to "authenticated";

grant delete on table "public"."company_branches" to "service_role";

grant insert on table "public"."company_branches" to "service_role";

grant references on table "public"."company_branches" to "service_role";

grant select on table "public"."company_branches" to "service_role";

grant trigger on table "public"."company_branches" to "service_role";

grant truncate on table "public"."company_branches" to "service_role";

grant update on table "public"."company_branches" to "service_role";

grant delete on table "public"."competition_clubs" to "anon";

grant insert on table "public"."competition_clubs" to "anon";

grant references on table "public"."competition_clubs" to "anon";

grant select on table "public"."competition_clubs" to "anon";

grant trigger on table "public"."competition_clubs" to "anon";

grant truncate on table "public"."competition_clubs" to "anon";

grant update on table "public"."competition_clubs" to "anon";

grant delete on table "public"."competition_clubs" to "authenticated";

grant insert on table "public"."competition_clubs" to "authenticated";

grant references on table "public"."competition_clubs" to "authenticated";

grant select on table "public"."competition_clubs" to "authenticated";

grant trigger on table "public"."competition_clubs" to "authenticated";

grant truncate on table "public"."competition_clubs" to "authenticated";

grant update on table "public"."competition_clubs" to "authenticated";

grant delete on table "public"."competition_clubs" to "service_role";

grant insert on table "public"."competition_clubs" to "service_role";

grant references on table "public"."competition_clubs" to "service_role";

grant select on table "public"."competition_clubs" to "service_role";

grant trigger on table "public"."competition_clubs" to "service_role";

grant truncate on table "public"."competition_clubs" to "service_role";

grant update on table "public"."competition_clubs" to "service_role";

grant delete on table "public"."competition_registrations" to "anon";

grant insert on table "public"."competition_registrations" to "anon";

grant references on table "public"."competition_registrations" to "anon";

grant select on table "public"."competition_registrations" to "anon";

grant trigger on table "public"."competition_registrations" to "anon";

grant truncate on table "public"."competition_registrations" to "anon";

grant update on table "public"."competition_registrations" to "anon";

grant delete on table "public"."competition_registrations" to "authenticated";

grant insert on table "public"."competition_registrations" to "authenticated";

grant references on table "public"."competition_registrations" to "authenticated";

grant select on table "public"."competition_registrations" to "authenticated";

grant trigger on table "public"."competition_registrations" to "authenticated";

grant truncate on table "public"."competition_registrations" to "authenticated";

grant update on table "public"."competition_registrations" to "authenticated";

grant delete on table "public"."competition_registrations" to "service_role";

grant insert on table "public"."competition_registrations" to "service_role";

grant references on table "public"."competition_registrations" to "service_role";

grant select on table "public"."competition_registrations" to "service_role";

grant trigger on table "public"."competition_registrations" to "service_role";

grant truncate on table "public"."competition_registrations" to "service_role";

grant update on table "public"."competition_registrations" to "service_role";

grant delete on table "public"."competition_results" to "anon";

grant insert on table "public"."competition_results" to "anon";

grant references on table "public"."competition_results" to "anon";

grant select on table "public"."competition_results" to "anon";

grant trigger on table "public"."competition_results" to "anon";

grant truncate on table "public"."competition_results" to "anon";

grant update on table "public"."competition_results" to "anon";

grant delete on table "public"."competition_results" to "authenticated";

grant insert on table "public"."competition_results" to "authenticated";

grant references on table "public"."competition_results" to "authenticated";

grant select on table "public"."competition_results" to "authenticated";

grant trigger on table "public"."competition_results" to "authenticated";

grant truncate on table "public"."competition_results" to "authenticated";

grant update on table "public"."competition_results" to "authenticated";

grant delete on table "public"."competition_results" to "service_role";

grant insert on table "public"."competition_results" to "service_role";

grant references on table "public"."competition_results" to "service_role";

grant select on table "public"."competition_results" to "service_role";

grant trigger on table "public"."competition_results" to "service_role";

grant truncate on table "public"."competition_results" to "service_role";

grant update on table "public"."competition_results" to "service_role";

grant delete on table "public"."competitions" to "anon";

grant insert on table "public"."competitions" to "anon";

grant references on table "public"."competitions" to "anon";

grant select on table "public"."competitions" to "anon";

grant trigger on table "public"."competitions" to "anon";

grant truncate on table "public"."competitions" to "anon";

grant update on table "public"."competitions" to "anon";

grant delete on table "public"."competitions" to "authenticated";

grant insert on table "public"."competitions" to "authenticated";

grant references on table "public"."competitions" to "authenticated";

grant select on table "public"."competitions" to "authenticated";

grant trigger on table "public"."competitions" to "authenticated";

grant truncate on table "public"."competitions" to "authenticated";

grant update on table "public"."competitions" to "authenticated";

grant delete on table "public"."competitions" to "service_role";

grant insert on table "public"."competitions" to "service_role";

grant references on table "public"."competitions" to "service_role";

grant select on table "public"."competitions" to "service_role";

grant trigger on table "public"."competitions" to "service_role";

grant truncate on table "public"."competitions" to "service_role";

grant update on table "public"."competitions" to "service_role";

grant delete on table "public"."conversations" to "anon";

grant insert on table "public"."conversations" to "anon";

grant references on table "public"."conversations" to "anon";

grant select on table "public"."conversations" to "anon";

grant trigger on table "public"."conversations" to "anon";

grant truncate on table "public"."conversations" to "anon";

grant update on table "public"."conversations" to "anon";

grant delete on table "public"."conversations" to "authenticated";

grant insert on table "public"."conversations" to "authenticated";

grant references on table "public"."conversations" to "authenticated";

grant select on table "public"."conversations" to "authenticated";

grant trigger on table "public"."conversations" to "authenticated";

grant truncate on table "public"."conversations" to "authenticated";

grant update on table "public"."conversations" to "authenticated";

grant delete on table "public"."conversations" to "service_role";

grant insert on table "public"."conversations" to "service_role";

grant references on table "public"."conversations" to "service_role";

grant select on table "public"."conversations" to "service_role";

grant trigger on table "public"."conversations" to "service_role";

grant truncate on table "public"."conversations" to "service_role";

grant update on table "public"."conversations" to "service_role";

grant delete on table "public"."conversations_backup_20251106" to "anon";

grant insert on table "public"."conversations_backup_20251106" to "anon";

grant references on table "public"."conversations_backup_20251106" to "anon";

grant select on table "public"."conversations_backup_20251106" to "anon";

grant trigger on table "public"."conversations_backup_20251106" to "anon";

grant truncate on table "public"."conversations_backup_20251106" to "anon";

grant update on table "public"."conversations_backup_20251106" to "anon";

grant delete on table "public"."conversations_backup_20251106" to "authenticated";

grant insert on table "public"."conversations_backup_20251106" to "authenticated";

grant references on table "public"."conversations_backup_20251106" to "authenticated";

grant select on table "public"."conversations_backup_20251106" to "authenticated";

grant trigger on table "public"."conversations_backup_20251106" to "authenticated";

grant truncate on table "public"."conversations_backup_20251106" to "authenticated";

grant update on table "public"."conversations_backup_20251106" to "authenticated";

grant delete on table "public"."conversations_backup_20251106" to "service_role";

grant insert on table "public"."conversations_backup_20251106" to "service_role";

grant references on table "public"."conversations_backup_20251106" to "service_role";

grant select on table "public"."conversations_backup_20251106" to "service_role";

grant trigger on table "public"."conversations_backup_20251106" to "service_role";

grant truncate on table "public"."conversations_backup_20251106" to "service_role";

grant update on table "public"."conversations_backup_20251106" to "service_role";

grant delete on table "public"."course_classes" to "anon";

grant insert on table "public"."course_classes" to "anon";

grant references on table "public"."course_classes" to "anon";

grant select on table "public"."course_classes" to "anon";

grant trigger on table "public"."course_classes" to "anon";

grant truncate on table "public"."course_classes" to "anon";

grant update on table "public"."course_classes" to "anon";

grant delete on table "public"."course_classes" to "authenticated";

grant insert on table "public"."course_classes" to "authenticated";

grant references on table "public"."course_classes" to "authenticated";

grant select on table "public"."course_classes" to "authenticated";

grant trigger on table "public"."course_classes" to "authenticated";

grant truncate on table "public"."course_classes" to "authenticated";

grant update on table "public"."course_classes" to "authenticated";

grant delete on table "public"."course_classes" to "service_role";

grant insert on table "public"."course_classes" to "service_role";

grant references on table "public"."course_classes" to "service_role";

grant select on table "public"."course_classes" to "service_role";

grant trigger on table "public"."course_classes" to "service_role";

grant truncate on table "public"."course_classes" to "service_role";

grant update on table "public"."course_classes" to "service_role";

grant delete on table "public"."course_co_educators" to "anon";

grant insert on table "public"."course_co_educators" to "anon";

grant references on table "public"."course_co_educators" to "anon";

grant select on table "public"."course_co_educators" to "anon";

grant trigger on table "public"."course_co_educators" to "anon";

grant truncate on table "public"."course_co_educators" to "anon";

grant update on table "public"."course_co_educators" to "anon";

grant delete on table "public"."course_co_educators" to "authenticated";

grant insert on table "public"."course_co_educators" to "authenticated";

grant references on table "public"."course_co_educators" to "authenticated";

grant select on table "public"."course_co_educators" to "authenticated";

grant trigger on table "public"."course_co_educators" to "authenticated";

grant truncate on table "public"."course_co_educators" to "authenticated";

grant update on table "public"."course_co_educators" to "authenticated";

grant delete on table "public"."course_co_educators" to "service_role";

grant insert on table "public"."course_co_educators" to "service_role";

grant references on table "public"."course_co_educators" to "service_role";

grant select on table "public"."course_co_educators" to "service_role";

grant trigger on table "public"."course_co_educators" to "service_role";

grant truncate on table "public"."course_co_educators" to "service_role";

grant update on table "public"."course_co_educators" to "service_role";

grant delete on table "public"."course_enrollments" to "anon";

grant insert on table "public"."course_enrollments" to "anon";

grant references on table "public"."course_enrollments" to "anon";

grant select on table "public"."course_enrollments" to "anon";

grant trigger on table "public"."course_enrollments" to "anon";

grant truncate on table "public"."course_enrollments" to "anon";

grant update on table "public"."course_enrollments" to "anon";

grant delete on table "public"."course_enrollments" to "authenticated";

grant insert on table "public"."course_enrollments" to "authenticated";

grant references on table "public"."course_enrollments" to "authenticated";

grant select on table "public"."course_enrollments" to "authenticated";

grant trigger on table "public"."course_enrollments" to "authenticated";

grant truncate on table "public"."course_enrollments" to "authenticated";

grant update on table "public"."course_enrollments" to "authenticated";

grant delete on table "public"."course_enrollments" to "service_role";

grant insert on table "public"."course_enrollments" to "service_role";

grant references on table "public"."course_enrollments" to "service_role";

grant select on table "public"."course_enrollments" to "service_role";

grant trigger on table "public"."course_enrollments" to "service_role";

grant truncate on table "public"."course_enrollments" to "service_role";

grant update on table "public"."course_enrollments" to "service_role";

grant delete on table "public"."course_modules" to "anon";

grant insert on table "public"."course_modules" to "anon";

grant references on table "public"."course_modules" to "anon";

grant select on table "public"."course_modules" to "anon";

grant trigger on table "public"."course_modules" to "anon";

grant truncate on table "public"."course_modules" to "anon";

grant update on table "public"."course_modules" to "anon";

grant delete on table "public"."course_modules" to "authenticated";

grant insert on table "public"."course_modules" to "authenticated";

grant references on table "public"."course_modules" to "authenticated";

grant select on table "public"."course_modules" to "authenticated";

grant trigger on table "public"."course_modules" to "authenticated";

grant truncate on table "public"."course_modules" to "authenticated";

grant update on table "public"."course_modules" to "authenticated";

grant delete on table "public"."course_modules" to "service_role";

grant insert on table "public"."course_modules" to "service_role";

grant references on table "public"."course_modules" to "service_role";

grant select on table "public"."course_modules" to "service_role";

grant trigger on table "public"."course_modules" to "service_role";

grant truncate on table "public"."course_modules" to "service_role";

grant update on table "public"."course_modules" to "service_role";

grant delete on table "public"."course_skills" to "anon";

grant insert on table "public"."course_skills" to "anon";

grant references on table "public"."course_skills" to "anon";

grant select on table "public"."course_skills" to "anon";

grant trigger on table "public"."course_skills" to "anon";

grant truncate on table "public"."course_skills" to "anon";

grant update on table "public"."course_skills" to "anon";

grant delete on table "public"."course_skills" to "authenticated";

grant insert on table "public"."course_skills" to "authenticated";

grant references on table "public"."course_skills" to "authenticated";

grant select on table "public"."course_skills" to "authenticated";

grant trigger on table "public"."course_skills" to "authenticated";

grant truncate on table "public"."course_skills" to "authenticated";

grant update on table "public"."course_skills" to "authenticated";

grant delete on table "public"."course_skills" to "service_role";

grant insert on table "public"."course_skills" to "service_role";

grant references on table "public"."course_skills" to "service_role";

grant select on table "public"."course_skills" to "service_role";

grant trigger on table "public"."course_skills" to "service_role";

grant truncate on table "public"."course_skills" to "service_role";

grant update on table "public"."course_skills" to "service_role";

grant delete on table "public"."courses" to "anon";

grant insert on table "public"."courses" to "anon";

grant references on table "public"."courses" to "anon";

grant select on table "public"."courses" to "anon";

grant trigger on table "public"."courses" to "anon";

grant truncate on table "public"."courses" to "anon";

grant update on table "public"."courses" to "anon";

grant delete on table "public"."courses" to "authenticated";

grant insert on table "public"."courses" to "authenticated";

grant references on table "public"."courses" to "authenticated";

grant select on table "public"."courses" to "authenticated";

grant trigger on table "public"."courses" to "authenticated";

grant truncate on table "public"."courses" to "authenticated";

grant update on table "public"."courses" to "authenticated";

grant delete on table "public"."courses" to "service_role";

grant insert on table "public"."courses" to "service_role";

grant references on table "public"."courses" to "service_role";

grant select on table "public"."courses" to "service_role";

grant trigger on table "public"."courses" to "service_role";

grant truncate on table "public"."courses" to "service_role";

grant update on table "public"."courses" to "service_role";

grant delete on table "public"."curriculum_academic_years" to "anon";

grant insert on table "public"."curriculum_academic_years" to "anon";

grant references on table "public"."curriculum_academic_years" to "anon";

grant select on table "public"."curriculum_academic_years" to "anon";

grant trigger on table "public"."curriculum_academic_years" to "anon";

grant truncate on table "public"."curriculum_academic_years" to "anon";

grant update on table "public"."curriculum_academic_years" to "anon";

grant delete on table "public"."curriculum_academic_years" to "authenticated";

grant insert on table "public"."curriculum_academic_years" to "authenticated";

grant references on table "public"."curriculum_academic_years" to "authenticated";

grant select on table "public"."curriculum_academic_years" to "authenticated";

grant trigger on table "public"."curriculum_academic_years" to "authenticated";

grant truncate on table "public"."curriculum_academic_years" to "authenticated";

grant update on table "public"."curriculum_academic_years" to "authenticated";

grant delete on table "public"."curriculum_academic_years" to "service_role";

grant insert on table "public"."curriculum_academic_years" to "service_role";

grant references on table "public"."curriculum_academic_years" to "service_role";

grant select on table "public"."curriculum_academic_years" to "service_role";

grant trigger on table "public"."curriculum_academic_years" to "service_role";

grant truncate on table "public"."curriculum_academic_years" to "service_role";

grant update on table "public"."curriculum_academic_years" to "service_role";

grant delete on table "public"."curriculum_chapters" to "anon";

grant insert on table "public"."curriculum_chapters" to "anon";

grant references on table "public"."curriculum_chapters" to "anon";

grant select on table "public"."curriculum_chapters" to "anon";

grant trigger on table "public"."curriculum_chapters" to "anon";

grant truncate on table "public"."curriculum_chapters" to "anon";

grant update on table "public"."curriculum_chapters" to "anon";

grant delete on table "public"."curriculum_chapters" to "authenticated";

grant insert on table "public"."curriculum_chapters" to "authenticated";

grant references on table "public"."curriculum_chapters" to "authenticated";

grant select on table "public"."curriculum_chapters" to "authenticated";

grant trigger on table "public"."curriculum_chapters" to "authenticated";

grant truncate on table "public"."curriculum_chapters" to "authenticated";

grant update on table "public"."curriculum_chapters" to "authenticated";

grant delete on table "public"."curriculum_chapters" to "service_role";

grant insert on table "public"."curriculum_chapters" to "service_role";

grant references on table "public"."curriculum_chapters" to "service_role";

grant select on table "public"."curriculum_chapters" to "service_role";

grant trigger on table "public"."curriculum_chapters" to "service_role";

grant truncate on table "public"."curriculum_chapters" to "service_role";

grant update on table "public"."curriculum_chapters" to "service_role";

grant delete on table "public"."curriculum_classes" to "anon";

grant insert on table "public"."curriculum_classes" to "anon";

grant references on table "public"."curriculum_classes" to "anon";

grant select on table "public"."curriculum_classes" to "anon";

grant trigger on table "public"."curriculum_classes" to "anon";

grant truncate on table "public"."curriculum_classes" to "anon";

grant update on table "public"."curriculum_classes" to "anon";

grant delete on table "public"."curriculum_classes" to "authenticated";

grant insert on table "public"."curriculum_classes" to "authenticated";

grant references on table "public"."curriculum_classes" to "authenticated";

grant select on table "public"."curriculum_classes" to "authenticated";

grant trigger on table "public"."curriculum_classes" to "authenticated";

grant truncate on table "public"."curriculum_classes" to "authenticated";

grant update on table "public"."curriculum_classes" to "authenticated";

grant delete on table "public"."curriculum_classes" to "service_role";

grant insert on table "public"."curriculum_classes" to "service_role";

grant references on table "public"."curriculum_classes" to "service_role";

grant select on table "public"."curriculum_classes" to "service_role";

grant trigger on table "public"."curriculum_classes" to "service_role";

grant truncate on table "public"."curriculum_classes" to "service_role";

grant update on table "public"."curriculum_classes" to "service_role";

grant delete on table "public"."curriculum_courses" to "anon";

grant insert on table "public"."curriculum_courses" to "anon";

grant references on table "public"."curriculum_courses" to "anon";

grant select on table "public"."curriculum_courses" to "anon";

grant trigger on table "public"."curriculum_courses" to "anon";

grant truncate on table "public"."curriculum_courses" to "anon";

grant update on table "public"."curriculum_courses" to "anon";

grant delete on table "public"."curriculum_courses" to "authenticated";

grant insert on table "public"."curriculum_courses" to "authenticated";

grant references on table "public"."curriculum_courses" to "authenticated";

grant select on table "public"."curriculum_courses" to "authenticated";

grant trigger on table "public"."curriculum_courses" to "authenticated";

grant truncate on table "public"."curriculum_courses" to "authenticated";

grant update on table "public"."curriculum_courses" to "authenticated";

grant delete on table "public"."curriculum_courses" to "service_role";

grant insert on table "public"."curriculum_courses" to "service_role";

grant references on table "public"."curriculum_courses" to "service_role";

grant select on table "public"."curriculum_courses" to "service_role";

grant trigger on table "public"."curriculum_courses" to "service_role";

grant truncate on table "public"."curriculum_courses" to "service_role";

grant update on table "public"."curriculum_courses" to "service_role";

grant delete on table "public"."curriculum_learning_outcomes" to "anon";

grant insert on table "public"."curriculum_learning_outcomes" to "anon";

grant references on table "public"."curriculum_learning_outcomes" to "anon";

grant select on table "public"."curriculum_learning_outcomes" to "anon";

grant trigger on table "public"."curriculum_learning_outcomes" to "anon";

grant truncate on table "public"."curriculum_learning_outcomes" to "anon";

grant update on table "public"."curriculum_learning_outcomes" to "anon";

grant delete on table "public"."curriculum_learning_outcomes" to "authenticated";

grant insert on table "public"."curriculum_learning_outcomes" to "authenticated";

grant references on table "public"."curriculum_learning_outcomes" to "authenticated";

grant select on table "public"."curriculum_learning_outcomes" to "authenticated";

grant trigger on table "public"."curriculum_learning_outcomes" to "authenticated";

grant truncate on table "public"."curriculum_learning_outcomes" to "authenticated";

grant update on table "public"."curriculum_learning_outcomes" to "authenticated";

grant delete on table "public"."curriculum_learning_outcomes" to "service_role";

grant insert on table "public"."curriculum_learning_outcomes" to "service_role";

grant references on table "public"."curriculum_learning_outcomes" to "service_role";

grant select on table "public"."curriculum_learning_outcomes" to "service_role";

grant trigger on table "public"."curriculum_learning_outcomes" to "service_role";

grant truncate on table "public"."curriculum_learning_outcomes" to "service_role";

grant update on table "public"."curriculum_learning_outcomes" to "service_role";

grant delete on table "public"."curriculum_subjects" to "anon";

grant insert on table "public"."curriculum_subjects" to "anon";

grant references on table "public"."curriculum_subjects" to "anon";

grant select on table "public"."curriculum_subjects" to "anon";

grant trigger on table "public"."curriculum_subjects" to "anon";

grant truncate on table "public"."curriculum_subjects" to "anon";

grant update on table "public"."curriculum_subjects" to "anon";

grant delete on table "public"."curriculum_subjects" to "authenticated";

grant insert on table "public"."curriculum_subjects" to "authenticated";

grant references on table "public"."curriculum_subjects" to "authenticated";

grant select on table "public"."curriculum_subjects" to "authenticated";

grant trigger on table "public"."curriculum_subjects" to "authenticated";

grant truncate on table "public"."curriculum_subjects" to "authenticated";

grant update on table "public"."curriculum_subjects" to "authenticated";

grant delete on table "public"."curriculum_subjects" to "service_role";

grant insert on table "public"."curriculum_subjects" to "service_role";

grant references on table "public"."curriculum_subjects" to "service_role";

grant select on table "public"."curriculum_subjects" to "service_role";

grant trigger on table "public"."curriculum_subjects" to "service_role";

grant truncate on table "public"."curriculum_subjects" to "service_role";

grant update on table "public"."curriculum_subjects" to "service_role";

grant delete on table "public"."curriculums" to "anon";

grant insert on table "public"."curriculums" to "anon";

grant references on table "public"."curriculums" to "anon";

grant select on table "public"."curriculums" to "anon";

grant trigger on table "public"."curriculums" to "anon";

grant truncate on table "public"."curriculums" to "anon";

grant update on table "public"."curriculums" to "anon";

grant delete on table "public"."curriculums" to "authenticated";

grant insert on table "public"."curriculums" to "authenticated";

grant references on table "public"."curriculums" to "authenticated";

grant select on table "public"."curriculums" to "authenticated";

grant trigger on table "public"."curriculums" to "authenticated";

grant truncate on table "public"."curriculums" to "authenticated";

grant update on table "public"."curriculums" to "authenticated";

grant delete on table "public"."curriculums" to "service_role";

grant insert on table "public"."curriculums" to "service_role";

grant references on table "public"."curriculums" to "service_role";

grant select on table "public"."curriculums" to "service_role";

grant trigger on table "public"."curriculums" to "service_role";

grant truncate on table "public"."curriculums" to "service_role";

grant update on table "public"."curriculums" to "service_role";

grant delete on table "public"."department_budgets" to "anon";

grant insert on table "public"."department_budgets" to "anon";

grant references on table "public"."department_budgets" to "anon";

grant select on table "public"."department_budgets" to "anon";

grant trigger on table "public"."department_budgets" to "anon";

grant truncate on table "public"."department_budgets" to "anon";

grant update on table "public"."department_budgets" to "anon";

grant delete on table "public"."department_budgets" to "authenticated";

grant insert on table "public"."department_budgets" to "authenticated";

grant references on table "public"."department_budgets" to "authenticated";

grant select on table "public"."department_budgets" to "authenticated";

grant trigger on table "public"."department_budgets" to "authenticated";

grant truncate on table "public"."department_budgets" to "authenticated";

grant update on table "public"."department_budgets" to "authenticated";

grant delete on table "public"."department_budgets" to "service_role";

grant insert on table "public"."department_budgets" to "service_role";

grant references on table "public"."department_budgets" to "service_role";

grant select on table "public"."department_budgets" to "service_role";

grant trigger on table "public"."department_budgets" to "service_role";

grant truncate on table "public"."department_budgets" to "service_role";

grant update on table "public"."department_budgets" to "service_role";

grant delete on table "public"."department_faculty_assignments" to "anon";

grant insert on table "public"."department_faculty_assignments" to "anon";

grant references on table "public"."department_faculty_assignments" to "anon";

grant select on table "public"."department_faculty_assignments" to "anon";

grant trigger on table "public"."department_faculty_assignments" to "anon";

grant truncate on table "public"."department_faculty_assignments" to "anon";

grant update on table "public"."department_faculty_assignments" to "anon";

grant delete on table "public"."department_faculty_assignments" to "authenticated";

grant insert on table "public"."department_faculty_assignments" to "authenticated";

grant references on table "public"."department_faculty_assignments" to "authenticated";

grant select on table "public"."department_faculty_assignments" to "authenticated";

grant trigger on table "public"."department_faculty_assignments" to "authenticated";

grant truncate on table "public"."department_faculty_assignments" to "authenticated";

grant update on table "public"."department_faculty_assignments" to "authenticated";

grant delete on table "public"."department_faculty_assignments" to "service_role";

grant insert on table "public"."department_faculty_assignments" to "service_role";

grant references on table "public"."department_faculty_assignments" to "service_role";

grant select on table "public"."department_faculty_assignments" to "service_role";

grant trigger on table "public"."department_faculty_assignments" to "service_role";

grant truncate on table "public"."department_faculty_assignments" to "service_role";

grant update on table "public"."department_faculty_assignments" to "service_role";

grant delete on table "public"."departments" to "anon";

grant insert on table "public"."departments" to "anon";

grant references on table "public"."departments" to "anon";

grant select on table "public"."departments" to "anon";

grant trigger on table "public"."departments" to "anon";

grant truncate on table "public"."departments" to "anon";

grant update on table "public"."departments" to "anon";

grant delete on table "public"."departments" to "authenticated";

grant insert on table "public"."departments" to "authenticated";

grant references on table "public"."departments" to "authenticated";

grant select on table "public"."departments" to "authenticated";

grant trigger on table "public"."departments" to "authenticated";

grant truncate on table "public"."departments" to "authenticated";

grant update on table "public"."departments" to "authenticated";

grant delete on table "public"."departments" to "service_role";

grant insert on table "public"."departments" to "service_role";

grant references on table "public"."departments" to "service_role";

grant select on table "public"."departments" to "service_role";

grant trigger on table "public"."departments" to "service_role";

grant truncate on table "public"."departments" to "service_role";

grant update on table "public"."departments" to "service_role";

grant delete on table "public"."document_access_history" to "anon";

grant insert on table "public"."document_access_history" to "anon";

grant references on table "public"."document_access_history" to "anon";

grant select on table "public"."document_access_history" to "anon";

grant trigger on table "public"."document_access_history" to "anon";

grant truncate on table "public"."document_access_history" to "anon";

grant update on table "public"."document_access_history" to "anon";

grant delete on table "public"."document_access_history" to "authenticated";

grant insert on table "public"."document_access_history" to "authenticated";

grant references on table "public"."document_access_history" to "authenticated";

grant select on table "public"."document_access_history" to "authenticated";

grant trigger on table "public"."document_access_history" to "authenticated";

grant truncate on table "public"."document_access_history" to "authenticated";

grant update on table "public"."document_access_history" to "authenticated";

grant delete on table "public"."document_access_history" to "service_role";

grant insert on table "public"."document_access_history" to "service_role";

grant references on table "public"."document_access_history" to "service_role";

grant select on table "public"."document_access_history" to "service_role";

grant trigger on table "public"."document_access_history" to "service_role";

grant truncate on table "public"."document_access_history" to "service_role";

grant update on table "public"."document_access_history" to "service_role";

grant delete on table "public"."education" to "anon";

grant insert on table "public"."education" to "anon";

grant references on table "public"."education" to "anon";

grant select on table "public"."education" to "anon";

grant trigger on table "public"."education" to "anon";

grant truncate on table "public"."education" to "anon";

grant update on table "public"."education" to "anon";

grant delete on table "public"."education" to "authenticated";

grant insert on table "public"."education" to "authenticated";

grant references on table "public"."education" to "authenticated";

grant select on table "public"."education" to "authenticated";

grant trigger on table "public"."education" to "authenticated";

grant truncate on table "public"."education" to "authenticated";

grant update on table "public"."education" to "authenticated";

grant delete on table "public"."education" to "service_role";

grant insert on table "public"."education" to "service_role";

grant references on table "public"."education" to "service_role";

grant select on table "public"."education" to "service_role";

grant trigger on table "public"."education" to "service_role";

grant truncate on table "public"."education" to "service_role";

grant update on table "public"."education" to "service_role";

grant delete on table "public"."embedding_cache" to "anon";

grant insert on table "public"."embedding_cache" to "anon";

grant references on table "public"."embedding_cache" to "anon";

grant select on table "public"."embedding_cache" to "anon";

grant trigger on table "public"."embedding_cache" to "anon";

grant truncate on table "public"."embedding_cache" to "anon";

grant update on table "public"."embedding_cache" to "anon";

grant delete on table "public"."embedding_cache" to "authenticated";

grant insert on table "public"."embedding_cache" to "authenticated";

grant references on table "public"."embedding_cache" to "authenticated";

grant select on table "public"."embedding_cache" to "authenticated";

grant trigger on table "public"."embedding_cache" to "authenticated";

grant truncate on table "public"."embedding_cache" to "authenticated";

grant update on table "public"."embedding_cache" to "authenticated";

grant delete on table "public"."embedding_cache" to "service_role";

grant insert on table "public"."embedding_cache" to "service_role";

grant references on table "public"."embedding_cache" to "service_role";

grant select on table "public"."embedding_cache" to "service_role";

grant trigger on table "public"."embedding_cache" to "service_role";

grant truncate on table "public"."embedding_cache" to "service_role";

grant update on table "public"."embedding_cache" to "service_role";

grant delete on table "public"."embedding_queue" to "anon";

grant insert on table "public"."embedding_queue" to "anon";

grant references on table "public"."embedding_queue" to "anon";

grant select on table "public"."embedding_queue" to "anon";

grant trigger on table "public"."embedding_queue" to "anon";

grant truncate on table "public"."embedding_queue" to "anon";

grant update on table "public"."embedding_queue" to "anon";

grant delete on table "public"."embedding_queue" to "authenticated";

grant insert on table "public"."embedding_queue" to "authenticated";

grant references on table "public"."embedding_queue" to "authenticated";

grant select on table "public"."embedding_queue" to "authenticated";

grant trigger on table "public"."embedding_queue" to "authenticated";

grant truncate on table "public"."embedding_queue" to "authenticated";

grant update on table "public"."embedding_queue" to "authenticated";

grant delete on table "public"."embedding_queue" to "service_role";

grant insert on table "public"."embedding_queue" to "service_role";

grant references on table "public"."embedding_queue" to "service_role";

grant select on table "public"."embedding_queue" to "service_role";

grant trigger on table "public"."embedding_queue" to "service_role";

grant truncate on table "public"."embedding_queue" to "service_role";

grant update on table "public"."embedding_queue" to "service_role";

grant delete on table "public"."event_registrations" to "anon";

grant insert on table "public"."event_registrations" to "anon";

grant references on table "public"."event_registrations" to "anon";

grant select on table "public"."event_registrations" to "anon";

grant trigger on table "public"."event_registrations" to "anon";

grant truncate on table "public"."event_registrations" to "anon";

grant update on table "public"."event_registrations" to "anon";

grant delete on table "public"."event_registrations" to "authenticated";

grant insert on table "public"."event_registrations" to "authenticated";

grant references on table "public"."event_registrations" to "authenticated";

grant select on table "public"."event_registrations" to "authenticated";

grant trigger on table "public"."event_registrations" to "authenticated";

grant truncate on table "public"."event_registrations" to "authenticated";

grant update on table "public"."event_registrations" to "authenticated";

grant delete on table "public"."event_registrations" to "service_role";

grant insert on table "public"."event_registrations" to "service_role";

grant references on table "public"."event_registrations" to "service_role";

grant select on table "public"."event_registrations" to "service_role";

grant trigger on table "public"."event_registrations" to "service_role";

grant truncate on table "public"."event_registrations" to "service_role";

grant update on table "public"."event_registrations" to "service_role";

grant delete on table "public"."exam_registrations" to "anon";

grant insert on table "public"."exam_registrations" to "anon";

grant references on table "public"."exam_registrations" to "anon";

grant select on table "public"."exam_registrations" to "anon";

grant trigger on table "public"."exam_registrations" to "anon";

grant truncate on table "public"."exam_registrations" to "anon";

grant update on table "public"."exam_registrations" to "anon";

grant delete on table "public"."exam_registrations" to "authenticated";

grant insert on table "public"."exam_registrations" to "authenticated";

grant references on table "public"."exam_registrations" to "authenticated";

grant select on table "public"."exam_registrations" to "authenticated";

grant trigger on table "public"."exam_registrations" to "authenticated";

grant truncate on table "public"."exam_registrations" to "authenticated";

grant update on table "public"."exam_registrations" to "authenticated";

grant delete on table "public"."exam_registrations" to "service_role";

grant insert on table "public"."exam_registrations" to "service_role";

grant references on table "public"."exam_registrations" to "service_role";

grant select on table "public"."exam_registrations" to "service_role";

grant trigger on table "public"."exam_registrations" to "service_role";

grant truncate on table "public"."exam_registrations" to "service_role";

grant update on table "public"."exam_registrations" to "service_role";

grant delete on table "public"."exam_rooms" to "anon";

grant insert on table "public"."exam_rooms" to "anon";

grant references on table "public"."exam_rooms" to "anon";

grant select on table "public"."exam_rooms" to "anon";

grant trigger on table "public"."exam_rooms" to "anon";

grant truncate on table "public"."exam_rooms" to "anon";

grant update on table "public"."exam_rooms" to "anon";

grant delete on table "public"."exam_rooms" to "authenticated";

grant insert on table "public"."exam_rooms" to "authenticated";

grant references on table "public"."exam_rooms" to "authenticated";

grant select on table "public"."exam_rooms" to "authenticated";

grant trigger on table "public"."exam_rooms" to "authenticated";

grant truncate on table "public"."exam_rooms" to "authenticated";

grant update on table "public"."exam_rooms" to "authenticated";

grant delete on table "public"."exam_rooms" to "service_role";

grant insert on table "public"."exam_rooms" to "service_role";

grant references on table "public"."exam_rooms" to "service_role";

grant select on table "public"."exam_rooms" to "service_role";

grant trigger on table "public"."exam_rooms" to "service_role";

grant truncate on table "public"."exam_rooms" to "service_role";

grant update on table "public"."exam_rooms" to "service_role";

grant delete on table "public"."exam_seating_arrangements" to "anon";

grant insert on table "public"."exam_seating_arrangements" to "anon";

grant references on table "public"."exam_seating_arrangements" to "anon";

grant select on table "public"."exam_seating_arrangements" to "anon";

grant trigger on table "public"."exam_seating_arrangements" to "anon";

grant truncate on table "public"."exam_seating_arrangements" to "anon";

grant update on table "public"."exam_seating_arrangements" to "anon";

grant delete on table "public"."exam_seating_arrangements" to "authenticated";

grant insert on table "public"."exam_seating_arrangements" to "authenticated";

grant references on table "public"."exam_seating_arrangements" to "authenticated";

grant select on table "public"."exam_seating_arrangements" to "authenticated";

grant trigger on table "public"."exam_seating_arrangements" to "authenticated";

grant truncate on table "public"."exam_seating_arrangements" to "authenticated";

grant update on table "public"."exam_seating_arrangements" to "authenticated";

grant delete on table "public"."exam_seating_arrangements" to "service_role";

grant insert on table "public"."exam_seating_arrangements" to "service_role";

grant references on table "public"."exam_seating_arrangements" to "service_role";

grant select on table "public"."exam_seating_arrangements" to "service_role";

grant trigger on table "public"."exam_seating_arrangements" to "service_role";

grant truncate on table "public"."exam_seating_arrangements" to "service_role";

grant update on table "public"."exam_seating_arrangements" to "service_role";

grant delete on table "public"."exam_timetable" to "anon";

grant insert on table "public"."exam_timetable" to "anon";

grant references on table "public"."exam_timetable" to "anon";

grant select on table "public"."exam_timetable" to "anon";

grant trigger on table "public"."exam_timetable" to "anon";

grant truncate on table "public"."exam_timetable" to "anon";

grant update on table "public"."exam_timetable" to "anon";

grant delete on table "public"."exam_timetable" to "authenticated";

grant insert on table "public"."exam_timetable" to "authenticated";

grant references on table "public"."exam_timetable" to "authenticated";

grant select on table "public"."exam_timetable" to "authenticated";

grant trigger on table "public"."exam_timetable" to "authenticated";

grant truncate on table "public"."exam_timetable" to "authenticated";

grant update on table "public"."exam_timetable" to "authenticated";

grant delete on table "public"."exam_timetable" to "service_role";

grant insert on table "public"."exam_timetable" to "service_role";

grant references on table "public"."exam_timetable" to "service_role";

grant select on table "public"."exam_timetable" to "service_role";

grant trigger on table "public"."exam_timetable" to "service_role";

grant truncate on table "public"."exam_timetable" to "service_role";

grant update on table "public"."exam_timetable" to "service_role";

grant delete on table "public"."exam_windows" to "anon";

grant insert on table "public"."exam_windows" to "anon";

grant references on table "public"."exam_windows" to "anon";

grant select on table "public"."exam_windows" to "anon";

grant trigger on table "public"."exam_windows" to "anon";

grant truncate on table "public"."exam_windows" to "anon";

grant update on table "public"."exam_windows" to "anon";

grant delete on table "public"."exam_windows" to "authenticated";

grant insert on table "public"."exam_windows" to "authenticated";

grant references on table "public"."exam_windows" to "authenticated";

grant select on table "public"."exam_windows" to "authenticated";

grant trigger on table "public"."exam_windows" to "authenticated";

grant truncate on table "public"."exam_windows" to "authenticated";

grant update on table "public"."exam_windows" to "authenticated";

grant delete on table "public"."exam_windows" to "service_role";

grant insert on table "public"."exam_windows" to "service_role";

grant references on table "public"."exam_windows" to "service_role";

grant select on table "public"."exam_windows" to "service_role";

grant trigger on table "public"."exam_windows" to "service_role";

grant truncate on table "public"."exam_windows" to "service_role";

grant update on table "public"."exam_windows" to "service_role";

grant delete on table "public"."expenditures" to "anon";

grant insert on table "public"."expenditures" to "anon";

grant references on table "public"."expenditures" to "anon";

grant select on table "public"."expenditures" to "anon";

grant trigger on table "public"."expenditures" to "anon";

grant truncate on table "public"."expenditures" to "anon";

grant update on table "public"."expenditures" to "anon";

grant delete on table "public"."expenditures" to "authenticated";

grant insert on table "public"."expenditures" to "authenticated";

grant references on table "public"."expenditures" to "authenticated";

grant select on table "public"."expenditures" to "authenticated";

grant trigger on table "public"."expenditures" to "authenticated";

grant truncate on table "public"."expenditures" to "authenticated";

grant update on table "public"."expenditures" to "authenticated";

grant delete on table "public"."expenditures" to "service_role";

grant insert on table "public"."expenditures" to "service_role";

grant references on table "public"."expenditures" to "service_role";

grant select on table "public"."expenditures" to "service_role";

grant trigger on table "public"."expenditures" to "service_role";

grant truncate on table "public"."expenditures" to "service_role";

grant update on table "public"."expenditures" to "service_role";

grant delete on table "public"."experience" to "anon";

grant insert on table "public"."experience" to "anon";

grant references on table "public"."experience" to "anon";

grant select on table "public"."experience" to "anon";

grant trigger on table "public"."experience" to "anon";

grant truncate on table "public"."experience" to "anon";

grant update on table "public"."experience" to "anon";

grant delete on table "public"."experience" to "authenticated";

grant insert on table "public"."experience" to "authenticated";

grant references on table "public"."experience" to "authenticated";

grant select on table "public"."experience" to "authenticated";

grant trigger on table "public"."experience" to "authenticated";

grant truncate on table "public"."experience" to "authenticated";

grant update on table "public"."experience" to "authenticated";

grant delete on table "public"."experience" to "service_role";

grant insert on table "public"."experience" to "service_role";

grant references on table "public"."experience" to "service_role";

grant select on table "public"."experience" to "service_role";

grant trigger on table "public"."experience" to "service_role";

grant truncate on table "public"."experience" to "service_role";

grant update on table "public"."experience" to "service_role";

grant delete on table "public"."export_activities" to "anon";

grant insert on table "public"."export_activities" to "anon";

grant references on table "public"."export_activities" to "anon";

grant select on table "public"."export_activities" to "anon";

grant trigger on table "public"."export_activities" to "anon";

grant truncate on table "public"."export_activities" to "anon";

grant update on table "public"."export_activities" to "anon";

grant delete on table "public"."export_activities" to "authenticated";

grant insert on table "public"."export_activities" to "authenticated";

grant references on table "public"."export_activities" to "authenticated";

grant select on table "public"."export_activities" to "authenticated";

grant trigger on table "public"."export_activities" to "authenticated";

grant truncate on table "public"."export_activities" to "authenticated";

grant update on table "public"."export_activities" to "authenticated";

grant delete on table "public"."export_activities" to "service_role";

grant insert on table "public"."export_activities" to "service_role";

grant references on table "public"."export_activities" to "service_role";

grant select on table "public"."export_activities" to "service_role";

grant trigger on table "public"."export_activities" to "service_role";

grant truncate on table "public"."export_activities" to "service_role";

grant update on table "public"."export_activities" to "service_role";

grant delete on table "public"."external_assessment_attempts" to "anon";

grant insert on table "public"."external_assessment_attempts" to "anon";

grant references on table "public"."external_assessment_attempts" to "anon";

grant select on table "public"."external_assessment_attempts" to "anon";

grant trigger on table "public"."external_assessment_attempts" to "anon";

grant truncate on table "public"."external_assessment_attempts" to "anon";

grant update on table "public"."external_assessment_attempts" to "anon";

grant delete on table "public"."external_assessment_attempts" to "authenticated";

grant insert on table "public"."external_assessment_attempts" to "authenticated";

grant references on table "public"."external_assessment_attempts" to "authenticated";

grant select on table "public"."external_assessment_attempts" to "authenticated";

grant trigger on table "public"."external_assessment_attempts" to "authenticated";

grant truncate on table "public"."external_assessment_attempts" to "authenticated";

grant update on table "public"."external_assessment_attempts" to "authenticated";

grant delete on table "public"."external_assessment_attempts" to "service_role";

grant insert on table "public"."external_assessment_attempts" to "service_role";

grant references on table "public"."external_assessment_attempts" to "service_role";

grant select on table "public"."external_assessment_attempts" to "service_role";

grant trigger on table "public"."external_assessment_attempts" to "service_role";

grant truncate on table "public"."external_assessment_attempts" to "service_role";

grant update on table "public"."external_assessment_attempts" to "service_role";

grant delete on table "public"."external_courses" to "anon";

grant insert on table "public"."external_courses" to "anon";

grant references on table "public"."external_courses" to "anon";

grant select on table "public"."external_courses" to "anon";

grant trigger on table "public"."external_courses" to "anon";

grant truncate on table "public"."external_courses" to "anon";

grant update on table "public"."external_courses" to "anon";

grant delete on table "public"."external_courses" to "authenticated";

grant insert on table "public"."external_courses" to "authenticated";

grant references on table "public"."external_courses" to "authenticated";

grant select on table "public"."external_courses" to "authenticated";

grant trigger on table "public"."external_courses" to "authenticated";

grant truncate on table "public"."external_courses" to "authenticated";

grant update on table "public"."external_courses" to "authenticated";

grant delete on table "public"."external_courses" to "service_role";

grant insert on table "public"."external_courses" to "service_role";

grant references on table "public"."external_courses" to "service_role";

grant select on table "public"."external_courses" to "service_role";

grant trigger on table "public"."external_courses" to "service_role";

grant truncate on table "public"."external_courses" to "service_role";

grant update on table "public"."external_courses" to "service_role";

grant delete on table "public"."fee_payments" to "anon";

grant insert on table "public"."fee_payments" to "anon";

grant references on table "public"."fee_payments" to "anon";

grant select on table "public"."fee_payments" to "anon";

grant trigger on table "public"."fee_payments" to "anon";

grant truncate on table "public"."fee_payments" to "anon";

grant update on table "public"."fee_payments" to "anon";

grant delete on table "public"."fee_payments" to "authenticated";

grant insert on table "public"."fee_payments" to "authenticated";

grant references on table "public"."fee_payments" to "authenticated";

grant select on table "public"."fee_payments" to "authenticated";

grant trigger on table "public"."fee_payments" to "authenticated";

grant truncate on table "public"."fee_payments" to "authenticated";

grant update on table "public"."fee_payments" to "authenticated";

grant delete on table "public"."fee_payments" to "service_role";

grant insert on table "public"."fee_payments" to "service_role";

grant references on table "public"."fee_payments" to "service_role";

grant select on table "public"."fee_payments" to "service_role";

grant trigger on table "public"."fee_payments" to "service_role";

grant truncate on table "public"."fee_payments" to "service_role";

grant update on table "public"."fee_payments" to "service_role";

grant delete on table "public"."fee_structures" to "anon";

grant insert on table "public"."fee_structures" to "anon";

grant references on table "public"."fee_structures" to "anon";

grant select on table "public"."fee_structures" to "anon";

grant trigger on table "public"."fee_structures" to "anon";

grant truncate on table "public"."fee_structures" to "anon";

grant update on table "public"."fee_structures" to "anon";

grant delete on table "public"."fee_structures" to "authenticated";

grant insert on table "public"."fee_structures" to "authenticated";

grant references on table "public"."fee_structures" to "authenticated";

grant select on table "public"."fee_structures" to "authenticated";

grant trigger on table "public"."fee_structures" to "authenticated";

grant truncate on table "public"."fee_structures" to "authenticated";

grant update on table "public"."fee_structures" to "authenticated";

grant delete on table "public"."fee_structures" to "service_role";

grant insert on table "public"."fee_structures" to "service_role";

grant references on table "public"."fee_structures" to "service_role";

grant select on table "public"."fee_structures" to "service_role";

grant trigger on table "public"."fee_structures" to "service_role";

grant truncate on table "public"."fee_structures" to "service_role";

grant update on table "public"."fee_structures" to "service_role";

grant delete on table "public"."generated_external_assessment" to "anon";

grant insert on table "public"."generated_external_assessment" to "anon";

grant references on table "public"."generated_external_assessment" to "anon";

grant select on table "public"."generated_external_assessment" to "anon";

grant trigger on table "public"."generated_external_assessment" to "anon";

grant truncate on table "public"."generated_external_assessment" to "anon";

grant update on table "public"."generated_external_assessment" to "anon";

grant delete on table "public"."generated_external_assessment" to "authenticated";

grant insert on table "public"."generated_external_assessment" to "authenticated";

grant references on table "public"."generated_external_assessment" to "authenticated";

grant select on table "public"."generated_external_assessment" to "authenticated";

grant trigger on table "public"."generated_external_assessment" to "authenticated";

grant truncate on table "public"."generated_external_assessment" to "authenticated";

grant update on table "public"."generated_external_assessment" to "authenticated";

grant delete on table "public"."generated_external_assessment" to "service_role";

grant insert on table "public"."generated_external_assessment" to "service_role";

grant references on table "public"."generated_external_assessment" to "service_role";

grant select on table "public"."generated_external_assessment" to "service_role";

grant trigger on table "public"."generated_external_assessment" to "service_role";

grant truncate on table "public"."generated_external_assessment" to "service_role";

grant update on table "public"."generated_external_assessment" to "service_role";

grant delete on table "public"."grading_systems" to "anon";

grant insert on table "public"."grading_systems" to "anon";

grant references on table "public"."grading_systems" to "anon";

grant select on table "public"."grading_systems" to "anon";

grant trigger on table "public"."grading_systems" to "anon";

grant truncate on table "public"."grading_systems" to "anon";

grant update on table "public"."grading_systems" to "anon";

grant delete on table "public"."grading_systems" to "authenticated";

grant insert on table "public"."grading_systems" to "authenticated";

grant references on table "public"."grading_systems" to "authenticated";

grant select on table "public"."grading_systems" to "authenticated";

grant trigger on table "public"."grading_systems" to "authenticated";

grant truncate on table "public"."grading_systems" to "authenticated";

grant update on table "public"."grading_systems" to "authenticated";

grant delete on table "public"."grading_systems" to "service_role";

grant insert on table "public"."grading_systems" to "service_role";

grant references on table "public"."grading_systems" to "service_role";

grant select on table "public"."grading_systems" to "service_role";

grant trigger on table "public"."grading_systems" to "service_role";

grant truncate on table "public"."grading_systems" to "service_role";

grant update on table "public"."grading_systems" to "service_role";

grant delete on table "public"."institution_pricing_tiers" to "anon";

grant insert on table "public"."institution_pricing_tiers" to "anon";

grant references on table "public"."institution_pricing_tiers" to "anon";

grant select on table "public"."institution_pricing_tiers" to "anon";

grant trigger on table "public"."institution_pricing_tiers" to "anon";

grant truncate on table "public"."institution_pricing_tiers" to "anon";

grant update on table "public"."institution_pricing_tiers" to "anon";

grant delete on table "public"."institution_pricing_tiers" to "authenticated";

grant insert on table "public"."institution_pricing_tiers" to "authenticated";

grant references on table "public"."institution_pricing_tiers" to "authenticated";

grant select on table "public"."institution_pricing_tiers" to "authenticated";

grant trigger on table "public"."institution_pricing_tiers" to "authenticated";

grant truncate on table "public"."institution_pricing_tiers" to "authenticated";

grant update on table "public"."institution_pricing_tiers" to "authenticated";

grant delete on table "public"."institution_pricing_tiers" to "service_role";

grant insert on table "public"."institution_pricing_tiers" to "service_role";

grant references on table "public"."institution_pricing_tiers" to "service_role";

grant select on table "public"."institution_pricing_tiers" to "service_role";

grant trigger on table "public"."institution_pricing_tiers" to "service_role";

grant truncate on table "public"."institution_pricing_tiers" to "service_role";

grant update on table "public"."institution_pricing_tiers" to "service_role";

grant delete on table "public"."internships" to "anon";

grant insert on table "public"."internships" to "anon";

grant references on table "public"."internships" to "anon";

grant select on table "public"."internships" to "anon";

grant trigger on table "public"."internships" to "anon";

grant truncate on table "public"."internships" to "anon";

grant update on table "public"."internships" to "anon";

grant delete on table "public"."internships" to "authenticated";

grant insert on table "public"."internships" to "authenticated";

grant references on table "public"."internships" to "authenticated";

grant select on table "public"."internships" to "authenticated";

grant trigger on table "public"."internships" to "authenticated";

grant truncate on table "public"."internships" to "authenticated";

grant update on table "public"."internships" to "authenticated";

grant delete on table "public"."internships" to "service_role";

grant insert on table "public"."internships" to "service_role";

grant references on table "public"."internships" to "service_role";

grant select on table "public"."internships" to "service_role";

grant trigger on table "public"."internships" to "service_role";

grant truncate on table "public"."internships" to "service_role";

grant update on table "public"."internships" to "service_role";

grant delete on table "public"."interview_reminders" to "anon";

grant insert on table "public"."interview_reminders" to "anon";

grant references on table "public"."interview_reminders" to "anon";

grant select on table "public"."interview_reminders" to "anon";

grant trigger on table "public"."interview_reminders" to "anon";

grant truncate on table "public"."interview_reminders" to "anon";

grant update on table "public"."interview_reminders" to "anon";

grant delete on table "public"."interview_reminders" to "authenticated";

grant insert on table "public"."interview_reminders" to "authenticated";

grant references on table "public"."interview_reminders" to "authenticated";

grant select on table "public"."interview_reminders" to "authenticated";

grant trigger on table "public"."interview_reminders" to "authenticated";

grant truncate on table "public"."interview_reminders" to "authenticated";

grant update on table "public"."interview_reminders" to "authenticated";

grant delete on table "public"."interview_reminders" to "service_role";

grant insert on table "public"."interview_reminders" to "service_role";

grant references on table "public"."interview_reminders" to "service_role";

grant select on table "public"."interview_reminders" to "service_role";

grant trigger on table "public"."interview_reminders" to "service_role";

grant truncate on table "public"."interview_reminders" to "service_role";

grant update on table "public"."interview_reminders" to "service_role";

grant delete on table "public"."interviews" to "anon";

grant insert on table "public"."interviews" to "anon";

grant references on table "public"."interviews" to "anon";

grant select on table "public"."interviews" to "anon";

grant trigger on table "public"."interviews" to "anon";

grant truncate on table "public"."interviews" to "anon";

grant update on table "public"."interviews" to "anon";

grant delete on table "public"."interviews" to "authenticated";

grant insert on table "public"."interviews" to "authenticated";

grant references on table "public"."interviews" to "authenticated";

grant select on table "public"."interviews" to "authenticated";

grant trigger on table "public"."interviews" to "authenticated";

grant truncate on table "public"."interviews" to "authenticated";

grant update on table "public"."interviews" to "authenticated";

grant delete on table "public"."interviews" to "service_role";

grant insert on table "public"."interviews" to "service_role";

grant references on table "public"."interviews" to "service_role";

grant select on table "public"."interviews" to "service_role";

grant trigger on table "public"."interviews" to "service_role";

grant truncate on table "public"."interviews" to "service_role";

grant update on table "public"."interviews" to "service_role";

grant delete on table "public"."invigilator_assignments" to "anon";

grant insert on table "public"."invigilator_assignments" to "anon";

grant references on table "public"."invigilator_assignments" to "anon";

grant select on table "public"."invigilator_assignments" to "anon";

grant trigger on table "public"."invigilator_assignments" to "anon";

grant truncate on table "public"."invigilator_assignments" to "anon";

grant update on table "public"."invigilator_assignments" to "anon";

grant delete on table "public"."invigilator_assignments" to "authenticated";

grant insert on table "public"."invigilator_assignments" to "authenticated";

grant references on table "public"."invigilator_assignments" to "authenticated";

grant select on table "public"."invigilator_assignments" to "authenticated";

grant trigger on table "public"."invigilator_assignments" to "authenticated";

grant truncate on table "public"."invigilator_assignments" to "authenticated";

grant update on table "public"."invigilator_assignments" to "authenticated";

grant delete on table "public"."invigilator_assignments" to "service_role";

grant insert on table "public"."invigilator_assignments" to "service_role";

grant references on table "public"."invigilator_assignments" to "service_role";

grant select on table "public"."invigilator_assignments" to "service_role";

grant trigger on table "public"."invigilator_assignments" to "service_role";

grant truncate on table "public"."invigilator_assignments" to "service_role";

grant update on table "public"."invigilator_assignments" to "service_role";

grant delete on table "public"."lesson_plans" to "anon";

grant insert on table "public"."lesson_plans" to "anon";

grant references on table "public"."lesson_plans" to "anon";

grant select on table "public"."lesson_plans" to "anon";

grant trigger on table "public"."lesson_plans" to "anon";

grant truncate on table "public"."lesson_plans" to "anon";

grant update on table "public"."lesson_plans" to "anon";

grant delete on table "public"."lesson_plans" to "authenticated";

grant insert on table "public"."lesson_plans" to "authenticated";

grant references on table "public"."lesson_plans" to "authenticated";

grant select on table "public"."lesson_plans" to "authenticated";

grant trigger on table "public"."lesson_plans" to "authenticated";

grant truncate on table "public"."lesson_plans" to "authenticated";

grant update on table "public"."lesson_plans" to "authenticated";

grant delete on table "public"."lesson_plans" to "service_role";

grant insert on table "public"."lesson_plans" to "service_role";

grant references on table "public"."lesson_plans" to "service_role";

grant select on table "public"."lesson_plans" to "service_role";

grant trigger on table "public"."lesson_plans" to "service_role";

grant truncate on table "public"."lesson_plans" to "service_role";

grant update on table "public"."lesson_plans" to "service_role";

grant delete on table "public"."lesson_resources" to "anon";

grant insert on table "public"."lesson_resources" to "anon";

grant references on table "public"."lesson_resources" to "anon";

grant select on table "public"."lesson_resources" to "anon";

grant trigger on table "public"."lesson_resources" to "anon";

grant truncate on table "public"."lesson_resources" to "anon";

grant update on table "public"."lesson_resources" to "anon";

grant delete on table "public"."lesson_resources" to "authenticated";

grant insert on table "public"."lesson_resources" to "authenticated";

grant references on table "public"."lesson_resources" to "authenticated";

grant select on table "public"."lesson_resources" to "authenticated";

grant trigger on table "public"."lesson_resources" to "authenticated";

grant truncate on table "public"."lesson_resources" to "authenticated";

grant update on table "public"."lesson_resources" to "authenticated";

grant delete on table "public"."lesson_resources" to "service_role";

grant insert on table "public"."lesson_resources" to "service_role";

grant references on table "public"."lesson_resources" to "service_role";

grant select on table "public"."lesson_resources" to "service_role";

grant trigger on table "public"."lesson_resources" to "service_role";

grant truncate on table "public"."lesson_resources" to "service_role";

grant update on table "public"."lesson_resources" to "service_role";

grant delete on table "public"."lessons" to "anon";

grant insert on table "public"."lessons" to "anon";

grant references on table "public"."lessons" to "anon";

grant select on table "public"."lessons" to "anon";

grant trigger on table "public"."lessons" to "anon";

grant truncate on table "public"."lessons" to "anon";

grant update on table "public"."lessons" to "anon";

grant delete on table "public"."lessons" to "authenticated";

grant insert on table "public"."lessons" to "authenticated";

grant references on table "public"."lessons" to "authenticated";

grant select on table "public"."lessons" to "authenticated";

grant trigger on table "public"."lessons" to "authenticated";

grant truncate on table "public"."lessons" to "authenticated";

grant update on table "public"."lessons" to "authenticated";

grant delete on table "public"."lessons" to "service_role";

grant insert on table "public"."lessons" to "service_role";

grant references on table "public"."lessons" to "service_role";

grant select on table "public"."lessons" to "service_role";

grant trigger on table "public"."lessons" to "service_role";

grant truncate on table "public"."lessons" to "service_role";

grant update on table "public"."lessons" to "service_role";

grant delete on table "public"."library_book_issues" to "anon";

grant insert on table "public"."library_book_issues" to "anon";

grant references on table "public"."library_book_issues" to "anon";

grant select on table "public"."library_book_issues" to "anon";

grant trigger on table "public"."library_book_issues" to "anon";

grant truncate on table "public"."library_book_issues" to "anon";

grant update on table "public"."library_book_issues" to "anon";

grant delete on table "public"."library_book_issues" to "authenticated";

grant insert on table "public"."library_book_issues" to "authenticated";

grant references on table "public"."library_book_issues" to "authenticated";

grant select on table "public"."library_book_issues" to "authenticated";

grant trigger on table "public"."library_book_issues" to "authenticated";

grant truncate on table "public"."library_book_issues" to "authenticated";

grant update on table "public"."library_book_issues" to "authenticated";

grant delete on table "public"."library_book_issues" to "service_role";

grant insert on table "public"."library_book_issues" to "service_role";

grant references on table "public"."library_book_issues" to "service_role";

grant select on table "public"."library_book_issues" to "service_role";

grant trigger on table "public"."library_book_issues" to "service_role";

grant truncate on table "public"."library_book_issues" to "service_role";

grant update on table "public"."library_book_issues" to "service_role";

grant delete on table "public"."library_book_issues_college" to "anon";

grant insert on table "public"."library_book_issues_college" to "anon";

grant references on table "public"."library_book_issues_college" to "anon";

grant select on table "public"."library_book_issues_college" to "anon";

grant trigger on table "public"."library_book_issues_college" to "anon";

grant truncate on table "public"."library_book_issues_college" to "anon";

grant update on table "public"."library_book_issues_college" to "anon";

grant delete on table "public"."library_book_issues_college" to "authenticated";

grant insert on table "public"."library_book_issues_college" to "authenticated";

grant references on table "public"."library_book_issues_college" to "authenticated";

grant select on table "public"."library_book_issues_college" to "authenticated";

grant trigger on table "public"."library_book_issues_college" to "authenticated";

grant truncate on table "public"."library_book_issues_college" to "authenticated";

grant update on table "public"."library_book_issues_college" to "authenticated";

grant delete on table "public"."library_book_issues_college" to "service_role";

grant insert on table "public"."library_book_issues_college" to "service_role";

grant references on table "public"."library_book_issues_college" to "service_role";

grant select on table "public"."library_book_issues_college" to "service_role";

grant trigger on table "public"."library_book_issues_college" to "service_role";

grant truncate on table "public"."library_book_issues_college" to "service_role";

grant update on table "public"."library_book_issues_college" to "service_role";

grant delete on table "public"."library_book_issues_school" to "anon";

grant insert on table "public"."library_book_issues_school" to "anon";

grant references on table "public"."library_book_issues_school" to "anon";

grant select on table "public"."library_book_issues_school" to "anon";

grant trigger on table "public"."library_book_issues_school" to "anon";

grant truncate on table "public"."library_book_issues_school" to "anon";

grant update on table "public"."library_book_issues_school" to "anon";

grant delete on table "public"."library_book_issues_school" to "authenticated";

grant insert on table "public"."library_book_issues_school" to "authenticated";

grant references on table "public"."library_book_issues_school" to "authenticated";

grant select on table "public"."library_book_issues_school" to "authenticated";

grant trigger on table "public"."library_book_issues_school" to "authenticated";

grant truncate on table "public"."library_book_issues_school" to "authenticated";

grant update on table "public"."library_book_issues_school" to "authenticated";

grant delete on table "public"."library_book_issues_school" to "service_role";

grant insert on table "public"."library_book_issues_school" to "service_role";

grant references on table "public"."library_book_issues_school" to "service_role";

grant select on table "public"."library_book_issues_school" to "service_role";

grant trigger on table "public"."library_book_issues_school" to "service_role";

grant truncate on table "public"."library_book_issues_school" to "service_role";

grant update on table "public"."library_book_issues_school" to "service_role";

grant delete on table "public"."library_books" to "anon";

grant insert on table "public"."library_books" to "anon";

grant references on table "public"."library_books" to "anon";

grant select on table "public"."library_books" to "anon";

grant trigger on table "public"."library_books" to "anon";

grant truncate on table "public"."library_books" to "anon";

grant update on table "public"."library_books" to "anon";

grant delete on table "public"."library_books" to "authenticated";

grant insert on table "public"."library_books" to "authenticated";

grant references on table "public"."library_books" to "authenticated";

grant select on table "public"."library_books" to "authenticated";

grant trigger on table "public"."library_books" to "authenticated";

grant truncate on table "public"."library_books" to "authenticated";

grant update on table "public"."library_books" to "authenticated";

grant delete on table "public"."library_books" to "service_role";

grant insert on table "public"."library_books" to "service_role";

grant references on table "public"."library_books" to "service_role";

grant select on table "public"."library_books" to "service_role";

grant trigger on table "public"."library_books" to "service_role";

grant truncate on table "public"."library_books" to "service_role";

grant update on table "public"."library_books" to "service_role";

grant delete on table "public"."library_books_college" to "anon";

grant insert on table "public"."library_books_college" to "anon";

grant references on table "public"."library_books_college" to "anon";

grant select on table "public"."library_books_college" to "anon";

grant trigger on table "public"."library_books_college" to "anon";

grant truncate on table "public"."library_books_college" to "anon";

grant update on table "public"."library_books_college" to "anon";

grant delete on table "public"."library_books_college" to "authenticated";

grant insert on table "public"."library_books_college" to "authenticated";

grant references on table "public"."library_books_college" to "authenticated";

grant select on table "public"."library_books_college" to "authenticated";

grant trigger on table "public"."library_books_college" to "authenticated";

grant truncate on table "public"."library_books_college" to "authenticated";

grant update on table "public"."library_books_college" to "authenticated";

grant delete on table "public"."library_books_college" to "service_role";

grant insert on table "public"."library_books_college" to "service_role";

grant references on table "public"."library_books_college" to "service_role";

grant select on table "public"."library_books_college" to "service_role";

grant trigger on table "public"."library_books_college" to "service_role";

grant truncate on table "public"."library_books_college" to "service_role";

grant update on table "public"."library_books_college" to "service_role";

grant delete on table "public"."library_books_school" to "anon";

grant insert on table "public"."library_books_school" to "anon";

grant references on table "public"."library_books_school" to "anon";

grant select on table "public"."library_books_school" to "anon";

grant trigger on table "public"."library_books_school" to "anon";

grant truncate on table "public"."library_books_school" to "anon";

grant update on table "public"."library_books_school" to "anon";

grant delete on table "public"."library_books_school" to "authenticated";

grant insert on table "public"."library_books_school" to "authenticated";

grant references on table "public"."library_books_school" to "authenticated";

grant select on table "public"."library_books_school" to "authenticated";

grant trigger on table "public"."library_books_school" to "authenticated";

grant truncate on table "public"."library_books_school" to "authenticated";

grant update on table "public"."library_books_school" to "authenticated";

grant delete on table "public"."library_books_school" to "service_role";

grant insert on table "public"."library_books_school" to "service_role";

grant references on table "public"."library_books_school" to "service_role";

grant select on table "public"."library_books_school" to "service_role";

grant trigger on table "public"."library_books_school" to "service_role";

grant truncate on table "public"."library_books_school" to "service_role";

grant update on table "public"."library_books_school" to "service_role";

grant delete on table "public"."library_categories" to "anon";

grant insert on table "public"."library_categories" to "anon";

grant references on table "public"."library_categories" to "anon";

grant select on table "public"."library_categories" to "anon";

grant trigger on table "public"."library_categories" to "anon";

grant truncate on table "public"."library_categories" to "anon";

grant update on table "public"."library_categories" to "anon";

grant delete on table "public"."library_categories" to "authenticated";

grant insert on table "public"."library_categories" to "authenticated";

grant references on table "public"."library_categories" to "authenticated";

grant select on table "public"."library_categories" to "authenticated";

grant trigger on table "public"."library_categories" to "authenticated";

grant truncate on table "public"."library_categories" to "authenticated";

grant update on table "public"."library_categories" to "authenticated";

grant delete on table "public"."library_categories" to "service_role";

grant insert on table "public"."library_categories" to "service_role";

grant references on table "public"."library_categories" to "service_role";

grant select on table "public"."library_categories" to "service_role";

grant trigger on table "public"."library_categories" to "service_role";

grant truncate on table "public"."library_categories" to "service_role";

grant update on table "public"."library_categories" to "service_role";

grant delete on table "public"."library_categories_college" to "anon";

grant insert on table "public"."library_categories_college" to "anon";

grant references on table "public"."library_categories_college" to "anon";

grant select on table "public"."library_categories_college" to "anon";

grant trigger on table "public"."library_categories_college" to "anon";

grant truncate on table "public"."library_categories_college" to "anon";

grant update on table "public"."library_categories_college" to "anon";

grant delete on table "public"."library_categories_college" to "authenticated";

grant insert on table "public"."library_categories_college" to "authenticated";

grant references on table "public"."library_categories_college" to "authenticated";

grant select on table "public"."library_categories_college" to "authenticated";

grant trigger on table "public"."library_categories_college" to "authenticated";

grant truncate on table "public"."library_categories_college" to "authenticated";

grant update on table "public"."library_categories_college" to "authenticated";

grant delete on table "public"."library_categories_college" to "service_role";

grant insert on table "public"."library_categories_college" to "service_role";

grant references on table "public"."library_categories_college" to "service_role";

grant select on table "public"."library_categories_college" to "service_role";

grant trigger on table "public"."library_categories_college" to "service_role";

grant truncate on table "public"."library_categories_college" to "service_role";

grant update on table "public"."library_categories_college" to "service_role";

grant delete on table "public"."library_categories_school" to "anon";

grant insert on table "public"."library_categories_school" to "anon";

grant references on table "public"."library_categories_school" to "anon";

grant select on table "public"."library_categories_school" to "anon";

grant trigger on table "public"."library_categories_school" to "anon";

grant truncate on table "public"."library_categories_school" to "anon";

grant update on table "public"."library_categories_school" to "anon";

grant delete on table "public"."library_categories_school" to "authenticated";

grant insert on table "public"."library_categories_school" to "authenticated";

grant references on table "public"."library_categories_school" to "authenticated";

grant select on table "public"."library_categories_school" to "authenticated";

grant trigger on table "public"."library_categories_school" to "authenticated";

grant truncate on table "public"."library_categories_school" to "authenticated";

grant update on table "public"."library_categories_school" to "authenticated";

grant delete on table "public"."library_categories_school" to "service_role";

grant insert on table "public"."library_categories_school" to "service_role";

grant references on table "public"."library_categories_school" to "service_role";

grant select on table "public"."library_categories_school" to "service_role";

grant trigger on table "public"."library_categories_school" to "service_role";

grant truncate on table "public"."library_categories_school" to "service_role";

grant update on table "public"."library_categories_school" to "service_role";

grant delete on table "public"."library_history" to "anon";

grant insert on table "public"."library_history" to "anon";

grant references on table "public"."library_history" to "anon";

grant select on table "public"."library_history" to "anon";

grant trigger on table "public"."library_history" to "anon";

grant truncate on table "public"."library_history" to "anon";

grant update on table "public"."library_history" to "anon";

grant delete on table "public"."library_history" to "authenticated";

grant insert on table "public"."library_history" to "authenticated";

grant references on table "public"."library_history" to "authenticated";

grant select on table "public"."library_history" to "authenticated";

grant trigger on table "public"."library_history" to "authenticated";

grant truncate on table "public"."library_history" to "authenticated";

grant update on table "public"."library_history" to "authenticated";

grant delete on table "public"."library_history" to "service_role";

grant insert on table "public"."library_history" to "service_role";

grant references on table "public"."library_history" to "service_role";

grant select on table "public"."library_history" to "service_role";

grant trigger on table "public"."library_history" to "service_role";

grant truncate on table "public"."library_history" to "service_role";

grant update on table "public"."library_history" to "service_role";

grant delete on table "public"."library_issued_books" to "anon";

grant insert on table "public"."library_issued_books" to "anon";

grant references on table "public"."library_issued_books" to "anon";

grant select on table "public"."library_issued_books" to "anon";

grant trigger on table "public"."library_issued_books" to "anon";

grant truncate on table "public"."library_issued_books" to "anon";

grant update on table "public"."library_issued_books" to "anon";

grant delete on table "public"."library_issued_books" to "authenticated";

grant insert on table "public"."library_issued_books" to "authenticated";

grant references on table "public"."library_issued_books" to "authenticated";

grant select on table "public"."library_issued_books" to "authenticated";

grant trigger on table "public"."library_issued_books" to "authenticated";

grant truncate on table "public"."library_issued_books" to "authenticated";

grant update on table "public"."library_issued_books" to "authenticated";

grant delete on table "public"."library_issued_books" to "service_role";

grant insert on table "public"."library_issued_books" to "service_role";

grant references on table "public"."library_issued_books" to "service_role";

grant select on table "public"."library_issued_books" to "service_role";

grant trigger on table "public"."library_issued_books" to "service_role";

grant truncate on table "public"."library_issued_books" to "service_role";

grant update on table "public"."library_issued_books" to "service_role";

grant delete on table "public"."library_reservations" to "anon";

grant insert on table "public"."library_reservations" to "anon";

grant references on table "public"."library_reservations" to "anon";

grant select on table "public"."library_reservations" to "anon";

grant trigger on table "public"."library_reservations" to "anon";

grant truncate on table "public"."library_reservations" to "anon";

grant update on table "public"."library_reservations" to "anon";

grant delete on table "public"."library_reservations" to "authenticated";

grant insert on table "public"."library_reservations" to "authenticated";

grant references on table "public"."library_reservations" to "authenticated";

grant select on table "public"."library_reservations" to "authenticated";

grant trigger on table "public"."library_reservations" to "authenticated";

grant truncate on table "public"."library_reservations" to "authenticated";

grant update on table "public"."library_reservations" to "authenticated";

grant delete on table "public"."library_reservations" to "service_role";

grant insert on table "public"."library_reservations" to "service_role";

grant references on table "public"."library_reservations" to "service_role";

grant select on table "public"."library_reservations" to "service_role";

grant trigger on table "public"."library_reservations" to "service_role";

grant truncate on table "public"."library_reservations" to "service_role";

grant update on table "public"."library_reservations" to "service_role";

grant delete on table "public"."library_reviews" to "anon";

grant insert on table "public"."library_reviews" to "anon";

grant references on table "public"."library_reviews" to "anon";

grant select on table "public"."library_reviews" to "anon";

grant trigger on table "public"."library_reviews" to "anon";

grant truncate on table "public"."library_reviews" to "anon";

grant update on table "public"."library_reviews" to "anon";

grant delete on table "public"."library_reviews" to "authenticated";

grant insert on table "public"."library_reviews" to "authenticated";

grant references on table "public"."library_reviews" to "authenticated";

grant select on table "public"."library_reviews" to "authenticated";

grant trigger on table "public"."library_reviews" to "authenticated";

grant truncate on table "public"."library_reviews" to "authenticated";

grant update on table "public"."library_reviews" to "authenticated";

grant delete on table "public"."library_reviews" to "service_role";

grant insert on table "public"."library_reviews" to "service_role";

grant references on table "public"."library_reviews" to "service_role";

grant select on table "public"."library_reviews" to "service_role";

grant trigger on table "public"."library_reviews" to "service_role";

grant truncate on table "public"."library_reviews" to "service_role";

grant update on table "public"."library_reviews" to "service_role";

grant delete on table "public"."library_settings" to "anon";

grant insert on table "public"."library_settings" to "anon";

grant references on table "public"."library_settings" to "anon";

grant select on table "public"."library_settings" to "anon";

grant trigger on table "public"."library_settings" to "anon";

grant truncate on table "public"."library_settings" to "anon";

grant update on table "public"."library_settings" to "anon";

grant delete on table "public"."library_settings" to "authenticated";

grant insert on table "public"."library_settings" to "authenticated";

grant references on table "public"."library_settings" to "authenticated";

grant select on table "public"."library_settings" to "authenticated";

grant trigger on table "public"."library_settings" to "authenticated";

grant truncate on table "public"."library_settings" to "authenticated";

grant update on table "public"."library_settings" to "authenticated";

grant delete on table "public"."library_settings" to "service_role";

grant insert on table "public"."library_settings" to "service_role";

grant references on table "public"."library_settings" to "service_role";

grant select on table "public"."library_settings" to "service_role";

grant trigger on table "public"."library_settings" to "service_role";

grant truncate on table "public"."library_settings" to "service_role";

grant update on table "public"."library_settings" to "service_role";

grant delete on table "public"."library_settings_college" to "anon";

grant insert on table "public"."library_settings_college" to "anon";

grant references on table "public"."library_settings_college" to "anon";

grant select on table "public"."library_settings_college" to "anon";

grant trigger on table "public"."library_settings_college" to "anon";

grant truncate on table "public"."library_settings_college" to "anon";

grant update on table "public"."library_settings_college" to "anon";

grant delete on table "public"."library_settings_college" to "authenticated";

grant insert on table "public"."library_settings_college" to "authenticated";

grant references on table "public"."library_settings_college" to "authenticated";

grant select on table "public"."library_settings_college" to "authenticated";

grant trigger on table "public"."library_settings_college" to "authenticated";

grant truncate on table "public"."library_settings_college" to "authenticated";

grant update on table "public"."library_settings_college" to "authenticated";

grant delete on table "public"."library_settings_college" to "service_role";

grant insert on table "public"."library_settings_college" to "service_role";

grant references on table "public"."library_settings_college" to "service_role";

grant select on table "public"."library_settings_college" to "service_role";

grant trigger on table "public"."library_settings_college" to "service_role";

grant truncate on table "public"."library_settings_college" to "service_role";

grant update on table "public"."library_settings_college" to "service_role";

grant delete on table "public"."library_settings_school" to "anon";

grant insert on table "public"."library_settings_school" to "anon";

grant references on table "public"."library_settings_school" to "anon";

grant select on table "public"."library_settings_school" to "anon";

grant trigger on table "public"."library_settings_school" to "anon";

grant truncate on table "public"."library_settings_school" to "anon";

grant update on table "public"."library_settings_school" to "anon";

grant delete on table "public"."library_settings_school" to "authenticated";

grant insert on table "public"."library_settings_school" to "authenticated";

grant references on table "public"."library_settings_school" to "authenticated";

grant select on table "public"."library_settings_school" to "authenticated";

grant trigger on table "public"."library_settings_school" to "authenticated";

grant truncate on table "public"."library_settings_school" to "authenticated";

grant update on table "public"."library_settings_school" to "authenticated";

grant delete on table "public"."library_settings_school" to "service_role";

grant insert on table "public"."library_settings_school" to "service_role";

grant references on table "public"."library_settings_school" to "service_role";

grant select on table "public"."library_settings_school" to "service_role";

grant trigger on table "public"."library_settings_school" to "service_role";

grant truncate on table "public"."library_settings_school" to "service_role";

grant update on table "public"."library_settings_school" to "service_role";

grant delete on table "public"."license_assignments" to "anon";

grant insert on table "public"."license_assignments" to "anon";

grant references on table "public"."license_assignments" to "anon";

grant select on table "public"."license_assignments" to "anon";

grant trigger on table "public"."license_assignments" to "anon";

grant truncate on table "public"."license_assignments" to "anon";

grant update on table "public"."license_assignments" to "anon";

grant delete on table "public"."license_assignments" to "authenticated";

grant insert on table "public"."license_assignments" to "authenticated";

grant references on table "public"."license_assignments" to "authenticated";

grant select on table "public"."license_assignments" to "authenticated";

grant trigger on table "public"."license_assignments" to "authenticated";

grant truncate on table "public"."license_assignments" to "authenticated";

grant update on table "public"."license_assignments" to "authenticated";

grant delete on table "public"."license_assignments" to "service_role";

grant insert on table "public"."license_assignments" to "service_role";

grant references on table "public"."license_assignments" to "service_role";

grant select on table "public"."license_assignments" to "service_role";

grant trigger on table "public"."license_assignments" to "service_role";

grant truncate on table "public"."license_assignments" to "service_role";

grant update on table "public"."license_assignments" to "service_role";

grant delete on table "public"."license_pools" to "anon";

grant insert on table "public"."license_pools" to "anon";

grant references on table "public"."license_pools" to "anon";

grant select on table "public"."license_pools" to "anon";

grant trigger on table "public"."license_pools" to "anon";

grant truncate on table "public"."license_pools" to "anon";

grant update on table "public"."license_pools" to "anon";

grant delete on table "public"."license_pools" to "authenticated";

grant insert on table "public"."license_pools" to "authenticated";

grant references on table "public"."license_pools" to "authenticated";

grant select on table "public"."license_pools" to "authenticated";

grant trigger on table "public"."license_pools" to "authenticated";

grant truncate on table "public"."license_pools" to "authenticated";

grant update on table "public"."license_pools" to "authenticated";

grant delete on table "public"."license_pools" to "service_role";

grant insert on table "public"."license_pools" to "service_role";

grant references on table "public"."license_pools" to "service_role";

grant select on table "public"."license_pools" to "service_role";

grant trigger on table "public"."license_pools" to "service_role";

grant truncate on table "public"."license_pools" to "service_role";

grant update on table "public"."license_pools" to "service_role";

grant delete on table "public"."mark_entries" to "anon";

grant insert on table "public"."mark_entries" to "anon";

grant references on table "public"."mark_entries" to "anon";

grant select on table "public"."mark_entries" to "anon";

grant trigger on table "public"."mark_entries" to "anon";

grant truncate on table "public"."mark_entries" to "anon";

grant update on table "public"."mark_entries" to "anon";

grant delete on table "public"."mark_entries" to "authenticated";

grant insert on table "public"."mark_entries" to "authenticated";

grant references on table "public"."mark_entries" to "authenticated";

grant select on table "public"."mark_entries" to "authenticated";

grant trigger on table "public"."mark_entries" to "authenticated";

grant truncate on table "public"."mark_entries" to "authenticated";

grant update on table "public"."mark_entries" to "authenticated";

grant delete on table "public"."mark_entries" to "service_role";

grant insert on table "public"."mark_entries" to "service_role";

grant references on table "public"."mark_entries" to "service_role";

grant select on table "public"."mark_entries" to "service_role";

grant trigger on table "public"."mark_entries" to "service_role";

grant truncate on table "public"."mark_entries" to "service_role";

grant update on table "public"."mark_entries" to "service_role";

grant delete on table "public"."mark_entry_batches" to "anon";

grant insert on table "public"."mark_entry_batches" to "anon";

grant references on table "public"."mark_entry_batches" to "anon";

grant select on table "public"."mark_entry_batches" to "anon";

grant trigger on table "public"."mark_entry_batches" to "anon";

grant truncate on table "public"."mark_entry_batches" to "anon";

grant update on table "public"."mark_entry_batches" to "anon";

grant delete on table "public"."mark_entry_batches" to "authenticated";

grant insert on table "public"."mark_entry_batches" to "authenticated";

grant references on table "public"."mark_entry_batches" to "authenticated";

grant select on table "public"."mark_entry_batches" to "authenticated";

grant trigger on table "public"."mark_entry_batches" to "authenticated";

grant truncate on table "public"."mark_entry_batches" to "authenticated";

grant update on table "public"."mark_entry_batches" to "authenticated";

grant delete on table "public"."mark_entry_batches" to "service_role";

grant insert on table "public"."mark_entry_batches" to "service_role";

grant references on table "public"."mark_entry_batches" to "service_role";

grant select on table "public"."mark_entry_batches" to "service_role";

grant trigger on table "public"."mark_entry_batches" to "service_role";

grant truncate on table "public"."mark_entry_batches" to "service_role";

grant update on table "public"."mark_entry_batches" to "service_role";

grant delete on table "public"."mark_moderation_log" to "anon";

grant insert on table "public"."mark_moderation_log" to "anon";

grant references on table "public"."mark_moderation_log" to "anon";

grant select on table "public"."mark_moderation_log" to "anon";

grant trigger on table "public"."mark_moderation_log" to "anon";

grant truncate on table "public"."mark_moderation_log" to "anon";

grant update on table "public"."mark_moderation_log" to "anon";

grant delete on table "public"."mark_moderation_log" to "authenticated";

grant insert on table "public"."mark_moderation_log" to "authenticated";

grant references on table "public"."mark_moderation_log" to "authenticated";

grant select on table "public"."mark_moderation_log" to "authenticated";

grant trigger on table "public"."mark_moderation_log" to "authenticated";

grant truncate on table "public"."mark_moderation_log" to "authenticated";

grant update on table "public"."mark_moderation_log" to "authenticated";

grant delete on table "public"."mark_moderation_log" to "service_role";

grant insert on table "public"."mark_moderation_log" to "service_role";

grant references on table "public"."mark_moderation_log" to "service_role";

grant select on table "public"."mark_moderation_log" to "service_role";

grant trigger on table "public"."mark_moderation_log" to "service_role";

grant truncate on table "public"."mark_moderation_log" to "service_role";

grant update on table "public"."mark_moderation_log" to "service_role";

grant delete on table "public"."mentor_notes" to "anon";

grant insert on table "public"."mentor_notes" to "anon";

grant references on table "public"."mentor_notes" to "anon";

grant select on table "public"."mentor_notes" to "anon";

grant trigger on table "public"."mentor_notes" to "anon";

grant truncate on table "public"."mentor_notes" to "anon";

grant update on table "public"."mentor_notes" to "anon";

grant delete on table "public"."mentor_notes" to "authenticated";

grant insert on table "public"."mentor_notes" to "authenticated";

grant references on table "public"."mentor_notes" to "authenticated";

grant select on table "public"."mentor_notes" to "authenticated";

grant trigger on table "public"."mentor_notes" to "authenticated";

grant truncate on table "public"."mentor_notes" to "authenticated";

grant update on table "public"."mentor_notes" to "authenticated";

grant delete on table "public"."mentor_notes" to "service_role";

grant insert on table "public"."mentor_notes" to "service_role";

grant references on table "public"."mentor_notes" to "service_role";

grant select on table "public"."mentor_notes" to "service_role";

grant trigger on table "public"."mentor_notes" to "service_role";

grant truncate on table "public"."mentor_notes" to "service_role";

grant update on table "public"."mentor_notes" to "service_role";

grant delete on table "public"."messages" to "anon";

grant insert on table "public"."messages" to "anon";

grant references on table "public"."messages" to "anon";

grant select on table "public"."messages" to "anon";

grant trigger on table "public"."messages" to "anon";

grant truncate on table "public"."messages" to "anon";

grant update on table "public"."messages" to "anon";

grant delete on table "public"."messages" to "authenticated";

grant insert on table "public"."messages" to "authenticated";

grant references on table "public"."messages" to "authenticated";

grant select on table "public"."messages" to "authenticated";

grant trigger on table "public"."messages" to "authenticated";

grant truncate on table "public"."messages" to "authenticated";

grant update on table "public"."messages" to "authenticated";

grant delete on table "public"."messages" to "service_role";

grant insert on table "public"."messages" to "service_role";

grant references on table "public"."messages" to "service_role";

grant select on table "public"."messages" to "service_role";

grant trigger on table "public"."messages" to "service_role";

grant truncate on table "public"."messages" to "service_role";

grant update on table "public"."messages" to "service_role";

grant delete on table "public"."messages_backup" to "anon";

grant insert on table "public"."messages_backup" to "anon";

grant references on table "public"."messages_backup" to "anon";

grant select on table "public"."messages_backup" to "anon";

grant trigger on table "public"."messages_backup" to "anon";

grant truncate on table "public"."messages_backup" to "anon";

grant update on table "public"."messages_backup" to "anon";

grant delete on table "public"."messages_backup" to "authenticated";

grant insert on table "public"."messages_backup" to "authenticated";

grant references on table "public"."messages_backup" to "authenticated";

grant select on table "public"."messages_backup" to "authenticated";

grant trigger on table "public"."messages_backup" to "authenticated";

grant truncate on table "public"."messages_backup" to "authenticated";

grant update on table "public"."messages_backup" to "authenticated";

grant delete on table "public"."messages_backup" to "service_role";

grant insert on table "public"."messages_backup" to "service_role";

grant references on table "public"."messages_backup" to "service_role";

grant select on table "public"."messages_backup" to "service_role";

grant trigger on table "public"."messages_backup" to "service_role";

grant truncate on table "public"."messages_backup" to "service_role";

grant update on table "public"."messages_backup" to "service_role";

grant delete on table "public"."metrics_snapshots" to "anon";

grant insert on table "public"."metrics_snapshots" to "anon";

grant references on table "public"."metrics_snapshots" to "anon";

grant select on table "public"."metrics_snapshots" to "anon";

grant trigger on table "public"."metrics_snapshots" to "anon";

grant truncate on table "public"."metrics_snapshots" to "anon";

grant update on table "public"."metrics_snapshots" to "anon";

grant delete on table "public"."metrics_snapshots" to "authenticated";

grant insert on table "public"."metrics_snapshots" to "authenticated";

grant references on table "public"."metrics_snapshots" to "authenticated";

grant select on table "public"."metrics_snapshots" to "authenticated";

grant trigger on table "public"."metrics_snapshots" to "authenticated";

grant truncate on table "public"."metrics_snapshots" to "authenticated";

grant update on table "public"."metrics_snapshots" to "authenticated";

grant delete on table "public"."metrics_snapshots" to "service_role";

grant insert on table "public"."metrics_snapshots" to "service_role";

grant references on table "public"."metrics_snapshots" to "service_role";

grant select on table "public"."metrics_snapshots" to "service_role";

grant trigger on table "public"."metrics_snapshots" to "service_role";

grant truncate on table "public"."metrics_snapshots" to "service_role";

grant update on table "public"."metrics_snapshots" to "service_role";

grant delete on table "public"."notifications" to "anon";

grant insert on table "public"."notifications" to "anon";

grant references on table "public"."notifications" to "anon";

grant select on table "public"."notifications" to "anon";

grant trigger on table "public"."notifications" to "anon";

grant truncate on table "public"."notifications" to "anon";

grant update on table "public"."notifications" to "anon";

grant delete on table "public"."notifications" to "authenticated";

grant insert on table "public"."notifications" to "authenticated";

grant references on table "public"."notifications" to "authenticated";

grant select on table "public"."notifications" to "authenticated";

grant trigger on table "public"."notifications" to "authenticated";

grant truncate on table "public"."notifications" to "authenticated";

grant update on table "public"."notifications" to "authenticated";

grant delete on table "public"."notifications" to "service_role";

grant insert on table "public"."notifications" to "service_role";

grant references on table "public"."notifications" to "service_role";

grant select on table "public"."notifications" to "service_role";

grant trigger on table "public"."notifications" to "service_role";

grant truncate on table "public"."notifications" to "service_role";

grant update on table "public"."notifications" to "service_role";

grant delete on table "public"."notifications_backup_20251106" to "anon";

grant insert on table "public"."notifications_backup_20251106" to "anon";

grant references on table "public"."notifications_backup_20251106" to "anon";

grant select on table "public"."notifications_backup_20251106" to "anon";

grant trigger on table "public"."notifications_backup_20251106" to "anon";

grant truncate on table "public"."notifications_backup_20251106" to "anon";

grant update on table "public"."notifications_backup_20251106" to "anon";

grant delete on table "public"."notifications_backup_20251106" to "authenticated";

grant insert on table "public"."notifications_backup_20251106" to "authenticated";

grant references on table "public"."notifications_backup_20251106" to "authenticated";

grant select on table "public"."notifications_backup_20251106" to "authenticated";

grant trigger on table "public"."notifications_backup_20251106" to "authenticated";

grant truncate on table "public"."notifications_backup_20251106" to "authenticated";

grant update on table "public"."notifications_backup_20251106" to "authenticated";

grant delete on table "public"."notifications_backup_20251106" to "service_role";

grant insert on table "public"."notifications_backup_20251106" to "service_role";

grant references on table "public"."notifications_backup_20251106" to "service_role";

grant select on table "public"."notifications_backup_20251106" to "service_role";

grant trigger on table "public"."notifications_backup_20251106" to "service_role";

grant truncate on table "public"."notifications_backup_20251106" to "service_role";

grant update on table "public"."notifications_backup_20251106" to "service_role";

grant delete on table "public"."offers" to "anon";

grant insert on table "public"."offers" to "anon";

grant references on table "public"."offers" to "anon";

grant select on table "public"."offers" to "anon";

grant trigger on table "public"."offers" to "anon";

grant truncate on table "public"."offers" to "anon";

grant update on table "public"."offers" to "anon";

grant delete on table "public"."offers" to "authenticated";

grant insert on table "public"."offers" to "authenticated";

grant references on table "public"."offers" to "authenticated";

grant select on table "public"."offers" to "authenticated";

grant trigger on table "public"."offers" to "authenticated";

grant truncate on table "public"."offers" to "authenticated";

grant update on table "public"."offers" to "authenticated";

grant delete on table "public"."offers" to "service_role";

grant insert on table "public"."offers" to "service_role";

grant references on table "public"."offers" to "service_role";

grant select on table "public"."offers" to "service_role";

grant trigger on table "public"."offers" to "service_role";

grant truncate on table "public"."offers" to "service_role";

grant update on table "public"."offers" to "service_role";

grant delete on table "public"."opportunities" to "anon";

grant insert on table "public"."opportunities" to "anon";

grant references on table "public"."opportunities" to "anon";

grant select on table "public"."opportunities" to "anon";

grant trigger on table "public"."opportunities" to "anon";

grant truncate on table "public"."opportunities" to "anon";

grant update on table "public"."opportunities" to "anon";

grant delete on table "public"."opportunities" to "authenticated";

grant insert on table "public"."opportunities" to "authenticated";

grant references on table "public"."opportunities" to "authenticated";

grant select on table "public"."opportunities" to "authenticated";

grant trigger on table "public"."opportunities" to "authenticated";

grant truncate on table "public"."opportunities" to "authenticated";

grant update on table "public"."opportunities" to "authenticated";

grant delete on table "public"."opportunities" to "service_role";

grant insert on table "public"."opportunities" to "service_role";

grant references on table "public"."opportunities" to "service_role";

grant select on table "public"."opportunities" to "service_role";

grant trigger on table "public"."opportunities" to "service_role";

grant truncate on table "public"."opportunities" to "service_role";

grant update on table "public"."opportunities" to "service_role";

grant delete on table "public"."opportunities_backup_migration" to "anon";

grant insert on table "public"."opportunities_backup_migration" to "anon";

grant references on table "public"."opportunities_backup_migration" to "anon";

grant select on table "public"."opportunities_backup_migration" to "anon";

grant trigger on table "public"."opportunities_backup_migration" to "anon";

grant truncate on table "public"."opportunities_backup_migration" to "anon";

grant update on table "public"."opportunities_backup_migration" to "anon";

grant delete on table "public"."opportunities_backup_migration" to "authenticated";

grant insert on table "public"."opportunities_backup_migration" to "authenticated";

grant references on table "public"."opportunities_backup_migration" to "authenticated";

grant select on table "public"."opportunities_backup_migration" to "authenticated";

grant trigger on table "public"."opportunities_backup_migration" to "authenticated";

grant truncate on table "public"."opportunities_backup_migration" to "authenticated";

grant update on table "public"."opportunities_backup_migration" to "authenticated";

grant delete on table "public"."opportunities_backup_migration" to "service_role";

grant insert on table "public"."opportunities_backup_migration" to "service_role";

grant references on table "public"."opportunities_backup_migration" to "service_role";

grant select on table "public"."opportunities_backup_migration" to "service_role";

grant trigger on table "public"."opportunities_backup_migration" to "service_role";

grant truncate on table "public"."opportunities_backup_migration" to "service_role";

grant update on table "public"."opportunities_backup_migration" to "service_role";

grant delete on table "public"."opportunities_duplicate" to "anon";

grant insert on table "public"."opportunities_duplicate" to "anon";

grant references on table "public"."opportunities_duplicate" to "anon";

grant select on table "public"."opportunities_duplicate" to "anon";

grant trigger on table "public"."opportunities_duplicate" to "anon";

grant truncate on table "public"."opportunities_duplicate" to "anon";

grant update on table "public"."opportunities_duplicate" to "anon";

grant delete on table "public"."opportunities_duplicate" to "authenticated";

grant insert on table "public"."opportunities_duplicate" to "authenticated";

grant references on table "public"."opportunities_duplicate" to "authenticated";

grant select on table "public"."opportunities_duplicate" to "authenticated";

grant trigger on table "public"."opportunities_duplicate" to "authenticated";

grant truncate on table "public"."opportunities_duplicate" to "authenticated";

grant update on table "public"."opportunities_duplicate" to "authenticated";

grant delete on table "public"."opportunities_duplicate" to "service_role";

grant insert on table "public"."opportunities_duplicate" to "service_role";

grant references on table "public"."opportunities_duplicate" to "service_role";

grant select on table "public"."opportunities_duplicate" to "service_role";

grant trigger on table "public"."opportunities_duplicate" to "service_role";

grant truncate on table "public"."opportunities_duplicate" to "service_role";

grant update on table "public"."opportunities_duplicate" to "service_role";

grant delete on table "public"."opportunity_interactions" to "anon";

grant insert on table "public"."opportunity_interactions" to "anon";

grant references on table "public"."opportunity_interactions" to "anon";

grant select on table "public"."opportunity_interactions" to "anon";

grant trigger on table "public"."opportunity_interactions" to "anon";

grant truncate on table "public"."opportunity_interactions" to "anon";

grant update on table "public"."opportunity_interactions" to "anon";

grant delete on table "public"."opportunity_interactions" to "authenticated";

grant insert on table "public"."opportunity_interactions" to "authenticated";

grant references on table "public"."opportunity_interactions" to "authenticated";

grant select on table "public"."opportunity_interactions" to "authenticated";

grant trigger on table "public"."opportunity_interactions" to "authenticated";

grant truncate on table "public"."opportunity_interactions" to "authenticated";

grant update on table "public"."opportunity_interactions" to "authenticated";

grant delete on table "public"."opportunity_interactions" to "service_role";

grant insert on table "public"."opportunity_interactions" to "service_role";

grant references on table "public"."opportunity_interactions" to "service_role";

grant select on table "public"."opportunity_interactions" to "service_role";

grant trigger on table "public"."opportunity_interactions" to "service_role";

grant truncate on table "public"."opportunity_interactions" to "service_role";

grant update on table "public"."opportunity_interactions" to "service_role";

grant delete on table "public"."opportunity_interactions_backup_uuid_migration" to "anon";

grant insert on table "public"."opportunity_interactions_backup_uuid_migration" to "anon";

grant references on table "public"."opportunity_interactions_backup_uuid_migration" to "anon";

grant select on table "public"."opportunity_interactions_backup_uuid_migration" to "anon";

grant trigger on table "public"."opportunity_interactions_backup_uuid_migration" to "anon";

grant truncate on table "public"."opportunity_interactions_backup_uuid_migration" to "anon";

grant update on table "public"."opportunity_interactions_backup_uuid_migration" to "anon";

grant delete on table "public"."opportunity_interactions_backup_uuid_migration" to "authenticated";

grant insert on table "public"."opportunity_interactions_backup_uuid_migration" to "authenticated";

grant references on table "public"."opportunity_interactions_backup_uuid_migration" to "authenticated";

grant select on table "public"."opportunity_interactions_backup_uuid_migration" to "authenticated";

grant trigger on table "public"."opportunity_interactions_backup_uuid_migration" to "authenticated";

grant truncate on table "public"."opportunity_interactions_backup_uuid_migration" to "authenticated";

grant update on table "public"."opportunity_interactions_backup_uuid_migration" to "authenticated";

grant delete on table "public"."opportunity_interactions_backup_uuid_migration" to "service_role";

grant insert on table "public"."opportunity_interactions_backup_uuid_migration" to "service_role";

grant references on table "public"."opportunity_interactions_backup_uuid_migration" to "service_role";

grant select on table "public"."opportunity_interactions_backup_uuid_migration" to "service_role";

grant trigger on table "public"."opportunity_interactions_backup_uuid_migration" to "service_role";

grant truncate on table "public"."opportunity_interactions_backup_uuid_migration" to "service_role";

grant update on table "public"."opportunity_interactions_backup_uuid_migration" to "service_role";

grant delete on table "public"."organization_invitations" to "anon";

grant insert on table "public"."organization_invitations" to "anon";

grant references on table "public"."organization_invitations" to "anon";

grant select on table "public"."organization_invitations" to "anon";

grant trigger on table "public"."organization_invitations" to "anon";

grant truncate on table "public"."organization_invitations" to "anon";

grant update on table "public"."organization_invitations" to "anon";

grant delete on table "public"."organization_invitations" to "authenticated";

grant insert on table "public"."organization_invitations" to "authenticated";

grant references on table "public"."organization_invitations" to "authenticated";

grant select on table "public"."organization_invitations" to "authenticated";

grant trigger on table "public"."organization_invitations" to "authenticated";

grant truncate on table "public"."organization_invitations" to "authenticated";

grant update on table "public"."organization_invitations" to "authenticated";

grant delete on table "public"."organization_invitations" to "service_role";

grant insert on table "public"."organization_invitations" to "service_role";

grant references on table "public"."organization_invitations" to "service_role";

grant select on table "public"."organization_invitations" to "service_role";

grant trigger on table "public"."organization_invitations" to "service_role";

grant truncate on table "public"."organization_invitations" to "service_role";

grant update on table "public"."organization_invitations" to "service_role";

grant delete on table "public"."organization_subscriptions" to "anon";

grant insert on table "public"."organization_subscriptions" to "anon";

grant references on table "public"."organization_subscriptions" to "anon";

grant select on table "public"."organization_subscriptions" to "anon";

grant trigger on table "public"."organization_subscriptions" to "anon";

grant truncate on table "public"."organization_subscriptions" to "anon";

grant update on table "public"."organization_subscriptions" to "anon";

grant delete on table "public"."organization_subscriptions" to "authenticated";

grant insert on table "public"."organization_subscriptions" to "authenticated";

grant references on table "public"."organization_subscriptions" to "authenticated";

grant select on table "public"."organization_subscriptions" to "authenticated";

grant trigger on table "public"."organization_subscriptions" to "authenticated";

grant truncate on table "public"."organization_subscriptions" to "authenticated";

grant update on table "public"."organization_subscriptions" to "authenticated";

grant delete on table "public"."organization_subscriptions" to "service_role";

grant insert on table "public"."organization_subscriptions" to "service_role";

grant references on table "public"."organization_subscriptions" to "service_role";

grant select on table "public"."organization_subscriptions" to "service_role";

grant trigger on table "public"."organization_subscriptions" to "service_role";

grant truncate on table "public"."organization_subscriptions" to "service_role";

grant update on table "public"."organization_subscriptions" to "service_role";

grant delete on table "public"."organizations" to "anon";

grant insert on table "public"."organizations" to "anon";

grant references on table "public"."organizations" to "anon";

grant select on table "public"."organizations" to "anon";

grant trigger on table "public"."organizations" to "anon";

grant truncate on table "public"."organizations" to "anon";

grant update on table "public"."organizations" to "anon";

grant delete on table "public"."organizations" to "authenticated";

grant insert on table "public"."organizations" to "authenticated";

grant references on table "public"."organizations" to "authenticated";

grant select on table "public"."organizations" to "authenticated";

grant trigger on table "public"."organizations" to "authenticated";

grant truncate on table "public"."organizations" to "authenticated";

grant update on table "public"."organizations" to "authenticated";

grant delete on table "public"."organizations" to "service_role";

grant insert on table "public"."organizations" to "service_role";

grant references on table "public"."organizations" to "service_role";

grant select on table "public"."organizations" to "service_role";

grant trigger on table "public"."organizations" to "service_role";

grant truncate on table "public"."organizations" to "service_role";

grant update on table "public"."organizations" to "service_role";

grant delete on table "public"."otp_requests_log" to "anon";

grant insert on table "public"."otp_requests_log" to "anon";

grant references on table "public"."otp_requests_log" to "anon";

grant select on table "public"."otp_requests_log" to "anon";

grant trigger on table "public"."otp_requests_log" to "anon";

grant truncate on table "public"."otp_requests_log" to "anon";

grant update on table "public"."otp_requests_log" to "anon";

grant delete on table "public"."otp_requests_log" to "authenticated";

grant insert on table "public"."otp_requests_log" to "authenticated";

grant references on table "public"."otp_requests_log" to "authenticated";

grant select on table "public"."otp_requests_log" to "authenticated";

grant trigger on table "public"."otp_requests_log" to "authenticated";

grant truncate on table "public"."otp_requests_log" to "authenticated";

grant update on table "public"."otp_requests_log" to "authenticated";

grant delete on table "public"."otp_requests_log" to "service_role";

grant insert on table "public"."otp_requests_log" to "service_role";

grant references on table "public"."otp_requests_log" to "service_role";

grant select on table "public"."otp_requests_log" to "service_role";

grant trigger on table "public"."otp_requests_log" to "service_role";

grant truncate on table "public"."otp_requests_log" to "service_role";

grant update on table "public"."otp_requests_log" to "service_role";

grant delete on table "public"."outcome_assessment_mappings" to "anon";

grant insert on table "public"."outcome_assessment_mappings" to "anon";

grant references on table "public"."outcome_assessment_mappings" to "anon";

grant select on table "public"."outcome_assessment_mappings" to "anon";

grant trigger on table "public"."outcome_assessment_mappings" to "anon";

grant truncate on table "public"."outcome_assessment_mappings" to "anon";

grant update on table "public"."outcome_assessment_mappings" to "anon";

grant delete on table "public"."outcome_assessment_mappings" to "authenticated";

grant insert on table "public"."outcome_assessment_mappings" to "authenticated";

grant references on table "public"."outcome_assessment_mappings" to "authenticated";

grant select on table "public"."outcome_assessment_mappings" to "authenticated";

grant trigger on table "public"."outcome_assessment_mappings" to "authenticated";

grant truncate on table "public"."outcome_assessment_mappings" to "authenticated";

grant update on table "public"."outcome_assessment_mappings" to "authenticated";

grant delete on table "public"."outcome_assessment_mappings" to "service_role";

grant insert on table "public"."outcome_assessment_mappings" to "service_role";

grant references on table "public"."outcome_assessment_mappings" to "service_role";

grant select on table "public"."outcome_assessment_mappings" to "service_role";

grant trigger on table "public"."outcome_assessment_mappings" to "service_role";

grant truncate on table "public"."outcome_assessment_mappings" to "service_role";

grant update on table "public"."outcome_assessment_mappings" to "service_role";

grant delete on table "public"."payment_transactions" to "anon";

grant insert on table "public"."payment_transactions" to "anon";

grant references on table "public"."payment_transactions" to "anon";

grant select on table "public"."payment_transactions" to "anon";

grant trigger on table "public"."payment_transactions" to "anon";

grant truncate on table "public"."payment_transactions" to "anon";

grant update on table "public"."payment_transactions" to "anon";

grant delete on table "public"."payment_transactions" to "authenticated";

grant insert on table "public"."payment_transactions" to "authenticated";

grant references on table "public"."payment_transactions" to "authenticated";

grant select on table "public"."payment_transactions" to "authenticated";

grant trigger on table "public"."payment_transactions" to "authenticated";

grant truncate on table "public"."payment_transactions" to "authenticated";

grant update on table "public"."payment_transactions" to "authenticated";

grant delete on table "public"."payment_transactions" to "service_role";

grant insert on table "public"."payment_transactions" to "service_role";

grant references on table "public"."payment_transactions" to "service_role";

grant select on table "public"."payment_transactions" to "service_role";

grant trigger on table "public"."payment_transactions" to "service_role";

grant truncate on table "public"."payment_transactions" to "service_role";

grant update on table "public"."payment_transactions" to "service_role";

grant delete on table "public"."permissions" to "anon";

grant insert on table "public"."permissions" to "anon";

grant references on table "public"."permissions" to "anon";

grant select on table "public"."permissions" to "anon";

grant trigger on table "public"."permissions" to "anon";

grant truncate on table "public"."permissions" to "anon";

grant update on table "public"."permissions" to "anon";

grant delete on table "public"."permissions" to "authenticated";

grant insert on table "public"."permissions" to "authenticated";

grant references on table "public"."permissions" to "authenticated";

grant select on table "public"."permissions" to "authenticated";

grant trigger on table "public"."permissions" to "authenticated";

grant truncate on table "public"."permissions" to "authenticated";

grant update on table "public"."permissions" to "authenticated";

grant delete on table "public"."permissions" to "service_role";

grant insert on table "public"."permissions" to "service_role";

grant references on table "public"."permissions" to "service_role";

grant select on table "public"."permissions" to "service_role";

grant trigger on table "public"."permissions" to "service_role";

grant truncate on table "public"."permissions" to "service_role";

grant update on table "public"."permissions" to "service_role";

grant delete on table "public"."personal_assessment_attempts" to "anon";

grant insert on table "public"."personal_assessment_attempts" to "anon";

grant references on table "public"."personal_assessment_attempts" to "anon";

grant select on table "public"."personal_assessment_attempts" to "anon";

grant trigger on table "public"."personal_assessment_attempts" to "anon";

grant truncate on table "public"."personal_assessment_attempts" to "anon";

grant update on table "public"."personal_assessment_attempts" to "anon";

grant delete on table "public"."personal_assessment_attempts" to "authenticated";

grant insert on table "public"."personal_assessment_attempts" to "authenticated";

grant references on table "public"."personal_assessment_attempts" to "authenticated";

grant select on table "public"."personal_assessment_attempts" to "authenticated";

grant trigger on table "public"."personal_assessment_attempts" to "authenticated";

grant truncate on table "public"."personal_assessment_attempts" to "authenticated";

grant update on table "public"."personal_assessment_attempts" to "authenticated";

grant delete on table "public"."personal_assessment_attempts" to "service_role";

grant insert on table "public"."personal_assessment_attempts" to "service_role";

grant references on table "public"."personal_assessment_attempts" to "service_role";

grant select on table "public"."personal_assessment_attempts" to "service_role";

grant trigger on table "public"."personal_assessment_attempts" to "service_role";

grant truncate on table "public"."personal_assessment_attempts" to "service_role";

grant update on table "public"."personal_assessment_attempts" to "service_role";

grant delete on table "public"."personal_assessment_questions" to "anon";

grant insert on table "public"."personal_assessment_questions" to "anon";

grant references on table "public"."personal_assessment_questions" to "anon";

grant select on table "public"."personal_assessment_questions" to "anon";

grant trigger on table "public"."personal_assessment_questions" to "anon";

grant truncate on table "public"."personal_assessment_questions" to "anon";

grant update on table "public"."personal_assessment_questions" to "anon";

grant delete on table "public"."personal_assessment_questions" to "authenticated";

grant insert on table "public"."personal_assessment_questions" to "authenticated";

grant references on table "public"."personal_assessment_questions" to "authenticated";

grant select on table "public"."personal_assessment_questions" to "authenticated";

grant trigger on table "public"."personal_assessment_questions" to "authenticated";

grant truncate on table "public"."personal_assessment_questions" to "authenticated";

grant update on table "public"."personal_assessment_questions" to "authenticated";

grant delete on table "public"."personal_assessment_questions" to "service_role";

grant insert on table "public"."personal_assessment_questions" to "service_role";

grant references on table "public"."personal_assessment_questions" to "service_role";

grant select on table "public"."personal_assessment_questions" to "service_role";

grant trigger on table "public"."personal_assessment_questions" to "service_role";

grant truncate on table "public"."personal_assessment_questions" to "service_role";

grant update on table "public"."personal_assessment_questions" to "service_role";

grant delete on table "public"."personal_assessment_response_scales" to "anon";

grant insert on table "public"."personal_assessment_response_scales" to "anon";

grant references on table "public"."personal_assessment_response_scales" to "anon";

grant select on table "public"."personal_assessment_response_scales" to "anon";

grant trigger on table "public"."personal_assessment_response_scales" to "anon";

grant truncate on table "public"."personal_assessment_response_scales" to "anon";

grant update on table "public"."personal_assessment_response_scales" to "anon";

grant delete on table "public"."personal_assessment_response_scales" to "authenticated";

grant insert on table "public"."personal_assessment_response_scales" to "authenticated";

grant references on table "public"."personal_assessment_response_scales" to "authenticated";

grant select on table "public"."personal_assessment_response_scales" to "authenticated";

grant trigger on table "public"."personal_assessment_response_scales" to "authenticated";

grant truncate on table "public"."personal_assessment_response_scales" to "authenticated";

grant update on table "public"."personal_assessment_response_scales" to "authenticated";

grant delete on table "public"."personal_assessment_response_scales" to "service_role";

grant insert on table "public"."personal_assessment_response_scales" to "service_role";

grant references on table "public"."personal_assessment_response_scales" to "service_role";

grant select on table "public"."personal_assessment_response_scales" to "service_role";

grant trigger on table "public"."personal_assessment_response_scales" to "service_role";

grant truncate on table "public"."personal_assessment_response_scales" to "service_role";

grant update on table "public"."personal_assessment_response_scales" to "service_role";

grant delete on table "public"."personal_assessment_responses" to "anon";

grant insert on table "public"."personal_assessment_responses" to "anon";

grant references on table "public"."personal_assessment_responses" to "anon";

grant select on table "public"."personal_assessment_responses" to "anon";

grant trigger on table "public"."personal_assessment_responses" to "anon";

grant truncate on table "public"."personal_assessment_responses" to "anon";

grant update on table "public"."personal_assessment_responses" to "anon";

grant delete on table "public"."personal_assessment_responses" to "authenticated";

grant insert on table "public"."personal_assessment_responses" to "authenticated";

grant references on table "public"."personal_assessment_responses" to "authenticated";

grant select on table "public"."personal_assessment_responses" to "authenticated";

grant trigger on table "public"."personal_assessment_responses" to "authenticated";

grant truncate on table "public"."personal_assessment_responses" to "authenticated";

grant update on table "public"."personal_assessment_responses" to "authenticated";

grant delete on table "public"."personal_assessment_responses" to "service_role";

grant insert on table "public"."personal_assessment_responses" to "service_role";

grant references on table "public"."personal_assessment_responses" to "service_role";

grant select on table "public"."personal_assessment_responses" to "service_role";

grant trigger on table "public"."personal_assessment_responses" to "service_role";

grant truncate on table "public"."personal_assessment_responses" to "service_role";

grant update on table "public"."personal_assessment_responses" to "service_role";

grant delete on table "public"."personal_assessment_restrictions" to "anon";

grant insert on table "public"."personal_assessment_restrictions" to "anon";

grant references on table "public"."personal_assessment_restrictions" to "anon";

grant select on table "public"."personal_assessment_restrictions" to "anon";

grant trigger on table "public"."personal_assessment_restrictions" to "anon";

grant truncate on table "public"."personal_assessment_restrictions" to "anon";

grant update on table "public"."personal_assessment_restrictions" to "anon";

grant delete on table "public"."personal_assessment_restrictions" to "authenticated";

grant insert on table "public"."personal_assessment_restrictions" to "authenticated";

grant references on table "public"."personal_assessment_restrictions" to "authenticated";

grant select on table "public"."personal_assessment_restrictions" to "authenticated";

grant trigger on table "public"."personal_assessment_restrictions" to "authenticated";

grant truncate on table "public"."personal_assessment_restrictions" to "authenticated";

grant update on table "public"."personal_assessment_restrictions" to "authenticated";

grant delete on table "public"."personal_assessment_restrictions" to "service_role";

grant insert on table "public"."personal_assessment_restrictions" to "service_role";

grant references on table "public"."personal_assessment_restrictions" to "service_role";

grant select on table "public"."personal_assessment_restrictions" to "service_role";

grant trigger on table "public"."personal_assessment_restrictions" to "service_role";

grant truncate on table "public"."personal_assessment_restrictions" to "service_role";

grant update on table "public"."personal_assessment_restrictions" to "service_role";

grant delete on table "public"."personal_assessment_results" to "anon";

grant insert on table "public"."personal_assessment_results" to "anon";

grant references on table "public"."personal_assessment_results" to "anon";

grant select on table "public"."personal_assessment_results" to "anon";

grant trigger on table "public"."personal_assessment_results" to "anon";

grant truncate on table "public"."personal_assessment_results" to "anon";

grant update on table "public"."personal_assessment_results" to "anon";

grant delete on table "public"."personal_assessment_results" to "authenticated";

grant insert on table "public"."personal_assessment_results" to "authenticated";

grant references on table "public"."personal_assessment_results" to "authenticated";

grant select on table "public"."personal_assessment_results" to "authenticated";

grant trigger on table "public"."personal_assessment_results" to "authenticated";

grant truncate on table "public"."personal_assessment_results" to "authenticated";

grant update on table "public"."personal_assessment_results" to "authenticated";

grant delete on table "public"."personal_assessment_results" to "service_role";

grant insert on table "public"."personal_assessment_results" to "service_role";

grant references on table "public"."personal_assessment_results" to "service_role";

grant select on table "public"."personal_assessment_results" to "service_role";

grant trigger on table "public"."personal_assessment_results" to "service_role";

grant truncate on table "public"."personal_assessment_results" to "service_role";

grant update on table "public"."personal_assessment_results" to "service_role";

grant delete on table "public"."personal_assessment_sections" to "anon";

grant insert on table "public"."personal_assessment_sections" to "anon";

grant references on table "public"."personal_assessment_sections" to "anon";

grant select on table "public"."personal_assessment_sections" to "anon";

grant trigger on table "public"."personal_assessment_sections" to "anon";

grant truncate on table "public"."personal_assessment_sections" to "anon";

grant update on table "public"."personal_assessment_sections" to "anon";

grant delete on table "public"."personal_assessment_sections" to "authenticated";

grant insert on table "public"."personal_assessment_sections" to "authenticated";

grant references on table "public"."personal_assessment_sections" to "authenticated";

grant select on table "public"."personal_assessment_sections" to "authenticated";

grant trigger on table "public"."personal_assessment_sections" to "authenticated";

grant truncate on table "public"."personal_assessment_sections" to "authenticated";

grant update on table "public"."personal_assessment_sections" to "authenticated";

grant delete on table "public"."personal_assessment_sections" to "service_role";

grant insert on table "public"."personal_assessment_sections" to "service_role";

grant references on table "public"."personal_assessment_sections" to "service_role";

grant select on table "public"."personal_assessment_sections" to "service_role";

grant trigger on table "public"."personal_assessment_sections" to "service_role";

grant truncate on table "public"."personal_assessment_sections" to "service_role";

grant update on table "public"."personal_assessment_sections" to "service_role";

grant delete on table "public"."personal_assessment_streams" to "anon";

grant insert on table "public"."personal_assessment_streams" to "anon";

grant references on table "public"."personal_assessment_streams" to "anon";

grant select on table "public"."personal_assessment_streams" to "anon";

grant trigger on table "public"."personal_assessment_streams" to "anon";

grant truncate on table "public"."personal_assessment_streams" to "anon";

grant update on table "public"."personal_assessment_streams" to "anon";

grant delete on table "public"."personal_assessment_streams" to "authenticated";

grant insert on table "public"."personal_assessment_streams" to "authenticated";

grant references on table "public"."personal_assessment_streams" to "authenticated";

grant select on table "public"."personal_assessment_streams" to "authenticated";

grant trigger on table "public"."personal_assessment_streams" to "authenticated";

grant truncate on table "public"."personal_assessment_streams" to "authenticated";

grant update on table "public"."personal_assessment_streams" to "authenticated";

grant delete on table "public"."personal_assessment_streams" to "service_role";

grant insert on table "public"."personal_assessment_streams" to "service_role";

grant references on table "public"."personal_assessment_streams" to "service_role";

grant select on table "public"."personal_assessment_streams" to "service_role";

grant trigger on table "public"."personal_assessment_streams" to "service_role";

grant truncate on table "public"."personal_assessment_streams" to "service_role";

grant update on table "public"."personal_assessment_streams" to "service_role";

grant delete on table "public"."phone_otps" to "anon";

grant insert on table "public"."phone_otps" to "anon";

grant references on table "public"."phone_otps" to "anon";

grant select on table "public"."phone_otps" to "anon";

grant trigger on table "public"."phone_otps" to "anon";

grant truncate on table "public"."phone_otps" to "anon";

grant update on table "public"."phone_otps" to "anon";

grant delete on table "public"."phone_otps" to "authenticated";

grant insert on table "public"."phone_otps" to "authenticated";

grant references on table "public"."phone_otps" to "authenticated";

grant select on table "public"."phone_otps" to "authenticated";

grant trigger on table "public"."phone_otps" to "authenticated";

grant truncate on table "public"."phone_otps" to "authenticated";

grant update on table "public"."phone_otps" to "authenticated";

grant delete on table "public"."phone_otps" to "service_role";

grant insert on table "public"."phone_otps" to "service_role";

grant references on table "public"."phone_otps" to "service_role";

grant select on table "public"."phone_otps" to "service_role";

grant trigger on table "public"."phone_otps" to "service_role";

grant truncate on table "public"."phone_otps" to "service_role";

grant update on table "public"."phone_otps" to "service_role";

grant delete on table "public"."pipeline_activities" to "anon";

grant insert on table "public"."pipeline_activities" to "anon";

grant references on table "public"."pipeline_activities" to "anon";

grant select on table "public"."pipeline_activities" to "anon";

grant trigger on table "public"."pipeline_activities" to "anon";

grant truncate on table "public"."pipeline_activities" to "anon";

grant update on table "public"."pipeline_activities" to "anon";

grant delete on table "public"."pipeline_activities" to "authenticated";

grant insert on table "public"."pipeline_activities" to "authenticated";

grant references on table "public"."pipeline_activities" to "authenticated";

grant select on table "public"."pipeline_activities" to "authenticated";

grant trigger on table "public"."pipeline_activities" to "authenticated";

grant truncate on table "public"."pipeline_activities" to "authenticated";

grant update on table "public"."pipeline_activities" to "authenticated";

grant delete on table "public"."pipeline_activities" to "service_role";

grant insert on table "public"."pipeline_activities" to "service_role";

grant references on table "public"."pipeline_activities" to "service_role";

grant select on table "public"."pipeline_activities" to "service_role";

grant trigger on table "public"."pipeline_activities" to "service_role";

grant truncate on table "public"."pipeline_activities" to "service_role";

grant update on table "public"."pipeline_activities" to "service_role";

grant delete on table "public"."pipeline_candidates" to "anon";

grant insert on table "public"."pipeline_candidates" to "anon";

grant references on table "public"."pipeline_candidates" to "anon";

grant select on table "public"."pipeline_candidates" to "anon";

grant trigger on table "public"."pipeline_candidates" to "anon";

grant truncate on table "public"."pipeline_candidates" to "anon";

grant update on table "public"."pipeline_candidates" to "anon";

grant delete on table "public"."pipeline_candidates" to "authenticated";

grant insert on table "public"."pipeline_candidates" to "authenticated";

grant references on table "public"."pipeline_candidates" to "authenticated";

grant select on table "public"."pipeline_candidates" to "authenticated";

grant trigger on table "public"."pipeline_candidates" to "authenticated";

grant truncate on table "public"."pipeline_candidates" to "authenticated";

grant update on table "public"."pipeline_candidates" to "authenticated";

grant delete on table "public"."pipeline_candidates" to "service_role";

grant insert on table "public"."pipeline_candidates" to "service_role";

grant references on table "public"."pipeline_candidates" to "service_role";

grant select on table "public"."pipeline_candidates" to "service_role";

grant trigger on table "public"."pipeline_candidates" to "service_role";

grant truncate on table "public"."pipeline_candidates" to "service_role";

grant update on table "public"."pipeline_candidates" to "service_role";

grant delete on table "public"."pipeline_candidates_backup_migration" to "anon";

grant insert on table "public"."pipeline_candidates_backup_migration" to "anon";

grant references on table "public"."pipeline_candidates_backup_migration" to "anon";

grant select on table "public"."pipeline_candidates_backup_migration" to "anon";

grant trigger on table "public"."pipeline_candidates_backup_migration" to "anon";

grant truncate on table "public"."pipeline_candidates_backup_migration" to "anon";

grant update on table "public"."pipeline_candidates_backup_migration" to "anon";

grant delete on table "public"."pipeline_candidates_backup_migration" to "authenticated";

grant insert on table "public"."pipeline_candidates_backup_migration" to "authenticated";

grant references on table "public"."pipeline_candidates_backup_migration" to "authenticated";

grant select on table "public"."pipeline_candidates_backup_migration" to "authenticated";

grant trigger on table "public"."pipeline_candidates_backup_migration" to "authenticated";

grant truncate on table "public"."pipeline_candidates_backup_migration" to "authenticated";

grant update on table "public"."pipeline_candidates_backup_migration" to "authenticated";

grant delete on table "public"."pipeline_candidates_backup_migration" to "service_role";

grant insert on table "public"."pipeline_candidates_backup_migration" to "service_role";

grant references on table "public"."pipeline_candidates_backup_migration" to "service_role";

grant select on table "public"."pipeline_candidates_backup_migration" to "service_role";

grant trigger on table "public"."pipeline_candidates_backup_migration" to "service_role";

grant truncate on table "public"."pipeline_candidates_backup_migration" to "service_role";

grant update on table "public"."pipeline_candidates_backup_migration" to "service_role";

grant delete on table "public"."placements" to "anon";

grant insert on table "public"."placements" to "anon";

grant references on table "public"."placements" to "anon";

grant select on table "public"."placements" to "anon";

grant trigger on table "public"."placements" to "anon";

grant truncate on table "public"."placements" to "anon";

grant update on table "public"."placements" to "anon";

grant delete on table "public"."placements" to "authenticated";

grant insert on table "public"."placements" to "authenticated";

grant references on table "public"."placements" to "authenticated";

grant select on table "public"."placements" to "authenticated";

grant trigger on table "public"."placements" to "authenticated";

grant truncate on table "public"."placements" to "authenticated";

grant update on table "public"."placements" to "authenticated";

grant delete on table "public"."placements" to "service_role";

grant insert on table "public"."placements" to "service_role";

grant references on table "public"."placements" to "service_role";

grant select on table "public"."placements" to "service_role";

grant trigger on table "public"."placements" to "service_role";

grant truncate on table "public"."placements" to "service_role";

grant update on table "public"."placements" to "service_role";

grant delete on table "public"."pre_registration_email_tracking" to "anon";

grant insert on table "public"."pre_registration_email_tracking" to "anon";

grant references on table "public"."pre_registration_email_tracking" to "anon";

grant select on table "public"."pre_registration_email_tracking" to "anon";

grant trigger on table "public"."pre_registration_email_tracking" to "anon";

grant truncate on table "public"."pre_registration_email_tracking" to "anon";

grant update on table "public"."pre_registration_email_tracking" to "anon";

grant delete on table "public"."pre_registration_email_tracking" to "authenticated";

grant insert on table "public"."pre_registration_email_tracking" to "authenticated";

grant references on table "public"."pre_registration_email_tracking" to "authenticated";

grant select on table "public"."pre_registration_email_tracking" to "authenticated";

grant trigger on table "public"."pre_registration_email_tracking" to "authenticated";

grant truncate on table "public"."pre_registration_email_tracking" to "authenticated";

grant update on table "public"."pre_registration_email_tracking" to "authenticated";

grant delete on table "public"."pre_registration_email_tracking" to "service_role";

grant insert on table "public"."pre_registration_email_tracking" to "service_role";

grant references on table "public"."pre_registration_email_tracking" to "service_role";

grant select on table "public"."pre_registration_email_tracking" to "service_role";

grant trigger on table "public"."pre_registration_email_tracking" to "service_role";

grant truncate on table "public"."pre_registration_email_tracking" to "service_role";

grant update on table "public"."pre_registration_email_tracking" to "service_role";

grant delete on table "public"."pre_registrations" to "anon";

grant insert on table "public"."pre_registrations" to "anon";

grant references on table "public"."pre_registrations" to "anon";

grant select on table "public"."pre_registrations" to "anon";

grant trigger on table "public"."pre_registrations" to "anon";

grant truncate on table "public"."pre_registrations" to "anon";

grant update on table "public"."pre_registrations" to "anon";

grant delete on table "public"."pre_registrations" to "authenticated";

grant insert on table "public"."pre_registrations" to "authenticated";

grant references on table "public"."pre_registrations" to "authenticated";

grant select on table "public"."pre_registrations" to "authenticated";

grant trigger on table "public"."pre_registrations" to "authenticated";

grant truncate on table "public"."pre_registrations" to "authenticated";

grant update on table "public"."pre_registrations" to "authenticated";

grant delete on table "public"."pre_registrations" to "service_role";

grant insert on table "public"."pre_registrations" to "service_role";

grant references on table "public"."pre_registrations" to "service_role";

grant select on table "public"."pre_registrations" to "service_role";

grant trigger on table "public"."pre_registrations" to "service_role";

grant truncate on table "public"."pre_registrations" to "service_role";

grant update on table "public"."pre_registrations" to "service_role";

grant delete on table "public"."profile_views" to "anon";

grant insert on table "public"."profile_views" to "anon";

grant references on table "public"."profile_views" to "anon";

grant select on table "public"."profile_views" to "anon";

grant trigger on table "public"."profile_views" to "anon";

grant truncate on table "public"."profile_views" to "anon";

grant update on table "public"."profile_views" to "anon";

grant delete on table "public"."profile_views" to "authenticated";

grant insert on table "public"."profile_views" to "authenticated";

grant references on table "public"."profile_views" to "authenticated";

grant select on table "public"."profile_views" to "authenticated";

grant trigger on table "public"."profile_views" to "authenticated";

grant truncate on table "public"."profile_views" to "authenticated";

grant update on table "public"."profile_views" to "authenticated";

grant delete on table "public"."profile_views" to "service_role";

grant insert on table "public"."profile_views" to "service_role";

grant references on table "public"."profile_views" to "service_role";

grant select on table "public"."profile_views" to "service_role";

grant trigger on table "public"."profile_views" to "service_role";

grant truncate on table "public"."profile_views" to "service_role";

grant update on table "public"."profile_views" to "service_role";

grant delete on table "public"."profile_views_backup_20251106" to "anon";

grant insert on table "public"."profile_views_backup_20251106" to "anon";

grant references on table "public"."profile_views_backup_20251106" to "anon";

grant select on table "public"."profile_views_backup_20251106" to "anon";

grant trigger on table "public"."profile_views_backup_20251106" to "anon";

grant truncate on table "public"."profile_views_backup_20251106" to "anon";

grant update on table "public"."profile_views_backup_20251106" to "anon";

grant delete on table "public"."profile_views_backup_20251106" to "authenticated";

grant insert on table "public"."profile_views_backup_20251106" to "authenticated";

grant references on table "public"."profile_views_backup_20251106" to "authenticated";

grant select on table "public"."profile_views_backup_20251106" to "authenticated";

grant trigger on table "public"."profile_views_backup_20251106" to "authenticated";

grant truncate on table "public"."profile_views_backup_20251106" to "authenticated";

grant update on table "public"."profile_views_backup_20251106" to "authenticated";

grant delete on table "public"."profile_views_backup_20251106" to "service_role";

grant insert on table "public"."profile_views_backup_20251106" to "service_role";

grant references on table "public"."profile_views_backup_20251106" to "service_role";

grant select on table "public"."profile_views_backup_20251106" to "service_role";

grant trigger on table "public"."profile_views_backup_20251106" to "service_role";

grant truncate on table "public"."profile_views_backup_20251106" to "service_role";

grant update on table "public"."profile_views_backup_20251106" to "service_role";

grant delete on table "public"."program_sections" to "anon";

grant insert on table "public"."program_sections" to "anon";

grant references on table "public"."program_sections" to "anon";

grant select on table "public"."program_sections" to "anon";

grant trigger on table "public"."program_sections" to "anon";

grant truncate on table "public"."program_sections" to "anon";

grant update on table "public"."program_sections" to "anon";

grant delete on table "public"."program_sections" to "authenticated";

grant insert on table "public"."program_sections" to "authenticated";

grant references on table "public"."program_sections" to "authenticated";

grant select on table "public"."program_sections" to "authenticated";

grant trigger on table "public"."program_sections" to "authenticated";

grant truncate on table "public"."program_sections" to "authenticated";

grant update on table "public"."program_sections" to "authenticated";

grant delete on table "public"."program_sections" to "service_role";

grant insert on table "public"."program_sections" to "service_role";

grant references on table "public"."program_sections" to "service_role";

grant select on table "public"."program_sections" to "service_role";

grant trigger on table "public"."program_sections" to "service_role";

grant truncate on table "public"."program_sections" to "service_role";

grant update on table "public"."program_sections" to "service_role";

grant delete on table "public"."programs" to "anon";

grant insert on table "public"."programs" to "anon";

grant references on table "public"."programs" to "anon";

grant select on table "public"."programs" to "anon";

grant trigger on table "public"."programs" to "anon";

grant truncate on table "public"."programs" to "anon";

grant update on table "public"."programs" to "anon";

grant delete on table "public"."programs" to "authenticated";

grant insert on table "public"."programs" to "authenticated";

grant references on table "public"."programs" to "authenticated";

grant select on table "public"."programs" to "authenticated";

grant trigger on table "public"."programs" to "authenticated";

grant truncate on table "public"."programs" to "authenticated";

grant update on table "public"."programs" to "authenticated";

grant delete on table "public"."programs" to "service_role";

grant insert on table "public"."programs" to "service_role";

grant references on table "public"."programs" to "service_role";

grant select on table "public"."programs" to "service_role";

grant trigger on table "public"."programs" to "service_role";

grant truncate on table "public"."programs" to "service_role";

grant update on table "public"."programs" to "service_role";

grant delete on table "public"."projects" to "anon";

grant insert on table "public"."projects" to "anon";

grant references on table "public"."projects" to "anon";

grant select on table "public"."projects" to "anon";

grant trigger on table "public"."projects" to "anon";

grant truncate on table "public"."projects" to "anon";

grant update on table "public"."projects" to "anon";

grant delete on table "public"."projects" to "authenticated";

grant insert on table "public"."projects" to "authenticated";

grant references on table "public"."projects" to "authenticated";

grant select on table "public"."projects" to "authenticated";

grant trigger on table "public"."projects" to "authenticated";

grant truncate on table "public"."projects" to "authenticated";

grant update on table "public"."projects" to "authenticated";

grant delete on table "public"."projects" to "service_role";

grant insert on table "public"."projects" to "service_role";

grant references on table "public"."projects" to "service_role";

grant select on table "public"."projects" to "service_role";

grant trigger on table "public"."projects" to "service_role";

grant truncate on table "public"."projects" to "service_role";

grant update on table "public"."projects" to "service_role";

grant delete on table "public"."promotional_events" to "anon";

grant insert on table "public"."promotional_events" to "anon";

grant references on table "public"."promotional_events" to "anon";

grant select on table "public"."promotional_events" to "anon";

grant trigger on table "public"."promotional_events" to "anon";

grant truncate on table "public"."promotional_events" to "anon";

grant update on table "public"."promotional_events" to "anon";

grant delete on table "public"."promotional_events" to "authenticated";

grant insert on table "public"."promotional_events" to "authenticated";

grant references on table "public"."promotional_events" to "authenticated";

grant select on table "public"."promotional_events" to "authenticated";

grant trigger on table "public"."promotional_events" to "authenticated";

grant truncate on table "public"."promotional_events" to "authenticated";

grant update on table "public"."promotional_events" to "authenticated";

grant delete on table "public"."promotional_events" to "service_role";

grant insert on table "public"."promotional_events" to "service_role";

grant references on table "public"."promotional_events" to "service_role";

grant select on table "public"."promotional_events" to "service_role";

grant trigger on table "public"."promotional_events" to "service_role";

grant truncate on table "public"."promotional_events" to "service_role";

grant update on table "public"."promotional_events" to "service_role";

grant delete on table "public"."quizzes" to "anon";

grant insert on table "public"."quizzes" to "anon";

grant references on table "public"."quizzes" to "anon";

grant select on table "public"."quizzes" to "anon";

grant trigger on table "public"."quizzes" to "anon";

grant truncate on table "public"."quizzes" to "anon";

grant update on table "public"."quizzes" to "anon";

grant delete on table "public"."quizzes" to "authenticated";

grant insert on table "public"."quizzes" to "authenticated";

grant references on table "public"."quizzes" to "authenticated";

grant select on table "public"."quizzes" to "authenticated";

grant trigger on table "public"."quizzes" to "authenticated";

grant truncate on table "public"."quizzes" to "authenticated";

grant update on table "public"."quizzes" to "authenticated";

grant delete on table "public"."quizzes" to "service_role";

grant insert on table "public"."quizzes" to "service_role";

grant references on table "public"."quizzes" to "service_role";

grant select on table "public"."quizzes" to "service_role";

grant trigger on table "public"."quizzes" to "service_role";

grant truncate on table "public"."quizzes" to "service_role";

grant update on table "public"."quizzes" to "service_role";

grant delete on table "public"."razorpay_orders" to "anon";

grant insert on table "public"."razorpay_orders" to "anon";

grant references on table "public"."razorpay_orders" to "anon";

grant select on table "public"."razorpay_orders" to "anon";

grant trigger on table "public"."razorpay_orders" to "anon";

grant truncate on table "public"."razorpay_orders" to "anon";

grant update on table "public"."razorpay_orders" to "anon";

grant delete on table "public"."razorpay_orders" to "authenticated";

grant insert on table "public"."razorpay_orders" to "authenticated";

grant references on table "public"."razorpay_orders" to "authenticated";

grant select on table "public"."razorpay_orders" to "authenticated";

grant trigger on table "public"."razorpay_orders" to "authenticated";

grant truncate on table "public"."razorpay_orders" to "authenticated";

grant update on table "public"."razorpay_orders" to "authenticated";

grant delete on table "public"."razorpay_orders" to "service_role";

grant insert on table "public"."razorpay_orders" to "service_role";

grant references on table "public"."razorpay_orders" to "service_role";

grant select on table "public"."razorpay_orders" to "service_role";

grant trigger on table "public"."razorpay_orders" to "service_role";

grant truncate on table "public"."razorpay_orders" to "service_role";

grant update on table "public"."razorpay_orders" to "service_role";

grant delete on table "public"."recent_updates" to "anon";

grant insert on table "public"."recent_updates" to "anon";

grant references on table "public"."recent_updates" to "anon";

grant select on table "public"."recent_updates" to "anon";

grant trigger on table "public"."recent_updates" to "anon";

grant truncate on table "public"."recent_updates" to "anon";

grant update on table "public"."recent_updates" to "anon";

grant delete on table "public"."recent_updates" to "authenticated";

grant insert on table "public"."recent_updates" to "authenticated";

grant references on table "public"."recent_updates" to "authenticated";

grant select on table "public"."recent_updates" to "authenticated";

grant trigger on table "public"."recent_updates" to "authenticated";

grant truncate on table "public"."recent_updates" to "authenticated";

grant update on table "public"."recent_updates" to "authenticated";

grant delete on table "public"."recent_updates" to "service_role";

grant insert on table "public"."recent_updates" to "service_role";

grant references on table "public"."recent_updates" to "service_role";

grant select on table "public"."recent_updates" to "service_role";

grant trigger on table "public"."recent_updates" to "service_role";

grant truncate on table "public"."recent_updates" to "service_role";

grant update on table "public"."recent_updates" to "service_role";

grant delete on table "public"."recruiter_activities" to "anon";

grant insert on table "public"."recruiter_activities" to "anon";

grant references on table "public"."recruiter_activities" to "anon";

grant select on table "public"."recruiter_activities" to "anon";

grant trigger on table "public"."recruiter_activities" to "anon";

grant truncate on table "public"."recruiter_activities" to "anon";

grant update on table "public"."recruiter_activities" to "anon";

grant delete on table "public"."recruiter_activities" to "authenticated";

grant insert on table "public"."recruiter_activities" to "authenticated";

grant references on table "public"."recruiter_activities" to "authenticated";

grant select on table "public"."recruiter_activities" to "authenticated";

grant trigger on table "public"."recruiter_activities" to "authenticated";

grant truncate on table "public"."recruiter_activities" to "authenticated";

grant update on table "public"."recruiter_activities" to "authenticated";

grant delete on table "public"."recruiter_activities" to "service_role";

grant insert on table "public"."recruiter_activities" to "service_role";

grant references on table "public"."recruiter_activities" to "service_role";

grant select on table "public"."recruiter_activities" to "service_role";

grant trigger on table "public"."recruiter_activities" to "service_role";

grant truncate on table "public"."recruiter_activities" to "service_role";

grant update on table "public"."recruiter_activities" to "service_role";

grant delete on table "public"."recruiter_saved_searches" to "anon";

grant insert on table "public"."recruiter_saved_searches" to "anon";

grant references on table "public"."recruiter_saved_searches" to "anon";

grant select on table "public"."recruiter_saved_searches" to "anon";

grant trigger on table "public"."recruiter_saved_searches" to "anon";

grant truncate on table "public"."recruiter_saved_searches" to "anon";

grant update on table "public"."recruiter_saved_searches" to "anon";

grant delete on table "public"."recruiter_saved_searches" to "authenticated";

grant insert on table "public"."recruiter_saved_searches" to "authenticated";

grant references on table "public"."recruiter_saved_searches" to "authenticated";

grant select on table "public"."recruiter_saved_searches" to "authenticated";

grant trigger on table "public"."recruiter_saved_searches" to "authenticated";

grant truncate on table "public"."recruiter_saved_searches" to "authenticated";

grant update on table "public"."recruiter_saved_searches" to "authenticated";

grant delete on table "public"."recruiter_saved_searches" to "service_role";

grant insert on table "public"."recruiter_saved_searches" to "service_role";

grant references on table "public"."recruiter_saved_searches" to "service_role";

grant select on table "public"."recruiter_saved_searches" to "service_role";

grant trigger on table "public"."recruiter_saved_searches" to "service_role";

grant truncate on table "public"."recruiter_saved_searches" to "service_role";

grant update on table "public"."recruiter_saved_searches" to "service_role";

grant delete on table "public"."recruiters" to "anon";

grant insert on table "public"."recruiters" to "anon";

grant references on table "public"."recruiters" to "anon";

grant select on table "public"."recruiters" to "anon";

grant trigger on table "public"."recruiters" to "anon";

grant truncate on table "public"."recruiters" to "anon";

grant update on table "public"."recruiters" to "anon";

grant delete on table "public"."recruiters" to "authenticated";

grant insert on table "public"."recruiters" to "authenticated";

grant references on table "public"."recruiters" to "authenticated";

grant select on table "public"."recruiters" to "authenticated";

grant trigger on table "public"."recruiters" to "authenticated";

grant truncate on table "public"."recruiters" to "authenticated";

grant update on table "public"."recruiters" to "authenticated";

grant delete on table "public"."recruiters" to "service_role";

grant insert on table "public"."recruiters" to "service_role";

grant references on table "public"."recruiters" to "service_role";

grant select on table "public"."recruiters" to "service_role";

grant trigger on table "public"."recruiters" to "service_role";

grant truncate on table "public"."recruiters" to "service_role";

grant update on table "public"."recruiters" to "service_role";

grant delete on table "public"."requisitions" to "anon";

grant insert on table "public"."requisitions" to "anon";

grant references on table "public"."requisitions" to "anon";

grant select on table "public"."requisitions" to "anon";

grant trigger on table "public"."requisitions" to "anon";

grant truncate on table "public"."requisitions" to "anon";

grant update on table "public"."requisitions" to "anon";

grant delete on table "public"."requisitions" to "authenticated";

grant insert on table "public"."requisitions" to "authenticated";

grant references on table "public"."requisitions" to "authenticated";

grant select on table "public"."requisitions" to "authenticated";

grant trigger on table "public"."requisitions" to "authenticated";

grant truncate on table "public"."requisitions" to "authenticated";

grant update on table "public"."requisitions" to "authenticated";

grant delete on table "public"."requisitions" to "service_role";

grant insert on table "public"."requisitions" to "service_role";

grant references on table "public"."requisitions" to "service_role";

grant select on table "public"."requisitions" to "service_role";

grant trigger on table "public"."requisitions" to "service_role";

grant truncate on table "public"."requisitions" to "service_role";

grant update on table "public"."requisitions" to "service_role";

grant delete on table "public"."reset_tokens" to "anon";

grant insert on table "public"."reset_tokens" to "anon";

grant references on table "public"."reset_tokens" to "anon";

grant select on table "public"."reset_tokens" to "anon";

grant trigger on table "public"."reset_tokens" to "anon";

grant truncate on table "public"."reset_tokens" to "anon";

grant update on table "public"."reset_tokens" to "anon";

grant delete on table "public"."reset_tokens" to "authenticated";

grant insert on table "public"."reset_tokens" to "authenticated";

grant references on table "public"."reset_tokens" to "authenticated";

grant select on table "public"."reset_tokens" to "authenticated";

grant trigger on table "public"."reset_tokens" to "authenticated";

grant truncate on table "public"."reset_tokens" to "authenticated";

grant update on table "public"."reset_tokens" to "authenticated";

grant delete on table "public"."reset_tokens" to "service_role";

grant insert on table "public"."reset_tokens" to "service_role";

grant references on table "public"."reset_tokens" to "service_role";

grant select on table "public"."reset_tokens" to "service_role";

grant trigger on table "public"."reset_tokens" to "service_role";

grant truncate on table "public"."reset_tokens" to "service_role";

grant update on table "public"."reset_tokens" to "service_role";

grant delete on table "public"."role_permissions" to "anon";

grant insert on table "public"."role_permissions" to "anon";

grant references on table "public"."role_permissions" to "anon";

grant select on table "public"."role_permissions" to "anon";

grant trigger on table "public"."role_permissions" to "anon";

grant truncate on table "public"."role_permissions" to "anon";

grant update on table "public"."role_permissions" to "anon";

grant delete on table "public"."role_permissions" to "authenticated";

grant insert on table "public"."role_permissions" to "authenticated";

grant references on table "public"."role_permissions" to "authenticated";

grant select on table "public"."role_permissions" to "authenticated";

grant trigger on table "public"."role_permissions" to "authenticated";

grant truncate on table "public"."role_permissions" to "authenticated";

grant update on table "public"."role_permissions" to "authenticated";

grant delete on table "public"."role_permissions" to "service_role";

grant insert on table "public"."role_permissions" to "service_role";

grant references on table "public"."role_permissions" to "service_role";

grant select on table "public"."role_permissions" to "service_role";

grant trigger on table "public"."role_permissions" to "service_role";

grant truncate on table "public"."role_permissions" to "service_role";

grant update on table "public"."role_permissions" to "service_role";

grant delete on table "public"."roles" to "anon";

grant insert on table "public"."roles" to "anon";

grant references on table "public"."roles" to "anon";

grant select on table "public"."roles" to "anon";

grant trigger on table "public"."roles" to "anon";

grant truncate on table "public"."roles" to "anon";

grant update on table "public"."roles" to "anon";

grant delete on table "public"."roles" to "authenticated";

grant insert on table "public"."roles" to "authenticated";

grant references on table "public"."roles" to "authenticated";

grant select on table "public"."roles" to "authenticated";

grant trigger on table "public"."roles" to "authenticated";

grant truncate on table "public"."roles" to "authenticated";

grant update on table "public"."roles" to "authenticated";

grant delete on table "public"."roles" to "service_role";

grant insert on table "public"."roles" to "service_role";

grant references on table "public"."roles" to "service_role";

grant select on table "public"."roles" to "service_role";

grant trigger on table "public"."roles" to "service_role";

grant truncate on table "public"."roles" to "service_role";

grant update on table "public"."roles" to "service_role";

grant delete on table "public"."saved_jobs" to "anon";

grant insert on table "public"."saved_jobs" to "anon";

grant references on table "public"."saved_jobs" to "anon";

grant select on table "public"."saved_jobs" to "anon";

grant trigger on table "public"."saved_jobs" to "anon";

grant truncate on table "public"."saved_jobs" to "anon";

grant update on table "public"."saved_jobs" to "anon";

grant delete on table "public"."saved_jobs" to "authenticated";

grant insert on table "public"."saved_jobs" to "authenticated";

grant references on table "public"."saved_jobs" to "authenticated";

grant select on table "public"."saved_jobs" to "authenticated";

grant trigger on table "public"."saved_jobs" to "authenticated";

grant truncate on table "public"."saved_jobs" to "authenticated";

grant update on table "public"."saved_jobs" to "authenticated";

grant delete on table "public"."saved_jobs" to "service_role";

grant insert on table "public"."saved_jobs" to "service_role";

grant references on table "public"."saved_jobs" to "service_role";

grant select on table "public"."saved_jobs" to "service_role";

grant trigger on table "public"."saved_jobs" to "service_role";

grant truncate on table "public"."saved_jobs" to "service_role";

grant update on table "public"."saved_jobs" to "service_role";

grant delete on table "public"."saved_jobs_backup_migration" to "anon";

grant insert on table "public"."saved_jobs_backup_migration" to "anon";

grant references on table "public"."saved_jobs_backup_migration" to "anon";

grant select on table "public"."saved_jobs_backup_migration" to "anon";

grant trigger on table "public"."saved_jobs_backup_migration" to "anon";

grant truncate on table "public"."saved_jobs_backup_migration" to "anon";

grant update on table "public"."saved_jobs_backup_migration" to "anon";

grant delete on table "public"."saved_jobs_backup_migration" to "authenticated";

grant insert on table "public"."saved_jobs_backup_migration" to "authenticated";

grant references on table "public"."saved_jobs_backup_migration" to "authenticated";

grant select on table "public"."saved_jobs_backup_migration" to "authenticated";

grant trigger on table "public"."saved_jobs_backup_migration" to "authenticated";

grant truncate on table "public"."saved_jobs_backup_migration" to "authenticated";

grant update on table "public"."saved_jobs_backup_migration" to "authenticated";

grant delete on table "public"."saved_jobs_backup_migration" to "service_role";

grant insert on table "public"."saved_jobs_backup_migration" to "service_role";

grant references on table "public"."saved_jobs_backup_migration" to "service_role";

grant select on table "public"."saved_jobs_backup_migration" to "service_role";

grant trigger on table "public"."saved_jobs_backup_migration" to "service_role";

grant truncate on table "public"."saved_jobs_backup_migration" to "service_role";

grant update on table "public"."saved_jobs_backup_migration" to "service_role";

grant delete on table "public"."school_classes" to "anon";

grant insert on table "public"."school_classes" to "anon";

grant references on table "public"."school_classes" to "anon";

grant select on table "public"."school_classes" to "anon";

grant trigger on table "public"."school_classes" to "anon";

grant truncate on table "public"."school_classes" to "anon";

grant update on table "public"."school_classes" to "anon";

grant delete on table "public"."school_classes" to "authenticated";

grant insert on table "public"."school_classes" to "authenticated";

grant references on table "public"."school_classes" to "authenticated";

grant select on table "public"."school_classes" to "authenticated";

grant trigger on table "public"."school_classes" to "authenticated";

grant truncate on table "public"."school_classes" to "authenticated";

grant update on table "public"."school_classes" to "authenticated";

grant delete on table "public"."school_classes" to "service_role";

grant insert on table "public"."school_classes" to "service_role";

grant references on table "public"."school_classes" to "service_role";

grant select on table "public"."school_classes" to "service_role";

grant trigger on table "public"."school_classes" to "service_role";

grant truncate on table "public"."school_classes" to "service_role";

grant update on table "public"."school_classes" to "service_role";

grant delete on table "public"."school_educator_class_assignments" to "anon";

grant insert on table "public"."school_educator_class_assignments" to "anon";

grant references on table "public"."school_educator_class_assignments" to "anon";

grant select on table "public"."school_educator_class_assignments" to "anon";

grant trigger on table "public"."school_educator_class_assignments" to "anon";

grant truncate on table "public"."school_educator_class_assignments" to "anon";

grant update on table "public"."school_educator_class_assignments" to "anon";

grant delete on table "public"."school_educator_class_assignments" to "authenticated";

grant insert on table "public"."school_educator_class_assignments" to "authenticated";

grant references on table "public"."school_educator_class_assignments" to "authenticated";

grant select on table "public"."school_educator_class_assignments" to "authenticated";

grant trigger on table "public"."school_educator_class_assignments" to "authenticated";

grant truncate on table "public"."school_educator_class_assignments" to "authenticated";

grant update on table "public"."school_educator_class_assignments" to "authenticated";

grant delete on table "public"."school_educator_class_assignments" to "service_role";

grant insert on table "public"."school_educator_class_assignments" to "service_role";

grant references on table "public"."school_educator_class_assignments" to "service_role";

grant select on table "public"."school_educator_class_assignments" to "service_role";

grant trigger on table "public"."school_educator_class_assignments" to "service_role";

grant truncate on table "public"."school_educator_class_assignments" to "service_role";

grant update on table "public"."school_educator_class_assignments" to "service_role";

grant delete on table "public"."school_educators" to "anon";

grant insert on table "public"."school_educators" to "anon";

grant references on table "public"."school_educators" to "anon";

grant select on table "public"."school_educators" to "anon";

grant trigger on table "public"."school_educators" to "anon";

grant truncate on table "public"."school_educators" to "anon";

grant update on table "public"."school_educators" to "anon";

grant delete on table "public"."school_educators" to "authenticated";

grant insert on table "public"."school_educators" to "authenticated";

grant references on table "public"."school_educators" to "authenticated";

grant select on table "public"."school_educators" to "authenticated";

grant trigger on table "public"."school_educators" to "authenticated";

grant truncate on table "public"."school_educators" to "authenticated";

grant update on table "public"."school_educators" to "authenticated";

grant delete on table "public"."school_educators" to "service_role";

grant insert on table "public"."school_educators" to "service_role";

grant references on table "public"."school_educators" to "service_role";

grant select on table "public"."school_educators" to "service_role";

grant trigger on table "public"."school_educators" to "service_role";

grant truncate on table "public"."school_educators" to "service_role";

grant update on table "public"."school_educators" to "service_role";

grant delete on table "public"."search_history" to "anon";

grant insert on table "public"."search_history" to "anon";

grant references on table "public"."search_history" to "anon";

grant select on table "public"."search_history" to "anon";

grant trigger on table "public"."search_history" to "anon";

grant truncate on table "public"."search_history" to "anon";

grant update on table "public"."search_history" to "anon";

grant delete on table "public"."search_history" to "authenticated";

grant insert on table "public"."search_history" to "authenticated";

grant references on table "public"."search_history" to "authenticated";

grant select on table "public"."search_history" to "authenticated";

grant trigger on table "public"."search_history" to "authenticated";

grant truncate on table "public"."search_history" to "authenticated";

grant update on table "public"."search_history" to "authenticated";

grant delete on table "public"."search_history" to "service_role";

grant insert on table "public"."search_history" to "service_role";

grant references on table "public"."search_history" to "service_role";

grant select on table "public"."search_history" to "service_role";

grant trigger on table "public"."search_history" to "service_role";

grant truncate on table "public"."search_history" to "service_role";

grant update on table "public"."search_history" to "service_role";

grant delete on table "public"."shortlist_candidates" to "anon";

grant insert on table "public"."shortlist_candidates" to "anon";

grant references on table "public"."shortlist_candidates" to "anon";

grant select on table "public"."shortlist_candidates" to "anon";

grant trigger on table "public"."shortlist_candidates" to "anon";

grant truncate on table "public"."shortlist_candidates" to "anon";

grant update on table "public"."shortlist_candidates" to "anon";

grant delete on table "public"."shortlist_candidates" to "authenticated";

grant insert on table "public"."shortlist_candidates" to "authenticated";

grant references on table "public"."shortlist_candidates" to "authenticated";

grant select on table "public"."shortlist_candidates" to "authenticated";

grant trigger on table "public"."shortlist_candidates" to "authenticated";

grant truncate on table "public"."shortlist_candidates" to "authenticated";

grant update on table "public"."shortlist_candidates" to "authenticated";

grant delete on table "public"."shortlist_candidates" to "service_role";

grant insert on table "public"."shortlist_candidates" to "service_role";

grant references on table "public"."shortlist_candidates" to "service_role";

grant select on table "public"."shortlist_candidates" to "service_role";

grant trigger on table "public"."shortlist_candidates" to "service_role";

grant truncate on table "public"."shortlist_candidates" to "service_role";

grant update on table "public"."shortlist_candidates" to "service_role";

grant delete on table "public"."shortlists" to "anon";

grant insert on table "public"."shortlists" to "anon";

grant references on table "public"."shortlists" to "anon";

grant select on table "public"."shortlists" to "anon";

grant trigger on table "public"."shortlists" to "anon";

grant truncate on table "public"."shortlists" to "anon";

grant update on table "public"."shortlists" to "anon";

grant delete on table "public"."shortlists" to "authenticated";

grant insert on table "public"."shortlists" to "authenticated";

grant references on table "public"."shortlists" to "authenticated";

grant select on table "public"."shortlists" to "authenticated";

grant trigger on table "public"."shortlists" to "authenticated";

grant truncate on table "public"."shortlists" to "authenticated";

grant update on table "public"."shortlists" to "authenticated";

grant delete on table "public"."shortlists" to "service_role";

grant insert on table "public"."shortlists" to "service_role";

grant references on table "public"."shortlists" to "service_role";

grant select on table "public"."shortlists" to "service_role";

grant trigger on table "public"."shortlists" to "service_role";

grant truncate on table "public"."shortlists" to "service_role";

grant update on table "public"."shortlists" to "service_role";

grant delete on table "public"."skill_assessments" to "anon";

grant insert on table "public"."skill_assessments" to "anon";

grant references on table "public"."skill_assessments" to "anon";

grant select on table "public"."skill_assessments" to "anon";

grant trigger on table "public"."skill_assessments" to "anon";

grant truncate on table "public"."skill_assessments" to "anon";

grant update on table "public"."skill_assessments" to "anon";

grant delete on table "public"."skill_assessments" to "authenticated";

grant insert on table "public"."skill_assessments" to "authenticated";

grant references on table "public"."skill_assessments" to "authenticated";

grant select on table "public"."skill_assessments" to "authenticated";

grant trigger on table "public"."skill_assessments" to "authenticated";

grant truncate on table "public"."skill_assessments" to "authenticated";

grant update on table "public"."skill_assessments" to "authenticated";

grant delete on table "public"."skill_assessments" to "service_role";

grant insert on table "public"."skill_assessments" to "service_role";

grant references on table "public"."skill_assessments" to "service_role";

grant select on table "public"."skill_assessments" to "service_role";

grant trigger on table "public"."skill_assessments" to "service_role";

grant truncate on table "public"."skill_assessments" to "service_role";

grant update on table "public"."skill_assessments" to "service_role";

grant delete on table "public"."skill_badges" to "anon";

grant insert on table "public"."skill_badges" to "anon";

grant references on table "public"."skill_badges" to "anon";

grant select on table "public"."skill_badges" to "anon";

grant trigger on table "public"."skill_badges" to "anon";

grant truncate on table "public"."skill_badges" to "anon";

grant update on table "public"."skill_badges" to "anon";

grant delete on table "public"."skill_badges" to "authenticated";

grant insert on table "public"."skill_badges" to "authenticated";

grant references on table "public"."skill_badges" to "authenticated";

grant select on table "public"."skill_badges" to "authenticated";

grant trigger on table "public"."skill_badges" to "authenticated";

grant truncate on table "public"."skill_badges" to "authenticated";

grant update on table "public"."skill_badges" to "authenticated";

grant delete on table "public"."skill_badges" to "service_role";

grant insert on table "public"."skill_badges" to "service_role";

grant references on table "public"."skill_badges" to "service_role";

grant select on table "public"."skill_badges" to "service_role";

grant trigger on table "public"."skill_badges" to "service_role";

grant truncate on table "public"."skill_badges" to "service_role";

grant update on table "public"."skill_badges" to "service_role";

grant delete on table "public"."skill_passports" to "anon";

grant insert on table "public"."skill_passports" to "anon";

grant references on table "public"."skill_passports" to "anon";

grant select on table "public"."skill_passports" to "anon";

grant trigger on table "public"."skill_passports" to "anon";

grant truncate on table "public"."skill_passports" to "anon";

grant update on table "public"."skill_passports" to "anon";

grant delete on table "public"."skill_passports" to "authenticated";

grant insert on table "public"."skill_passports" to "authenticated";

grant references on table "public"."skill_passports" to "authenticated";

grant select on table "public"."skill_passports" to "authenticated";

grant trigger on table "public"."skill_passports" to "authenticated";

grant truncate on table "public"."skill_passports" to "authenticated";

grant update on table "public"."skill_passports" to "authenticated";

grant delete on table "public"."skill_passports" to "service_role";

grant insert on table "public"."skill_passports" to "service_role";

grant references on table "public"."skill_passports" to "service_role";

grant select on table "public"."skill_passports" to "service_role";

grant trigger on table "public"."skill_passports" to "service_role";

grant truncate on table "public"."skill_passports" to "service_role";

grant update on table "public"."skill_passports" to "service_role";

grant delete on table "public"."skill_trends" to "anon";

grant insert on table "public"."skill_trends" to "anon";

grant references on table "public"."skill_trends" to "anon";

grant select on table "public"."skill_trends" to "anon";

grant trigger on table "public"."skill_trends" to "anon";

grant truncate on table "public"."skill_trends" to "anon";

grant update on table "public"."skill_trends" to "anon";

grant delete on table "public"."skill_trends" to "authenticated";

grant insert on table "public"."skill_trends" to "authenticated";

grant references on table "public"."skill_trends" to "authenticated";

grant select on table "public"."skill_trends" to "authenticated";

grant trigger on table "public"."skill_trends" to "authenticated";

grant truncate on table "public"."skill_trends" to "authenticated";

grant update on table "public"."skill_trends" to "authenticated";

grant delete on table "public"."skill_trends" to "service_role";

grant insert on table "public"."skill_trends" to "service_role";

grant references on table "public"."skill_trends" to "service_role";

grant select on table "public"."skill_trends" to "service_role";

grant trigger on table "public"."skill_trends" to "service_role";

grant truncate on table "public"."skill_trends" to "service_role";

grant update on table "public"."skill_trends" to "service_role";

grant delete on table "public"."skill_verification_requests" to "anon";

grant insert on table "public"."skill_verification_requests" to "anon";

grant references on table "public"."skill_verification_requests" to "anon";

grant select on table "public"."skill_verification_requests" to "anon";

grant trigger on table "public"."skill_verification_requests" to "anon";

grant truncate on table "public"."skill_verification_requests" to "anon";

grant update on table "public"."skill_verification_requests" to "anon";

grant delete on table "public"."skill_verification_requests" to "authenticated";

grant insert on table "public"."skill_verification_requests" to "authenticated";

grant references on table "public"."skill_verification_requests" to "authenticated";

grant select on table "public"."skill_verification_requests" to "authenticated";

grant trigger on table "public"."skill_verification_requests" to "authenticated";

grant truncate on table "public"."skill_verification_requests" to "authenticated";

grant update on table "public"."skill_verification_requests" to "authenticated";

grant delete on table "public"."skill_verification_requests" to "service_role";

grant insert on table "public"."skill_verification_requests" to "service_role";

grant references on table "public"."skill_verification_requests" to "service_role";

grant select on table "public"."skill_verification_requests" to "service_role";

grant trigger on table "public"."skill_verification_requests" to "service_role";

grant truncate on table "public"."skill_verification_requests" to "service_role";

grant update on table "public"."skill_verification_requests" to "service_role";

grant delete on table "public"."skills" to "anon";

grant insert on table "public"."skills" to "anon";

grant references on table "public"."skills" to "anon";

grant select on table "public"."skills" to "anon";

grant trigger on table "public"."skills" to "anon";

grant truncate on table "public"."skills" to "anon";

grant update on table "public"."skills" to "anon";

grant delete on table "public"."skills" to "authenticated";

grant insert on table "public"."skills" to "authenticated";

grant references on table "public"."skills" to "authenticated";

grant select on table "public"."skills" to "authenticated";

grant trigger on table "public"."skills" to "authenticated";

grant truncate on table "public"."skills" to "authenticated";

grant update on table "public"."skills" to "authenticated";

grant delete on table "public"."skills" to "service_role";

grant insert on table "public"."skills" to "service_role";

grant references on table "public"."skills" to "service_role";

grant select on table "public"."skills" to "service_role";

grant trigger on table "public"."skills" to "service_role";

grant truncate on table "public"."skills" to "service_role";

grant update on table "public"."skills" to "service_role";

grant delete on table "public"."streak_notification_log" to "anon";

grant insert on table "public"."streak_notification_log" to "anon";

grant references on table "public"."streak_notification_log" to "anon";

grant select on table "public"."streak_notification_log" to "anon";

grant trigger on table "public"."streak_notification_log" to "anon";

grant truncate on table "public"."streak_notification_log" to "anon";

grant update on table "public"."streak_notification_log" to "anon";

grant delete on table "public"."streak_notification_log" to "authenticated";

grant insert on table "public"."streak_notification_log" to "authenticated";

grant references on table "public"."streak_notification_log" to "authenticated";

grant select on table "public"."streak_notification_log" to "authenticated";

grant trigger on table "public"."streak_notification_log" to "authenticated";

grant truncate on table "public"."streak_notification_log" to "authenticated";

grant update on table "public"."streak_notification_log" to "authenticated";

grant delete on table "public"."streak_notification_log" to "service_role";

grant insert on table "public"."streak_notification_log" to "service_role";

grant references on table "public"."streak_notification_log" to "service_role";

grant select on table "public"."streak_notification_log" to "service_role";

grant trigger on table "public"."streak_notification_log" to "service_role";

grant truncate on table "public"."streak_notification_log" to "service_role";

grant update on table "public"."streak_notification_log" to "service_role";

grant delete on table "public"."stream_recommendation_reports" to "anon";

grant insert on table "public"."stream_recommendation_reports" to "anon";

grant references on table "public"."stream_recommendation_reports" to "anon";

grant select on table "public"."stream_recommendation_reports" to "anon";

grant trigger on table "public"."stream_recommendation_reports" to "anon";

grant truncate on table "public"."stream_recommendation_reports" to "anon";

grant update on table "public"."stream_recommendation_reports" to "anon";

grant delete on table "public"."stream_recommendation_reports" to "authenticated";

grant insert on table "public"."stream_recommendation_reports" to "authenticated";

grant references on table "public"."stream_recommendation_reports" to "authenticated";

grant select on table "public"."stream_recommendation_reports" to "authenticated";

grant trigger on table "public"."stream_recommendation_reports" to "authenticated";

grant truncate on table "public"."stream_recommendation_reports" to "authenticated";

grant update on table "public"."stream_recommendation_reports" to "authenticated";

grant delete on table "public"."stream_recommendation_reports" to "service_role";

grant insert on table "public"."stream_recommendation_reports" to "service_role";

grant references on table "public"."stream_recommendation_reports" to "service_role";

grant select on table "public"."stream_recommendation_reports" to "service_role";

grant trigger on table "public"."stream_recommendation_reports" to "service_role";

grant truncate on table "public"."stream_recommendation_reports" to "service_role";

grant update on table "public"."stream_recommendation_reports" to "service_role";

grant delete on table "public"."student_assignments" to "anon";

grant insert on table "public"."student_assignments" to "anon";

grant references on table "public"."student_assignments" to "anon";

grant select on table "public"."student_assignments" to "anon";

grant trigger on table "public"."student_assignments" to "anon";

grant truncate on table "public"."student_assignments" to "anon";

grant update on table "public"."student_assignments" to "anon";

grant delete on table "public"."student_assignments" to "authenticated";

grant insert on table "public"."student_assignments" to "authenticated";

grant references on table "public"."student_assignments" to "authenticated";

grant select on table "public"."student_assignments" to "authenticated";

grant trigger on table "public"."student_assignments" to "authenticated";

grant truncate on table "public"."student_assignments" to "authenticated";

grant update on table "public"."student_assignments" to "authenticated";

grant delete on table "public"."student_assignments" to "service_role";

grant insert on table "public"."student_assignments" to "service_role";

grant references on table "public"."student_assignments" to "service_role";

grant select on table "public"."student_assignments" to "service_role";

grant trigger on table "public"."student_assignments" to "service_role";

grant truncate on table "public"."student_assignments" to "service_role";

grant update on table "public"."student_assignments" to "service_role";

grant delete on table "public"."student_course_progress" to "anon";

grant insert on table "public"."student_course_progress" to "anon";

grant references on table "public"."student_course_progress" to "anon";

grant select on table "public"."student_course_progress" to "anon";

grant trigger on table "public"."student_course_progress" to "anon";

grant truncate on table "public"."student_course_progress" to "anon";

grant update on table "public"."student_course_progress" to "anon";

grant delete on table "public"."student_course_progress" to "authenticated";

grant insert on table "public"."student_course_progress" to "authenticated";

grant references on table "public"."student_course_progress" to "authenticated";

grant select on table "public"."student_course_progress" to "authenticated";

grant trigger on table "public"."student_course_progress" to "authenticated";

grant truncate on table "public"."student_course_progress" to "authenticated";

grant update on table "public"."student_course_progress" to "authenticated";

grant delete on table "public"."student_course_progress" to "service_role";

grant insert on table "public"."student_course_progress" to "service_role";

grant references on table "public"."student_course_progress" to "service_role";

grant select on table "public"."student_course_progress" to "service_role";

grant trigger on table "public"."student_course_progress" to "service_role";

grant truncate on table "public"."student_course_progress" to "service_role";

grant update on table "public"."student_course_progress" to "service_role";

grant delete on table "public"."student_course_recommendations" to "anon";

grant insert on table "public"."student_course_recommendations" to "anon";

grant references on table "public"."student_course_recommendations" to "anon";

grant select on table "public"."student_course_recommendations" to "anon";

grant trigger on table "public"."student_course_recommendations" to "anon";

grant truncate on table "public"."student_course_recommendations" to "anon";

grant update on table "public"."student_course_recommendations" to "anon";

grant delete on table "public"."student_course_recommendations" to "authenticated";

grant insert on table "public"."student_course_recommendations" to "authenticated";

grant references on table "public"."student_course_recommendations" to "authenticated";

grant select on table "public"."student_course_recommendations" to "authenticated";

grant trigger on table "public"."student_course_recommendations" to "authenticated";

grant truncate on table "public"."student_course_recommendations" to "authenticated";

grant update on table "public"."student_course_recommendations" to "authenticated";

grant delete on table "public"."student_course_recommendations" to "service_role";

grant insert on table "public"."student_course_recommendations" to "service_role";

grant references on table "public"."student_course_recommendations" to "service_role";

grant select on table "public"."student_course_recommendations" to "service_role";

grant trigger on table "public"."student_course_recommendations" to "service_role";

grant truncate on table "public"."student_course_recommendations" to "service_role";

grant update on table "public"."student_course_recommendations" to "service_role";

grant delete on table "public"."student_enrollments" to "anon";

grant insert on table "public"."student_enrollments" to "anon";

grant references on table "public"."student_enrollments" to "anon";

grant select on table "public"."student_enrollments" to "anon";

grant trigger on table "public"."student_enrollments" to "anon";

grant truncate on table "public"."student_enrollments" to "anon";

grant update on table "public"."student_enrollments" to "anon";

grant delete on table "public"."student_enrollments" to "authenticated";

grant insert on table "public"."student_enrollments" to "authenticated";

grant references on table "public"."student_enrollments" to "authenticated";

grant select on table "public"."student_enrollments" to "authenticated";

grant trigger on table "public"."student_enrollments" to "authenticated";

grant truncate on table "public"."student_enrollments" to "authenticated";

grant update on table "public"."student_enrollments" to "authenticated";

grant delete on table "public"."student_enrollments" to "service_role";

grant insert on table "public"."student_enrollments" to "service_role";

grant references on table "public"."student_enrollments" to "service_role";

grant select on table "public"."student_enrollments" to "service_role";

grant trigger on table "public"."student_enrollments" to "service_role";

grant truncate on table "public"."student_enrollments" to "service_role";

grant update on table "public"."student_enrollments" to "service_role";

grant delete on table "public"."student_job_matches" to "anon";

grant insert on table "public"."student_job_matches" to "anon";

grant references on table "public"."student_job_matches" to "anon";

grant select on table "public"."student_job_matches" to "anon";

grant trigger on table "public"."student_job_matches" to "anon";

grant truncate on table "public"."student_job_matches" to "anon";

grant update on table "public"."student_job_matches" to "anon";

grant delete on table "public"."student_job_matches" to "authenticated";

grant insert on table "public"."student_job_matches" to "authenticated";

grant references on table "public"."student_job_matches" to "authenticated";

grant select on table "public"."student_job_matches" to "authenticated";

grant trigger on table "public"."student_job_matches" to "authenticated";

grant truncate on table "public"."student_job_matches" to "authenticated";

grant update on table "public"."student_job_matches" to "authenticated";

grant delete on table "public"."student_job_matches" to "service_role";

grant insert on table "public"."student_job_matches" to "service_role";

grant references on table "public"."student_job_matches" to "service_role";

grant select on table "public"."student_job_matches" to "service_role";

grant trigger on table "public"."student_job_matches" to "service_role";

grant truncate on table "public"."student_job_matches" to "service_role";

grant update on table "public"."student_job_matches" to "service_role";

grant delete on table "public"."student_ledgers" to "anon";

grant insert on table "public"."student_ledgers" to "anon";

grant references on table "public"."student_ledgers" to "anon";

grant select on table "public"."student_ledgers" to "anon";

grant trigger on table "public"."student_ledgers" to "anon";

grant truncate on table "public"."student_ledgers" to "anon";

grant update on table "public"."student_ledgers" to "anon";

grant delete on table "public"."student_ledgers" to "authenticated";

grant insert on table "public"."student_ledgers" to "authenticated";

grant references on table "public"."student_ledgers" to "authenticated";

grant select on table "public"."student_ledgers" to "authenticated";

grant trigger on table "public"."student_ledgers" to "authenticated";

grant truncate on table "public"."student_ledgers" to "authenticated";

grant update on table "public"."student_ledgers" to "authenticated";

grant delete on table "public"."student_ledgers" to "service_role";

grant insert on table "public"."student_ledgers" to "service_role";

grant references on table "public"."student_ledgers" to "service_role";

grant select on table "public"."student_ledgers" to "service_role";

grant trigger on table "public"."student_ledgers" to "service_role";

grant truncate on table "public"."student_ledgers" to "service_role";

grant update on table "public"."student_ledgers" to "service_role";

grant delete on table "public"."student_management_records" to "anon";

grant insert on table "public"."student_management_records" to "anon";

grant references on table "public"."student_management_records" to "anon";

grant select on table "public"."student_management_records" to "anon";

grant trigger on table "public"."student_management_records" to "anon";

grant truncate on table "public"."student_management_records" to "anon";

grant update on table "public"."student_management_records" to "anon";

grant delete on table "public"."student_management_records" to "authenticated";

grant insert on table "public"."student_management_records" to "authenticated";

grant references on table "public"."student_management_records" to "authenticated";

grant select on table "public"."student_management_records" to "authenticated";

grant trigger on table "public"."student_management_records" to "authenticated";

grant truncate on table "public"."student_management_records" to "authenticated";

grant update on table "public"."student_management_records" to "authenticated";

grant delete on table "public"."student_management_records" to "service_role";

grant insert on table "public"."student_management_records" to "service_role";

grant references on table "public"."student_management_records" to "service_role";

grant select on table "public"."student_management_records" to "service_role";

grant trigger on table "public"."student_management_records" to "service_role";

grant truncate on table "public"."student_management_records" to "service_role";

grant update on table "public"."student_management_records" to "service_role";

grant delete on table "public"."student_promotions" to "anon";

grant insert on table "public"."student_promotions" to "anon";

grant references on table "public"."student_promotions" to "anon";

grant select on table "public"."student_promotions" to "anon";

grant trigger on table "public"."student_promotions" to "anon";

grant truncate on table "public"."student_promotions" to "anon";

grant update on table "public"."student_promotions" to "anon";

grant delete on table "public"."student_promotions" to "authenticated";

grant insert on table "public"."student_promotions" to "authenticated";

grant references on table "public"."student_promotions" to "authenticated";

grant select on table "public"."student_promotions" to "authenticated";

grant trigger on table "public"."student_promotions" to "authenticated";

grant truncate on table "public"."student_promotions" to "authenticated";

grant update on table "public"."student_promotions" to "authenticated";

grant delete on table "public"."student_promotions" to "service_role";

grant insert on table "public"."student_promotions" to "service_role";

grant references on table "public"."student_promotions" to "service_role";

grant select on table "public"."student_promotions" to "service_role";

grant trigger on table "public"."student_promotions" to "service_role";

grant truncate on table "public"."student_promotions" to "service_role";

grant update on table "public"."student_promotions" to "service_role";

grant delete on table "public"."student_quiz_progress" to "anon";

grant insert on table "public"."student_quiz_progress" to "anon";

grant references on table "public"."student_quiz_progress" to "anon";

grant select on table "public"."student_quiz_progress" to "anon";

grant trigger on table "public"."student_quiz_progress" to "anon";

grant truncate on table "public"."student_quiz_progress" to "anon";

grant update on table "public"."student_quiz_progress" to "anon";

grant delete on table "public"."student_quiz_progress" to "authenticated";

grant insert on table "public"."student_quiz_progress" to "authenticated";

grant references on table "public"."student_quiz_progress" to "authenticated";

grant select on table "public"."student_quiz_progress" to "authenticated";

grant trigger on table "public"."student_quiz_progress" to "authenticated";

grant truncate on table "public"."student_quiz_progress" to "authenticated";

grant update on table "public"."student_quiz_progress" to "authenticated";

grant delete on table "public"."student_quiz_progress" to "service_role";

grant insert on table "public"."student_quiz_progress" to "service_role";

grant references on table "public"."student_quiz_progress" to "service_role";

grant select on table "public"."student_quiz_progress" to "service_role";

grant trigger on table "public"."student_quiz_progress" to "service_role";

grant truncate on table "public"."student_quiz_progress" to "service_role";

grant update on table "public"."student_quiz_progress" to "service_role";

grant delete on table "public"."student_reports" to "anon";

grant insert on table "public"."student_reports" to "anon";

grant references on table "public"."student_reports" to "anon";

grant select on table "public"."student_reports" to "anon";

grant trigger on table "public"."student_reports" to "anon";

grant truncate on table "public"."student_reports" to "anon";

grant update on table "public"."student_reports" to "anon";

grant delete on table "public"."student_reports" to "authenticated";

grant insert on table "public"."student_reports" to "authenticated";

grant references on table "public"."student_reports" to "authenticated";

grant select on table "public"."student_reports" to "authenticated";

grant trigger on table "public"."student_reports" to "authenticated";

grant truncate on table "public"."student_reports" to "authenticated";

grant update on table "public"."student_reports" to "authenticated";

grant delete on table "public"."student_reports" to "service_role";

grant insert on table "public"."student_reports" to "service_role";

grant references on table "public"."student_reports" to "service_role";

grant select on table "public"."student_reports" to "service_role";

grant trigger on table "public"."student_reports" to "service_role";

grant truncate on table "public"."student_reports" to "service_role";

grant update on table "public"."student_reports" to "service_role";

grant delete on table "public"."student_skill_badges" to "anon";

grant insert on table "public"."student_skill_badges" to "anon";

grant references on table "public"."student_skill_badges" to "anon";

grant select on table "public"."student_skill_badges" to "anon";

grant trigger on table "public"."student_skill_badges" to "anon";

grant truncate on table "public"."student_skill_badges" to "anon";

grant update on table "public"."student_skill_badges" to "anon";

grant delete on table "public"."student_skill_badges" to "authenticated";

grant insert on table "public"."student_skill_badges" to "authenticated";

grant references on table "public"."student_skill_badges" to "authenticated";

grant select on table "public"."student_skill_badges" to "authenticated";

grant trigger on table "public"."student_skill_badges" to "authenticated";

grant truncate on table "public"."student_skill_badges" to "authenticated";

grant update on table "public"."student_skill_badges" to "authenticated";

grant delete on table "public"."student_skill_badges" to "service_role";

grant insert on table "public"."student_skill_badges" to "service_role";

grant references on table "public"."student_skill_badges" to "service_role";

grant select on table "public"."student_skill_badges" to "service_role";

grant trigger on table "public"."student_skill_badges" to "service_role";

grant truncate on table "public"."student_skill_badges" to "service_role";

grant update on table "public"."student_skill_badges" to "service_role";

grant delete on table "public"."student_streaks" to "anon";

grant insert on table "public"."student_streaks" to "anon";

grant references on table "public"."student_streaks" to "anon";

grant select on table "public"."student_streaks" to "anon";

grant trigger on table "public"."student_streaks" to "anon";

grant truncate on table "public"."student_streaks" to "anon";

grant update on table "public"."student_streaks" to "anon";

grant delete on table "public"."student_streaks" to "authenticated";

grant insert on table "public"."student_streaks" to "authenticated";

grant references on table "public"."student_streaks" to "authenticated";

grant select on table "public"."student_streaks" to "authenticated";

grant trigger on table "public"."student_streaks" to "authenticated";

grant truncate on table "public"."student_streaks" to "authenticated";

grant update on table "public"."student_streaks" to "authenticated";

grant delete on table "public"."student_streaks" to "service_role";

grant insert on table "public"."student_streaks" to "service_role";

grant references on table "public"."student_streaks" to "service_role";

grant select on table "public"."student_streaks" to "service_role";

grant trigger on table "public"."student_streaks" to "service_role";

grant truncate on table "public"."student_streaks" to "service_role";

grant update on table "public"."student_streaks" to "service_role";

grant delete on table "public"."students" to "anon";

grant insert on table "public"."students" to "anon";

grant references on table "public"."students" to "anon";

grant select on table "public"."students" to "anon";

grant trigger on table "public"."students" to "anon";

grant truncate on table "public"."students" to "anon";

grant update on table "public"."students" to "anon";

grant delete on table "public"."students" to "authenticated";

grant insert on table "public"."students" to "authenticated";

grant references on table "public"."students" to "authenticated";

grant select on table "public"."students" to "authenticated";

grant trigger on table "public"."students" to "authenticated";

grant truncate on table "public"."students" to "authenticated";

grant update on table "public"."students" to "authenticated";

grant delete on table "public"."students" to "service_role";

grant insert on table "public"."students" to "service_role";

grant references on table "public"."students" to "service_role";

grant select on table "public"."students" to "service_role";

grant trigger on table "public"."students" to "service_role";

grant truncate on table "public"."students" to "service_role";

grant update on table "public"."students" to "service_role";

grant delete on table "public"."subscription_cancellations" to "anon";

grant insert on table "public"."subscription_cancellations" to "anon";

grant references on table "public"."subscription_cancellations" to "anon";

grant select on table "public"."subscription_cancellations" to "anon";

grant trigger on table "public"."subscription_cancellations" to "anon";

grant truncate on table "public"."subscription_cancellations" to "anon";

grant update on table "public"."subscription_cancellations" to "anon";

grant delete on table "public"."subscription_cancellations" to "authenticated";

grant insert on table "public"."subscription_cancellations" to "authenticated";

grant references on table "public"."subscription_cancellations" to "authenticated";

grant select on table "public"."subscription_cancellations" to "authenticated";

grant trigger on table "public"."subscription_cancellations" to "authenticated";

grant truncate on table "public"."subscription_cancellations" to "authenticated";

grant update on table "public"."subscription_cancellations" to "authenticated";

grant delete on table "public"."subscription_cancellations" to "service_role";

grant insert on table "public"."subscription_cancellations" to "service_role";

grant references on table "public"."subscription_cancellations" to "service_role";

grant select on table "public"."subscription_cancellations" to "service_role";

grant trigger on table "public"."subscription_cancellations" to "service_role";

grant truncate on table "public"."subscription_cancellations" to "service_role";

grant update on table "public"."subscription_cancellations" to "service_role";

grant delete on table "public"."subscription_migrations" to "anon";

grant insert on table "public"."subscription_migrations" to "anon";

grant references on table "public"."subscription_migrations" to "anon";

grant select on table "public"."subscription_migrations" to "anon";

grant trigger on table "public"."subscription_migrations" to "anon";

grant truncate on table "public"."subscription_migrations" to "anon";

grant update on table "public"."subscription_migrations" to "anon";

grant delete on table "public"."subscription_migrations" to "authenticated";

grant insert on table "public"."subscription_migrations" to "authenticated";

grant references on table "public"."subscription_migrations" to "authenticated";

grant select on table "public"."subscription_migrations" to "authenticated";

grant trigger on table "public"."subscription_migrations" to "authenticated";

grant truncate on table "public"."subscription_migrations" to "authenticated";

grant update on table "public"."subscription_migrations" to "authenticated";

grant delete on table "public"."subscription_migrations" to "service_role";

grant insert on table "public"."subscription_migrations" to "service_role";

grant references on table "public"."subscription_migrations" to "service_role";

grant select on table "public"."subscription_migrations" to "service_role";

grant trigger on table "public"."subscription_migrations" to "service_role";

grant truncate on table "public"."subscription_migrations" to "service_role";

grant update on table "public"."subscription_migrations" to "service_role";

grant delete on table "public"."subscription_plan_features" to "anon";

grant insert on table "public"."subscription_plan_features" to "anon";

grant references on table "public"."subscription_plan_features" to "anon";

grant select on table "public"."subscription_plan_features" to "anon";

grant trigger on table "public"."subscription_plan_features" to "anon";

grant truncate on table "public"."subscription_plan_features" to "anon";

grant update on table "public"."subscription_plan_features" to "anon";

grant delete on table "public"."subscription_plan_features" to "authenticated";

grant insert on table "public"."subscription_plan_features" to "authenticated";

grant references on table "public"."subscription_plan_features" to "authenticated";

grant select on table "public"."subscription_plan_features" to "authenticated";

grant trigger on table "public"."subscription_plan_features" to "authenticated";

grant truncate on table "public"."subscription_plan_features" to "authenticated";

grant update on table "public"."subscription_plan_features" to "authenticated";

grant delete on table "public"."subscription_plan_features" to "service_role";

grant insert on table "public"."subscription_plan_features" to "service_role";

grant references on table "public"."subscription_plan_features" to "service_role";

grant select on table "public"."subscription_plan_features" to "service_role";

grant trigger on table "public"."subscription_plan_features" to "service_role";

grant truncate on table "public"."subscription_plan_features" to "service_role";

grant update on table "public"."subscription_plan_features" to "service_role";

grant delete on table "public"."subscription_plans" to "anon";

grant insert on table "public"."subscription_plans" to "anon";

grant references on table "public"."subscription_plans" to "anon";

grant select on table "public"."subscription_plans" to "anon";

grant trigger on table "public"."subscription_plans" to "anon";

grant truncate on table "public"."subscription_plans" to "anon";

grant update on table "public"."subscription_plans" to "anon";

grant delete on table "public"."subscription_plans" to "authenticated";

grant insert on table "public"."subscription_plans" to "authenticated";

grant references on table "public"."subscription_plans" to "authenticated";

grant select on table "public"."subscription_plans" to "authenticated";

grant trigger on table "public"."subscription_plans" to "authenticated";

grant truncate on table "public"."subscription_plans" to "authenticated";

grant update on table "public"."subscription_plans" to "authenticated";

grant delete on table "public"."subscription_plans" to "service_role";

grant insert on table "public"."subscription_plans" to "service_role";

grant references on table "public"."subscription_plans" to "service_role";

grant select on table "public"."subscription_plans" to "service_role";

grant trigger on table "public"."subscription_plans" to "service_role";

grant truncate on table "public"."subscription_plans" to "service_role";

grant update on table "public"."subscription_plans" to "service_role";

grant delete on table "public"."subscriptions" to "anon";

grant insert on table "public"."subscriptions" to "anon";

grant references on table "public"."subscriptions" to "anon";

grant select on table "public"."subscriptions" to "anon";

grant trigger on table "public"."subscriptions" to "anon";

grant truncate on table "public"."subscriptions" to "anon";

grant update on table "public"."subscriptions" to "anon";

grant delete on table "public"."subscriptions" to "authenticated";

grant insert on table "public"."subscriptions" to "authenticated";

grant references on table "public"."subscriptions" to "authenticated";

grant select on table "public"."subscriptions" to "authenticated";

grant trigger on table "public"."subscriptions" to "authenticated";

grant truncate on table "public"."subscriptions" to "authenticated";

grant update on table "public"."subscriptions" to "authenticated";

grant delete on table "public"."subscriptions" to "service_role";

grant insert on table "public"."subscriptions" to "service_role";

grant references on table "public"."subscriptions" to "service_role";

grant select on table "public"."subscriptions" to "service_role";

grant trigger on table "public"."subscriptions" to "service_role";

grant truncate on table "public"."subscriptions" to "service_role";

grant update on table "public"."subscriptions" to "service_role";

grant delete on table "public"."teacher_journal" to "anon";

grant insert on table "public"."teacher_journal" to "anon";

grant references on table "public"."teacher_journal" to "anon";

grant select on table "public"."teacher_journal" to "anon";

grant trigger on table "public"."teacher_journal" to "anon";

grant truncate on table "public"."teacher_journal" to "anon";

grant update on table "public"."teacher_journal" to "anon";

grant delete on table "public"."teacher_journal" to "authenticated";

grant insert on table "public"."teacher_journal" to "authenticated";

grant references on table "public"."teacher_journal" to "authenticated";

grant select on table "public"."teacher_journal" to "authenticated";

grant trigger on table "public"."teacher_journal" to "authenticated";

grant truncate on table "public"."teacher_journal" to "authenticated";

grant update on table "public"."teacher_journal" to "authenticated";

grant delete on table "public"."teacher_journal" to "service_role";

grant insert on table "public"."teacher_journal" to "service_role";

grant references on table "public"."teacher_journal" to "service_role";

grant select on table "public"."teacher_journal" to "service_role";

grant trigger on table "public"."teacher_journal" to "service_role";

grant truncate on table "public"."teacher_journal" to "service_role";

grant update on table "public"."teacher_journal" to "service_role";

grant delete on table "public"."teacher_workload" to "anon";

grant insert on table "public"."teacher_workload" to "anon";

grant references on table "public"."teacher_workload" to "anon";

grant select on table "public"."teacher_workload" to "anon";

grant trigger on table "public"."teacher_workload" to "anon";

grant truncate on table "public"."teacher_workload" to "anon";

grant update on table "public"."teacher_workload" to "anon";

grant delete on table "public"."teacher_workload" to "authenticated";

grant insert on table "public"."teacher_workload" to "authenticated";

grant references on table "public"."teacher_workload" to "authenticated";

grant select on table "public"."teacher_workload" to "authenticated";

grant trigger on table "public"."teacher_workload" to "authenticated";

grant truncate on table "public"."teacher_workload" to "authenticated";

grant update on table "public"."teacher_workload" to "authenticated";

grant delete on table "public"."teacher_workload" to "service_role";

grant insert on table "public"."teacher_workload" to "service_role";

grant references on table "public"."teacher_workload" to "service_role";

grant select on table "public"."teacher_workload" to "service_role";

grant trigger on table "public"."teacher_workload" to "service_role";

grant truncate on table "public"."teacher_workload" to "service_role";

grant update on table "public"."teacher_workload" to "service_role";

grant delete on table "public"."timetable_conflicts" to "anon";

grant insert on table "public"."timetable_conflicts" to "anon";

grant references on table "public"."timetable_conflicts" to "anon";

grant select on table "public"."timetable_conflicts" to "anon";

grant trigger on table "public"."timetable_conflicts" to "anon";

grant truncate on table "public"."timetable_conflicts" to "anon";

grant update on table "public"."timetable_conflicts" to "anon";

grant delete on table "public"."timetable_conflicts" to "authenticated";

grant insert on table "public"."timetable_conflicts" to "authenticated";

grant references on table "public"."timetable_conflicts" to "authenticated";

grant select on table "public"."timetable_conflicts" to "authenticated";

grant trigger on table "public"."timetable_conflicts" to "authenticated";

grant truncate on table "public"."timetable_conflicts" to "authenticated";

grant update on table "public"."timetable_conflicts" to "authenticated";

grant delete on table "public"."timetable_conflicts" to "service_role";

grant insert on table "public"."timetable_conflicts" to "service_role";

grant references on table "public"."timetable_conflicts" to "service_role";

grant select on table "public"."timetable_conflicts" to "service_role";

grant trigger on table "public"."timetable_conflicts" to "service_role";

grant truncate on table "public"."timetable_conflicts" to "service_role";

grant update on table "public"."timetable_conflicts" to "service_role";

grant delete on table "public"."timetable_slots" to "anon";

grant insert on table "public"."timetable_slots" to "anon";

grant references on table "public"."timetable_slots" to "anon";

grant select on table "public"."timetable_slots" to "anon";

grant trigger on table "public"."timetable_slots" to "anon";

grant truncate on table "public"."timetable_slots" to "anon";

grant update on table "public"."timetable_slots" to "anon";

grant delete on table "public"."timetable_slots" to "authenticated";

grant insert on table "public"."timetable_slots" to "authenticated";

grant references on table "public"."timetable_slots" to "authenticated";

grant select on table "public"."timetable_slots" to "authenticated";

grant trigger on table "public"."timetable_slots" to "authenticated";

grant truncate on table "public"."timetable_slots" to "authenticated";

grant update on table "public"."timetable_slots" to "authenticated";

grant delete on table "public"."timetable_slots" to "service_role";

grant insert on table "public"."timetable_slots" to "service_role";

grant references on table "public"."timetable_slots" to "service_role";

grant select on table "public"."timetable_slots" to "service_role";

grant trigger on table "public"."timetable_slots" to "service_role";

grant truncate on table "public"."timetable_slots" to "service_role";

grant update on table "public"."timetable_slots" to "service_role";

grant delete on table "public"."timetables" to "anon";

grant insert on table "public"."timetables" to "anon";

grant references on table "public"."timetables" to "anon";

grant select on table "public"."timetables" to "anon";

grant trigger on table "public"."timetables" to "anon";

grant truncate on table "public"."timetables" to "anon";

grant update on table "public"."timetables" to "anon";

grant delete on table "public"."timetables" to "authenticated";

grant insert on table "public"."timetables" to "authenticated";

grant references on table "public"."timetables" to "authenticated";

grant select on table "public"."timetables" to "authenticated";

grant trigger on table "public"."timetables" to "authenticated";

grant truncate on table "public"."timetables" to "authenticated";

grant update on table "public"."timetables" to "authenticated";

grant delete on table "public"."timetables" to "service_role";

grant insert on table "public"."timetables" to "service_role";

grant references on table "public"."timetables" to "service_role";

grant select on table "public"."timetables" to "service_role";

grant trigger on table "public"."timetables" to "service_role";

grant truncate on table "public"."timetables" to "service_role";

grant update on table "public"."timetables" to "service_role";

grant delete on table "public"."training_notifications" to "anon";

grant insert on table "public"."training_notifications" to "anon";

grant references on table "public"."training_notifications" to "anon";

grant select on table "public"."training_notifications" to "anon";

grant trigger on table "public"."training_notifications" to "anon";

grant truncate on table "public"."training_notifications" to "anon";

grant update on table "public"."training_notifications" to "anon";

grant delete on table "public"."training_notifications" to "authenticated";

grant insert on table "public"."training_notifications" to "authenticated";

grant references on table "public"."training_notifications" to "authenticated";

grant select on table "public"."training_notifications" to "authenticated";

grant trigger on table "public"."training_notifications" to "authenticated";

grant truncate on table "public"."training_notifications" to "authenticated";

grant update on table "public"."training_notifications" to "authenticated";

grant delete on table "public"."training_notifications" to "service_role";

grant insert on table "public"."training_notifications" to "service_role";

grant references on table "public"."training_notifications" to "service_role";

grant select on table "public"."training_notifications" to "service_role";

grant trigger on table "public"."training_notifications" to "service_role";

grant truncate on table "public"."training_notifications" to "service_role";

grant update on table "public"."training_notifications" to "service_role";

grant delete on table "public"."trainings" to "anon";

grant insert on table "public"."trainings" to "anon";

grant references on table "public"."trainings" to "anon";

grant select on table "public"."trainings" to "anon";

grant trigger on table "public"."trainings" to "anon";

grant truncate on table "public"."trainings" to "anon";

grant update on table "public"."trainings" to "anon";

grant delete on table "public"."trainings" to "authenticated";

grant insert on table "public"."trainings" to "authenticated";

grant references on table "public"."trainings" to "authenticated";

grant select on table "public"."trainings" to "authenticated";

grant trigger on table "public"."trainings" to "authenticated";

grant truncate on table "public"."trainings" to "authenticated";

grant update on table "public"."trainings" to "authenticated";

grant delete on table "public"."trainings" to "service_role";

grant insert on table "public"."trainings" to "service_role";

grant references on table "public"."trainings" to "service_role";

grant select on table "public"."trainings" to "service_role";

grant trigger on table "public"."trainings" to "service_role";

grant truncate on table "public"."trainings" to "service_role";

grant update on table "public"."trainings" to "service_role";

grant delete on table "public"."transcript_requests" to "anon";

grant insert on table "public"."transcript_requests" to "anon";

grant references on table "public"."transcript_requests" to "anon";

grant select on table "public"."transcript_requests" to "anon";

grant trigger on table "public"."transcript_requests" to "anon";

grant truncate on table "public"."transcript_requests" to "anon";

grant update on table "public"."transcript_requests" to "anon";

grant delete on table "public"."transcript_requests" to "authenticated";

grant insert on table "public"."transcript_requests" to "authenticated";

grant references on table "public"."transcript_requests" to "authenticated";

grant select on table "public"."transcript_requests" to "authenticated";

grant trigger on table "public"."transcript_requests" to "authenticated";

grant truncate on table "public"."transcript_requests" to "authenticated";

grant update on table "public"."transcript_requests" to "authenticated";

grant delete on table "public"."transcript_requests" to "service_role";

grant insert on table "public"."transcript_requests" to "service_role";

grant references on table "public"."transcript_requests" to "service_role";

grant select on table "public"."transcript_requests" to "service_role";

grant trigger on table "public"."transcript_requests" to "service_role";

grant truncate on table "public"."transcript_requests" to "service_role";

grant update on table "public"."transcript_requests" to "service_role";

grant delete on table "public"."transcripts" to "anon";

grant insert on table "public"."transcripts" to "anon";

grant references on table "public"."transcripts" to "anon";

grant select on table "public"."transcripts" to "anon";

grant trigger on table "public"."transcripts" to "anon";

grant truncate on table "public"."transcripts" to "anon";

grant update on table "public"."transcripts" to "anon";

grant delete on table "public"."transcripts" to "authenticated";

grant insert on table "public"."transcripts" to "authenticated";

grant references on table "public"."transcripts" to "authenticated";

grant select on table "public"."transcripts" to "authenticated";

grant trigger on table "public"."transcripts" to "authenticated";

grant truncate on table "public"."transcripts" to "authenticated";

grant update on table "public"."transcripts" to "authenticated";

grant delete on table "public"."transcripts" to "service_role";

grant insert on table "public"."transcripts" to "service_role";

grant references on table "public"."transcripts" to "service_role";

grant select on table "public"."transcripts" to "service_role";

grant trigger on table "public"."transcripts" to "service_role";

grant truncate on table "public"."transcripts" to "service_role";

grant update on table "public"."transcripts" to "service_role";

grant delete on table "public"."tutor_conversations" to "anon";

grant insert on table "public"."tutor_conversations" to "anon";

grant references on table "public"."tutor_conversations" to "anon";

grant select on table "public"."tutor_conversations" to "anon";

grant trigger on table "public"."tutor_conversations" to "anon";

grant truncate on table "public"."tutor_conversations" to "anon";

grant update on table "public"."tutor_conversations" to "anon";

grant delete on table "public"."tutor_conversations" to "authenticated";

grant insert on table "public"."tutor_conversations" to "authenticated";

grant references on table "public"."tutor_conversations" to "authenticated";

grant select on table "public"."tutor_conversations" to "authenticated";

grant trigger on table "public"."tutor_conversations" to "authenticated";

grant truncate on table "public"."tutor_conversations" to "authenticated";

grant update on table "public"."tutor_conversations" to "authenticated";

grant delete on table "public"."tutor_conversations" to "service_role";

grant insert on table "public"."tutor_conversations" to "service_role";

grant references on table "public"."tutor_conversations" to "service_role";

grant select on table "public"."tutor_conversations" to "service_role";

grant trigger on table "public"."tutor_conversations" to "service_role";

grant truncate on table "public"."tutor_conversations" to "service_role";

grant update on table "public"."tutor_conversations" to "service_role";

grant delete on table "public"."tutor_feedback" to "anon";

grant insert on table "public"."tutor_feedback" to "anon";

grant references on table "public"."tutor_feedback" to "anon";

grant select on table "public"."tutor_feedback" to "anon";

grant trigger on table "public"."tutor_feedback" to "anon";

grant truncate on table "public"."tutor_feedback" to "anon";

grant update on table "public"."tutor_feedback" to "anon";

grant delete on table "public"."tutor_feedback" to "authenticated";

grant insert on table "public"."tutor_feedback" to "authenticated";

grant references on table "public"."tutor_feedback" to "authenticated";

grant select on table "public"."tutor_feedback" to "authenticated";

grant trigger on table "public"."tutor_feedback" to "authenticated";

grant truncate on table "public"."tutor_feedback" to "authenticated";

grant update on table "public"."tutor_feedback" to "authenticated";

grant delete on table "public"."tutor_feedback" to "service_role";

grant insert on table "public"."tutor_feedback" to "service_role";

grant references on table "public"."tutor_feedback" to "service_role";

grant select on table "public"."tutor_feedback" to "service_role";

grant trigger on table "public"."tutor_feedback" to "service_role";

grant truncate on table "public"."tutor_feedback" to "service_role";

grant update on table "public"."tutor_feedback" to "service_role";

grant delete on table "public"."university_colleges" to "anon";

grant insert on table "public"."university_colleges" to "anon";

grant references on table "public"."university_colleges" to "anon";

grant select on table "public"."university_colleges" to "anon";

grant trigger on table "public"."university_colleges" to "anon";

grant truncate on table "public"."university_colleges" to "anon";

grant update on table "public"."university_colleges" to "anon";

grant delete on table "public"."university_colleges" to "authenticated";

grant insert on table "public"."university_colleges" to "authenticated";

grant references on table "public"."university_colleges" to "authenticated";

grant select on table "public"."university_colleges" to "authenticated";

grant trigger on table "public"."university_colleges" to "authenticated";

grant truncate on table "public"."university_colleges" to "authenticated";

grant update on table "public"."university_colleges" to "authenticated";

grant delete on table "public"."university_colleges" to "service_role";

grant insert on table "public"."university_colleges" to "service_role";

grant references on table "public"."university_colleges" to "service_role";

grant select on table "public"."university_colleges" to "service_role";

grant trigger on table "public"."university_colleges" to "service_role";

grant truncate on table "public"."university_colleges" to "service_role";

grant update on table "public"."university_colleges" to "service_role";

grant delete on table "public"."university_courses" to "anon";

grant insert on table "public"."university_courses" to "anon";

grant references on table "public"."university_courses" to "anon";

grant select on table "public"."university_courses" to "anon";

grant trigger on table "public"."university_courses" to "anon";

grant truncate on table "public"."university_courses" to "anon";

grant update on table "public"."university_courses" to "anon";

grant delete on table "public"."university_courses" to "authenticated";

grant insert on table "public"."university_courses" to "authenticated";

grant references on table "public"."university_courses" to "authenticated";

grant select on table "public"."university_courses" to "authenticated";

grant trigger on table "public"."university_courses" to "authenticated";

grant truncate on table "public"."university_courses" to "authenticated";

grant update on table "public"."university_courses" to "authenticated";

grant delete on table "public"."university_courses" to "service_role";

grant insert on table "public"."university_courses" to "service_role";

grant references on table "public"."university_courses" to "service_role";

grant select on table "public"."university_courses" to "service_role";

grant trigger on table "public"."university_courses" to "service_role";

grant truncate on table "public"."university_courses" to "service_role";

grant update on table "public"."university_courses" to "service_role";

grant delete on table "public"."university_performance" to "anon";

grant insert on table "public"."university_performance" to "anon";

grant references on table "public"."university_performance" to "anon";

grant select on table "public"."university_performance" to "anon";

grant trigger on table "public"."university_performance" to "anon";

grant truncate on table "public"."university_performance" to "anon";

grant update on table "public"."university_performance" to "anon";

grant delete on table "public"."university_performance" to "authenticated";

grant insert on table "public"."university_performance" to "authenticated";

grant references on table "public"."university_performance" to "authenticated";

grant select on table "public"."university_performance" to "authenticated";

grant trigger on table "public"."university_performance" to "authenticated";

grant truncate on table "public"."university_performance" to "authenticated";

grant update on table "public"."university_performance" to "authenticated";

grant delete on table "public"."university_performance" to "service_role";

grant insert on table "public"."university_performance" to "service_role";

grant references on table "public"."university_performance" to "service_role";

grant select on table "public"."university_performance" to "service_role";

grant trigger on table "public"."university_performance" to "service_role";

grant truncate on table "public"."university_performance" to "service_role";

grant update on table "public"."university_performance" to "service_role";

grant delete on table "public"."user_categories" to "anon";

grant insert on table "public"."user_categories" to "anon";

grant references on table "public"."user_categories" to "anon";

grant select on table "public"."user_categories" to "anon";

grant trigger on table "public"."user_categories" to "anon";

grant truncate on table "public"."user_categories" to "anon";

grant update on table "public"."user_categories" to "anon";

grant delete on table "public"."user_categories" to "authenticated";

grant insert on table "public"."user_categories" to "authenticated";

grant references on table "public"."user_categories" to "authenticated";

grant select on table "public"."user_categories" to "authenticated";

grant trigger on table "public"."user_categories" to "authenticated";

grant truncate on table "public"."user_categories" to "authenticated";

grant update on table "public"."user_categories" to "authenticated";

grant delete on table "public"."user_categories" to "service_role";

grant insert on table "public"."user_categories" to "service_role";

grant references on table "public"."user_categories" to "service_role";

grant select on table "public"."user_categories" to "service_role";

grant trigger on table "public"."user_categories" to "service_role";

grant truncate on table "public"."user_categories" to "service_role";

grant update on table "public"."user_categories" to "service_role";

grant delete on table "public"."user_entitlements" to "anon";

grant insert on table "public"."user_entitlements" to "anon";

grant references on table "public"."user_entitlements" to "anon";

grant select on table "public"."user_entitlements" to "anon";

grant trigger on table "public"."user_entitlements" to "anon";

grant truncate on table "public"."user_entitlements" to "anon";

grant update on table "public"."user_entitlements" to "anon";

grant delete on table "public"."user_entitlements" to "authenticated";

grant insert on table "public"."user_entitlements" to "authenticated";

grant references on table "public"."user_entitlements" to "authenticated";

grant select on table "public"."user_entitlements" to "authenticated";

grant trigger on table "public"."user_entitlements" to "authenticated";

grant truncate on table "public"."user_entitlements" to "authenticated";

grant update on table "public"."user_entitlements" to "authenticated";

grant delete on table "public"."user_entitlements" to "service_role";

grant insert on table "public"."user_entitlements" to "service_role";

grant references on table "public"."user_entitlements" to "service_role";

grant select on table "public"."user_entitlements" to "service_role";

grant trigger on table "public"."user_entitlements" to "service_role";

grant truncate on table "public"."user_entitlements" to "service_role";

grant update on table "public"."user_entitlements" to "service_role";

grant delete on table "public"."user_login_history" to "anon";

grant insert on table "public"."user_login_history" to "anon";

grant references on table "public"."user_login_history" to "anon";

grant select on table "public"."user_login_history" to "anon";

grant trigger on table "public"."user_login_history" to "anon";

grant truncate on table "public"."user_login_history" to "anon";

grant update on table "public"."user_login_history" to "anon";

grant delete on table "public"."user_login_history" to "authenticated";

grant insert on table "public"."user_login_history" to "authenticated";

grant references on table "public"."user_login_history" to "authenticated";

grant select on table "public"."user_login_history" to "authenticated";

grant trigger on table "public"."user_login_history" to "authenticated";

grant truncate on table "public"."user_login_history" to "authenticated";

grant update on table "public"."user_login_history" to "authenticated";

grant delete on table "public"."user_login_history" to "service_role";

grant insert on table "public"."user_login_history" to "service_role";

grant references on table "public"."user_login_history" to "service_role";

grant select on table "public"."user_login_history" to "service_role";

grant trigger on table "public"."user_login_history" to "service_role";

grant truncate on table "public"."user_login_history" to "service_role";

grant update on table "public"."user_login_history" to "service_role";

grant delete on table "public"."user_profiles" to "anon";

grant insert on table "public"."user_profiles" to "anon";

grant references on table "public"."user_profiles" to "anon";

grant select on table "public"."user_profiles" to "anon";

grant trigger on table "public"."user_profiles" to "anon";

grant truncate on table "public"."user_profiles" to "anon";

grant update on table "public"."user_profiles" to "anon";

grant delete on table "public"."user_profiles" to "authenticated";

grant insert on table "public"."user_profiles" to "authenticated";

grant references on table "public"."user_profiles" to "authenticated";

grant select on table "public"."user_profiles" to "authenticated";

grant trigger on table "public"."user_profiles" to "authenticated";

grant truncate on table "public"."user_profiles" to "authenticated";

grant update on table "public"."user_profiles" to "authenticated";

grant delete on table "public"."user_profiles" to "service_role";

grant insert on table "public"."user_profiles" to "service_role";

grant references on table "public"."user_profiles" to "service_role";

grant select on table "public"."user_profiles" to "service_role";

grant trigger on table "public"."user_profiles" to "service_role";

grant truncate on table "public"."user_profiles" to "service_role";

grant update on table "public"."user_profiles" to "service_role";

grant delete on table "public"."user_sessions" to "anon";

grant insert on table "public"."user_sessions" to "anon";

grant references on table "public"."user_sessions" to "anon";

grant select on table "public"."user_sessions" to "anon";

grant trigger on table "public"."user_sessions" to "anon";

grant truncate on table "public"."user_sessions" to "anon";

grant update on table "public"."user_sessions" to "anon";

grant delete on table "public"."user_sessions" to "authenticated";

grant insert on table "public"."user_sessions" to "authenticated";

grant references on table "public"."user_sessions" to "authenticated";

grant select on table "public"."user_sessions" to "authenticated";

grant trigger on table "public"."user_sessions" to "authenticated";

grant truncate on table "public"."user_sessions" to "authenticated";

grant update on table "public"."user_sessions" to "authenticated";

grant delete on table "public"."user_sessions" to "service_role";

grant insert on table "public"."user_sessions" to "service_role";

grant references on table "public"."user_sessions" to "service_role";

grant select on table "public"."user_sessions" to "service_role";

grant trigger on table "public"."user_sessions" to "service_role";

grant truncate on table "public"."user_sessions" to "service_role";

grant update on table "public"."user_sessions" to "service_role";

grant delete on table "public"."user_settings" to "anon";

grant insert on table "public"."user_settings" to "anon";

grant references on table "public"."user_settings" to "anon";

grant select on table "public"."user_settings" to "anon";

grant trigger on table "public"."user_settings" to "anon";

grant truncate on table "public"."user_settings" to "anon";

grant update on table "public"."user_settings" to "anon";

grant delete on table "public"."user_settings" to "authenticated";

grant insert on table "public"."user_settings" to "authenticated";

grant references on table "public"."user_settings" to "authenticated";

grant select on table "public"."user_settings" to "authenticated";

grant trigger on table "public"."user_settings" to "authenticated";

grant truncate on table "public"."user_settings" to "authenticated";

grant update on table "public"."user_settings" to "authenticated";

grant delete on table "public"."user_settings" to "service_role";

grant insert on table "public"."user_settings" to "service_role";

grant references on table "public"."user_settings" to "service_role";

grant select on table "public"."user_settings" to "service_role";

grant trigger on table "public"."user_settings" to "service_role";

grant truncate on table "public"."user_settings" to "service_role";

grant update on table "public"."user_settings" to "service_role";

grant delete on table "public"."user_state_history" to "anon";

grant insert on table "public"."user_state_history" to "anon";

grant references on table "public"."user_state_history" to "anon";

grant select on table "public"."user_state_history" to "anon";

grant trigger on table "public"."user_state_history" to "anon";

grant truncate on table "public"."user_state_history" to "anon";

grant update on table "public"."user_state_history" to "anon";

grant delete on table "public"."user_state_history" to "authenticated";

grant insert on table "public"."user_state_history" to "authenticated";

grant references on table "public"."user_state_history" to "authenticated";

grant select on table "public"."user_state_history" to "authenticated";

grant trigger on table "public"."user_state_history" to "authenticated";

grant truncate on table "public"."user_state_history" to "authenticated";

grant update on table "public"."user_state_history" to "authenticated";

grant delete on table "public"."user_state_history" to "service_role";

grant insert on table "public"."user_state_history" to "service_role";

grant references on table "public"."user_state_history" to "service_role";

grant select on table "public"."user_state_history" to "service_role";

grant trigger on table "public"."user_state_history" to "service_role";

grant truncate on table "public"."user_state_history" to "service_role";

grant update on table "public"."user_state_history" to "service_role";

grant delete on table "public"."users" to "anon";

grant insert on table "public"."users" to "anon";

grant references on table "public"."users" to "anon";

grant select on table "public"."users" to "anon";

grant trigger on table "public"."users" to "anon";

grant truncate on table "public"."users" to "anon";

grant update on table "public"."users" to "anon";

grant delete on table "public"."users" to "authenticated";

grant insert on table "public"."users" to "authenticated";

grant references on table "public"."users" to "authenticated";

grant select on table "public"."users" to "authenticated";

grant trigger on table "public"."users" to "authenticated";

grant truncate on table "public"."users" to "authenticated";

grant update on table "public"."users" to "authenticated";

grant delete on table "public"."users" to "service_role";

grant insert on table "public"."users" to "service_role";

grant references on table "public"."users" to "service_role";

grant select on table "public"."users" to "service_role";

grant trigger on table "public"."users" to "service_role";

grant truncate on table "public"."users" to "service_role";

grant update on table "public"."users" to "service_role";

grant insert on table "public"."users" to "supabase_auth_admin";

grant select on table "public"."users" to "supabase_auth_admin";

grant delete on table "public"."verifications" to "anon";

grant insert on table "public"."verifications" to "anon";

grant references on table "public"."verifications" to "anon";

grant select on table "public"."verifications" to "anon";

grant trigger on table "public"."verifications" to "anon";

grant truncate on table "public"."verifications" to "anon";

grant update on table "public"."verifications" to "anon";

grant delete on table "public"."verifications" to "authenticated";

grant insert on table "public"."verifications" to "authenticated";

grant references on table "public"."verifications" to "authenticated";

grant select on table "public"."verifications" to "authenticated";

grant trigger on table "public"."verifications" to "authenticated";

grant truncate on table "public"."verifications" to "authenticated";

grant update on table "public"."verifications" to "authenticated";

grant delete on table "public"."verifications" to "service_role";

grant insert on table "public"."verifications" to "service_role";

grant references on table "public"."verifications" to "service_role";

grant select on table "public"."verifications" to "service_role";

grant trigger on table "public"."verifications" to "service_role";

grant truncate on table "public"."verifications" to "service_role";

grant update on table "public"."verifications" to "service_role";

grant delete on table "public"."video_summaries" to "anon";

grant insert on table "public"."video_summaries" to "anon";

grant references on table "public"."video_summaries" to "anon";

grant select on table "public"."video_summaries" to "anon";

grant trigger on table "public"."video_summaries" to "anon";

grant truncate on table "public"."video_summaries" to "anon";

grant update on table "public"."video_summaries" to "anon";

grant delete on table "public"."video_summaries" to "authenticated";

grant insert on table "public"."video_summaries" to "authenticated";

grant references on table "public"."video_summaries" to "authenticated";

grant select on table "public"."video_summaries" to "authenticated";

grant trigger on table "public"."video_summaries" to "authenticated";

grant truncate on table "public"."video_summaries" to "authenticated";

grant update on table "public"."video_summaries" to "authenticated";

grant delete on table "public"."video_summaries" to "service_role";

grant insert on table "public"."video_summaries" to "service_role";

grant references on table "public"."video_summaries" to "service_role";

grant select on table "public"."video_summaries" to "service_role";

grant trigger on table "public"."video_summaries" to "service_role";

grant truncate on table "public"."video_summaries" to "service_role";

grant update on table "public"."video_summaries" to "service_role";


  create policy "Authenticated users can insert questions"
  on "public"."adaptive_aptitude_questions_cache"
  as permissive
  for insert
  to public
with check ((auth.role() = 'authenticated'::text));



  create policy "Authenticated users can read questions"
  on "public"."adaptive_aptitude_questions_cache"
  as permissive
  for select
  to public
using (((auth.role() = 'authenticated'::text) AND (is_active = true)));



  create policy "Authenticated users can update questions"
  on "public"."adaptive_aptitude_questions_cache"
  as permissive
  for update
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "Service role can manage questions"
  on "public"."adaptive_aptitude_questions_cache"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text));



  create policy "Students can create responses for own sessions"
  on "public"."adaptive_aptitude_responses"
  as permissive
  for insert
  to public
with check ((session_id IN ( SELECT adaptive_aptitude_sessions.id
   FROM public.adaptive_aptitude_sessions
  WHERE (adaptive_aptitude_sessions.student_id IN ( SELECT students.id
           FROM public.students
          WHERE (students.user_id = auth.uid()))))));



  create policy "Students can view own responses"
  on "public"."adaptive_aptitude_responses"
  as permissive
  for select
  to public
using ((session_id IN ( SELECT adaptive_aptitude_sessions.id
   FROM public.adaptive_aptitude_sessions
  WHERE (adaptive_aptitude_sessions.student_id IN ( SELECT students.id
           FROM public.students
          WHERE (students.user_id = auth.uid()))))));



  create policy "Students can create own results"
  on "public"."adaptive_aptitude_results"
  as permissive
  for insert
  to public
with check ((student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.user_id = auth.uid()))));



  create policy "Students can view own results"
  on "public"."adaptive_aptitude_results"
  as permissive
  for select
  to public
using ((student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.user_id = auth.uid()))));



  create policy "Students can create own sessions"
  on "public"."adaptive_aptitude_sessions"
  as permissive
  for insert
  to public
with check ((student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.user_id = auth.uid()))));



  create policy "Students can update own sessions"
  on "public"."adaptive_aptitude_sessions"
  as permissive
  for update
  to public
using ((student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.user_id = auth.uid()))));



  create policy "Students can view own sessions"
  on "public"."adaptive_aptitude_sessions"
  as permissive
  for select
  to public
using ((student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.user_id = auth.uid()))));



  create policy "Discount codes readable by authenticated"
  on "public"."addon_discount_codes"
  as permissive
  for select
  to public
using (((auth.role() = 'authenticated'::text) AND (is_active = true) AND (valid_from <= now()) AND (valid_until >= now())));



  create policy "Service role can read all events"
  on "public"."addon_events"
  as permissive
  for select
  to public
using ((auth.role() = 'service_role'::text));



  create policy "Users can insert own events"
  on "public"."addon_events"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Service role can manage addon orders"
  on "public"."addon_pending_orders"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text));



  create policy "Users can view own addon orders"
  on "public"."addon_pending_orders"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "admin_delete"
  on "public"."admin_users"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admin_users au
  WHERE ((au.id = ( SELECT auth.uid() AS uid)) AND (au.admin_role = 'super_admin'::text)))));



  create policy "admin_insert"
  on "public"."admin_users"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.admin_users au
  WHERE ((au.id = ( SELECT auth.uid() AS uid)) AND (au.admin_role = 'super_admin'::text)))));



  create policy "admin_read"
  on "public"."admin_users"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admin_users au
  WHERE ((au.id = ( SELECT auth.uid() AS uid)) AND (au.admin_role = 'super_admin'::text)))));



  create policy "admin_update"
  on "public"."admin_users"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admin_users au
  WHERE ((au.id = ( SELECT auth.uid() AS uid)) AND (au.admin_role = 'super_admin'::text)))))
with check ((EXISTS ( SELECT 1
   FROM public.admin_users au
  WHERE ((au.id = ( SELECT auth.uid() AS uid)) AND (au.admin_role = 'super_admin'::text)))));



  create policy "School admins can insert applications"
  on "public"."admission_applications"
  as permissive
  for insert
  to public
with check ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "School admins can update their school's applications"
  on "public"."admission_applications"
  as permissive
  for update
  to public
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "School admins can view their school's applications"
  on "public"."admission_applications"
  as permissive
  for select
  to public
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "Students can add evaluations"
  on "public"."ai_evaluations"
  as permissive
  for insert
  to public
with check (((auth.uid() = student_id) AND (EXISTS ( SELECT 1
   FROM public.career_ai_conversations
  WHERE ((career_ai_conversations.id = ai_evaluations.conversation_id) AND (career_ai_conversations.student_id = auth.uid()))))));



  create policy "Students can update own evaluations"
  on "public"."ai_evaluations"
  as permissive
  for update
  to public
using ((auth.uid() = student_id));



  create policy "Students view own evaluations"
  on "public"."ai_evaluations"
  as permissive
  for select
  to public
using ((auth.uid() = student_id));



  create policy "Recruiters can update application status"
  on "public"."applied_jobs"
  as permissive
  for update
  to public
using ((opportunity_id_old IN ( SELECT opportunities.id_old AS id
   FROM public.opportunities
  WHERE (opportunities.created_by = (auth.uid())::text))));



  create policy "Recruiters can view applications for their opportunities"
  on "public"."applied_jobs"
  as permissive
  for select
  to public
using ((opportunity_id_old IN ( SELECT opportunities.id_old AS id
   FROM public.opportunities
  WHERE (opportunities.created_by = (auth.uid())::text))));



  create policy "Students can create own applications"
  on "public"."applied_jobs"
  as permissive
  for insert
  to public
with check (((student_id = auth.uid()) OR (student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.id = auth.uid())))));



  create policy "Students can delete own applications"
  on "public"."applied_jobs"
  as permissive
  for delete
  to public
using (((student_id = auth.uid()) OR (student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.id = auth.uid())))));



  create policy "Students can update own applications"
  on "public"."applied_jobs"
  as permissive
  for update
  to public
using (((student_id = auth.uid()) OR (student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.id = auth.uid())))));



  create policy "Students can view own applications"
  on "public"."applied_jobs"
  as permissive
  for select
  to public
using (((student_id = auth.uid()) OR (student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.id = auth.uid())))));



  create policy "Anyone can view assessment types"
  on "public"."assessment_types"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Enable delete for authenticated users only"
  on "public"."assignment_attachments"
  as permissive
  for delete
  to authenticated
using (true);



  create policy "Enable insert for authenticated users only"
  on "public"."assignment_attachments"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Enable read access for all users"
  on "public"."assignment_attachments"
  as permissive
  for select
  to public
using (true);



  create policy "Enable update for authenticated users only"
  on "public"."assignment_attachments"
  as permissive
  for update
  to authenticated
using (true)
with check (true);



  create policy "Enable insert for authenticated users only"
  on "public"."assignments"
  as permissive
  for insert
  to public
with check (true);



  create policy "Enable read access for all users"
  on "public"."assignments"
  as permissive
  for select
  to public
using (true);



  create policy "School staff can manage alerts"
  on "public"."attendance_alerts"
  as permissive
  for all
  to public
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "School staff can view alerts"
  on "public"."attendance_alerts"
  as permissive
  for select
  to public
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "School staff can manage attendance"
  on "public"."attendance_records"
  as permissive
  for all
  to public
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "School staff can view attendance"
  on "public"."attendance_records"
  as permissive
  for select
  to public
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "Allow public insert"
  on "public"."audit_logs"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow public read"
  on "public"."audit_logs"
  as permissive
  for select
  to public
using (true);



  create policy "Bundle features are publicly readable"
  on "public"."bundle_features"
  as permissive
  for select
  to public
using (true);



  create policy "Bundles are publicly readable"
  on "public"."bundles"
  as permissive
  for select
  to public
using ((is_active = true));



  create policy "Users can delete own career conversations"
  on "public"."career_ai_conversations"
  as permissive
  for delete
  to public
using ((auth.uid() = student_id));



  create policy "Users can insert own career conversations"
  on "public"."career_ai_conversations"
  as permissive
  for insert
  to public
with check ((auth.uid() = student_id));



  create policy "Users can update own career conversations"
  on "public"."career_ai_conversations"
  as permissive
  for update
  to public
using ((auth.uid() = student_id));



  create policy "Users can view own career conversations"
  on "public"."career_ai_conversations"
  as permissive
  for select
  to public
using ((auth.uid() = student_id));



  create policy "Enable delete for users based on user_id"
  on "public"."certificates"
  as permissive
  for delete
  to public
using (true);



  create policy "Enable insert for authenticated users only"
  on "public"."certificates"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Enable read access for all users"
  on "public"."certificates"
  as permissive
  for select
  to public
using (true);



  create policy "Policy with table joins"
  on "public"."certificates"
  as permissive
  for update
  to public
using (true);



  create policy "Admins can view all swap history"
  on "public"."class_swap_history"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['super_admin'::public.user_role, 'rm_admin'::public.user_role, 'school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role]))))));



  create policy "Allow system to insert history entries"
  on "public"."class_swap_history"
  as permissive
  for insert
  to public
with check (true);



  create policy "Faculty can view own swap history"
  on "public"."class_swap_history"
  as permissive
  for select
  to public
using ((swap_request_id IN ( SELECT class_swap_requests.id
   FROM public.class_swap_requests
  WHERE ((class_swap_requests.requester_faculty_id IN ( SELECT school_educators.id
           FROM public.school_educators
          WHERE (school_educators.user_id = auth.uid())
        UNION
         SELECT college_lecturers.id
           FROM public.college_lecturers
          WHERE (college_lecturers.user_id = auth.uid()))) OR (class_swap_requests.target_faculty_id IN ( SELECT school_educators.id
           FROM public.school_educators
          WHERE (school_educators.user_id = auth.uid())
        UNION
         SELECT college_lecturers.id
           FROM public.college_lecturers
          WHERE (college_lecturers.user_id = auth.uid())))))));



  create policy "Admins can manage all swap requests"
  on "public"."class_swap_requests"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['super_admin'::public.user_role, 'rm_admin'::public.user_role, 'school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role]))))));



  create policy "Faculty can create swap requests"
  on "public"."class_swap_requests"
  as permissive
  for insert
  to public
with check ((requester_faculty_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid())
UNION
 SELECT college_lecturers.id
   FROM public.college_lecturers
  WHERE (college_lecturers.user_id = auth.uid()))));



  create policy "Faculty can update swap requests"
  on "public"."class_swap_requests"
  as permissive
  for update
  to public
using (((requester_faculty_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid())
UNION
 SELECT college_lecturers.id
   FROM public.college_lecturers
  WHERE (college_lecturers.user_id = auth.uid()))) OR (target_faculty_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid())
UNION
 SELECT college_lecturers.id
   FROM public.college_lecturers
  WHERE (college_lecturers.user_id = auth.uid())))));



  create policy "Faculty can view own swap requests"
  on "public"."class_swap_requests"
  as permissive
  for select
  to public
using (((requester_faculty_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid())
UNION
 SELECT college_lecturers.id
   FROM public.college_lecturers
  WHERE (college_lecturers.user_id = auth.uid()))) OR (target_faculty_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid())
UNION
 SELECT college_lecturers.id
   FROM public.college_lecturers
  WHERE (college_lecturers.user_id = auth.uid())))));



  create policy "college_admins_all_assignments"
  on "public"."college_assignments"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.organizations o
  WHERE ((o.id = college_assignments.college_id) AND ((o.organization_type)::text = 'college'::text) AND (o.admin_id = auth.uid())))));



  create policy "college_lecturers_own_assignments"
  on "public"."college_assignments"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.college_lecturers cl
  WHERE ((cl.user_id = auth.uid()) AND (cl.user_id = college_assignments.college_educator_id)))));



  create policy "students_assigned_assignments"
  on "public"."college_assignments"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.college_student_assignments csa
  WHERE ((csa.assignment_id = college_assignments.assignment_id) AND (csa.student_id = auth.uid()) AND (csa.is_deleted = false)))));



  create policy "Allow delete for authenticated users on college_breaks"
  on "public"."college_breaks"
  as permissive
  for delete
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "Allow insert for authenticated users on college_breaks"
  on "public"."college_breaks"
  as permissive
  for insert
  to public
with check ((auth.role() = 'authenticated'::text));



  create policy "Allow read access to college_breaks"
  on "public"."college_breaks"
  as permissive
  for select
  to public
using (true);



  create policy "Allow update for authenticated users on college_breaks"
  on "public"."college_breaks"
  as permissive
  for update
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "College admins can delete their college circulars"
  on "public"."college_circulars"
  as permissive
  for delete
  to public
using (true);



  create policy "College admins can insert circulars for their college"
  on "public"."college_circulars"
  as permissive
  for insert
  to public
with check (true);



  create policy "College admins can update their college circulars"
  on "public"."college_circulars"
  as permissive
  for update
  to public
using (true);



  create policy "College admins can view their college circulars"
  on "public"."college_circulars"
  as permissive
  for select
  to public
using (true);



  create policy "Allow delete for authenticated users"
  on "public"."college_classes"
  as permissive
  for delete
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "Allow insert for authenticated users"
  on "public"."college_classes"
  as permissive
  for insert
  to public
with check ((auth.role() = 'authenticated'::text));



  create policy "Allow read access to college_classes"
  on "public"."college_classes"
  as permissive
  for select
  to public
using (true);



  create policy "Allow update for authenticated users"
  on "public"."college_classes"
  as permissive
  for update
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "College admins can update their curriculum"
  on "public"."college_curriculums"
  as permissive
  for update
  to public
using ((college_id IN ( SELECT users."organizationId"
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = 'college_admin'::public.user_role)))));



  create policy "College admins can view their curriculum"
  on "public"."college_curriculums"
  as permissive
  for select
  to public
using ((college_id IN ( SELECT users."organizationId"
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = 'college_admin'::public.user_role)))));



  create policy "University admins can update curriculum for approval"
  on "public"."college_curriculums"
  as permissive
  for update
  to public
using (((university_id IN ( SELECT users."organizationId"
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = 'university_admin'::public.user_role)))) AND ((status)::text = ANY ((ARRAY['pending_approval'::character varying, 'rejected'::character varying])::text[]))));



  create policy "University admins can view affiliated college curriculum"
  on "public"."college_curriculums"
  as permissive
  for select
  to public
using ((university_id IN ( SELECT users."organizationId"
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = 'university_admin'::public.user_role)))));



  create policy "Allow all operations on college_event_registrations"
  on "public"."college_event_registrations"
  as permissive
  for all
  to public
using (true)
with check (true);



  create policy "College admins can delete their college events"
  on "public"."college_events"
  as permissive
  for delete
  to public
using (true);



  create policy "College admins can insert events for their college"
  on "public"."college_events"
  as permissive
  for insert
  to public
with check (true);



  create policy "College admins can update their college events"
  on "public"."college_events"
  as permissive
  for update
  to public
using (true);



  create policy "College admins can view their college events"
  on "public"."college_events"
  as permissive
  for select
  to public
using (true);



  create policy "Allow delete for authenticated on faculty_class_assignments"
  on "public"."college_faculty_class_assignments"
  as permissive
  for delete
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "Allow insert for authenticated on faculty_class_assignments"
  on "public"."college_faculty_class_assignments"
  as permissive
  for insert
  to public
with check ((auth.role() = 'authenticated'::text));



  create policy "Allow read access to faculty_class_assignments"
  on "public"."college_faculty_class_assignments"
  as permissive
  for select
  to public
using (true);



  create policy "Allow update for authenticated on faculty_class_assignments"
  on "public"."college_faculty_class_assignments"
  as permissive
  for update
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "Allow all for college_faculty_leave_balances"
  on "public"."college_faculty_leave_balances"
  as permissive
  for all
  to public
using (true);



  create policy "Allow all for college_faculty_leaves"
  on "public"."college_faculty_leaves"
  as permissive
  for all
  to public
using (true);



  create policy "Allow all for college_faculty_substitutions"
  on "public"."college_faculty_substitutions"
  as permissive
  for all
  to public
using (true);



  create policy "Allow all for college_leave_types"
  on "public"."college_leave_types"
  as permissive
  for all
  to public
using (true);



  create policy "College users can create lesson plans"
  on "public"."college_lesson_plans"
  as permissive
  for insert
  to public
with check (((college_id IN ( SELECT college_lecturers."collegeId"
   FROM public.college_lecturers
  WHERE (college_lecturers.user_id = auth.uid())
UNION
 SELECT departments.college_id
   FROM public.departments
  WHERE (departments.created_by = auth.uid()))) AND (created_by = auth.uid())));



  create policy "College users can delete their lesson plans"
  on "public"."college_lesson_plans"
  as permissive
  for delete
  to public
using (((created_by = auth.uid()) AND (college_id IN ( SELECT college_lecturers."collegeId"
   FROM public.college_lecturers
  WHERE (college_lecturers.user_id = auth.uid())
UNION
 SELECT departments.college_id
   FROM public.departments
  WHERE (departments.created_by = auth.uid())))));



  create policy "College users can update their lesson plans"
  on "public"."college_lesson_plans"
  as permissive
  for update
  to public
using (((created_by = auth.uid()) AND (college_id IN ( SELECT college_lecturers."collegeId"
   FROM public.college_lecturers
  WHERE (college_lecturers.user_id = auth.uid())
UNION
 SELECT departments.college_id
   FROM public.departments
  WHERE (departments.created_by = auth.uid())))));



  create policy "College users can view lesson plans in their college"
  on "public"."college_lesson_plans"
  as permissive
  for select
  to public
using ((college_id IN ( SELECT college_lecturers."collegeId"
   FROM public.college_lecturers
  WHERE (college_lecturers.user_id = auth.uid())
UNION
 SELECT departments.college_id
   FROM public.departments
  WHERE (departments.created_by = auth.uid()))));



  create policy "Development access for lesson plans"
  on "public"."college_lesson_plans"
  as permissive
  for all
  to public
using ((auth.uid() IS NOT NULL))
with check ((auth.uid() IS NOT NULL));



  create policy "educators_created_assignments"
  on "public"."college_student_assignments"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.college_assignments ca
  WHERE ((ca.assignment_id = college_student_assignments.assignment_id) AND (ca.college_educator_id = auth.uid())))));



  create policy "students_own_assignments"
  on "public"."college_student_assignments"
  as permissive
  for all
  to public
using ((auth.uid() = student_id));



  create policy "Allow delete for authenticated users on college_time_periods"
  on "public"."college_time_periods"
  as permissive
  for delete
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "Allow insert for authenticated users on college_time_periods"
  on "public"."college_time_periods"
  as permissive
  for insert
  to public
with check ((auth.role() = 'authenticated'::text));



  create policy "Allow read access to college_time_periods"
  on "public"."college_time_periods"
  as permissive
  for select
  to public
using (true);



  create policy "Allow update for authenticated users on college_time_periods"
  on "public"."college_time_periods"
  as permissive
  for update
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "Allow delete for authenticated users"
  on "public"."college_timetable_slots"
  as permissive
  for delete
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "Allow insert for authenticated users"
  on "public"."college_timetable_slots"
  as permissive
  for insert
  to public
with check ((auth.role() = 'authenticated'::text));



  create policy "Allow read access to college_timetable_slots"
  on "public"."college_timetable_slots"
  as permissive
  for select
  to public
using (true);



  create policy "Allow update for authenticated users"
  on "public"."college_timetable_slots"
  as permissive
  for update
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "Allow delete for authenticated users"
  on "public"."college_timetables"
  as permissive
  for delete
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "Allow insert for authenticated users"
  on "public"."college_timetables"
  as permissive
  for insert
  to public
with check ((auth.role() = 'authenticated'::text));



  create policy "Allow read access to college_timetables"
  on "public"."college_timetables"
  as permissive
  for select
  to public
using (true);



  create policy "Allow update for authenticated users"
  on "public"."college_timetables"
  as permissive
  for update
  to public
using ((auth.role() = 'authenticated'::text));



  create policy "Educators can create admin conversations"
  on "public"."conversations"
  as permissive
  for insert
  to public
with check (((educator_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))) AND ((conversation_type)::text = 'educator_admin'::text)));



  create policy "Educators can create student conversations"
  on "public"."conversations"
  as permissive
  for insert
  to public
with check (((educator_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))) AND ((conversation_type)::text = 'student_educator'::text)));



  create policy "Educators can update their admin conversations"
  on "public"."conversations"
  as permissive
  for update
  to public
using (((educator_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))) AND ((conversation_type)::text = 'educator_admin'::text)));



  create policy "Educators can update their student conversations"
  on "public"."conversations"
  as permissive
  for update
  to public
using (((educator_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))) AND ((conversation_type)::text = 'student_educator'::text)));



  create policy "Educators can view their admin conversations"
  on "public"."conversations"
  as permissive
  for select
  to public
using (((educator_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))) AND ((conversation_type)::text = 'educator_admin'::text) AND ((deleted_by_educator IS NULL) OR (deleted_by_educator = false))));



  create policy "Educators can view their student conversations"
  on "public"."conversations"
  as permissive
  for select
  to public
using (((educator_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))) AND ((conversation_type)::text = 'student_educator'::text) AND ((deleted_by_educator IS NULL) OR (deleted_by_educator = false))));



  create policy "Recruiters can create student conversations"
  on "public"."conversations"
  as permissive
  for insert
  to public
with check (((recruiter_id = auth.uid()) AND (student_id IS NOT NULL) AND ((conversation_type IS NULL) OR ((conversation_type)::text = 'student_recruiter'::text))));



  create policy "Recruiters can update their student conversations"
  on "public"."conversations"
  as permissive
  for update
  to public
using (((recruiter_id = auth.uid()) AND (student_id IS NOT NULL) AND ((conversation_type IS NULL) OR ((conversation_type)::text = 'student_recruiter'::text))));



  create policy "Recruiters can view their student conversations"
  on "public"."conversations"
  as permissive
  for select
  to public
using (((recruiter_id = auth.uid()) AND (student_id IS NOT NULL) AND ((conversation_type IS NULL) OR ((conversation_type)::text = 'student_recruiter'::text)) AND ((deleted_by_recruiter IS NULL) OR (deleted_by_recruiter = false))));



  create policy "School admins can create educator conversations"
  on "public"."conversations"
  as permissive
  for insert
  to public
with check (((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE ((school_educators.user_id = auth.uid()) AND ((school_educators.role)::text = 'school_admin'::text)))) AND ((conversation_type)::text = 'educator_admin'::text)));



  create policy "School admins can create student conversations"
  on "public"."conversations"
  as permissive
  for insert
  to public
with check (((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE ((school_educators.user_id = auth.uid()) AND ((school_educators.role)::text = 'school_admin'::text)))) AND ((conversation_type)::text = 'student_admin'::text)));



  create policy "School admins can update their educator conversations"
  on "public"."conversations"
  as permissive
  for update
  to public
using (((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE ((school_educators.user_id = auth.uid()) AND ((school_educators.role)::text = 'school_admin'::text)))) AND ((conversation_type)::text = 'educator_admin'::text)));



  create policy "School admins can update their student conversations"
  on "public"."conversations"
  as permissive
  for update
  to public
using (((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE ((school_educators.user_id = auth.uid()) AND ((school_educators.role)::text = 'school_admin'::text)))) AND ((conversation_type)::text = 'student_admin'::text)));



  create policy "School admins can view their educator conversations"
  on "public"."conversations"
  as permissive
  for select
  to public
using (((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE ((school_educators.user_id = auth.uid()) AND ((school_educators.role)::text = 'school_admin'::text)))) AND ((conversation_type)::text = 'educator_admin'::text) AND ((deleted_by_admin IS NULL) OR (deleted_by_admin = false))));



  create policy "School admins can view their student conversations"
  on "public"."conversations"
  as permissive
  for select
  to public
using (((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE ((school_educators.user_id = auth.uid()) AND ((school_educators.role)::text = 'school_admin'::text)))) AND ((conversation_type)::text = 'student_admin'::text) AND ((deleted_by_admin IS NULL) OR (deleted_by_admin = false))));



  create policy "Students can create admin conversations"
  on "public"."conversations"
  as permissive
  for insert
  to public
with check (((student_id = auth.uid()) AND ((conversation_type)::text = 'student_admin'::text)));



  create policy "Students can create college admin conversations"
  on "public"."conversations"
  as permissive
  for insert
  to public
with check (((student_id = auth.uid()) AND ((conversation_type)::text = 'student_college_admin'::text)));



  create policy "Students can create educator conversations"
  on "public"."conversations"
  as permissive
  for insert
  to public
with check (((student_id = auth.uid()) AND ((conversation_type)::text = 'student_educator'::text)));



  create policy "Students can create recruiter conversations"
  on "public"."conversations"
  as permissive
  for insert
  to public
with check (((student_id = auth.uid()) AND (recruiter_id IS NOT NULL) AND ((conversation_type IS NULL) OR ((conversation_type)::text = 'student_recruiter'::text))));



  create policy "Students can update their admin conversations"
  on "public"."conversations"
  as permissive
  for update
  to public
using (((student_id = auth.uid()) AND ((conversation_type)::text = 'student_admin'::text)));



  create policy "Students can update their college admin conversations"
  on "public"."conversations"
  as permissive
  for update
  to public
using (((student_id = auth.uid()) AND ((conversation_type)::text = 'student_college_admin'::text)));



  create policy "Students can update their educator conversations"
  on "public"."conversations"
  as permissive
  for update
  to public
using (((student_id = auth.uid()) AND ((conversation_type)::text = 'student_educator'::text)));



  create policy "Students can update their recruiter conversations"
  on "public"."conversations"
  as permissive
  for update
  to public
using (((student_id = auth.uid()) AND (recruiter_id IS NOT NULL) AND ((conversation_type IS NULL) OR ((conversation_type)::text = 'student_recruiter'::text))));



  create policy "Students can view their admin conversations"
  on "public"."conversations"
  as permissive
  for select
  to public
using (((student_id = auth.uid()) AND ((conversation_type)::text = 'student_admin'::text) AND ((deleted_by_student IS NULL) OR (deleted_by_student = false))));



  create policy "Students can view their college admin conversations"
  on "public"."conversations"
  as permissive
  for select
  to public
using (((student_id = auth.uid()) AND ((conversation_type)::text = 'student_college_admin'::text) AND ((deleted_by_student IS NULL) OR (deleted_by_student = false))));



  create policy "Students can view their educator conversations"
  on "public"."conversations"
  as permissive
  for select
  to public
using (((student_id = auth.uid()) AND ((conversation_type)::text = 'student_educator'::text) AND ((deleted_by_student IS NULL) OR (deleted_by_student = false))));



  create policy "Students can view their recruiter conversations"
  on "public"."conversations"
  as permissive
  for select
  to public
using (((student_id = auth.uid()) AND (recruiter_id IS NOT NULL) AND ((conversation_type IS NULL) OR ((conversation_type)::text = 'student_recruiter'::text)) AND ((deleted_by_student IS NULL) OR (deleted_by_student = false))));



  create policy "Educators can delete classes of their courses"
  on "public"."course_classes"
  as permissive
  for delete
  to public
using ((EXISTS ( SELECT 1
   FROM public.courses
  WHERE ((courses.course_id = course_classes.course_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can insert classes for their courses"
  on "public"."course_classes"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.courses
  WHERE ((courses.course_id = course_classes.course_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can update classes of their courses"
  on "public"."course_classes"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.courses
  WHERE ((courses.course_id = course_classes.course_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can view classes of their courses"
  on "public"."course_classes"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.courses
  WHERE ((courses.course_id = course_classes.course_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can manage co-educators of their courses"
  on "public"."course_co_educators"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.courses
  WHERE ((courses.course_id = course_co_educators.course_id) AND (courses.educator_id = auth.uid())))));



  create policy "Educators can view course enrollments"
  on "public"."course_enrollments"
  as permissive
  for select
  to public
using (((educator_id)::text = (auth.jwt() ->> 'sub'::text)));



  create policy "Students can create own enrollments"
  on "public"."course_enrollments"
  as permissive
  for insert
  to public
with check (((student_email = (auth.jwt() ->> 'email'::text)) OR ((student_id)::text = (auth.jwt() ->> 'sub'::text))));



  create policy "Students can update own enrollments"
  on "public"."course_enrollments"
  as permissive
  for update
  to public
using (((student_email = (auth.jwt() ->> 'email'::text)) OR ((student_id)::text = (auth.jwt() ->> 'sub'::text))));



  create policy "Students can view own enrollments"
  on "public"."course_enrollments"
  as permissive
  for select
  to public
using (((student_email = (auth.jwt() ->> 'email'::text)) OR ((student_id)::text = (auth.jwt() ->> 'sub'::text))));



  create policy "Authenticated users can read modules"
  on "public"."course_modules"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Educators can delete modules"
  on "public"."course_modules"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.courses
  WHERE ((courses.course_id = course_modules.course_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can insert modules"
  on "public"."course_modules"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.courses
  WHERE ((courses.course_id = course_modules.course_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can update modules"
  on "public"."course_modules"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.courses
  WHERE ((courses.course_id = course_modules.course_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can delete skills of their courses"
  on "public"."course_skills"
  as permissive
  for delete
  to public
using ((EXISTS ( SELECT 1
   FROM public.courses
  WHERE ((courses.course_id = course_skills.course_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can insert skills for their courses"
  on "public"."course_skills"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.courses
  WHERE ((courses.course_id = course_skills.course_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can update skills of their courses"
  on "public"."course_skills"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.courses
  WHERE ((courses.course_id = course_skills.course_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can view skills of their courses"
  on "public"."course_skills"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.courses
  WHERE ((courses.course_id = course_skills.course_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can delete their own courses"
  on "public"."courses"
  as permissive
  for delete
  to public
using ((educator_id = auth.uid()));



  create policy "Educators can insert their own courses"
  on "public"."courses"
  as permissive
  for insert
  to public
with check ((educator_id = auth.uid()));



  create policy "Educators can update their own courses"
  on "public"."courses"
  as permissive
  for update
  to public
using (((educator_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.course_co_educators
  WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid()))))));



  create policy "Educators can view their own courses"
  on "public"."courses"
  as permissive
  for select
  to public
using (((educator_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.course_co_educators
  WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid()))))));



  create policy "Educators can manage chapters in their draft/rejected curriculu"
  on "public"."curriculum_chapters"
  as permissive
  for all
  to authenticated
using ((curriculum_id IN ( SELECT curriculums.id
   FROM public.curriculums
  WHERE ((curriculums.created_by IN ( SELECT school_educators.id
           FROM public.school_educators
          WHERE (school_educators.user_id = auth.uid()))) AND ((curriculums.status)::text = ANY ((ARRAY['draft'::character varying, 'rejected'::character varying])::text[]))))));



  create policy "Educators can view chapters from their school curriculums"
  on "public"."curriculum_chapters"
  as permissive
  for select
  to authenticated
using ((curriculum_id IN ( SELECT curriculums.id
   FROM public.curriculums
  WHERE (curriculums.school_id IN ( SELECT school_educators.school_id
           FROM public.school_educators
          WHERE (school_educators.user_id = auth.uid()))))));



  create policy "Educators can manage outcomes in their draft/rejected curriculu"
  on "public"."curriculum_learning_outcomes"
  as permissive
  for all
  to authenticated
using ((chapter_id IN ( SELECT cc.id
   FROM (public.curriculum_chapters cc
     JOIN public.curriculums c ON ((cc.curriculum_id = c.id)))
  WHERE ((c.created_by IN ( SELECT school_educators.id
           FROM public.school_educators
          WHERE (school_educators.user_id = auth.uid()))) AND ((c.status)::text = ANY ((ARRAY['draft'::character varying, 'rejected'::character varying])::text[]))))));



  create policy "Educators can view outcomes from their school curriculums"
  on "public"."curriculum_learning_outcomes"
  as permissive
  for select
  to authenticated
using ((chapter_id IN ( SELECT cc.id
   FROM (public.curriculum_chapters cc
     JOIN public.curriculums c ON ((cc.curriculum_id = c.id)))
  WHERE (c.school_id IN ( SELECT school_educators.school_id
           FROM public.school_educators
          WHERE (school_educators.user_id = auth.uid()))))));



  create policy "Educators can create curriculums"
  on "public"."curriculums"
  as permissive
  for insert
  to authenticated
with check ((created_by IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "Educators can delete their own draft curriculums"
  on "public"."curriculums"
  as permissive
  for delete
  to authenticated
using (((created_by IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))) AND ((status)::text = 'draft'::text)));



  create policy "Educators can update their own draft/rejected curriculums"
  on "public"."curriculums"
  as permissive
  for update
  to authenticated
using (((created_by IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))) AND ((status)::text = ANY ((ARRAY['draft'::character varying, 'rejected'::character varying])::text[]))));



  create policy "Educators can view curriculums from their school"
  on "public"."curriculums"
  as permissive
  for select
  to authenticated
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "Admins can view all document access"
  on "public"."document_access_history"
  as permissive
  for select
  to public
using (((auth.jwt() ->> 'role'::text) = 'admin'::text));



  create policy "System can insert document access"
  on "public"."document_access_history"
  as permissive
  for insert
  to public
with check (true);



  create policy "Users can view own document access"
  on "public"."document_access_history"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Allow authenticated users to delete cache"
  on "public"."embedding_cache"
  as permissive
  for delete
  to authenticated
using (true);



  create policy "Allow authenticated users to insert cache"
  on "public"."embedding_cache"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Allow authenticated users to read cache"
  on "public"."embedding_cache"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Allow authenticated users to update cache"
  on "public"."embedding_cache"
  as permissive
  for update
  to authenticated
using (true);



  create policy "Enable insert for authenticated users only"
  on "public"."experience"
  as permissive
  for insert
  to public
with check (true);



  create policy "Enable read access for all users"
  on "public"."experience"
  as permissive
  for select
  to public
using (true);



  create policy "Policy with table joins"
  on "public"."experience"
  as permissive
  for update
  to public
using (true);



  create policy "Authenticated users can log export activities"
  on "public"."export_activities"
  as permissive
  for insert
  to public
with check (true);



  create policy "Authenticated users can view export activities"
  on "public"."export_activities"
  as permissive
  for select
  to public
using (true);



  create policy "Admins can view all external assessment attempts"
  on "public"."external_assessment_attempts"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM public.users
  WHERE ((users.id = auth.uid()) AND (users.role = ANY (ARRAY['school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role, 'super_admin'::public.user_role]))))));



  create policy "Educators can view student external assessment attempts"
  on "public"."external_assessment_attempts"
  as permissive
  for select
  to public
using ((student_id IN ( SELECT s.id
   FROM (public.students s
     JOIN public.school_educators se ON ((se.school_id = s.school_id)))
  WHERE (se.user_id = auth.uid()))));



  create policy "Students can insert own external assessment attempts"
  on "public"."external_assessment_attempts"
  as permissive
  for insert
  to public
with check ((student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.user_id = auth.uid()))));



  create policy "Students can update own external assessment attempts"
  on "public"."external_assessment_attempts"
  as permissive
  for update
  to public
using ((student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.user_id = auth.uid()))))
with check ((student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.user_id = auth.uid()))));



  create policy "Students can view own external assessment attempts"
  on "public"."external_assessment_attempts"
  as permissive
  for select
  to public
using ((student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.user_id = auth.uid()))));



  create policy "Allow public insert"
  on "public"."generated_external_assessment"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow public read"
  on "public"."generated_external_assessment"
  as permissive
  for select
  to public
using (true);



  create policy "Anyone can read generated assessments"
  on "public"."generated_external_assessment"
  as permissive
  for select
  to public
using (true);



  create policy "Authenticated users can insert generated assessments"
  on "public"."generated_external_assessment"
  as permissive
  for insert
  to public
with check ((auth.role() = 'authenticated'::text));



  create policy "Recruiters can view approved internships"
  on "public"."internships"
  as permissive
  for select
  to public
using (((enabled = true) AND (approval_status = 'approved'::text)));



  create policy "Students can delete own internships"
  on "public"."internships"
  as permissive
  for delete
  to public
using (((auth.uid() = student_id) OR (student_email = (auth.jwt() ->> 'email'::text))));



  create policy "Students can insert own internships"
  on "public"."internships"
  as permissive
  for insert
  to public
with check (((auth.uid() = student_id) OR (student_email = (auth.jwt() ->> 'email'::text))));



  create policy "Students can update own internships"
  on "public"."internships"
  as permissive
  for update
  to public
using (((auth.uid() = student_id) OR (student_email = (auth.jwt() ->> 'email'::text))))
with check (((auth.uid() = student_id) OR (student_email = (auth.jwt() ->> 'email'::text))));



  create policy "Students can view own internships"
  on "public"."internships"
  as permissive
  for select
  to public
using (((auth.uid() = student_id) OR (student_email = (auth.jwt() ->> 'email'::text))));



  create policy "Authenticated users can log reminders"
  on "public"."interview_reminders"
  as permissive
  for insert
  to public
with check (true);



  create policy "Authenticated users can view reminders"
  on "public"."interview_reminders"
  as permissive
  for select
  to public
using (true);



  create policy "Authenticated users can create interviews"
  on "public"."interviews"
  as permissive
  for insert
  to public
with check (true);



  create policy "Authenticated users can delete interviews"
  on "public"."interviews"
  as permissive
  for delete
  to public
using (true);



  create policy "Authenticated users can update interviews"
  on "public"."interviews"
  as permissive
  for update
  to public
using (true);



  create policy "Authenticated users can view interviews"
  on "public"."interviews"
  as permissive
  for select
  to public
using (true);



  create policy "Educators can create lesson plans"
  on "public"."lesson_plans"
  as permissive
  for insert
  to public
with check ((educator_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "Educators can update own draft lesson plans"
  on "public"."lesson_plans"
  as permissive
  for update
  to public
using (((educator_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))) AND ((status)::text = ANY ((ARRAY['draft'::character varying, 'revision_required'::character varying])::text[]))));



  create policy "Educators can view own lesson plans"
  on "public"."lesson_plans"
  as permissive
  for select
  to public
using ((educator_id IN ( SELECT school_educators.id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "School admins can review lesson plans"
  on "public"."lesson_plans"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.school_educators se
  WHERE ((se.id = lesson_plans.educator_id) AND (se.school_id IN ( SELECT school_educators.school_id
           FROM public.school_educators
          WHERE ((school_educators.user_id = auth.uid()) AND ((school_educators.role)::text = 'school_admin'::text))))))));



  create policy "School admins can view all lesson plans"
  on "public"."lesson_plans"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.school_educators se
  WHERE ((se.id = lesson_plans.educator_id) AND (se.school_id IN ( SELECT school_educators.school_id
           FROM public.school_educators
          WHERE ((school_educators.user_id = auth.uid()) AND ((school_educators.role)::text = 'school_admin'::text))))))));



  create policy "Authenticated users can read resources"
  on "public"."lesson_resources"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Educators can delete resources"
  on "public"."lesson_resources"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM ((public.lessons
     JOIN public.course_modules ON ((course_modules.module_id = lessons.module_id)))
     JOIN public.courses ON ((courses.course_id = course_modules.course_id)))
  WHERE ((lessons.lesson_id = lesson_resources.lesson_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can insert resources"
  on "public"."lesson_resources"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM ((public.lessons
     JOIN public.course_modules ON ((course_modules.module_id = lessons.module_id)))
     JOIN public.courses ON ((courses.course_id = course_modules.course_id)))
  WHERE ((lessons.lesson_id = lesson_resources.lesson_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can update resources"
  on "public"."lesson_resources"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM ((public.lessons
     JOIN public.course_modules ON ((course_modules.module_id = lessons.module_id)))
     JOIN public.courses ON ((courses.course_id = course_modules.course_id)))
  WHERE ((lessons.lesson_id = lesson_resources.lesson_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Authenticated users can read lessons"
  on "public"."lessons"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Educators can delete lessons"
  on "public"."lessons"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.course_modules
     JOIN public.courses ON ((courses.course_id = course_modules.course_id)))
  WHERE ((course_modules.module_id = lessons.module_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can insert lessons"
  on "public"."lessons"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM (public.course_modules
     JOIN public.courses ON ((courses.course_id = course_modules.course_id)))
  WHERE ((course_modules.module_id = lessons.module_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Educators can update lessons"
  on "public"."lessons"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM (public.course_modules
     JOIN public.courses ON ((courses.course_id = course_modules.course_id)))
  WHERE ((course_modules.module_id = lessons.module_id) AND ((courses.educator_id = auth.uid()) OR (EXISTS ( SELECT 1
           FROM public.course_co_educators
          WHERE ((course_co_educators.course_id = courses.course_id) AND (course_co_educators.educator_id = auth.uid())))))))));



  create policy "Admins can view all book issues"
  on "public"."library_book_issues"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((users.id = auth.uid()) AND ((users.raw_user_meta_data ->> 'role'::text) = ANY (ARRAY['admin'::text, 'college_admin'::text, 'librarian'::text]))))));



  create policy "Only admins can manage book issues"
  on "public"."library_book_issues"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((users.id = auth.uid()) AND ((users.raw_user_meta_data ->> 'role'::text) = ANY (ARRAY['admin'::text, 'college_admin'::text, 'librarian'::text]))))));



  create policy "Students can view their own book issues"
  on "public"."library_book_issues"
  as permissive
  for select
  to public
using ((auth.uid() = student_id));



  create policy "Admins can view all book issues"
  on "public"."library_book_issues_college"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((users.id = auth.uid()) AND (((users.raw_user_meta_data ->> 'role'::text) = ANY (ARRAY['admin'::text, 'college_admin'::text, 'librarian'::text])) OR ((users.email)::text ~~ '%@admin.%'::text))))));



  create policy "Only admins can manage book issues"
  on "public"."library_book_issues_college"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((users.id = auth.uid()) AND (((users.raw_user_meta_data ->> 'role'::text) = ANY (ARRAY['admin'::text, 'college_admin'::text, 'librarian'::text])) OR ((users.email)::text ~~ '%@admin.%'::text))))));



  create policy "Students can view their own book issues"
  on "public"."library_book_issues_college"
  as permissive
  for select
  to public
using (((auth.uid())::text = student_id));



  create policy "Anyone can view library books"
  on "public"."library_books_college"
  as permissive
  for select
  to public
using (true);



  create policy "Only admins can manage library books"
  on "public"."library_books_college"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((users.id = auth.uid()) AND (((users.raw_user_meta_data ->> 'role'::text) = ANY (ARRAY['admin'::text, 'college_admin'::text, 'librarian'::text])) OR ((users.email)::text ~~ '%@admin.%'::text))))));



  create policy "Anyone can view library categories"
  on "public"."library_categories"
  as permissive
  for select
  to public
using (true);



  create policy "Only admins can manage library categories"
  on "public"."library_categories"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((users.id = auth.uid()) AND ((users.raw_user_meta_data ->> 'role'::text) = ANY (ARRAY['admin'::text, 'college_admin'::text, 'librarian'::text]))))));



  create policy "Anyone can view library categories"
  on "public"."library_categories_college"
  as permissive
  for select
  to public
using (true);



  create policy "Only admins can manage library categories"
  on "public"."library_categories_college"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((users.id = auth.uid()) AND (((users.raw_user_meta_data ->> 'role'::text) = ANY (ARRAY['admin'::text, 'college_admin'::text, 'librarian'::text])) OR ((users.email)::text ~~ '%@admin.%'::text))))));



  create policy "Admins can view library settings"
  on "public"."library_settings"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((users.id = auth.uid()) AND ((users.raw_user_meta_data ->> 'role'::text) = ANY (ARRAY['admin'::text, 'college_admin'::text, 'librarian'::text]))))));



  create policy "Only admins can manage library settings"
  on "public"."library_settings"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((users.id = auth.uid()) AND ((users.raw_user_meta_data ->> 'role'::text) = ANY (ARRAY['admin'::text, 'college_admin'::text, 'librarian'::text]))))));



  create policy "Admins can view library settings"
  on "public"."library_settings_college"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((users.id = auth.uid()) AND (((users.raw_user_meta_data ->> 'role'::text) = ANY (ARRAY['admin'::text, 'college_admin'::text, 'librarian'::text])) OR ((users.email)::text ~~ '%@admin.%'::text))))));



  create policy "Only admins can manage library settings"
  on "public"."library_settings_college"
  as permissive
  for all
  to public
using ((EXISTS ( SELECT 1
   FROM auth.users
  WHERE ((users.id = auth.uid()) AND (((users.raw_user_meta_data ->> 'role'::text) = ANY (ARRAY['admin'::text, 'college_admin'::text, 'librarian'::text])) OR ((users.email)::text ~~ '%@admin.%'::text))))));



  create policy "Admins can create license assignments"
  on "public"."license_assignments"
  as permissive
  for insert
  to public
with check (((auth.uid() = assigned_by) AND (auth.uid() IN ( SELECT u.id
   FROM public.users u
  WHERE (u.role = ANY (ARRAY['school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role, 'super_admin'::public.user_role]))))));



  create policy "Admins can update license assignments"
  on "public"."license_assignments"
  as permissive
  for update
  to public
using (((auth.uid() = assigned_by) OR (auth.uid() IN ( SELECT os.purchased_by
   FROM public.organization_subscriptions os
  WHERE (os.id = license_assignments.organization_subscription_id))) OR (auth.uid() IN ( SELECT u.id
   FROM public.users u
  WHERE (u.role = ANY (ARRAY['school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role, 'super_admin'::public.user_role]))))));



  create policy "Admins can view organization license assignments"
  on "public"."license_assignments"
  as permissive
  for select
  to public
using (((auth.uid() = user_id) OR (auth.uid() = assigned_by) OR (auth.uid() IN ( SELECT os.purchased_by
   FROM public.organization_subscriptions os
  WHERE (os.id = license_assignments.organization_subscription_id))) OR (auth.uid() IN ( SELECT u.id
   FROM public.users u
  WHERE (u.role = ANY (ARRAY['school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role, 'super_admin'::public.user_role]))))));



  create policy "Admins can create license pools"
  on "public"."license_pools"
  as permissive
  for insert
  to public
with check (((auth.uid() = created_by) AND (auth.uid() IN ( SELECT u.id
   FROM public.users u
  WHERE (u.role = ANY (ARRAY['school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role, 'super_admin'::public.user_role]))))));



  create policy "Admins can delete license pools"
  on "public"."license_pools"
  as permissive
  for delete
  to public
using (((auth.uid() = created_by) OR (auth.uid() IN ( SELECT u.id
   FROM public.users u
  WHERE (u.role = ANY (ARRAY['school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role, 'super_admin'::public.user_role]))))));



  create policy "Admins can update license pools"
  on "public"."license_pools"
  as permissive
  for update
  to public
using (((auth.uid() = created_by) OR (auth.uid() IN ( SELECT u.id
   FROM public.users u
  WHERE (u.role = ANY (ARRAY['school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role, 'super_admin'::public.user_role]))))));



  create policy "Admins can view own organization license pools"
  on "public"."license_pools"
  as permissive
  for select
  to public
using (((auth.uid() = created_by) OR (auth.uid() IN ( SELECT u.id
   FROM public.users u
  WHERE ((u.role = ANY (ARRAY['school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role, 'super_admin'::public.user_role])) AND ((((license_pools.organization_type)::text = 'school'::text) AND (EXISTS ( SELECT 1
           FROM public.school_educators se
          WHERE ((se.user_id = u.id) AND (se.school_id = license_pools.organization_id))))) OR (((license_pools.organization_type)::text = 'college'::text) AND (EXISTS ( SELECT 1
           FROM public.college_lecturers cl
          WHERE ((cl.user_id = u.id) AND (cl."collegeId" = license_pools.organization_id))))) OR (((license_pools.organization_type)::text = 'university'::text) AND (u.role = 'university_admin'::public.user_role))))))));



  create policy "College admins can send messages to students"
  on "public"."messages"
  as permissive
  for insert
  to public
with check (((sender_id = auth.uid()) AND (sender_type = 'college_admin'::text) AND (receiver_type = 'student'::text)));



  create policy "College admins can view student conversation messages"
  on "public"."messages"
  as permissive
  for select
  to public
using ((((sender_id = auth.uid()) AND (sender_type = 'college_admin'::text)) OR ((receiver_id = auth.uid()) AND (receiver_type = 'college_admin'::text))));



  create policy "Educators can send messages to school admins"
  on "public"."messages"
  as permissive
  for insert
  to public
with check (((sender_id = auth.uid()) AND (sender_type = 'educator'::text) AND (receiver_type = 'school_admin'::text)));



  create policy "Educators can send messages to students"
  on "public"."messages"
  as permissive
  for insert
  to public
with check (((sender_id = auth.uid()) AND (sender_type = 'educator'::text) AND (receiver_type = 'student'::text)));



  create policy "Educators can view admin conversation messages"
  on "public"."messages"
  as permissive
  for select
  to public
using ((((sender_id = auth.uid()) AND (sender_type = 'educator'::text)) OR ((receiver_id = auth.uid()) AND (receiver_type = 'educator'::text))));



  create policy "Educators can view student conversation messages"
  on "public"."messages"
  as permissive
  for select
  to public
using ((((sender_id = auth.uid()) AND (sender_type = 'educator'::text)) OR ((receiver_id = auth.uid()) AND (receiver_type = 'educator'::text))));



  create policy "Recruiters can send messages to students"
  on "public"."messages"
  as permissive
  for insert
  to public
with check (((sender_id = auth.uid()) AND (sender_type = 'recruiter'::text) AND (receiver_type = 'student'::text)));



  create policy "Recruiters can view student conversation messages"
  on "public"."messages"
  as permissive
  for select
  to public
using ((((sender_id = auth.uid()) AND (sender_type = 'recruiter'::text) AND (receiver_type = 'student'::text)) OR ((receiver_id = auth.uid()) AND (receiver_type = 'recruiter'::text) AND (sender_type = 'student'::text))));



  create policy "School admins can send messages to educators"
  on "public"."messages"
  as permissive
  for insert
  to public
with check (((sender_id = auth.uid()) AND (sender_type = 'school_admin'::text) AND (receiver_type = 'educator'::text)));



  create policy "School admins can send messages to students"
  on "public"."messages"
  as permissive
  for insert
  to public
with check (((sender_id = auth.uid()) AND (sender_type = 'school_admin'::text) AND (receiver_type = 'student'::text)));



  create policy "School admins can view educator conversation messages"
  on "public"."messages"
  as permissive
  for select
  to public
using ((((sender_id = auth.uid()) AND (sender_type = 'school_admin'::text)) OR ((receiver_id = auth.uid()) AND (receiver_type = 'school_admin'::text))));



  create policy "School admins can view student conversation messages"
  on "public"."messages"
  as permissive
  for select
  to public
using ((((sender_id = auth.uid()) AND (sender_type = 'school_admin'::text)) OR ((receiver_id = auth.uid()) AND (receiver_type = 'school_admin'::text))));



  create policy "Students can send messages to college admins"
  on "public"."messages"
  as permissive
  for insert
  to public
with check (((sender_id = auth.uid()) AND (sender_type = 'student'::text) AND (receiver_type = 'college_admin'::text)));



  create policy "Students can send messages to educators"
  on "public"."messages"
  as permissive
  for insert
  to public
with check (((sender_id = auth.uid()) AND (sender_type = 'student'::text) AND (receiver_type = 'educator'::text)));



  create policy "Students can send messages to recruiters"
  on "public"."messages"
  as permissive
  for insert
  to public
with check (((sender_id = auth.uid()) AND (sender_type = 'student'::text) AND (receiver_type = 'recruiter'::text)));



  create policy "Students can send messages to school admins"
  on "public"."messages"
  as permissive
  for insert
  to public
with check (((sender_id = auth.uid()) AND (sender_type = 'student'::text) AND (receiver_type = 'school_admin'::text)));



  create policy "Students can view admin conversation messages"
  on "public"."messages"
  as permissive
  for select
  to public
using ((((sender_id = auth.uid()) AND (sender_type = 'student'::text)) OR ((receiver_id = auth.uid()) AND (receiver_type = 'student'::text))));



  create policy "Students can view college admin conversation messages"
  on "public"."messages"
  as permissive
  for select
  to public
using ((((sender_id = auth.uid()) AND (sender_type = 'student'::text)) OR ((receiver_id = auth.uid()) AND (receiver_type = 'student'::text))));



  create policy "Students can view educator conversation messages"
  on "public"."messages"
  as permissive
  for select
  to public
using ((((sender_id = auth.uid()) AND (sender_type = 'student'::text)) OR ((receiver_id = auth.uid()) AND (receiver_type = 'student'::text))));



  create policy "Students can view recruiter conversation messages"
  on "public"."messages"
  as permissive
  for select
  to public
using ((((sender_id = auth.uid()) AND (sender_type = 'student'::text) AND (receiver_type = 'recruiter'::text)) OR ((receiver_id = auth.uid()) AND (receiver_type = 'student'::text) AND (sender_type = 'recruiter'::text))));



  create policy "Users can update their received messages"
  on "public"."messages"
  as permissive
  for update
  to public
using ((receiver_id = auth.uid()));



  create policy "Allow public insert"
  on "public"."metrics_snapshots"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow public read"
  on "public"."metrics_snapshots"
  as permissive
  for select
  to public
using (true);



  create policy "Allow public update"
  on "public"."metrics_snapshots"
  as permissive
  for update
  to public
using (true);



  create policy "Allow authenticated inserts"
  on "public"."notifications"
  as permissive
  for insert
  to public
with check (true);



  create policy "Users can read their own notifications"
  on "public"."notifications"
  as permissive
  for select
  to public
using ((recipient_id = auth.uid()));



  create policy "Enable delete for users based on user_id"
  on "public"."offers"
  as permissive
  for delete
  to public
using (true);



  create policy "Enable insert for authenticated users only"
  on "public"."offers"
  as permissive
  for insert
  to public
with check (true);



  create policy "Enable read access for all users"
  on "public"."offers"
  as permissive
  for select
  to public
using (true);



  create policy "Policy with table joins"
  on "public"."offers"
  as permissive
  for update
  to public
using (true);



  create policy "Allow all users to view opportunities"
  on "public"."opportunities"
  as permissive
  for select
  to public
using (true);



  create policy "Authenticated users can delete opportunities"
  on "public"."opportunities"
  as permissive
  for delete
  to authenticated
using (true);



  create policy "Authenticated users can insert opportunities"
  on "public"."opportunities"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Authenticated users can update opportunities"
  on "public"."opportunities"
  as permissive
  for update
  to authenticated
using (true)
with check (true);



  create policy "Anyone can view invitation by token"
  on "public"."organization_invitations"
  as permissive
  for select
  to public
using ((invitation_token IS NOT NULL));



  create policy "Create organization invitations"
  on "public"."organization_invitations"
  as permissive
  for insert
  to public
with check (((auth.uid() = invited_by) AND public.is_organization_admin(auth.uid())));



  create policy "Delete organization invitations"
  on "public"."organization_invitations"
  as permissive
  for delete
  to public
using (public.is_organization_admin(auth.uid()));



  create policy "Update organization invitations"
  on "public"."organization_invitations"
  as permissive
  for update
  to public
using ((public.is_organization_admin(auth.uid()) OR ((invitee_email = public.get_user_email(auth.uid())) AND (status = 'pending'::text))))
with check ((public.is_organization_admin(auth.uid()) OR ((invitee_email = public.get_user_email(auth.uid())) AND (status = ANY (ARRAY['accepted'::text, 'pending'::text])))));



  create policy "View organization invitations"
  on "public"."organization_invitations"
  as permissive
  for select
  to public
using ((public.is_organization_admin(auth.uid()) OR (invitee_email = public.get_user_email(auth.uid()))));



  create policy "Admins can create organization subscriptions"
  on "public"."organization_subscriptions"
  as permissive
  for insert
  to public
with check (((auth.uid() = purchased_by) AND (auth.uid() IN ( SELECT u.id
   FROM public.users u
  WHERE (u.role = ANY (ARRAY['school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role, 'super_admin'::public.user_role]))))));



  create policy "Admins can update organization subscriptions"
  on "public"."organization_subscriptions"
  as permissive
  for update
  to public
using (((auth.uid() = purchased_by) OR (auth.uid() IN ( SELECT u.id
   FROM public.users u
  WHERE (u.role = ANY (ARRAY['school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role, 'super_admin'::public.user_role]))))));



  create policy "Admins can view own organization subscriptions"
  on "public"."organization_subscriptions"
  as permissive
  for select
  to public
using (((auth.uid() = purchased_by) OR (auth.uid() IN ( SELECT u.id
   FROM public.users u
  WHERE ((u.role = ANY (ARRAY['school_admin'::public.user_role, 'college_admin'::public.user_role, 'university_admin'::public.user_role, 'super_admin'::public.user_role])) AND ((((organization_subscriptions.organization_type)::text = 'school'::text) AND (EXISTS ( SELECT 1
           FROM public.school_educators se
          WHERE ((se.user_id = u.id) AND (se.school_id = organization_subscriptions.organization_id))))) OR (((organization_subscriptions.organization_type)::text = 'college'::text) AND (EXISTS ( SELECT 1
           FROM public.college_lecturers cl
          WHERE ((cl.user_id = u.id) AND (cl."collegeId" = organization_subscriptions.organization_id))))) OR (((organization_subscriptions.organization_type)::text = 'university'::text) AND (u.role = 'university_admin'::public.user_role))))))));



  create policy "License holders can view their organization subscription"
  on "public"."organization_subscriptions"
  as permissive
  for select
  to public
using (public.user_has_license_for_org_subscription(id));



  create policy "Allow authenticated users to read organizations"
  on "public"."organizations"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Allow users to delete their own organization"
  on "public"."organizations"
  as permissive
  for delete
  to authenticated
using ((admin_id = auth.uid()));



  create policy "Allow users to insert their own organization"
  on "public"."organizations"
  as permissive
  for insert
  to authenticated
with check ((admin_id = auth.uid()));



  create policy "Allow users to update their own organization"
  on "public"."organizations"
  as permissive
  for update
  to authenticated
using ((admin_id = auth.uid()))
with check ((admin_id = auth.uid()));



  create policy "Service role access otp_requests_log"
  on "public"."otp_requests_log"
  as permissive
  for all
  to public
using (true);



  create policy "Educators can manage mappings in their draft/rejected curriculu"
  on "public"."outcome_assessment_mappings"
  as permissive
  for all
  to authenticated
using ((learning_outcome_id IN ( SELECT clo.id
   FROM ((public.curriculum_learning_outcomes clo
     JOIN public.curriculum_chapters cc ON ((clo.chapter_id = cc.id)))
     JOIN public.curriculums c ON ((cc.curriculum_id = c.id)))
  WHERE ((c.created_by IN ( SELECT school_educators.id
           FROM public.school_educators
          WHERE (school_educators.user_id = auth.uid()))) AND ((c.status)::text = ANY ((ARRAY['draft'::character varying, 'rejected'::character varying])::text[]))))));



  create policy "Educators can view mappings from their school curriculums"
  on "public"."outcome_assessment_mappings"
  as permissive
  for select
  to authenticated
using ((learning_outcome_id IN ( SELECT clo.id
   FROM ((public.curriculum_learning_outcomes clo
     JOIN public.curriculum_chapters cc ON ((clo.chapter_id = cc.id)))
     JOIN public.curriculums c ON ((cc.curriculum_id = c.id)))
  WHERE (c.school_id IN ( SELECT school_educators.school_id
           FROM public.school_educators
          WHERE (school_educators.user_id = auth.uid()))))));



  create policy "Users can create own payment transactions"
  on "public"."payment_transactions"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can view own payment transactions"
  on "public"."payment_transactions"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Allow authenticated delete attempts"
  on "public"."personal_assessment_attempts"
  as permissive
  for delete
  to authenticated
using (true);



  create policy "Allow authenticated insert attempts"
  on "public"."personal_assessment_attempts"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Allow authenticated select attempts"
  on "public"."personal_assessment_attempts"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Allow authenticated update attempts"
  on "public"."personal_assessment_attempts"
  as permissive
  for update
  to authenticated
using (true)
with check (true);



  create policy "Anyone can read assessment questions"
  on "public"."personal_assessment_questions"
  as permissive
  for select
  to public
using (true);



  create policy "Anyone can view assessment questions"
  on "public"."personal_assessment_questions"
  as permissive
  for select
  to public
using ((is_active = true));



  create policy "Anyone can view response scales"
  on "public"."personal_assessment_response_scales"
  as permissive
  for select
  to public
using (true);



  create policy "Allow authenticated delete responses"
  on "public"."personal_assessment_responses"
  as permissive
  for delete
  to authenticated
using (true);



  create policy "Allow authenticated insert responses"
  on "public"."personal_assessment_responses"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Allow authenticated select responses"
  on "public"."personal_assessment_responses"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Allow authenticated update responses"
  on "public"."personal_assessment_responses"
  as permissive
  for update
  to authenticated
using (true)
with check (true);



  create policy "Allow authenticated delete restrictions"
  on "public"."personal_assessment_restrictions"
  as permissive
  for delete
  to authenticated
using (true);



  create policy "Allow authenticated insert restrictions"
  on "public"."personal_assessment_restrictions"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Allow authenticated select restrictions"
  on "public"."personal_assessment_restrictions"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Allow authenticated update restrictions"
  on "public"."personal_assessment_restrictions"
  as permissive
  for update
  to authenticated
using (true)
with check (true);



  create policy "Allow authenticated delete results"
  on "public"."personal_assessment_results"
  as permissive
  for delete
  to authenticated
using (true);



  create policy "Allow authenticated insert results"
  on "public"."personal_assessment_results"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Allow authenticated select results"
  on "public"."personal_assessment_results"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Allow authenticated update results"
  on "public"."personal_assessment_results"
  as permissive
  for update
  to authenticated
using (true)
with check (true);



  create policy "Anyone can read assessment sections"
  on "public"."personal_assessment_sections"
  as permissive
  for select
  to public
using (true);



  create policy "Anyone can view assessment sections"
  on "public"."personal_assessment_sections"
  as permissive
  for select
  to public
using ((is_active = true));



  create policy "Anyone can read assessment streams"
  on "public"."personal_assessment_streams"
  as permissive
  for select
  to public
using (true);



  create policy "Anyone can view active streams"
  on "public"."personal_assessment_streams"
  as permissive
  for select
  to public
using ((is_active = true));



  create policy "Anyone can view assessment streams"
  on "public"."personal_assessment_streams"
  as permissive
  for select
  to public
using ((is_active = true));



  create policy "Service role access phone_otps"
  on "public"."phone_otps"
  as permissive
  for all
  to public
using (true);



  create policy "Authenticated users can log activities"
  on "public"."pipeline_activities"
  as permissive
  for insert
  to public
with check (true);



  create policy "Authenticated users can view activities"
  on "public"."pipeline_activities"
  as permissive
  for select
  to public
using (true);



  create policy "Authenticated users can manage pipeline candidates"
  on "public"."pipeline_candidates"
  as permissive
  for all
  to public
using (true);



  create policy "Authenticated users can view pipeline candidates"
  on "public"."pipeline_candidates"
  as permissive
  for select
  to public
using (true);



  create policy "Allow public insert"
  on "public"."placements"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow public read"
  on "public"."placements"
  as permissive
  for select
  to public
using (true);



  create policy "Allow public update"
  on "public"."placements"
  as permissive
  for update
  to public
using (true);



  create policy "Allow anon insert"
  on "public"."pre_registrations"
  as permissive
  for insert
  to anon
with check (true);



  create policy "Allow anon select"
  on "public"."pre_registrations"
  as permissive
  for select
  to anon
using (true);



  create policy "Allow anon update"
  on "public"."pre_registrations"
  as permissive
  for update
  to anon
using (true)
with check (true);



  create policy "Anyone can track profile views"
  on "public"."profile_views"
  as permissive
  for insert
  to public
with check (true);



  create policy "Students can view own profile views"
  on "public"."profile_views"
  as permissive
  for select
  to public
using (true);



  create policy "Enable insert for authenticated users only"
  on "public"."projects"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Allow public read access to recent_updates"
  on "public"."recent_updates"
  as permissive
  for select
  to public
using (true);



  create policy "Allow users to insert own recent_updates"
  on "public"."recent_updates"
  as permissive
  for insert
  to public
with check ((auth.uid() = student_id));



  create policy "Allow users to update own recent_updates"
  on "public"."recent_updates"
  as permissive
  for update
  to public
using ((auth.uid() = student_id));



  create policy "Allow public insert"
  on "public"."recruiter_activities"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow public read"
  on "public"."recruiter_activities"
  as permissive
  for select
  to public
using (true);



  create policy "Users can delete own saved searches"
  on "public"."recruiter_saved_searches"
  as permissive
  for delete
  to public
using (true);



  create policy "Users can insert own saved searches"
  on "public"."recruiter_saved_searches"
  as permissive
  for insert
  to public
with check (true);



  create policy "Users can update own saved searches"
  on "public"."recruiter_saved_searches"
  as permissive
  for update
  to public
using (true);



  create policy "Users can view own saved searches"
  on "public"."recruiter_saved_searches"
  as permissive
  for select
  to public
using (true);



  create policy "Enable insert for authenticated users only"
  on "public"."recruiters"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Enable read access for all users"
  on "public"."recruiters"
  as permissive
  for select
  to public
using (true);



  create policy "Policy with table joins"
  on "public"."recruiters"
  as permissive
  for update
  to public
using (true);



  create policy "Authenticated users can manage requisitions"
  on "public"."requisitions"
  as permissive
  for all
  to public
using (true);



  create policy "Authenticated users can view requisitions"
  on "public"."requisitions"
  as permissive
  for select
  to public
using (true);



  create policy "Service role can do everything"
  on "public"."reset_tokens"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Enable delete for users based on user_id"
  on "public"."school_classes"
  as permissive
  for delete
  to public
using (true);



  create policy "Enable insert for authenticated users only"
  on "public"."school_classes"
  as permissive
  for insert
  to public
with check (true);



  create policy "Enable read access for all users"
  on "public"."school_classes"
  as permissive
  for select
  to public
using (true);



  create policy "Policy with table joins"
  on "public"."school_classes"
  as permissive
  for update
  to public
using (true);



  create policy "Authenticated users can manage shortlist candidates"
  on "public"."shortlist_candidates"
  as permissive
  for all
  to public
using (true);



  create policy "Authenticated users can view shortlist candidates"
  on "public"."shortlist_candidates"
  as permissive
  for select
  to public
using (true);



  create policy "Authenticated users can create shortlists"
  on "public"."shortlists"
  as permissive
  for insert
  to public
with check (true);



  create policy "Authenticated users can delete shortlists"
  on "public"."shortlists"
  as permissive
  for delete
  to public
using (true);



  create policy "Authenticated users can update shortlists"
  on "public"."shortlists"
  as permissive
  for update
  to public
using (true);



  create policy "Authenticated users can view shortlists"
  on "public"."shortlists"
  as permissive
  for select
  to public
using (true);



  create policy "School staff can manage assessments"
  on "public"."skill_assessments"
  as permissive
  for all
  to public
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "School staff can view assessments"
  on "public"."skill_assessments"
  as permissive
  for select
  to public
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "Allow public insert"
  on "public"."skill_passports"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow public read"
  on "public"."skill_passports"
  as permissive
  for select
  to public
using (true);



  create policy "Allow public update"
  on "public"."skill_passports"
  as permissive
  for update
  to public
using (true);



  create policy "Allow public insert"
  on "public"."skill_trends"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow public read"
  on "public"."skill_trends"
  as permissive
  for select
  to public
using (true);



  create policy "Allow public update"
  on "public"."skill_trends"
  as permissive
  for update
  to public
using (true);



  create policy "Admins can update verification requests"
  on "public"."skill_verification_requests"
  as permissive
  for update
  to public
using (true);



  create policy "Admins can view all verification requests"
  on "public"."skill_verification_requests"
  as permissive
  for select
  to public
using (true);



  create policy "Students can insert verification requests"
  on "public"."skill_verification_requests"
  as permissive
  for insert
  to public
with check ((auth.uid() = student_id));



  create policy "Students can view their own verification requests"
  on "public"."skill_verification_requests"
  as permissive
  for select
  to public
using ((auth.uid() = student_id));



  create policy "Enable insert for authenticated users only"
  on "public"."student_assignments"
  as permissive
  for insert
  to public
with check (true);



  create policy "Enable read access for all users"
  on "public"."student_assignments"
  as permissive
  for select
  to public
using (true);



  create policy "Policy with table joins"
  on "public"."student_assignments"
  as permissive
  for update
  to public
using (true);



  create policy "Service role has full access to student_course_progress"
  on "public"."student_course_progress"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "Students can create their own progress"
  on "public"."student_course_progress"
  as permissive
  for insert
  to public
with check ((auth.uid() = student_id));



  create policy "Students can update their own progress"
  on "public"."student_course_progress"
  as permissive
  for update
  to public
using ((auth.uid() = student_id))
with check ((auth.uid() = student_id));



  create policy "Students can view their own progress"
  on "public"."student_course_progress"
  as permissive
  for select
  to public
using ((auth.uid() = student_id));



  create policy "College admins can delete their enrollments"
  on "public"."student_enrollments"
  as permissive
  for delete
  to public
using ((EXISTS ( SELECT 1
   FROM (public.college_lecturers cl
     JOIN public.students s ON ((s.college_id = cl."collegeId")))
  WHERE ((cl.user_id = auth.uid()) AND (s.id = student_enrollments.student_id)))));



  create policy "College admins can insert enrollments"
  on "public"."student_enrollments"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM (public.college_lecturers cl
     JOIN public.students s ON ((s.college_id = cl."collegeId")))
  WHERE ((cl.user_id = auth.uid()) AND (s.id = student_enrollments.student_id)))));



  create policy "College admins can update their enrollments"
  on "public"."student_enrollments"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM (public.college_lecturers cl
     JOIN public.students s ON ((s.college_id = cl."collegeId")))
  WHERE ((cl.user_id = auth.uid()) AND (s.id = student_enrollments.student_id)))));



  create policy "College admins can view their enrollments"
  on "public"."student_enrollments"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM (public.college_lecturers cl
     JOIN public.students s ON ((s.college_id = cl."collegeId")))
  WHERE ((cl.user_id = auth.uid()) AND (s.id = student_enrollments.student_id)))));



  create policy "Service role has full access to job matches cache"
  on "public"."student_job_matches"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text))
with check ((auth.role() = 'service_role'::text));



  create policy "Students can view their own job matches cache"
  on "public"."student_job_matches"
  as permissive
  for select
  to public
using ((student_id IN ( SELECT students.id
   FROM public.students
  WHERE (students.user_id = auth.uid()))));



  create policy "School staff can manage student records"
  on "public"."student_management_records"
  as permissive
  for all
  to public
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "School staff can view their school's student records"
  on "public"."student_management_records"
  as permissive
  for select
  to public
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "Students can insert own quiz progress"
  on "public"."student_quiz_progress"
  as permissive
  for insert
  to public
with check ((student_id = auth.uid()));



  create policy "Students can update own quiz progress"
  on "public"."student_quiz_progress"
  as permissive
  for update
  to public
using ((student_id = auth.uid()));



  create policy "Students can view own quiz progress"
  on "public"."student_quiz_progress"
  as permissive
  for select
  to public
using ((student_id = auth.uid()));



  create policy "School staff can manage reports"
  on "public"."student_reports"
  as permissive
  for all
  to public
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "School staff can view reports"
  on "public"."student_reports"
  as permissive
  for select
  to public
using ((school_id IN ( SELECT school_educators.school_id
   FROM public.school_educators
  WHERE (school_educators.user_id = auth.uid()))));



  create policy "Allow full access to authenticated users"
  on "public"."students"
  as permissive
  for all
  to authenticated
using (true)
with check (true);



  create policy "Allow public insert"
  on "public"."students"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow public read"
  on "public"."students"
  as permissive
  for select
  to public
using (true);



  create policy "Allow public update"
  on "public"."students"
  as permissive
  for update
  to public
using (true);



  create policy "Enable read access for all users"
  on "public"."students"
  as permissive
  for select
  to public
using (true);



  create policy "Students can insert own profile"
  on "public"."students"
  as permissive
  for insert
  to public
with check ((auth.uid() = id));



  create policy "Users can view own migrations"
  on "public"."subscription_migrations"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Allow admin write access to features"
  on "public"."subscription_plan_features"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text));



  create policy "Allow public read access to plan features"
  on "public"."subscription_plan_features"
  as permissive
  for select
  to public
using (true);



  create policy "Allow admin write access to plans"
  on "public"."subscription_plans"
  as permissive
  for all
  to public
using ((auth.role() = 'service_role'::text));



  create policy "Allow public read access to active plans"
  on "public"."subscription_plans"
  as permissive
  for select
  to public
using ((is_active = true));



  create policy "Users can create own subscriptions"
  on "public"."subscriptions"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can update own subscriptions"
  on "public"."subscriptions"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "Users can view own subscription"
  on "public"."subscriptions"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Users can view own subscriptions"
  on "public"."subscriptions"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "tutor_conversations_delete"
  on "public"."tutor_conversations"
  as permissive
  for delete
  to authenticated
using ((auth.uid() = student_id));



  create policy "tutor_conversations_insert"
  on "public"."tutor_conversations"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() = student_id));



  create policy "tutor_conversations_select"
  on "public"."tutor_conversations"
  as permissive
  for select
  to authenticated
using ((auth.uid() = student_id));



  create policy "tutor_conversations_update"
  on "public"."tutor_conversations"
  as permissive
  for update
  to authenticated
using ((auth.uid() = student_id))
with check ((auth.uid() = student_id));



  create policy "Service role has full access to tutor_feedback"
  on "public"."tutor_feedback"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'service_role'::text));



  create policy "Students can create feedback on their conversations"
  on "public"."tutor_feedback"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.tutor_conversations tc
  WHERE ((tc.id = tutor_feedback.conversation_id) AND (tc.student_id = auth.uid())))));



  create policy "Students can view feedback on their conversations"
  on "public"."tutor_feedback"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.tutor_conversations tc
  WHERE ((tc.id = tutor_feedback.conversation_id) AND (tc.student_id = auth.uid())))));



  create policy "Allow public insert"
  on "public"."university_performance"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow public read"
  on "public"."university_performance"
  as permissive
  for select
  to public
using (true);



  create policy "Allow public update"
  on "public"."university_performance"
  as permissive
  for update
  to public
using (true);



  create policy "Admins can manage categories"
  on "public"."user_categories"
  as permissive
  for all
  to public
using (((auth.jwt() ->> 'role'::text) = 'admin'::text));



  create policy "Anyone can view categories"
  on "public"."user_categories"
  as permissive
  for select
  to public
using (true);



  create policy "user_entitlements_insert_own"
  on "public"."user_entitlements"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() = user_id));



  create policy "user_entitlements_select_own"
  on "public"."user_entitlements"
  as permissive
  for select
  to authenticated
using ((auth.uid() = user_id));



  create policy "user_entitlements_service_role"
  on "public"."user_entitlements"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "user_entitlements_update_own"
  on "public"."user_entitlements"
  as permissive
  for update
  to authenticated
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));



  create policy "System can insert login history"
  on "public"."user_login_history"
  as permissive
  for insert
  to public
with check (true);



  create policy "Users can view own login history"
  on "public"."user_login_history"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Admins can view all profiles"
  on "public"."user_profiles"
  as permissive
  for select
  to public
using (((auth.jwt() ->> 'role'::text) = 'admin'::text));



  create policy "Users can insert own profile"
  on "public"."user_profiles"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can update own profile"
  on "public"."user_profiles"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "Users can view own profile"
  on "public"."user_profiles"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Users can insert own sessions"
  on "public"."user_sessions"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can update own sessions"
  on "public"."user_sessions"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "Users can view own sessions"
  on "public"."user_sessions"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Users can insert own settings"
  on "public"."user_settings"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can update own settings"
  on "public"."user_settings"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "Users can view own settings"
  on "public"."user_settings"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Admins can view all state history"
  on "public"."user_state_history"
  as permissive
  for select
  to public
using (((auth.jwt() ->> 'role'::text) = 'admin'::text));



  create policy "System can insert state history"
  on "public"."user_state_history"
  as permissive
  for insert
  to public
with check (true);



  create policy "Users can view own state history"
  on "public"."user_state_history"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Allow public delete"
  on "public"."users"
  as permissive
  for delete
  to public
using (true);



  create policy "Allow public insert"
  on "public"."users"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow public read"
  on "public"."users"
  as permissive
  for select
  to public
using (true);



  create policy "Allow public update"
  on "public"."users"
  as permissive
  for update
  to public
using (true);



  create policy "Allow public insert"
  on "public"."verifications"
  as permissive
  for insert
  to public
with check (true);



  create policy "Allow public read"
  on "public"."verifications"
  as permissive
  for select
  to public
using (true);



  create policy "Anyone can read video summaries"
  on "public"."video_summaries"
  as permissive
  for select
  to public
using (true);



  create policy "Service role can manage video summaries"
  on "public"."video_summaries"
  as permissive
  for all
  to public
using (true)
with check (true);


CREATE TRIGGER update_adaptive_sessions_updated_at BEFORE UPDATE ON public.adaptive_aptitude_sessions FOR EACH ROW EXECUTE FUNCTION public.update_adaptive_updated_at();

CREATE TRIGGER update_admission_applications_updated_at BEFORE UPDATE ON public.admission_applications FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_auto_add_to_pipeline AFTER INSERT ON public.applied_jobs FOR EACH ROW EXECUTE FUNCTION public.auto_add_applicant_to_pipeline();

CREATE TRIGGER trigger_decrement_applications_count AFTER DELETE ON public.applied_jobs FOR EACH ROW EXECUTE FUNCTION public.decrement_applications_count();

CREATE TRIGGER trigger_increment_applications_count AFTER INSERT ON public.applied_jobs FOR EACH ROW EXECUTE FUNCTION public.increment_applications_count();

CREATE TRIGGER trigger_update_applied_jobs_timestamp BEFORE UPDATE ON public.applied_jobs FOR EACH ROW EXECUTE FUNCTION public.update_applied_jobs_updated_at();

CREATE TRIGGER update_applied_jobs_updated_at BEFORE UPDATE ON public.applied_jobs FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER set_approval_requests_timestamp BEFORE UPDATE ON public.approval_requests FOR EACH ROW EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_approval_types_timestamp BEFORE UPDATE ON public.approval_types FOR EACH ROW EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_approval_workflows_timestamp BEFORE UPDATE ON public.approval_workflows FOR EACH ROW EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER update_assessment_types_updated_at BEFORE UPDATE ON public.assessment_types FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_assessments_updated_at BEFORE UPDATE ON public.assessments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_assignments_updated BEFORE UPDATE ON public.assignments FOR EACH ROW EXECUTE FUNCTION public.trg_assignments_updated_fn();

CREATE TRIGGER attendance_slot_id_check BEFORE INSERT OR UPDATE ON public.attendance_records FOR EACH ROW EXECUTE FUNCTION public.check_attendance_slot_id();

CREATE TRIGGER update_attendance_records_updated_at BEFORE UPDATE ON public.attendance_records FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_certificates_embedding AFTER INSERT OR DELETE OR UPDATE ON public.certificates FOR EACH ROW EXECUTE FUNCTION public.trigger_related_student_embedding();

CREATE TRIGGER trigger_certificate_embedding AFTER INSERT OR UPDATE OF title, issuer, platform, level, category, description, enabled ON public.certificates FOR EACH ROW WHEN ((new.enabled = true)) EXECUTE FUNCTION public.trigger_entity_embedding_generation();

CREATE TRIGGER trigger_certificates_updated_at BEFORE UPDATE ON public.certificates FOR EACH ROW EXECUTE FUNCTION public.update_certificates_updated_at();

CREATE TRIGGER update_certificates_updated_at BEFORE UPDATE ON public.certificates FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_create_swap_history AFTER INSERT OR UPDATE ON public.class_swap_requests FOR EACH ROW EXECUTE FUNCTION public.create_swap_history_entry();

CREATE TRIGGER trigger_update_swap_request_timestamp BEFORE UPDATE ON public.class_swap_requests FOR EACH ROW EXECUTE FUNCTION public.update_swap_request_timestamp();

CREATE TRIGGER trg_activities_timestamp BEFORE UPDATE ON public.club_activities FOR EACH ROW EXECUTE FUNCTION public.update_timestamp();

CREATE TRIGGER trg_update_attendance AFTER INSERT OR UPDATE ON public.club_attendance_records FOR EACH ROW EXECUTE FUNCTION public.update_membership_attendance();

CREATE TRIGGER trg_generate_credential_id BEFORE INSERT ON public.club_certificates FOR EACH ROW EXECUTE FUNCTION public.generate_certificate_credential_id();

CREATE TRIGGER trg_check_club_capacity BEFORE INSERT OR UPDATE ON public.club_memberships FOR EACH ROW EXECUTE FUNCTION public.check_club_capacity();

CREATE TRIGGER trg_check_max_clubs BEFORE INSERT OR UPDATE ON public.club_memberships FOR EACH ROW EXECUTE FUNCTION public.check_max_clubs_per_student();

CREATE TRIGGER trg_validate_club_membership_school BEFORE INSERT OR UPDATE ON public.club_memberships FOR EACH ROW EXECUTE FUNCTION public.validate_student_school_match();

CREATE TRIGGER trg_clubs_timestamp BEFORE UPDATE ON public.clubs FOR EACH ROW EXECUTE FUNCTION public.update_timestamp();

CREATE TRIGGER trg_college_assignments_updated BEFORE UPDATE ON public.college_assignments FOR EACH ROW EXECUTE FUNCTION public.trg_college_assignments_updated_fn();

CREATE TRIGGER trigger_update_session_stats AFTER INSERT OR DELETE OR UPDATE ON public.college_attendance_records FOR EACH ROW EXECUTE FUNCTION public.update_session_attendance_stats();

CREATE TRIGGER trigger_set_total_students BEFORE INSERT ON public.college_attendance_sessions FOR EACH ROW EXECUTE FUNCTION public.set_session_total_students();

CREATE TRIGGER check_break_overlap_trigger BEFORE INSERT OR UPDATE ON public.college_breaks FOR EACH ROW EXECUTE FUNCTION public.check_break_date_overlap();

CREATE TRIGGER trigger_college_circulars_updated_at BEFORE UPDATE ON public.college_circulars FOR EACH ROW EXECUTE FUNCTION public.update_college_circulars_updated_at();

CREATE TRIGGER trigger_auto_set_university_id BEFORE INSERT OR UPDATE ON public.college_curriculums FOR EACH ROW EXECUTE FUNCTION public.auto_set_university_id();

CREATE TRIGGER update_college_event_registrations_updated_at BEFORE UPDATE ON public.college_event_registrations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_college_events_updated_at BEFORE UPDATE ON public.college_events FOR EACH ROW EXECUTE FUNCTION public.update_college_events_updated_at();

CREATE TRIGGER trigger_auto_assign_license_college_lecturers AFTER INSERT ON public.college_lecturers FOR EACH ROW EXECUTE FUNCTION public.auto_assign_license_to_member();

CREATE TRIGGER trigger_create_faculty_leave_balances AFTER INSERT ON public.college_lecturers FOR EACH ROW EXECUTE FUNCTION public.create_faculty_leave_balances();

CREATE TRIGGER trigger_update_college_lesson_plans_updated_at BEFORE UPDATE ON public.college_lesson_plans FOR EACH ROW EXECUTE FUNCTION public.update_college_lesson_plans_updated_at();

CREATE TRIGGER trigger_update_mentor_note_timestamp BEFORE UPDATE ON public.college_mentor_notes FOR EACH ROW EXECUTE FUNCTION public.update_mentor_note_timestamp();

CREATE TRIGGER trg_college_student_assignments_grade_pct BEFORE INSERT OR UPDATE OF grade_received ON public.college_student_assignments FOR EACH ROW EXECUTE FUNCTION public.trg_college_student_assignments_grade_pct_fn();

CREATE TRIGGER trg_college_student_assignments_late_check BEFORE INSERT OR UPDATE OF submission_date ON public.college_student_assignments FOR EACH ROW EXECUTE FUNCTION public.trg_college_student_assignments_late_check_fn();

CREATE TRIGGER trg_college_student_assignments_status BEFORE INSERT OR UPDATE OF status ON public.college_student_assignments FOR EACH ROW EXECUTE FUNCTION public.trg_college_student_assignments_status_fn();

CREATE TRIGGER trg_college_student_assignments_updated BEFORE UPDATE ON public.college_student_assignments FOR EACH ROW EXECUTE FUNCTION public.trg_college_student_assignments_updated_fn();

CREATE TRIGGER check_slot_conflicts_trigger BEFORE INSERT OR UPDATE ON public.college_timetable_slots FOR EACH ROW EXECUTE FUNCTION public.check_timetable_slot_conflicts();

CREATE TRIGGER trg_validate_competition_registration_school BEFORE INSERT OR UPDATE ON public.competition_registrations FOR EACH ROW EXECUTE FUNCTION public.validate_student_competition_school();

CREATE TRIGGER trg_competitions_timestamp BEFORE UPDATE ON public.competitions FOR EACH ROW EXECUTE FUNCTION public.update_timestamp();

CREATE TRIGGER update_conversations_updated_at BEFORE UPDATE ON public.conversations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_conversations_backup_20251106_updated_at BEFORE UPDATE ON public.conversations_backup_20251106 FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER auto_create_skills_from_internal_course BEFORE UPDATE ON public.course_enrollments FOR EACH ROW EXECUTE FUNCTION public.create_skills_from_internal_course();

CREATE TRIGGER trg_enrollment_completion_embedding AFTER UPDATE OF progress, status ON public.course_enrollments FOR EACH ROW EXECUTE FUNCTION public.trigger_enrollment_completion_embedding();

CREATE TRIGGER trigger_course_enrollment_embedding AFTER INSERT OR UPDATE OF course_title, status, progress, grade, skills_acquired ON public.course_enrollments FOR EACH ROW WHEN ((new.status = ANY (ARRAY['completed'::text, 'in_progress'::text, 'active'::text]))) EXECUTE FUNCTION public.trigger_entity_embedding_generation();

CREATE TRIGGER trigger_invalidate_job_matches_on_enrollment AFTER INSERT OR DELETE OR UPDATE ON public.course_enrollments FOR EACH ROW EXECUTE FUNCTION public.invalidate_job_matches_cache();

CREATE TRIGGER trigger_reset_quiz_on_enrollment_reset AFTER UPDATE ON public.course_enrollments FOR EACH ROW WHEN ((new.progress = 0)) EXECUTE FUNCTION public.reset_quiz_progress_on_enrollment_reset();

CREATE TRIGGER trigger_sync_training_on_enrollment_update AFTER UPDATE ON public.course_enrollments FOR EACH ROW EXECUTE FUNCTION public.sync_training_from_enrollment();

CREATE TRIGGER update_course_enrollments_updated_at BEFORE UPDATE ON public.course_enrollments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_modules_updated_at BEFORE UPDATE ON public.course_modules FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_courses_updated_at BEFORE UPDATE ON public.courses FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_curriculum_academic_years_updated_at BEFORE UPDATE ON public.curriculum_academic_years FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_curriculum_chapters_updated_at BEFORE UPDATE ON public.curriculum_chapters FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_curriculum_on_chapter_change AFTER INSERT OR DELETE OR UPDATE ON public.curriculum_chapters FOR EACH ROW EXECUTE FUNCTION public.update_curriculum_last_modified();

CREATE TRIGGER update_curriculum_classes_updated_at BEFORE UPDATE ON public.curriculum_classes FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_curriculum_courses_updated_at BEFORE UPDATE ON public.curriculum_courses FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_curriculum_learning_outcomes_updated_at BEFORE UPDATE ON public.curriculum_learning_outcomes FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_curriculum_on_outcome_change AFTER INSERT OR DELETE OR UPDATE ON public.curriculum_learning_outcomes FOR EACH ROW EXECUTE FUNCTION public.update_curriculum_last_modified();

CREATE TRIGGER update_curriculum_subjects_updated_at BEFORE UPDATE ON public.curriculum_subjects FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_curriculums_updated_at BEFORE UPDATE ON public.curriculums FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_department_budgets_updated_at BEFORE UPDATE ON public.department_budgets FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_department_faculty_assignments_updated_at BEFORE UPDATE ON public.department_faculty_assignments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_departments_updated_at BEFORE UPDATE ON public.departments FOR EACH ROW EXECUTE FUNCTION public.update_departments_updated_at();

CREATE TRIGGER update_education_updated_at BEFORE UPDATE ON public.education FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_calculate_exam_registration_fee BEFORE INSERT OR UPDATE ON public.exam_registrations FOR EACH ROW EXECUTE FUNCTION public.calculate_exam_registration_fee();

CREATE TRIGGER trigger_sync_student_record_exam_reg BEFORE INSERT OR UPDATE ON public.exam_registrations FOR EACH ROW EXECUTE FUNCTION public.sync_student_record_id();

CREATE TRIGGER update_exam_registrations_updated_at BEFORE UPDATE ON public.exam_registrations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_exam_rooms_updated_at BEFORE UPDATE ON public.exam_rooms FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_sync_student_record_seating BEFORE INSERT OR UPDATE ON public.exam_seating_arrangements FOR EACH ROW EXECUTE FUNCTION public.sync_student_record_id();

CREATE TRIGGER update_exam_seating_updated_at BEFORE UPDATE ON public.exam_seating_arrangements FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_exam_timetable_updated_at BEFORE UPDATE ON public.exam_timetable FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_exam_windows_updated_at BEFORE UPDATE ON public.exam_windows FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_budget_on_expenditure AFTER INSERT OR UPDATE ON public.expenditures FOR EACH ROW EXECUTE FUNCTION public.update_budget_on_expenditure();

CREATE TRIGGER update_expenditures_updated_at BEFORE UPDATE ON public.expenditures FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER experience_notification_trigger AFTER INSERT OR UPDATE ON public.experience FOR EACH ROW EXECUTE FUNCTION public.notify_admin_experience_submission();

CREATE TRIGGER trg_experience_embedding AFTER INSERT OR DELETE OR UPDATE ON public.experience FOR EACH ROW EXECUTE FUNCTION public.trigger_related_student_embedding();

CREATE TRIGGER trigger_notify_experience_submission AFTER INSERT ON public.experience FOR EACH ROW WHEN (((new.approval_status)::text = 'pending'::text)) EXECUTE FUNCTION public.notify_experience_submission();

CREATE TRIGGER trigger_set_experience_approval_authority BEFORE INSERT OR UPDATE ON public.experience FOR EACH ROW EXECUTE FUNCTION public.set_experience_approval_authority();

CREATE TRIGGER update_experience_updated_at BEFORE UPDATE ON public.experience FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_external_assessment_attempts_timestamp BEFORE UPDATE ON public.external_assessment_attempts FOR EACH ROW EXECUTE FUNCTION public.update_external_assessment_attempts_updated_at();

CREATE TRIGGER auto_create_skills_from_external_course BEFORE INSERT OR UPDATE ON public.external_courses FOR EACH ROW EXECUTE FUNCTION public.create_skills_from_external_course();

CREATE TRIGGER update_external_courses_updated_at BEFORE UPDATE ON public.external_courses FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_fee_payments_updated_at BEFORE UPDATE ON public.fee_payments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_fee_structures_updated_at BEFORE UPDATE ON public.fee_structures FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_grading_systems_updated_at BEFORE UPDATE ON public.grading_systems FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_internships_updated_at BEFORE UPDATE ON public.internships FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_interviews_updated_at BEFORE UPDATE ON public.interviews FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_sync_lecturer_record_invigilator BEFORE INSERT OR UPDATE ON public.invigilator_assignments FOR EACH ROW EXECUTE FUNCTION public.sync_lecturer_record_id();

CREATE TRIGGER update_invigilator_assignments_updated_at BEFORE UPDATE ON public.invigilator_assignments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER lesson_plan_approved_trigger AFTER INSERT OR UPDATE OF status ON public.lesson_plans FOR EACH ROW EXECUTE FUNCTION public.add_to_teacher_journal();

CREATE TRIGGER populate_chapter_name_trigger BEFORE INSERT OR UPDATE OF chapter_id ON public.lesson_plans FOR EACH ROW EXECUTE FUNCTION public.populate_chapter_name();

CREATE TRIGGER update_lesson_plans_updated_at BEFORE UPDATE ON public.lesson_plans FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER validate_evaluation_items_trigger BEFORE INSERT OR UPDATE OF evaluation_items ON public.lesson_plans FOR EACH ROW EXECUTE FUNCTION public.validate_evaluation_items();

CREATE TRIGGER update_lessons_updated_at BEFORE UPDATE ON public.lessons FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_book_availability AFTER INSERT OR DELETE OR UPDATE ON public.library_book_issues FOR EACH ROW EXECUTE FUNCTION public.update_book_availability();

CREATE TRIGGER trigger_update_book_availability_college AFTER INSERT OR DELETE OR UPDATE ON public.library_book_issues_college FOR EACH ROW EXECUTE FUNCTION public.update_book_availability_college();

CREATE TRIGGER update_library_book_issues_college_updated_at BEFORE UPDATE ON public.library_book_issues_college FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_book_availability_school AFTER INSERT OR DELETE OR UPDATE ON public.library_book_issues_school FOR EACH ROW EXECUTE FUNCTION public.update_book_availability_school();

CREATE TRIGGER update_library_books_updated_at BEFORE UPDATE ON public.library_books FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_library_books_college_updated_at BEFORE UPDATE ON public.library_books_college FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_library_categories_college_updated_at BEFORE UPDATE ON public.library_categories_college FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_calculate_days_borrowed BEFORE INSERT OR UPDATE ON public.library_history FOR EACH ROW EXECUTE FUNCTION public.calculate_days_borrowed();

CREATE TRIGGER trigger_calculate_library_fine BEFORE INSERT OR UPDATE ON public.library_issued_books FOR EACH ROW EXECUTE FUNCTION public.calculate_library_fine();

CREATE TRIGGER trigger_sync_student_record_library BEFORE INSERT OR UPDATE ON public.library_issued_books FOR EACH ROW EXECUTE FUNCTION public.sync_student_record_id();

CREATE TRIGGER trigger_update_book_on_issue AFTER INSERT ON public.library_issued_books FOR EACH ROW EXECUTE FUNCTION public.update_book_availability_on_issue();

CREATE TRIGGER trigger_update_book_on_return AFTER UPDATE ON public.library_issued_books FOR EACH ROW EXECUTE FUNCTION public.update_book_availability_on_return();

CREATE TRIGGER update_library_issued_books_updated_at BEFORE UPDATE ON public.library_issued_books FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_library_reservations_updated_at BEFORE UPDATE ON public.library_reservations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_book_rating AFTER INSERT OR UPDATE ON public.library_reviews FOR EACH ROW WHEN ((new.is_approved = true)) EXECUTE FUNCTION public.update_book_rating();

CREATE TRIGGER update_library_reviews_updated_at BEFORE UPDATE ON public.library_reviews FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_library_settings_college_updated_at BEFORE UPDATE ON public.library_settings_college FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_sync_pool_seats AFTER INSERT OR DELETE OR UPDATE ON public.license_assignments FOR EACH ROW EXECUTE FUNCTION public.sync_pool_assigned_seats();

CREATE TRIGGER trigger_update_license_assignments_updated_at BEFORE UPDATE ON public.license_assignments FOR EACH ROW EXECUTE FUNCTION public.update_license_assignments_updated_at();

CREATE TRIGGER trigger_validate_seat_availability BEFORE INSERT ON public.license_assignments FOR EACH ROW EXECUTE FUNCTION public.validate_seat_availability();

CREATE TRIGGER trigger_update_license_pools_updated_at BEFORE UPDATE ON public.license_pools FOR EACH ROW EXECUTE FUNCTION public.update_license_pools_updated_at();

CREATE TRIGGER trigger_validate_pool_allocation BEFORE INSERT OR UPDATE ON public.license_pools FOR EACH ROW EXECUTE FUNCTION public.validate_pool_allocation();

CREATE TRIGGER trigger_sync_student_record_mark_entries BEFORE INSERT OR UPDATE ON public.mark_entries FOR EACH ROW EXECUTE FUNCTION public.sync_student_record_id();

CREATE TRIGGER update_mark_entries_updated_at BEFORE UPDATE ON public.mark_entries FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_calculate_batch_statistics BEFORE INSERT OR UPDATE ON public.mark_entry_batches FOR EACH ROW EXECUTE FUNCTION public.calculate_batch_statistics();

CREATE TRIGGER update_mark_entry_batches_updated_at BEFORE UPDATE ON public.mark_entry_batches FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_calculate_moderation_difference BEFORE INSERT OR UPDATE ON public.mark_moderation_log FOR EACH ROW EXECUTE FUNCTION public.calculate_moderation_difference();

CREATE TRIGGER on_message_read AFTER UPDATE OF is_read ON public.messages FOR EACH ROW WHEN (((old.is_read = false) AND (new.is_read = true))) EXECUTE FUNCTION public.reset_unread_count();

CREATE TRIGGER trigger_create_message_notification AFTER INSERT ON public.messages FOR EACH ROW EXECUTE FUNCTION public.create_message_notification();

CREATE TRIGGER trigger_reset_unread_count AFTER UPDATE ON public.messages FOR EACH ROW EXECUTE FUNCTION public.reset_unread_count();

CREATE TRIGGER trigger_update_conversation_on_message AFTER INSERT ON public.messages FOR EACH ROW EXECUTE FUNCTION public.update_conversation_on_message();

CREATE TRIGGER trigger_update_conversation_unread_count AFTER INSERT ON public.messages FOR EACH ROW EXECUTE FUNCTION public.update_conversation_unread_count();

CREATE TRIGGER update_messages_updated_at BEFORE UPDATE ON public.messages FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_offers_updated_at BEFORE UPDATE ON public.offers FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER auto_opportunity_embedding AFTER INSERT OR UPDATE OF title, description, skills_required, requirements ON public.opportunities FOR EACH ROW WHEN ((new.embedding IS NULL)) EXECUTE FUNCTION public.trigger_opportunity_embedding();

CREATE TRIGGER trigger_invalidate_all_job_matches_on_opportunity AFTER INSERT OR DELETE OR UPDATE OF title, description, requirements, skills_required, status, embedding ON public.opportunities FOR EACH ROW EXECUTE FUNCTION public.invalidate_all_job_matches_on_opportunity_change();

CREATE TRIGGER trigger_new_opportunity_notification AFTER INSERT ON public.opportunities FOR EACH ROW WHEN ((new.is_active IS TRUE)) EXECUTE FUNCTION public.notify_students_new_opportunity();

CREATE TRIGGER trigger_opportunity_update_notification AFTER UPDATE ON public.opportunities FOR EACH ROW WHEN ((old.is_active IS DISTINCT FROM new.is_active)) EXECUTE FUNCTION public.notify_students_opportunity_update();

CREATE TRIGGER update_opportunities_updated_at BEFORE UPDATE ON public.opportunities FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_update_organization_invitations_timestamp BEFORE UPDATE ON public.organization_invitations FOR EACH ROW EXECUTE FUNCTION public.update_organization_invitations_updated_at();

CREATE TRIGGER trigger_update_organization_subscriptions_updated_at BEFORE UPDATE ON public.organization_subscriptions FOR EACH ROW EXECUTE FUNCTION public.update_organization_subscriptions_updated_at();

CREATE TRIGGER trigger_auto_create_assessment_result AFTER UPDATE ON public.personal_assessment_attempts FOR EACH ROW EXECUTE FUNCTION public.auto_create_assessment_result();

CREATE TRIGGER trigger_create_assessment_restriction AFTER UPDATE ON public.personal_assessment_attempts FOR EACH ROW EXECUTE FUNCTION public.create_assessment_restriction();

CREATE TRIGGER auto_populate_result_columns BEFORE INSERT ON public.personal_assessment_results FOR EACH ROW EXECUTE FUNCTION public.populate_result_columns_from_gemini();

CREATE TRIGGER auto_populate_result_columns_update BEFORE UPDATE ON public.personal_assessment_results FOR EACH ROW WHEN ((new.gemini_results IS DISTINCT FROM old.gemini_results)) EXECUTE FUNCTION public.populate_result_columns_from_gemini();

CREATE TRIGGER auto_reset_attempt_on_result_delete AFTER DELETE ON public.personal_assessment_results FOR EACH ROW EXECUTE FUNCTION public.reset_attempt_on_result_delete();

CREATE TRIGGER calculate_assessment_scores_trigger BEFORE INSERT ON public.personal_assessment_results FOR EACH ROW EXECUTE FUNCTION public.calculate_assessment_scores();

CREATE TRIGGER update_phone_otps_updated_at BEFORE UPDATE ON public.phone_otps FOR EACH ROW EXECUTE FUNCTION public.update_phone_otps_updated_at();

CREATE TRIGGER pipeline_activity_notification_trigger AFTER INSERT ON public.pipeline_activities FOR EACH ROW EXECUTE FUNCTION public.create_notification_from_pipeline_activity();

CREATE TRIGGER update_pipeline_candidates_updated_at BEFORE UPDATE ON public.pipeline_candidates FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_placements_timestamp BEFORE UPDATE ON public.placements FOR EACH ROW EXECUTE FUNCTION public.update_timestamp();

CREATE TRIGGER trigger_update_email_tracking_updated_at BEFORE UPDATE ON public.pre_registration_email_tracking FOR EACH ROW EXECUTE FUNCTION public.update_email_tracking_updated_at();

CREATE TRIGGER set_program_sections_timestamp BEFORE UPDATE ON public.program_sections FOR EACH ROW EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_programs_timestamp BEFORE UPDATE ON public.programs FOR EACH ROW EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER trg_projects_embedding AFTER INSERT OR DELETE OR UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION public.trigger_related_student_embedding();

CREATE TRIGGER trigger_notify_project_approval_unified AFTER INSERT OR UPDATE OF approval_status ON public.projects FOR EACH ROW EXECUTE FUNCTION public.notify_project_approval_unified();

CREATE TRIGGER trigger_project_embedding AFTER INSERT OR UPDATE OF title, role, organization, tech_stack, description, enabled ON public.projects FOR EACH ROW WHEN ((new.enabled = true)) EXECUTE FUNCTION public.trigger_entity_embedding_generation();

CREATE TRIGGER trigger_set_project_approval_authority BEFORE INSERT OR UPDATE OF organization, student_id ON public.projects FOR EACH ROW EXECUTE FUNCTION public.set_project_approval_authority();

CREATE TRIGGER update_projects_updated_at BEFORE UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_recent_updates_updated_at BEFORE UPDATE ON public.recent_updates FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_recruiter_saved_searches_updated_at BEFORE UPDATE ON public.recruiter_saved_searches FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_requisitions_updated_at BEFORE UPDATE ON public.requisitions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER set_role_permissions_timestamp BEFORE UPDATE ON public.role_permissions FOR EACH ROW EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER set_roles_timestamp BEFORE UPDATE ON public.roles FOR EACH ROW EXECUTE FUNCTION public.set_updated_at_timestamp();

CREATE TRIGGER trigger_update_saved_jobs_timestamp BEFORE UPDATE ON public.saved_jobs FOR EACH ROW EXECUTE FUNCTION public.update_saved_jobs_updated_at();

CREATE TRIGGER update_saved_jobs_updated_at BEFORE UPDATE ON public.saved_jobs FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_school_classes_updated_at BEFORE UPDATE ON public.school_classes FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER set_teacher_id BEFORE INSERT ON public.school_educators FOR EACH ROW WHEN (((new.teacher_id IS NULL) OR ((new.teacher_id)::text = ''::text))) EXECUTE FUNCTION public.generate_teacher_id();

CREATE TRIGGER trigger_auto_assign_license_school_educators AFTER INSERT ON public.school_educators FOR EACH ROW EXECUTE FUNCTION public.auto_assign_license_to_member();

CREATE TRIGGER update_school_educators_updated_at BEFORE UPDATE ON public.school_educators FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_shortlists_updated_at BEFORE UPDATE ON public.shortlists FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_skill_assessments_updated_at BEFORE UPDATE ON public.skill_assessments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_passports_timestamp BEFORE UPDATE ON public.skill_passports FOR EACH ROW EXECUTE FUNCTION public.update_timestamp();

CREATE TRIGGER update_skill_verification_requests_updated_at BEFORE UPDATE ON public.skill_verification_requests FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_skills_embedding AFTER INSERT OR DELETE OR UPDATE ON public.skills FOR EACH ROW EXECUTE FUNCTION public.trigger_related_student_embedding();

CREATE TRIGGER trigger_skill_embedding AFTER INSERT OR UPDATE OF name, type, level, proficiency_level, description, enabled ON public.skills FOR EACH ROW WHEN ((new.enabled = true)) EXECUTE FUNCTION public.trigger_entity_embedding_generation();

CREATE TRIGGER update_skills_updated_at BEFORE UPDATE ON public.skills FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_mark_previous_reports_not_latest AFTER INSERT ON public.stream_recommendation_reports FOR EACH ROW EXECUTE FUNCTION public.mark_previous_stream_reports_not_latest();

CREATE TRIGGER trg_stream_reports_updated_at BEFORE UPDATE ON public.stream_recommendation_reports FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_student_assignments_grade_pct BEFORE INSERT OR UPDATE OF grade_received ON public.student_assignments FOR EACH ROW EXECUTE FUNCTION public.trg_student_assignments_grade_pct_fn();

CREATE TRIGGER trg_student_assignments_late_check BEFORE INSERT OR UPDATE OF submission_date ON public.student_assignments FOR EACH ROW EXECUTE FUNCTION public.trg_student_assignments_late_check_fn();

CREATE TRIGGER trg_student_assignments_status BEFORE INSERT OR UPDATE OF status ON public.student_assignments FOR EACH ROW EXECUTE FUNCTION public.trg_student_assignments_status_fn();

CREATE TRIGGER trg_student_assignments_updated BEFORE UPDATE ON public.student_assignments FOR EACH ROW EXECUTE FUNCTION public.trg_student_assignments_updated_fn();

CREATE TRIGGER trigger_student_course_progress_updated_at BEFORE UPDATE ON public.student_course_progress FOR EACH ROW EXECUTE FUNCTION public.update_student_course_progress_updated_at();

CREATE TRIGGER trigger_update_section_enrollment_count AFTER INSERT OR DELETE OR UPDATE ON public.student_enrollments FOR EACH ROW EXECUTE FUNCTION public.update_section_enrollment_count();

CREATE TRIGGER trigger_sync_student_record_ledgers BEFORE INSERT OR UPDATE ON public.student_ledgers FOR EACH ROW EXECUTE FUNCTION public.sync_student_record_id();

CREATE TRIGGER trigger_update_ledger_overdue BEFORE INSERT OR UPDATE ON public.student_ledgers FOR EACH ROW EXECUTE FUNCTION public.update_ledger_overdue_status();

CREATE TRIGGER update_student_ledgers_updated_at BEFORE UPDATE ON public.student_ledgers FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_student_management_records_updated_at BEFORE UPDATE ON public.student_management_records FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_student_promotions_updated_at BEFORE UPDATE ON public.student_promotions FOR EACH ROW EXECUTE FUNCTION public.update_student_promotions_updated_at();

CREATE TRIGGER trg_update_student_grade_on_promotion AFTER INSERT OR UPDATE OF is_promoted, to_grade ON public.student_promotions FOR EACH ROW WHEN (((new.is_promoted = true) AND (new.to_grade IS NOT NULL))) EXECUTE FUNCTION public.update_student_grade_on_promotion();

CREATE TRIGGER trigger_update_streak_timestamp BEFORE UPDATE ON public.student_streaks FOR EACH ROW EXECUTE FUNCTION public.update_streak_timestamp();

CREATE TRIGGER set_students_updated_at BEFORE UPDATE ON public.students FOR EACH ROW EXECUTE FUNCTION public.update_students_updated_at();

CREATE TRIGGER trg_generate_student_id BEFORE INSERT ON public.students FOR EACH ROW EXECUTE FUNCTION public.generate_student_id();

CREATE TRIGGER trg_student_embedding_queue AFTER INSERT OR UPDATE OF name, email, bio, skill_summary, branch_field, course_name, university ON public.students FOR EACH ROW EXECUTE FUNCTION public.trigger_student_embedding_queue();

CREATE TRIGGER trg_update_grade_on_program BEFORE INSERT OR UPDATE OF program_id ON public.students FOR EACH ROW EXECUTE FUNCTION public.update_grade_on_program_mapping();

CREATE TRIGGER trigger_auto_assign_license_students AFTER INSERT ON public.students FOR EACH ROW EXECUTE FUNCTION public.auto_assign_license_to_member();

CREATE TRIGGER trigger_initialize_student_streak AFTER INSERT ON public.students FOR EACH ROW EXECUTE FUNCTION public.initialize_student_streak();

CREATE TRIGGER trigger_invalidate_job_matches_on_student AFTER UPDATE OF name, branch_field, semester, "currentCgpa", skill_summary, interests, hobbies, embedding, metadata ON public.students FOR EACH ROW EXECUTE FUNCTION public.invalidate_job_matches_cache();

CREATE TRIGGER update_students_updated_at BEFORE UPDATE ON public.students FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER validate_aadhar_trigger BEFORE INSERT OR UPDATE ON public.students FOR EACH ROW EXECUTE FUNCTION public.trigger_validate_aadhar();

CREATE TRIGGER trigger_subscription_plans_updated_at BEFORE UPDATE ON public.subscription_plans FOR EACH ROW EXECUTE FUNCTION public.update_subscription_plans_updated_at();

CREATE TRIGGER prevent_duplicate_active_subscription BEFORE INSERT OR UPDATE ON public.subscriptions FOR EACH ROW EXECUTE FUNCTION public.check_duplicate_active_subscription();

CREATE TRIGGER trigger_auto_set_cancelled_at BEFORE UPDATE ON public.subscriptions FOR EACH ROW WHEN ((old.status IS DISTINCT FROM new.status)) EXECUTE FUNCTION public.auto_set_cancelled_at();

CREATE TRIGGER update_subscriptions_updated_at BEFORE UPDATE ON public.subscriptions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER validate_status_transition BEFORE UPDATE ON public.subscriptions FOR EACH ROW WHEN ((old.status IS DISTINCT FROM new.status)) EXECUTE FUNCTION public.validate_subscription_status_transition();

CREATE TRIGGER update_teacher_journal_updated_at BEFORE UPDATE ON public.teacher_journal FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER timetable_slot_workload_trigger AFTER INSERT OR DELETE OR UPDATE ON public.timetable_slots FOR EACH ROW EXECUTE FUNCTION public.on_timetable_slot_change();

CREATE TRIGGER update_timetable_slots_updated_at BEFORE UPDATE ON public.timetable_slots FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_timetables_updated_at BEFORE UPDATE ON public.timetables FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER training_notification_trigger AFTER INSERT ON public.trainings FOR EACH ROW EXECUTE FUNCTION public.notify_admin_training_submission();

CREATE TRIGGER trg_trainings_embedding AFTER INSERT OR DELETE OR UPDATE ON public.trainings FOR EACH ROW EXECUTE FUNCTION public.trigger_related_student_embedding();

CREATE TRIGGER trigger_invalidate_job_matches_on_training AFTER INSERT OR DELETE OR UPDATE ON public.trainings FOR EACH ROW EXECUTE FUNCTION public.invalidate_job_matches_cache();

CREATE TRIGGER trigger_notify_training_submission AFTER INSERT ON public.trainings FOR EACH ROW WHEN (((new.approval_status)::text = 'pending'::text)) EXECUTE FUNCTION public.notify_training_submission();

CREATE TRIGGER trigger_set_approval_authority BEFORE INSERT OR UPDATE ON public.trainings FOR EACH ROW EXECUTE FUNCTION public.set_approval_authority();

CREATE TRIGGER trigger_set_training_approval_authority BEFORE INSERT OR UPDATE ON public.trainings FOR EACH ROW EXECUTE FUNCTION public.set_training_approval_authority();

CREATE TRIGGER trigger_training_embedding AFTER INSERT OR UPDATE OF title, organization, source, duration, description ON public.trainings FOR EACH ROW EXECUTE FUNCTION public.trigger_entity_embedding_generation();

CREATE TRIGGER update_trainings_updated_at BEFORE UPDATE ON public.trainings FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_calculate_transcript_request_fee BEFORE INSERT OR UPDATE ON public.transcript_requests FOR EACH ROW EXECUTE FUNCTION public.calculate_transcript_request_fee();

CREATE TRIGGER update_transcript_requests_updated_at BEFORE UPDATE ON public.transcript_requests FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_sync_student_record_transcripts BEFORE INSERT OR UPDATE ON public.transcripts FOR EACH ROW EXECUTE FUNCTION public.sync_student_record_id();

CREATE TRIGGER update_transcripts_updated_at BEFORE UPDATE ON public.transcripts FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_tutor_conversations_updated_at BEFORE UPDATE ON public.tutor_conversations FOR EACH ROW EXECUTE FUNCTION public.update_tutor_conversations_updated_at();

CREATE TRIGGER update_university_colleges_updated_at BEFORE UPDATE ON public.university_colleges FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_university_courses_updated_at BEFORE UPDATE ON public.university_courses FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_user_categories_updated_at BEFORE UPDATE ON public.user_categories FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_user_profiles_updated_at BEFORE UPDATE ON public.user_profiles FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_user_settings_updated_at BEFORE UPDATE ON public.user_settings FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();


  create policy "Anyone can view course images"
  on "storage"."objects"
  as permissive
  for select
  to public
using ((bucket_id = 'course-images'::text));



  create policy "Authenticated users can upload course images"
  on "storage"."objects"
  as permissive
  for insert
  to public
with check (((bucket_id = 'course-images'::text) AND (auth.role() = 'authenticated'::text)));



  create policy "School staff can upload admission documents"
  on "storage"."objects"
  as permissive
  for insert
  to public
with check (((bucket_id = 'admission-documents'::text) AND (auth.role() = 'authenticated'::text)));



  create policy "School staff can view admission documents"
  on "storage"."objects"
  as permissive
  for select
  to public
using (((bucket_id = 'admission-documents'::text) AND (auth.role() = 'authenticated'::text)));



  create policy "Users can delete course images"
  on "storage"."objects"
  as permissive
  for delete
  to public
using (((bucket_id = 'course-images'::text) AND (auth.role() = 'authenticated'::text)));



  create policy "Users can update course images"
  on "storage"."objects"
  as permissive
  for update
  to public
using (((bucket_id = 'course-images'::text) AND (auth.role() = 'authenticated'::text)));


-- Storage triggers are managed by Supabase automatically, removed to avoid conflicts
-- CREATE TRIGGER objects_delete_delete_prefix AFTER DELETE ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();
-- CREATE TRIGGER objects_insert_create_prefix BEFORE INSERT ON storage.objects FOR EACH ROW EXECUTE FUNCTION storage.objects_insert_prefix_trigger();
-- CREATE TRIGGER objects_update_create_prefix BEFORE UPDATE ON storage.objects FOR EACH ROW WHEN (((new.name <> old.name) OR (new.bucket_id <> old.bucket_id))) EXECUTE FUNCTION storage.objects_update_prefix_trigger();
-- CREATE TRIGGER prefixes_create_hierarchy BEFORE INSERT ON storage.prefixes FOR EACH ROW WHEN ((pg_trigger_depth() < 1)) EXECUTE FUNCTION storage.prefixes_insert_trigger();
-- CREATE TRIGGER prefixes_delete_hierarchy AFTER DELETE ON storage.prefixes FOR EACH ROW EXECUTE FUNCTION storage.delete_prefix_hierarchy_trigger();


