// Career AI Chat - Main Handler (Refactored)
// This is the slim entry point that imports from shared modules

import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { createClient } from 'npm:@supabase/supabase-js@2.38.4';

// Import shared modules
import { corsHeaders } from '../_shared/utils/cors.ts';
import { authenticateUser } from '../_shared/utils/auth.ts';
import type { ChatRequest, StoredMessage, Opportunity } from '../_shared/types/career-ai.ts';
import { detectIntent } from '../_shared/ai/intent-detection.ts';
import { getConversationPhase, getPhaseParameters } from '../_shared/ai/conversation-phase.ts';
import { buildStudentContext } from '../_shared/context/student.ts';
import { buildAssessmentContext } from '../_shared/context/assessment.ts';
import { buildCareerProgressContext } from '../_shared/context/progress.ts';
import { fetchOpportunities } from '../_shared/context/opportunities.ts';
import { buildCareerSystemPrompt } from '../_shared/ai/prompts/system-prompt.ts';

// Utility function
function generateConversationTitle(message: string): string {
  const cleaned = message.replace(/[^\w\s]/g, '').trim();
  return cleaned.length > 50 ? cleaned.slice(0, 47) + '...' : cleaned;
}

// Main handler
Deno.serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const SUPABASE_URL = Deno.env.get('SUPABASE_URL');
    const SUPABASE_ANON_KEY = Deno.env.get('SUPABASE_ANON_KEY');
    const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');

    if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
      console.error('Missing Supabase environment variables');
      return new Response(JSON.stringify({ error: 'Server configuration error' }), 
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // Authenticate user
    const authHeader = req.headers.get('Authorization');
    const user = await authenticateUser(authHeader, SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

    if (!user) {
      return new Response(JSON.stringify({ error: 'Authentication required. Please log in again.' }), 
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    const studentId = user.id;

    // Create Supabase clients
    const supabaseAdmin = SUPABASE_SERVICE_ROLE_KEY 
      ? createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)
      : null;
    
    const supabaseUser = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      global: { headers: { Authorization: authHeader! } },
    });
    
    const supabase = supabaseUser;
    const dbClient = supabaseAdmin || supabaseUser;

    // Parse request
    const { conversationId, message, selectedChips = [] }: ChatRequest = await req.json();
    console.log(`Processing - studentId: ${studentId}, conversationId: ${conversationId || 'new'}, message: "${message.slice(0, 50)}..."`);

    if (!message) {
      return new Response(JSON.stringify({ error: 'Message is required' }), 
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // Fetch existing conversation messages
    let currentConversationId = conversationId;
    let existingMessages: StoredMessage[] = [];

    if (conversationId) {
      const { data: conversation, error: convError } = await supabase
        .from('career_ai_conversations')
        .select('messages')
        .eq('id', conversationId)
        .eq('student_id', studentId)
        .single();

      if (!convError && conversation) {
        existingMessages = conversation.messages || [];
      }
    }

    // Determine conversation phase and intent
    const messageCount = existingMessages.length;
    const conversationPhase = getConversationPhase(messageCount);
    const intentResult = detectIntent(message, selectedChips, existingMessages);
    const phaseParams = getPhaseParameters(conversationPhase, intentResult.intent);
    
    console.log(`[Phase] ${conversationPhase} (${messageCount} msgs) | [Intent] ${intentResult.intent} (${intentResult.confidence})`);

    // Handle direct job listing requests
    const lowerMessage = message.toLowerCase();
    const isJobListRequest = 
      lowerMessage.includes('list all') ||
      lowerMessage.includes('show all') ||
      lowerMessage.includes('all job') ||
      lowerMessage.includes('all opportunities') ||
      lowerMessage.includes('what jobs') ||
      lowerMessage.includes('available job');

    if (isJobListRequest) {
      return await handleDirectJobListing(
        supabase, dbClient, studentId, message, 
        existingMessages, currentConversationId
      );
    }

    // Full AI processing
    console.log('[Context] Building student profile...');
    const studentProfile = await buildStudentContext(supabase, studentId);
    if (!studentProfile) {
      return new Response(JSON.stringify({ error: 'Unable to load student profile' }), 
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    console.log('[Context] Building assessment context...');
    const assessmentContext = await buildAssessmentContext(supabase, studentId);
    
    console.log('[Context] Building career progress context...');
    const progressContext = await buildCareerProgressContext(supabase, studentId);

    // Fetch opportunities for relevant intents
    let opportunities: Opportunity[] = [];
    if (['find-jobs', 'skill-gap', 'career-guidance', 'application-status'].includes(intentResult.intent)) {
      opportunities = await fetchOpportunities(supabase, 50);
      console.log(`[Context] Fetched ${opportunities.length} opportunities`);
    }

    // Build comprehensive system prompt
    const systemPrompt = buildCareerSystemPrompt(
      studentProfile, 
      assessmentContext, 
      progressContext, 
      opportunities, 
      conversationPhase, 
      intentResult
    );

    // Prepare messages for AI
    const turnId = crypto.randomUUID();
    const userMessage: StoredMessage = {
      id: turnId,
      role: 'user',
      content: message,
      timestamp: new Date().toISOString()
    };

    // Build conversation history (limit to last 10 messages)
    const recentMessages = existingMessages.slice(-10);
    const aiMessages = [
      { role: 'system', content: systemPrompt },
      ...recentMessages.map(m => ({ role: m.role, content: m.content })),
      { role: 'user', content: message }
    ];

    // Get API key
    const openRouterKey = Deno.env.get('OPENROUTER_API_KEY') || Deno.env.get('OPENAI_API_KEY');
    if (!openRouterKey) {
      return new Response(JSON.stringify({ error: 'AI service not configured' }), 
        { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
    }

    // Stream response
    return await streamAIResponse(
      openRouterKey, SUPABASE_URL, aiMessages, phaseParams,
      dbClient, studentId, existingMessages, userMessage,
      currentConversationId, message, intentResult, conversationPhase, assessmentContext
    );

  } catch (error) {
    console.error('Error in career-ai-chat:', error);
    return new Response(JSON.stringify({ error: (error as Error)?.message || 'Internal server error' }), 
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } });
  }
});

// Handle direct job listing requests
async function handleDirectJobListing(
  supabase: any, dbClient: any, studentId: string, message: string,
  existingMessages: StoredMessage[], currentConversationId: string | undefined
) {
  console.log('[DIRECT RESPONSE] Job listing request - fetching from database');
  
  const directOpportunities = await fetchOpportunities(supabase, 100);
  console.log(`[DIRECT RESPONSE] Found ${directOpportunities.length} opportunities`);
  
  if (directOpportunities.length > 0) {
    const studentProfile = await buildStudentContext(supabase, studentId);
    const studentName = studentProfile?.name?.split(' ')[0] || 'there';
    
    // Group by employment type
    const internships = directOpportunities.filter(o => o.employment_type?.toLowerCase().includes('intern'));
    const fullTime = directOpportunities.filter(o => !o.employment_type?.toLowerCase().includes('intern'));
    
    let jobListFormatted = '';
    
    if (internships.length > 0) {
      jobListFormatted += `**üéì Internships (${internships.length})**\n`;
      jobListFormatted += internships.map((opp, i) => 
        `${i + 1}. **${opp.title}** (ID: ${opp.id})\n   üìç ${opp.location || 'Location not specified'} | üè¢ ${opp.company_name || 'Company not specified'}`
      ).join('\n\n');
    }
    
    if (fullTime.length > 0) {
      if (internships.length > 0) jobListFormatted += '\n\n';
      jobListFormatted += `**üíº Full-time/Part-time (${fullTime.length})**\n`;
      jobListFormatted += fullTime.map((opp, i) => 
        `${i + 1}. **${opp.title}** (ID: ${opp.id})\n   üìç ${opp.location || 'Location not specified'} | üè¢ ${opp.company_name || 'Company not specified'}`
      ).join('\n\n');
    }
    
    const directResponse = `Hi ${studentName}! üëã Here are **all ${directOpportunities.length} active opportunities** in our database:\n\n${jobListFormatted}\n\n---\nüìä **Total:** ${directOpportunities.length} opportunities (${internships.length} internships, ${fullTime.length} jobs)\n\nWould you like me to:\n- **Analyze** which ones best match your profile?\n- **Get details** about a specific opportunity?\n- **Filter** by location, skills, or type?`;
    
    // Save conversation
    const turnId = crypto.randomUUID();
    const userMessage: StoredMessage = { id: turnId, role: 'user', content: message, timestamp: new Date().toISOString() };
    const assistantMessage: StoredMessage = { id: turnId, role: 'assistant', content: directResponse, timestamp: new Date().toISOString() };
    const updatedMessages = [...existingMessages, userMessage, assistantMessage];
    
    if (dbClient) {
      if (currentConversationId) {
        await dbClient.from('career_ai_conversations')
          .update({ messages: updatedMessages, updated_at: new Date().toISOString() })
          .eq('id', currentConversationId).eq('student_id', studentId);
      } else {
        const { data: newConv } = await dbClient.from('career_ai_conversations')
          .insert({ student_id: studentId, title: message.slice(0, 50), messages: updatedMessages })
          .select('id').single();
        if (newConv) currentConversationId = newConv.id;
      }
    }
    
    const encoder = new TextEncoder();
    const directStream = new ReadableStream({
      start(controller) {
        controller.enqueue(encoder.encode(`event: token\ndata: ${JSON.stringify({ content: directResponse })}\n\n`));
        controller.enqueue(encoder.encode(`event: done\ndata: ${JSON.stringify({ conversationId: currentConversationId, messageId: turnId, intent: 'find-jobs', phase: 'direct_response' })}\n\n`));
        controller.close();
      }
    });
    
    return new Response(directStream, {
      headers: { ...corsHeaders, 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' }
    });
  }
  
  // No opportunities found
  const encoder = new TextEncoder();
  const emptyStream = new ReadableStream({
    start(controller) {
      controller.enqueue(encoder.encode(`event: token\ndata: ${JSON.stringify({ content: "I couldn't find any active opportunities at the moment. Please check back later!" })}\n\n`));
      controller.enqueue(encoder.encode(`event: done\ndata: ${JSON.stringify({ intent: 'find-jobs' })}\n\n`));
      controller.close();
    }
  });
  
  return new Response(emptyStream, {
    headers: { ...corsHeaders, 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' }
  });
}

// Stream AI response
async function streamAIResponse(
  openRouterKey: string, supabaseUrl: string, aiMessages: any[], phaseParams: any,
  dbClient: any, studentId: string, existingMessages: StoredMessage[], userMessage: StoredMessage,
  currentConversationId: string | undefined, message: string, intentResult: any, 
  conversationPhase: string, assessmentContext: any
) {
  const encoder = new TextEncoder();
  let fullResponse = '';

  const stream = new ReadableStream({
    async start(controller) {
      try {
        const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${openRouterKey}`,
            'Content-Type': 'application/json',
            'HTTP-Referer': supabaseUrl,
            'X-Title': 'Career AI Assistant'
          },
          body: JSON.stringify({
            model: 'openai/gpt-4o-mini',
            messages: aiMessages,
            stream: true,
            max_tokens: phaseParams.max_tokens,
            temperature: phaseParams.temperature
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error('OpenRouter error:', response.status, errorText);
          controller.enqueue(encoder.encode(`event: error\ndata: ${JSON.stringify({ error: `AI service error (${response.status})` })}\n\n`));
          controller.close();
          return;
        }

        const reader = response.body?.getReader();
        if (!reader) {
          controller.enqueue(encoder.encode(`event: error\ndata: ${JSON.stringify({ error: 'No response stream' })}\n\n`));
          controller.close();
          return;
        }

        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              if (data === '[DONE]') continue;
              try {
                const parsed = JSON.parse(data);
                const content = parsed.choices?.[0]?.delta?.content;
                if (content) {
                  fullResponse += content;
                  controller.enqueue(encoder.encode(`event: token\ndata: ${JSON.stringify({ content })}\n\n`));
                }
              } catch { /* skip parse errors */ }
            }
          }
        }

        // Save conversation
        const assistantMessage: StoredMessage = {
          id: userMessage.id,
          role: 'assistant',
          content: fullResponse,
          timestamp: new Date().toISOString()
        };

        const updatedMessages = [...existingMessages, userMessage, assistantMessage];

        if (dbClient) {
          if (currentConversationId) {
            await dbClient.from('career_ai_conversations')
              .update({ messages: updatedMessages, updated_at: new Date().toISOString() })
              .eq('id', currentConversationId).eq('student_id', studentId);
            console.log(`[DB] Updated conversation: ${currentConversationId}`);
          } else {
            const title = generateConversationTitle(message);
            const { data: newConv } = await dbClient.from('career_ai_conversations')
              .insert({ student_id: studentId, title: title.slice(0, 255), messages: updatedMessages })
              .select('id').single();
            if (newConv) {
              currentConversationId = newConv.id;
              console.log(`[DB] Created conversation: ${currentConversationId}`);
            }
          }
        }

        // Send completion event
        controller.enqueue(encoder.encode(`event: done\ndata: ${JSON.stringify({
          conversationId: currentConversationId,
          messageId: assistantMessage.id,
          intent: intentResult.intent,
          intentConfidence: intentResult.confidence,
          phase: conversationPhase,
          hasAssessment: assessmentContext.hasAssessment
        })}\n\n`));
        controller.close();

      } catch (error) {
        console.error('Streaming error:', error);
        controller.enqueue(encoder.encode(`event: error\ndata: ${JSON.stringify({ error: 'Stream processing error' })}\n\n`));
        controller.close();
      }
    }
  });

  return new Response(stream, {
    headers: { ...corsHeaders, 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' }
  });
}
